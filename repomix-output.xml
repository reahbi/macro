This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.mcp.json
.vooster/project.json
APPLICATION_GUIDE.md
AUTO_ERROR_RECOVERY_GUIDE.md
CLAUDE.md
COLLECT_ERRORS_WINDOWS.bat
CURRENT_STATUS.md
ERROR_COLLECTION_GUIDE.md
ERROR_FIXES_SUMMARY.md
INSTALL_DEPENDENCIES.bat
package.json
prd.md
pyproject.toml
QUICK_REFERENCE.md
README.md
requirements.txt
resources/locales/en.json
resources/locales/ko.json
run_from_windows_native.ps1
run_main_fixed.py
run_main.py
RUN_SIMPLE.bat
run_simple.py
run_windows_wsl.sh
run_windows.ps1
run_with_debug.py
run_with_recovery.py
RUNNING_GUIDE.md
setup_wsl_gui.sh
src/__init__.py
src/automation/__init__.py
src/automation/engine.py
src/automation/executor.py
src/automation/hotkey_listener.py
src/config/settings.py
src/core/__init__.py
src/core/macro_storage.py
src/core/macro_types.py
src/excel/excel_manager.py
src/excel/models.py
src/logger/app_logger.py
src/logger/execution_logger.py
src/ui/dialogs/__init__.py
src/ui/dialogs/error_report_dialog.py
src/ui/dialogs/if_condition_step_dialog.py
src/ui/dialogs/image_step_dialog.py
src/ui/dialogs/keyboard_hotkey_step_dialog.py
src/ui/dialogs/keyboard_type_step_dialog.py
src/ui/dialogs/log_viewer_dialog.py
src/ui/dialogs/loop_step_dialog.py
src/ui/dialogs/macro_save_dialog.py
src/ui/dialogs/mouse_click_step_dialog.py
src/ui/dialogs/mouse_move_step_dialog.py
src/ui/dialogs/screenshot_step_dialog.py
src/ui/dialogs/text_search_step_dialog.py
src/ui/dialogs/wait_time_step_dialog.py
src/ui/main_window.py
src/ui/widgets/__init__.py
src/ui/widgets/data_preview.py
src/ui/widgets/excel_widget.py
src/ui/widgets/execution_widget.py
src/ui/widgets/file_selector.py
src/ui/widgets/macro_editor.py
src/ui/widgets/monitor_widget.py
src/ui/widgets/roi_selector.py
src/ui/widgets/sheet_mapper.py
src/ui/widgets/simple_roi_selector.py
src/utils/apply_recovery_example.py
src/utils/background_monitor.py
src/utils/clipboard_utils.py
src/utils/encryption.py
src/utils/error_decorator.py
src/utils/error_recovery.py
src/utils/error_report_generator.py
src/utils/macro_loader.py
src/utils/monitor_utils.py
src/utils/path_utils.py
src/utils/self_diagnosis.py
src/vision/__init__.py
src/vision/image_matcher.py
src/vision/text_extractor.py
start_gui.sh
trd.md
uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250715_225040.json
uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_111655.json
uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_230208.json
usage_tracking2.json
web_macro.json
web_ui_enhanced.py
web_ui_integrated_working.py
web_ui_launcher.py
WINDOWS_GUIDE.md
WINDOWS_RUN.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="INSTALL_DEPENDENCIES.bat">
@echo off
chcp 65001 >nul
REM === Excel Macro Dependencies Installer ===

cls

echo ===============================
echo Excel Macro Dependencies Setup
echo ===============================
echo.

REM Change to project directory
cd /d "%~dp0"

REM Check Python
echo Checking Python installation...
python --version >nul 2>&1
if errorlevel 1 (
    echo.
    echo [ERROR] Python is not installed or not in PATH!
    echo.
    echo Please install Python from: https://python.org
    echo Make sure to check "Add Python to PATH" during installation
    echo.
    pause
    exit /b 1
)

python --version
echo Python found!
echo.

REM Check pip
echo Checking pip...
python -m pip --version >nul 2>&1
if errorlevel 1 (
    echo [ERROR] pip not found!
    pause
    exit /b 1
)

REM Upgrade pip
echo Upgrading pip...
python -m pip install --upgrade pip

REM Check if requirements.txt exists
if exist "requirements.txt" (
    echo.
    echo Installing from requirements.txt...
    python -m pip install -r requirements.txt
    
    if errorlevel 1 (
        echo.
        echo [WARNING] Some packages from requirements.txt failed to install.
        echo Trying individual package installation...
    ) else (
        echo.
        echo âœ“ All dependencies installed successfully from requirements.txt!
        goto :SUCCESS
    )
)

REM Manual package installation
echo.
echo Installing core packages individually...
echo.

echo Installing GUI framework (PyQt5)...
python -m pip install PyQt5>=5.15.0

echo Installing data processing libraries...
python -m pip install pandas>=1.3.0 openpyxl>=3.0.0 numpy>=1.21.0

echo Installing automation libraries...
python -m pip install pyautogui>=0.9.53 pillow>=8.3.0 opencv-python>=4.5.0

echo Installing screen capture...
python -m pip install screeninfo>=0.8.0 mss>=6.1.0

echo Installing security...
python -m pip install cryptography>=3.4.0

echo.
echo Installing OCR (This may take a while on first install)...
python -m pip install easyocr>=1.7.0

echo.
echo Installing testing frameworks (optional)...
python -m pip install pytest>=6.2.0 pytest-qt>=4.0.0

echo.
echo Installing development tools (optional)...
python -m pip install black>=21.0 flake8>=3.9.0

:SUCCESS
echo.
echo ===============================
echo Dependencies installation completed!
echo ===============================
echo.

REM Test import key packages
echo Testing package imports...
python -c "import PyQt5; print('âœ“ PyQt5 OK')" 2>nul
python -c "import pandas; print('âœ“ pandas OK')" 2>nul  
python -c "import pyautogui; print('âœ“ pyautogui OK')" 2>nul
python -c "import cv2; print('âœ“ opencv OK')" 2>nul

echo.
echo Ready to run Excel Macro Automation!
echo Use WINDOWS_RUN.bat or RUN_SIMPLE.bat to start the application.
echo.

pause
</file>

<file path="RUN_SIMPLE.bat">
@echo off
chcp 65001 >nul
REM === Simple Excel Macro Launcher ===

cls

echo ===============================
echo Excel Macro Automation
echo ===============================
echo.

REM Change to project directory
cd /d "%~dp0"

REM Quick Python check
python --version >nul 2>&1
if errorlevel 1 (
    echo [ERROR] Python not found! Please install Python first.
    pause
    exit /b
)

echo Starting application...
echo.

REM Run the application
if exist "run_main.py" (
    python run_main.py
) else if exist "run_main_fixed.py" (
    python run_main_fixed.py
) else (
    echo [ERROR] No launcher found!
    echo Please ensure run_main.py exists.
    pause
    exit /b
)

echo.
echo Application closed.
pause
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# Custom
*.enc
*.encrypted
config/settings.json
logs/
temp/
.DS_Store
.idea/
.vscode/
*.swp
*.swo
</file>

<file path=".vooster/project.json">
{
  "projectUid": "X179",
  "projectName": "ì—‘ì…€(Excel) íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ, ì‚¬ìš©ìê°€ ì„¤ì •í•œ ìˆœì„œëŒ€ë¡œ ì‘ì—…ì„ ìë™ ìˆ˜...",
  "description": "ì—‘ì…€(Excel) íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ, ì‚¬ìš©ìê°€ ì„¤ì •í•œ ìˆœì„œëŒ€ë¡œ ì‘ì—…ì„ ìë™ ìˆ˜í–‰í•˜ê³  ì™„ë£Œ ì—¬ë¶€ë¥¼ í‘œì‹œí•˜ëŠ” ë§¤í¬ë¡œ í”„ë¡œê·¸ë¨ì— ëŒ€í•œ ì œí’ˆ ìš”êµ¬ì‚¬í•­ì„ ê¸°ìˆ í•©ë‹ˆë‹¤. ì‚¬ìš©ìëŠ” ì§ê´€ì ì¸ ê·¸ë˜í”½ ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤(GUI)ë¥¼ í†µí•´ ìë™í™”í•  ì‘ì—…ì„ ë‹¨ê³„ë³„ë¡œ ì‰½ê²Œ ì…ë ¥í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ í”„ë¡œê·¸ë¨ì€ ë°˜ë³µì ì¸ ìˆ˜ì‘ì—…ì„ ìë™í™”í•˜ì—¬ ì—…ë¬´ íš¨ìœ¨ì„±ì„ ê·¹ëŒ€í™”í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.",
  "version": "1.0.0",
  "agent": "claude-code"
}
</file>

<file path="APPLICATION_GUIDE.md">
# Excel Macro Automation - ì• í”Œë¦¬ì¼€ì´ì…˜ ê°€ì´ë“œ

## ğŸš€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ ë°©ë²•

### 1. ì˜ì¡´ì„± í™•ì¸
```bash
# ì´ë¯¸ ì„¤ì¹˜ë¨ (pip3 install -r requirements.txt)
# ì£¼ìš” íŒ¨í‚¤ì§€: PyQt5, pandas, opencv-python, pyautogui, easyocr
```

### 2. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
```bash
# í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ì‹¤í–‰
cd /home/nosky/macro
python3 main.py

# ë˜ëŠ” (ê²½ë¡œ ë¬¸ì œê°€ ìˆì„ ê²½ìš°)
python3 test_app.py
```

## ğŸ“‹ ì£¼ìš” ê¸°ëŠ¥

### 1. Excel íƒ­
- **íŒŒì¼ ì„ íƒ**: Excel íŒŒì¼ì„ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” ì°¾ì•„ë³´ê¸°ë¡œ ì„ íƒ
- **ì‹œíŠ¸ ì„ íƒ**: ë“œë¡­ë‹¤ìš´ì—ì„œ ì‘ì—…í•  ì‹œíŠ¸ ì„ íƒ
- **ì—´ ë§¤í•‘**: ê° ì—´ì˜ ë°ì´í„° íƒ€ì… ìë™ ê°ì§€
- **ë¯¸ë¦¬ë³´ê¸°**: ì„ íƒí•œ ë°ì´í„°ì˜ ì²˜ìŒ 10í–‰ í‘œì‹œ
- **ìƒíƒœ ì—´**: ì‘ì—… ì™„ë£Œ ìƒíƒœë¥¼ ê¸°ë¡í•  ì—´ ìë™ ê°ì§€/ìƒì„±

### 2. Editor íƒ­ (ë§¤í¬ë¡œ í¸ì§‘ê¸°)
- **ë“œë˜ê·¸ ì•¤ ë“œë¡­**: ì™¼ìª½ íŒ”ë ˆíŠ¸ì—ì„œ ë‹¨ê³„ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€
- **ì§€ì›ë˜ëŠ” ë‹¨ê³„ íƒ€ì…**:
  - ğŸ–±ï¸ ë§ˆìš°ìŠ¤ í´ë¦­/ì´ë™
  - âŒ¨ï¸ í…ìŠ¤íŠ¸ ì…ë ¥/ë‹¨ì¶•í‚¤
  - â±ï¸ ëŒ€ê¸° ì‹œê°„
  - ğŸ–¼ï¸ ì´ë¯¸ì§€ ëŒ€ê¸°/ê²€ìƒ‰
  - ğŸ“· í™”ë©´ ìº¡ì²˜
  - â“ ì¡°ê±´ë¬¸ (êµ¬í˜„ ì˜ˆì •)
  - ğŸ”„ ë°˜ë³µë¬¸ (êµ¬í˜„ ì˜ˆì •)
- **ë‹¨ê³„ í¸ì§‘**: ê° ë‹¨ê³„ ë”ë¸”í´ë¦­ìœ¼ë¡œ ìƒì„¸ ì„¤ì •
- **ë³€ìˆ˜ ì‚¬ìš©**: {{column_name}} í˜•ì‹ìœ¼ë¡œ Excel ë°ì´í„° ì°¸ì¡°

### 3. Run íƒ­ (ì‹¤í–‰)
- **ì‹¤í–‰ ì œì–´**: ì‹œì‘/ì¼ì‹œì •ì§€/ì •ì§€ ë²„íŠ¼
- **í•«í‚¤ ì§€ì›**: 
  - F9: ì¼ì‹œì •ì§€/ì¬ê°œ
  - ESC: ì •ì§€
- **ì§„í–‰ ìƒíƒœ**: ì‹¤ì‹œê°„ ì§„í–‰ë¥  í‘œì‹œ
- **ì‹¤í–‰ ë¡œê·¸**: ê° ë‹¨ê³„ë³„ ì„±ê³µ/ì‹¤íŒ¨ ê¸°ë¡
- **ì˜µì…˜**: ë¯¸ì™„ë£Œ í•­ëª©ë§Œ ì‹¤í–‰ ì²´í¬ë°•ìŠ¤

## ğŸ¯ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤

### ì‹œë‚˜ë¦¬ì˜¤ 1: ë°˜ë³µì ì¸ ë°ì´í„° ì…ë ¥
1. Excel íŒŒì¼ì— ì…ë ¥í•  ë°ì´í„° ëª©ë¡ ì¤€ë¹„
2. ë§¤í¬ë¡œ í¸ì§‘ê¸°ì—ì„œ ë‹¤ìŒ ë‹¨ê³„ êµ¬ì„±:
   - ë§ˆìš°ìŠ¤ í´ë¦­ (ì…ë ¥ í•„ë“œ ìœ„ì¹˜)
   - í…ìŠ¤íŠ¸ ì…ë ¥ ({{ì´ë¦„}} ë³€ìˆ˜ ì‚¬ìš©)
   - ëŒ€ê¸° (0.5ì´ˆ)
   - ë‹¤ìŒ í•„ë“œë¡œ ì´ë™...
3. ì‹¤í–‰í•˜ë©´ Excelì˜ ê° í–‰ë§ˆë‹¤ ìë™ ì…ë ¥

### ì‹œë‚˜ë¦¬ì˜¤ 2: ì´ë¯¸ì§€ ê¸°ë°˜ ìë™í™”
1. ì´ë¯¸ì§€ ëŒ€ê¸° ë‹¨ê³„ ì¶”ê°€
2. "Capture" ë²„íŠ¼ìœ¼ë¡œ ëŒ€ìƒ ì´ë¯¸ì§€ ìº¡ì²˜
3. ROI(ê´€ì‹¬ ì˜ì—­) ì„¤ì •ìœ¼ë¡œ ê²€ìƒ‰ ë²”ìœ„ ì œí•œ
4. ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚˜ë©´ ë‹¤ìŒ ë™ì‘ ìˆ˜í–‰

## âš ï¸ ì£¼ì˜ì‚¬í•­

### í˜„ì¬ ìƒíƒœ
- âœ… ê¸°ë³¸ ìë™í™” ê¸°ëŠ¥ êµ¬í˜„ ì™„ë£Œ
- âœ… ì´ë¯¸ì§€ ì¸ì‹ (OpenCV) êµ¬í˜„ ì™„ë£Œ
- âŒ OCR í…ìŠ¤íŠ¸ ì¸ì‹ ë¯¸êµ¬í˜„
- âŒ ì¡°ê±´ë¬¸/ë°˜ë³µë¬¸ ì‹¤ì œ ë™ì‘ ë¯¸êµ¬í˜„
- âŒ ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ë¯¸êµ¬í˜„

### ì‹¤í–‰ í™˜ê²½
- GUI í™˜ê²½ í•„ìš” (X11, Wayland ë“±)
- ê´€ë¦¬ì ê¶Œí•œ ë¶ˆí•„ìš”
- Python 3.8+ í•„ìš”

## ğŸ”§ ë¬¸ì œ í•´ê²°

### 1. ImportError ë°œìƒ ì‹œ
```bash
# í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ì‹¤í–‰ í™•ì¸
cd /home/nosky/macro
export PYTHONPATH=$PWD/src:$PYTHONPATH
python3 main.py
```

### 2. Qt í”Œë«í¼ ì—ëŸ¬
```bash
# Linuxì—ì„œ X11 forwarding í•„ìš”
export DISPLAY=:0
# ë˜ëŠ” SSHì˜ ê²½ìš°
ssh -X user@host
```

### 3. ì˜ì¡´ì„± ë¬¸ì œ
```bash
# ê°œë³„ íŒ¨í‚¤ì§€ ì¬ì„¤ì¹˜
pip3 install --upgrade PyQt5
pip3 install --upgrade opencv-python
```

## ğŸ“ ë‹¤ìŒ ë‹¨ê³„

1. **OCR ê¸°ëŠ¥ êµ¬í˜„** (T-006)
   - EasyOCRì„ ì‚¬ìš©í•œ ë™ì  í…ìŠ¤íŠ¸ ê²€ìƒ‰
   - Excel ë°ì´í„° ê¸°ë°˜ í…ìŠ¤íŠ¸ ì°¾ê¸° ë° í´ë¦­

2. **ì¡°ê±´ë¬¸ êµ¬í˜„** (T-007)
   - If-Then-Else ë¡œì§
   - ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ì¡´ì¬ ì—¬ë¶€ íŒë‹¨

3. **ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°** (T-008)
   - JSON í˜•ì‹ìœ¼ë¡œ ë§¤í¬ë¡œ ì €ì¥
   - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë§¤í¬ë¡œ ë¼ì´ë¸ŒëŸ¬ë¦¬

4. **ê³ ê¸‰ ë¡œê¹…** (T-009)
   - CSV í˜•ì‹ ì‹¤í–‰ ë¡œê·¸
   - ì˜¤ë¥˜ ìŠ¤í¬ë¦°ìƒ· ìë™ ì €ì¥
</file>

<file path="AUTO_ERROR_RECOVERY_GUIDE.md">
# ìë™ ì˜¤ë¥˜ ë³µêµ¬ ì‹œìŠ¤í…œ ê°€ì´ë“œ

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#ê°œìš”)
2. [ì‹œìŠ¤í…œ êµ¬ì„±](#ì‹œìŠ¤í…œ-êµ¬ì„±)
3. [ì‚¬ìš© ë°©ë²•](#ì‚¬ìš©-ë°©ë²•)
4. [ë™ì‘ ì›ë¦¬](#ë™ì‘-ì›ë¦¬)
5. [ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ](#ëª¨ë‹ˆí„°ë§-ì‹œìŠ¤í…œ)
6. [ë¬¸ì œ í•´ê²°](#ë¬¸ì œ-í•´ê²°)
7. [ê³ ê¸‰ ì„¤ì •](#ê³ ê¸‰-ì„¤ì •)

## ê°œìš”

Excel Macro Automationì˜ ìë™ ì˜¤ë¥˜ ë³µêµ¬ ì‹œìŠ¤í…œì€ Windows í™˜ê²½ì—ì„œ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ì˜¤ë¥˜ë¥¼ ìë™ìœ¼ë¡œ ê°ì§€í•˜ê³  ë³µêµ¬í•˜ì—¬ ì‘ì—… ì¤‘ë‹¨ì„ ìµœì†Œí™”í•©ë‹ˆë‹¤.

### ì£¼ìš” ê¸°ëŠ¥
- ğŸ”§ **ìë™ ì˜¤ë¥˜ ë³µêµ¬**: ì¼ë°˜ì ì¸ ì˜¤ë¥˜ë¥¼ ìë™ìœ¼ë¡œ í•´ê²°
- ğŸ¥ **ìê°€ ì§„ë‹¨**: ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ì‚¬ì „ì— ì ê²€í•˜ê³  ë¬¸ì œ ì˜ˆë°©
- ğŸ“Š **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**: ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ì™€ ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒíƒœ ê°ì‹œ
- ğŸ“ **ìƒì„¸í•œ ë¡œê¹…**: ëª¨ë“  ì˜¤ë¥˜ì™€ ë³µêµ¬ ì‹œë„ ê¸°ë¡

## ì‹œìŠ¤í…œ êµ¬ì„±

### 1. ì˜¤ë¥˜ ë³µêµ¬ ë§¤ë‹ˆì € (`error_recovery.py`)
ìë™ìœ¼ë¡œ ì˜¤ë¥˜ë¥¼ ê°ì§€í•˜ê³  ë³µêµ¬í•˜ëŠ” í•µì‹¬ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.

**ì§€ì›í•˜ëŠ” ì˜¤ë¥˜ ìœ í˜•:**
- ì¸ì½”ë”© ì˜¤ë¥˜ (UTF-8, CP949)
- ëª¨ë“ˆ ì„í¬íŠ¸ ì˜¤ë¥˜
- íŒŒì¼ ê²½ë¡œ ì˜¤ë¥˜
- ê¶Œí•œ ì˜¤ë¥˜
- Qt ê´€ë ¨ ì˜¤ë¥˜
- ë©”ëª¨ë¦¬/ë¦¬ì†ŒìŠ¤ ë¶€ì¡±

### 2. ìê°€ ì§„ë‹¨ ë„êµ¬ (`self_diagnosis.py`)
ì‹œìŠ¤í…œ í™˜ê²½ì„ ì ê²€í•˜ê³  ë¬¸ì œë¥¼ ì‚¬ì „ì— í•´ê²°í•©ë‹ˆë‹¤.

**ì§„ë‹¨ í•­ëª©:**
- Python ë²„ì „ ë° í™˜ê²½
- í•„ìˆ˜/ì„ íƒ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ìƒíƒœ
- íŒŒì¼ ì‹œìŠ¤í…œ ë¬´ê²°ì„±
- ì¸ì½”ë”© ì„¤ì •
- Qt í™˜ê²½ ì„¤ì •
- ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤

### 3. ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„° (`background_monitor.py`)
ì‹¤ì‹œê°„ìœ¼ë¡œ ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ê°ì‹œí•˜ê³  ë¬¸ì œë¥¼ ì˜ˆë°©í•©ë‹ˆë‹¤.

**ëª¨ë‹ˆí„°ë§ í•­ëª©:**
- CPU ì‚¬ìš©ë¥ 
- ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
- ë””ìŠ¤í¬ ê³µê°„
- ìŠ¤ë ˆë“œ ìˆ˜
- ë¡œê·¸ íŒŒì¼ í¬ê¸°
- ì„ì‹œ íŒŒì¼

### 4. ì˜¤ë¥˜ ë°ì½”ë ˆì´í„° (`error_decorator.py`)
ê¸°ì¡´ ì½”ë“œì— ì‰½ê²Œ ì˜¤ë¥˜ ë³µêµ¬ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ë„êµ¬ì…ë‹ˆë‹¤.

## ì‚¬ìš© ë°©ë²•

### ê¸°ë³¸ ì‹¤í–‰ (ìë™ ë³µêµ¬ í¬í•¨)
```batch
RUN_WITH_AUTOFIX.bat
```
- ì‹œì‘ ì‹œ ìë™ìœ¼ë¡œ ì‹œìŠ¤í…œ ì§„ë‹¨ ì‹¤í–‰
- ì˜¤ë¥˜ ë°œìƒ ì‹œ ìë™ ë³µêµ¬ ì‹œë„
- ë³µêµ¬ í†µê³„ í‘œì‹œ

### ì‹œìŠ¤í…œ ì§„ë‹¨ë§Œ ì‹¤í–‰
```batch
DIAGNOSE_AND_FIX.bat
```
- ì „ì²´ ì‹œìŠ¤í…œ ì ê²€
- ë°œê²¬ëœ ë¬¸ì œ ìë™ ìˆ˜ì •
- ìƒì„¸í•œ ì§„ë‹¨ ë¦¬í¬íŠ¸ ìƒì„±

### Pythonì—ì„œ ì§ì ‘ ì‚¬ìš©
```python
# ì§„ë‹¨ ì‹¤í–‰
from utils.self_diagnosis import run_diagnosis
run_diagnosis()

# ëª¨ë‹ˆí„°ë§ ì‹œì‘
from utils.background_monitor import get_monitor
monitor = get_monitor()
monitor.start()
```

## ë™ì‘ ì›ë¦¬

### 1. ì˜¤ë¥˜ ê°ì§€ ë° ë³µêµ¬ í”„ë¡œì„¸ìŠ¤

```
ì˜¤ë¥˜ ë°œìƒ
    â†“
ì˜¤ë¥˜ íŒ¨í„´ ë¶„ì„
    â†“
ë³µêµ¬ ì „ëµ ì„ íƒ
    â†“
ìë™ ë³µêµ¬ ì‹œë„
    â†“
ì„±ê³µ â†’ ì‘ì—… ê³„ì†
ì‹¤íŒ¨ â†’ ì‚¬ìš©ì ì•Œë¦¼
```

### 2. ì˜¤ë¥˜ íŒ¨í„´ ë§¤ì¹­

ì‹œìŠ¤í…œì€ ì˜¤ë¥˜ ë©”ì‹œì§€ì™€ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ë¥¼ ë¶„ì„í•˜ì—¬ ì•Œë ¤ì§„ íŒ¨í„´ê³¼ ë§¤ì¹­í•©ë‹ˆë‹¤:

```python
# ì˜ˆ: ì¸ì½”ë”© ì˜¤ë¥˜ íŒ¨í„´
patterns = [
    "UnicodeDecodeError",
    "UnicodeEncodeError", 
    "codec can't decode"
]
```

### 3. ë³µêµ¬ ì „ëµ

ê° ì˜¤ë¥˜ ìœ í˜•ì— ë§ëŠ” ë³µêµ¬ ì „ëµì´ ì ìš©ë©ë‹ˆë‹¤:

#### ì¸ì½”ë”© ì˜¤ë¥˜
1. íŒŒì¼ ì¸ì½”ë”© ìë™ ê°ì§€
2. UTF-8ë¡œ ë³€í™˜
3. ì‹œìŠ¤í…œ ë¡œì¼€ì¼ ì„¤ì •

#### ì„í¬íŠ¸ ì˜¤ë¥˜
1. ëª¨ë“ˆëª… ì¶”ì¶œ
2. pipë¡œ ìë™ ì„¤ì¹˜
3. ì¬ì‹œë„

#### ê²½ë¡œ ì˜¤ë¥˜
1. ê²½ë¡œ ì •ê·œí™”
2. ë””ë ‰í† ë¦¬ ìë™ ìƒì„±
3. Windows ê²½ë¡œ í˜•ì‹ ë³€í™˜

### 4. ë°ì½”ë ˆì´í„° ì‚¬ìš©

ê¸°ì¡´ í•¨ìˆ˜ì— ì‰½ê²Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```python
from utils.error_decorator import auto_recover

@auto_recover(retry_count=2)
def load_file(path):
    # íŒŒì¼ ë¡œë“œ ë¡œì§
    pass
```

## ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

### ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ëŠ” 5ì´ˆë§ˆë‹¤ ì‹œìŠ¤í…œì„ ì²´í¬í•©ë‹ˆë‹¤:

```
CPU ì‚¬ìš©ë¥  â†’ 80% ì´ìƒ ì‹œ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜
ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  â†’ 85% ì´ìƒ ì‹œ ë©”ëª¨ë¦¬ ì •ë¦¬
ë””ìŠ¤í¬ ê³µê°„ â†’ 90% ì´ìƒ ì‹œ ì„ì‹œ íŒŒì¼ ì •ë¦¬
ìŠ¤ë ˆë“œ ìˆ˜ â†’ 100ê°œ ì´ìƒ ì‹œ ëˆ„ìˆ˜ ê²½ê³ 
```

### ëª¨ë‹ˆí„°ë§ ê·œì¹™ ì¶”ê°€

ì»¤ìŠ¤í…€ ê·œì¹™ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```python
monitor.add_rule(
    name="custom_check",
    check_func=lambda: get_some_metric(),
    threshold=100,
    action_func=handle_violation,
    check_interval=30  # ì´ˆ
)
```

### ì•Œë¦¼ ì‹œìŠ¤í…œ

ë¬¸ì œ ê°ì§€ ì‹œ:
1. ë¡œê·¸ì— ê¸°ë¡
2. UIì— ì•Œë¦¼ í‘œì‹œ
3. 3íšŒ ì—°ì† ìœ„ë°˜ ì‹œ ìë™ ì•¡ì…˜ ì‹¤í–‰

## ë¬¸ì œ í•´ê²°

### ìì£¼ ë°œìƒí•˜ëŠ” ë¬¸ì œ

#### 1. "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤"
- í•´ê²°: ë°°ì¹˜ íŒŒì¼ì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰

#### 2. "ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
- í•´ê²°: `DIAGNOSE_AND_FIX.bat` ì‹¤í–‰ìœ¼ë¡œ ìë™ ì„¤ì¹˜

#### 3. "ì¸ì½”ë”© ì˜¤ë¥˜ê°€ ê³„ì† ë°œìƒí•©ë‹ˆë‹¤"
- í•´ê²°: í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
  ```batch
  set PYTHONUTF8=1
  ```

### ë¡œê·¸ í™•ì¸

ë³µêµ¬ ì‹œë„ ê¸°ë¡:
```
%USERPROFILE%\.excel_macro_automation\error_recovery_history.json
```

ì§„ë‹¨ ê²°ê³¼:
```
%USERPROFILE%\.excel_macro_automation\diagnosis_results.json
```

ëª¨ë‹ˆí„°ë§ ë¦¬í¬íŠ¸:
```
%USERPROFILE%\.excel_macro_automation\monitor_report.json
```

## ê³ ê¸‰ ì„¤ì •

### í™˜ê²½ ë³€ìˆ˜

ì‹œìŠ¤í…œ ë™ì‘ì„ ì œì–´í•˜ëŠ” í™˜ê²½ ë³€ìˆ˜:

```batch
REM UTF-8 ê°•ì œ ì‚¬ìš©
set PYTHONUTF8=1

REM Qt í”Œë«í¼ ì„¤ì •
set QT_QPA_PLATFORM=windows

REM ë””ë²„ê·¸ ëª¨ë“œ
set MACRO_DEBUG=1
```

### ë³µêµ¬ ì •ì±… ì»¤ìŠ¤í„°ë§ˆì´ì§•

`error_recovery.py`ì—ì„œ ìƒˆë¡œìš´ íŒ¨í„´ ì¶”ê°€:

```python
recovery_manager.register_pattern(
    name="custom_error",
    patterns=["MyCustomError"],
    recovery_func=my_recovery_function,
    priority=10
)
```

### ëª¨ë‹ˆí„°ë§ ì„ê³„ê°’ ì¡°ì •

ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥  ì„ê³„ê°’ ë³€ê²½:

```python
# CPU ì„ê³„ê°’ì„ 90%ë¡œ ë³€ê²½
monitor.rules[0].threshold = 90.0
```

### ìë™ ì‹œì‘ ì„¤ì •

Windows ì‹œì‘ ì‹œ ëª¨ë‹ˆí„°ë§ ìë™ ì‹œì‘:
1. `WIN+R` â†’ `shell:startup`
2. `START_MONITOR.bat` íŒŒì¼ ìƒì„±:
   ```batch
   @echo off
   cd /d "C:\path\to\macro"
   start /min python -c "from utils.background_monitor import get_monitor; get_monitor().start()"
   ```

## ì„±ëŠ¥ ìµœì í™”

### ë©”ëª¨ë¦¬ ì‚¬ìš© ì¤„ì´ê¸°
- ëª¨ë‹ˆí„°ë§ ì£¼ê¸° ëŠ˜ë¦¬ê¸°: `monitor_timer.start(10000)` # 10ì´ˆ
- íˆìŠ¤í† ë¦¬ í¬ê¸° ì¤„ì´ê¸°: `SystemMetrics(history_size=50)`

### ë¡œê·¸ ê´€ë¦¬
- ìë™ ì •ë¦¬ ì£¼ê¸°: 7ì¼ â†’ 3ì¼ë¡œ ë³€ê²½
- ë¡œê·¸ ë ˆë²¨ ì¡°ì •: WARNING ì´ìƒë§Œ ê¸°ë¡

## ë§ˆë¬´ë¦¬

ì´ ì‹œìŠ¤í…œì€ ì§€ì†ì ìœ¼ë¡œ í•™ìŠµí•˜ê³  ê°œì„ ë©ë‹ˆë‹¤:
- ì˜¤ë¥˜ íŒ¨í„´ì´ ëˆ„ì ë ìˆ˜ë¡ ë³µêµ¬ ì„±ê³µë¥  í–¥ìƒ
- ì‚¬ìš©ì í™˜ê²½ì— ë§ê²Œ ìë™ ìµœì í™”
- ìƒˆë¡œìš´ ì˜¤ë¥˜ ìœ í˜•ë„ ì ì§„ì ìœ¼ë¡œ ëŒ€ì‘

ë¬¸ì œê°€ ì§€ì†ë˜ë©´ GitHub ì´ìŠˆë¡œ ë³´ê³ í•´ì£¼ì„¸ìš”!
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## í´ë¡œë“œ ì½”ë“œì—ì„œì˜ MCP (Model Context Protocol) ì„¤ì¹˜ ë° ì„¤ì • ê°€ì´ë“œ 

### ê³µí†µ ì£¼ì˜ì‚¬í•­
1. í˜„ì¬ ì‚¬ìš© í™˜ê²½ì„ í™•ì¸í•  ê²ƒ. ëª¨ë¥´ë©´ ì‚¬ìš©ìì—ê²Œ ë¬¼ì–´ë³¼ ê²ƒ. 
2. OS(ìœˆë„ìš°,ë¦¬ëˆ…ìŠ¤,ë§¥) ë° í™˜ê²½ë“¤(íŒŒì›Œì…¸,ëª…ë ¹í”„ë¡¬í”„íŠ¸ë“±)ì„ íŒŒì•…í•´ì„œ ê·¸ì— ë§ê²Œ ì„¸íŒ…í•  ê²ƒ. ëª¨ë¥´ë©´ ì‚¬ìš©ìì—ê²Œ ë¬¼ì–´ë³¼ ê²ƒ.
3. mcp-installerì„ ì´ìš©í•´ í•„ìš”í•œ MCPë“¤ì„ ì„¤ì¹˜í•  ê²ƒ (user ìŠ¤ì½”í”„ë¡œ ì„¤ì¹˜ ë° ì ìš©í• ê²ƒ)
4. íŠ¹ì • MCP ì„¤ì¹˜ì‹œ, ë°”ë¡œ ì„¤ì¹˜í•˜ì§€ ë§ê³ , WebSearch ë„êµ¬ë¡œ í•´ë‹¹ MCPì˜ ê³µì‹ ì‚¬ì´íŠ¸ í™•ì¸í•˜ê³  í˜„ì¬ OS ë° í™˜ê²½ ë§¤ì¹˜í•˜ì—¬, ê³µì‹ ì„¤ì¹˜ë²•ë¶€í„° í™•ì¸í•  ê²ƒ
5. ê³µì‹ ì‚¬ì´íŠ¸ í™•ì¸ í›„ì—ëŠ” context7 MCP ì¡´ì¬í•˜ëŠ” ê²½ìš°, context7ìœ¼ë¡œ ë‹¤ì‹œ í•œë²ˆ í™•ì¸í•  ê²ƒ
6. MCP ì„¤ì¹˜ í›„, taskë¥¼ í†µí•´ ë””ë²„ê·¸ ëª¨ë“œë¡œ ì„œë¸Œ ì—ì´ì „íŠ¸ êµ¬ë™í•œ í›„, /mcp ë¥¼ í†µí•´ ì‹¤ì œ ì‘ë™ì—¬ë¶€ë¥¼ ë°˜ë“œì‹œ í™•ì¸í•  ê²ƒ 
7. ì„¤ì • ì‹œ, API KEY í™˜ê²½ ë³€ìˆ˜ ì„¤ì •ì´ í•„ìš”í•œ ê²½ìš°, ê°€ìƒì˜ API í‚¤ë¡œ ë””í´íŠ¸ë¡œ ì„¤ì¹˜ ë° ì„¤ì • í›„, ì˜¬ë°”ë¥¸ API í‚¤ ì •ë³´ë¥¼ ì…ë ¥í•´ì•¼ í•¨ì„ ì‚¬ìš©ìì—ê²Œ ì•Œë¦´ ê²ƒ
8. íŠ¹ì • ì„œë²„ê°€ êµ¬ë™ì¤‘ ìƒíƒœì—¬ì•¼ë§Œ ì •ìƒ ì‘ë™í•˜ëŠ” MCPëŠ” ì—ëŸ¬ê°€ ë‚˜ë„ ì¬ì„¤ì¹˜í•˜ì§€ ë§ê³ , ì •ìƒ êµ¬ë™ì„ ìœ„í•œ ì¡°ê±´ì„ ì‚¬ìš©ìì—ê²Œ ì•Œë¦´ ê²ƒ
9. í˜„ì¬ í´ë¡œë“œ ì½”ë“œê°€ ì‹¤í–‰ë˜ëŠ” í™˜ê²½
10. ì„¤ì¹˜ ìš”ì²­ ë°›ì€ MCPë§Œ ì„¤ì¹˜í•˜ë©´ ë¨. í˜¹ì‹œ ì´ë¯¸ ì„¤ì¹˜ëœ ë‹¤ë¥¸ MCP ì—ëŸ¬ ìˆì–´ë„, ê·¸ëƒ¥ ë‘˜ ê²ƒ

### Windowsì—ì„œì˜ ì£¼ì˜ì‚¬í•­
1. ì„¤ì • íŒŒì¼ ì§ì ‘ ì„¸íŒ…ì‹œ, Windows ê²½ë¡œ êµ¬ë¶„ìëŠ” ë°±ìŠ¬ë˜ì‹œ(\)ì´ë©°, JSON ë‚´ì—ì„œëŠ” ë°˜ë“œì‹œ ì´ìŠ¤ì¼€ì´í”„ ì²˜ë¦¬(\\\\)í•´ì•¼ í•¨
2. Node.jsê°€ %PATH%ì— ë“±ë¡ë˜ì–´ ìˆëŠ”ì§€, ë²„ì „ì´ ìµœì†Œ v18 ì´ìƒì¸ì§€ í™•ì¸í•  ê²ƒ
3. npx -y ì˜µì…˜ì„ ì¶”ê°€í•˜ë©´ ë²„ì „ í˜¸í™˜ì„± ë¬¸ì œë¥¼ ì¤„ì¼ ìˆ˜ ìˆìŒ

### MCP ì„œë²„ ì„¤ì¹˜ ìˆœì„œ

1. **ê¸°ë³¸ ì„¤ì¹˜**: mcp-installerë¥¼ ì‚¬ìš©í•´ ì„¤ì¹˜
2. **ì„¤ì¹˜ í›„ ì •ìƒ ì„¤ì¹˜ ì—¬ë¶€ í™•ì¸**: claude mcp listìœ¼ë¡œ ì„¤ì¹˜ ëª©ë¡ í™•ì¸ í›„, taskë¥¼ í†µí•´ ë””ë²„ê·¸ ëª¨ë“œë¡œ ì„œë¸Œ ì—ì´ì „íŠ¸ êµ¬ë™í•˜ì—¬ /mcpë¡œ ì‘ë™ì—¬ë¶€ í™•ì¸
3. **ë¬¸ì œ ì‹œ ì§ì ‘ ì„¤ì¹˜**: User ìŠ¤ì½”í”„ë¡œ claude mcp add ëª…ë ¹ì–´ ì‚¬ìš©
4. **ê³µì‹ ì‚¬ì´íŠ¸ í™•ì¸ í›„ ê¶Œì¥ ë°©ë²•ìœ¼ë¡œ ì„¤ì¹˜**: npm, pip, uvx ë“±ìœ¼ë¡œ ì§ì ‘ ì„¤ì¹˜

**MCP ì„œë²„ ì œê±° ì‹œ**: `claude mcp remove [server-name]`

---

## Project Overview

Excel Macro Automation is a Python desktop application for automating repetitive tasks by reading Excel files and executing screen automation sequences. Designed for non-technical users in office/medical environments.

## Quick Start Commands

### Running the Application
```bash
# Primary method - simple and fast (recommended)
RUN_SIMPLE.bat

# Complete setup with dependency installation
WINDOWS_RUN.bat

# Python direct execution - handles import fixing automatically
python run_main.py

# Alternative Python launchers
python run_main_fixed.py
python run_simple.py
```

### Development Commands
```bash
# Install dependencies (Windows batch)
INSTALL_DEPENDENCIES.bat

# Or manual dependency installation
pip install -r requirements.txt

# Manual application testing as needed

# Code formatting (line length: 100)
black src/ --line-length 100

# Linting
flake8 src/ --max-line-length=100

# Build executable
pyinstaller excel_macro.spec
```

### Manual Testing
Manual testing can be performed by running the application and testing functionality.

## Architecture Overview

### Tech Stack
- **GUI**: PyQt5 (primary), Tkinter (fallback)
- **Data**: pandas, openpyxl for Excel processing
- **Automation**: pyautogui, opencv-python for screen interaction
- **Vision**: easyocr for OCR, mss for screenshots
- **Security**: cryptography for AES-256 encryption
- **Build**: PyInstaller for single-file distribution

### Core Components
```
src/
â”œâ”€â”€ ui/main_window.py          # Main application window with tabbed interface
â”œâ”€â”€ automation/engine.py       # Core automation execution engine
â”œâ”€â”€ excel/excel_manager.py     # Excel file processing and data mapping
â”œâ”€â”€ core/macro_storage.py      # Macro serialization/persistence
â”œâ”€â”€ vision/                    # OCR and image recognition modules
â”œâ”€â”€ config/settings.py         # Application configuration with encryption
â””â”€â”€ logger/app_logger.py       # Logging infrastructure
```

### Application Flow
1. **Excel Tab**: Load files, map sheets/columns, preview data
2. **Editor Tab**: Drag & drop macro step creation with visual workflow builder
3. **Run Tab**: Execute macros with progress monitoring and CSV logging
4. Data flows: Excel â†’ Core Controller â†’ Automation Engine â†’ Screen actions â†’ Logs

### Key Features
- **Drag & Drop Editor**: Visual macro builder with step configuration dialogs
- **Screen Automation**: Mouse/keyboard actions, image search, OCR text recognition
- **Conditional Logic**: If statements, loops, variables with Excel data binding
- **Multi-language**: Korean/English localization (resources/locales/)
- **Error Recovery**: Automated error handling with detailed reporting
- **Execution Logging**: CSV logs with filtering and export capabilities

## Development Guidelines

### Code Architecture Patterns
- **MVC Pattern**: Established structure with clear separation of concerns
- **Component Organization**: UI widgets in separate modules with dialog system
- **Event-Driven**: PyQt5 signal/slot system for UI interactions
- **Data Layer**: Excel integration with status tracking and CSV output

### Import Structure
- Use absolute imports (handled automatically by run_main.py)
- Core modules: `from automation.engine import AutomationEngine`
- UI components: `from ui.widgets.excel_widget import ExcelWidget`
- Config/Utils: `from config.settings import Settings`

### File Naming Conventions
- Python files: snake_case.py
- UI dialogs: `*_dialog.py` in `src/ui/dialogs/`
- Temporary files: `temp_*.py` for debugging
- Batch scripts: UPPERCASE.bat for Windows operations

### Windows Environment Considerations  
- **C Drive Direct Execution**: No more WSL file copying - runs directly from project directory
- **Path Handling**: Use Path objects; JSON configs require escaped backslashes (`\\\\`)
- **Dependency Management**: INSTALL_DEPENDENCIES.bat handles all package installation
- **Batch Scripts**: RUN_SIMPLE.bat (fast) and WINDOWS_RUN.bat (complete setup)
- **Screen Resolution**: Minimum 1280x720, handles DPI scaling

### Quality Assurance
- **Manual Testing**: Comprehensive testing of drag&drop, execution, logging
- **Error Collection**: Use COLLECT_ERRORS_WINDOWS.bat for systematic error reporting
- **Code Quality**: Use black and flake8 for formatting and linting

### Configuration Management
- **Settings**: `src/config/settings.py` with AES-256 encryption for sensitive data
- **Localization**: JSON files in `resources/locales/` (en.json, ko.json)
- **Build Config**: `pyproject.toml` defines tool configurations (black, flake8, mypy)

### Security Considerations
- No hardcoded API keys or credentials
- AES-256 encryption for saved macro files (.emf format)
- Local-only operation (no internet required)
- Sensitive data handling in error reports

### Error Handling Best Practices
- Use established logging infrastructure (`logger.app_logger`)
- Implement comprehensive error dialogs with actionable information
- Include screenshot capture in error reports
- Follow error recovery patterns in existing codebase

### Performance Considerations
- Handle large Excel files (100+ rows) efficiently
- Monitor memory usage during long-running operations
- Implement proper cleanup for screen capture resources
- Use threading for non-blocking UI operations during automation

---

# Git Commit Message Rules

## Format Structure
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

## Types (Required)
- `feat`: new feature
- `fix`: bug fix
- `docs`: documentation only
- `style`: formatting, missing semi colons, etc
- `refactor`: code change that neither fixes bug nor adds feature
- `perf`: performance improvement
- `chore`: updating grunt tasks, dependencies, etc
- `ci`: changes to CI configuration
- `build`: changes affecting build system
- `revert`: reverting previous commit

## Scope (Optional)
- Component, file, or feature area affected
- Use kebab-case: `user-auth`, `payment-api`
- Omit if change affects multiple areas

## Description Rules
- Use imperative mood: "add" not "added" or "adds"
- No capitalization of first letter
- No period at end
- Max 50 characters
- Be specific and actionable

## Body Guidelines
- Wrap at 72 characters
- Explain what and why, not how
- Separate from description with blank line
- Use bullet points for multiple changes

## Footer Format
- `BREAKING CHANGE:` for breaking changes
- `Closes #123` for issue references
- `Co-authored-by: Name <email>`

## Examples
```
feat(auth): add OAuth2 Google login

fix: resolve memory leak in user session cleanup

docs(api): update authentication endpoints

refactor(utils): extract validation helpers to separate module

BREAKING CHANGE: remove deprecated getUserData() method
```

## Workflow Integration
**ALWAYS write a commit message after completing any development task, feature, or bug fix.**

## Validation Checklist
- [ ] Type is from approved list
- [ ] Description under 50 chars
- [ ] Imperative mood used
- [ ] No trailing period
- [ ] Meaningful and clear context
# Clean Code Guidelines

You are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:

## Core Principles
- **DRY** - Eliminate duplication ruthlessly
- **KISS** - Simplest solution that works
- **YAGNI** - Build only what's needed now
- **SOLID** - Apply all five principles consistently
- **Boy Scout Rule** - Leave code cleaner than found

## Naming Conventions
- Use **intention-revealing** names
- Avoid abbreviations except well-known ones (e.g., URL, API)
- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix
- Constants: UPPER_SNAKE_CASE
- No magic numbers - use named constants

## Functions & Methods
- **Single Responsibility** - one reason to change
- Maximum 20 lines (prefer under 10)
- Maximum 3 parameters (use objects for more)
- No side effects in pure functions
- Early returns over nested conditions

## Code Structure
- **Cyclomatic complexity** < 10
- Maximum nesting depth: 3 levels
- Organize by feature, not by type
- Dependencies point inward (Clean Architecture)
- Interfaces over implementations

## Comments & Documentation
- Code should be self-documenting
- Comments explain **why**, not what
- Update comments with code changes
- Delete commented-out code immediately
- Document public APIs thoroughly

## Error Handling
- Fail fast with clear messages
- Use exceptions over error codes
- Handle errors at appropriate levels
- Never catch generic exceptions
- Log errors with context

## Quality Assurance
- Manual testing of key features
- Code review before commits
- Error handling verification

## Performance & Optimization
- Profile before optimizing
- Optimize algorithms before micro-optimizations
- Cache expensive operations
- Lazy load when appropriate
- Avoid premature optimization

## Security
- Never trust user input
- Sanitize all inputs
- Use parameterized queries
- Follow **principle of least privilege**
- Keep dependencies updated
- No secrets in code

## Version Control
- Atomic commits - one logical change
- Imperative mood commit messages
- Reference issue numbers
- Branch names: `type/description`
- Rebase feature branches before merging

## Code Reviews
- Review for correctness first
- Check edge cases
- Verify naming clarity
- Ensure consistent style
- Suggest improvements constructively

## Refactoring Triggers
- Duplicate code (Rule of Three)
- Long methods/classes
- Feature envy
- Data clumps
- Divergent change
- Shotgun surgery

## Final Checklist
Before committing, ensure:
- [ ] No linting errors
- [ ] No console logs
- [ ] No commented code
- [ ] No TODOs without tickets
- [ ] Performance acceptable
- [ ] Security considered
- [ ] Documentation updated

Remember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.
## Core Directive
You are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.

## Guiding Principles
- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity
- **Expert-Level Standards**: Every output must meet professional software engineering standards
- **Concrete Results**: Provide specific, actionable details at each step

---

## Phase 1: Codebase Exploration & Analysis
**REQUIRED ACTIONS:**
1. **Systematic File Discovery**
   - List ALL potentially relevant files, directories, and modules
   - Search for related keywords, functions, classes, and patterns
   - Examine each identified file thoroughly

2. **Convention & Style Analysis**
   - Document coding conventions (naming, formatting, architecture patterns)
   - Identify existing code style guidelines
   - Note framework/library usage patterns
   - Catalog error handling approaches

**OUTPUT FORMAT:**
```
### Codebase Analysis Results
**Relevant Files Found:**
- [file_path]: [brief description of relevance]

**Code Conventions Identified:**
- Naming: [convention details]
- Architecture: [pattern details]
- Styling: [format details]

**Key Dependencies & Patterns:**
- [library/framework]: [usage pattern]
```

---

## Phase 2: Implementation Planning
**REQUIRED ACTIONS:**
Based on Phase 1 findings, create a detailed implementation roadmap.

**OUTPUT FORMAT:**
```markdown
## Implementation Plan

### Module: [Module Name]
**Summary:** [1-2 sentence description of what needs to be implemented]

**Tasks:**
- [ ] [Specific implementation task]
- [ ] [Specific implementation task]

**Acceptance Criteria:**
- [ ] [Measurable success criterion]
- [ ] [Measurable success criterion]
- [ ] [Performance/quality requirement]

### Module: [Next Module Name]
[Repeat structure above]
```

---

## Phase 3: Implementation Execution
**REQUIRED ACTIONS:**
1. Implement each module following the plan from Phase 2
2. Verify ALL acceptance criteria are met before proceeding
3. Ensure code adheres to conventions identified in Phase 1

**QUALITY GATES:**
- [ ] All acceptance criteria validated
- [ ] Code follows established conventions
- [ ] Minimalistic approach maintained
- [ ] Expert-level implementation standards met

---

## Success Validation
Before completing any task, confirm:
- âœ… All three phases completed sequentially
- âœ… Each phase output meets specified format requirements
- âœ… Implementation satisfies all acceptance criteria
- âœ… Code quality meets professional standards

## Response Structure
Always structure your response as:
1. **Phase 1 Results**: [Codebase analysis findings]
2. **Phase 2 Plan**: [Implementation roadmap]  
3. **Phase 3 Implementation**: [Actual code with validation]
</file>

<file path="COLLECT_ERRORS_WINDOWS.bat">
@echo off
chcp 65001 >nul
echo =====================================
echo ì˜¤ë¥˜ ìˆ˜ì§‘ ì‹œìŠ¤í…œ (Windows)
echo =====================================
echo.

REM ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
set WORK_DIR=C:\macro
if not exist "%WORK_DIR%" (
    echo [ERROR] %WORK_DIR% ë””ë ‰í† ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.
    echo RUN_ON_WINDOWS.batì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”.
    pause
    exit /b 1
)

cd /d "%WORK_DIR%"

echo ìµœê·¼ 7ì¼ê°„ì˜ ì˜¤ë¥˜ë¥¼ ìˆ˜ì§‘í•©ë‹ˆë‹¤...
python -c "import sys; sys.path.insert(0, '.'); from src.utils.error_report_generator import collect_and_save_errors; count = collect_and_save_errors(7); print(f'\nì´ {count}ê°œì˜ ì˜¤ë¥˜ê°€ ìˆ˜ì§‘ë˜ì—ˆìŠµë‹ˆë‹¤.')"

echo.
echo ìˆ˜ì§‘ëœ ì˜¤ë¥˜ íŒŒì¼ ìœ„ì¹˜:
echo %USERPROFILE%\.excel_macro_automation\collected_errors\
echo.

echo ìµœì‹  ì˜¤ë¥˜ ìš”ì•½:
python -c "import sys; sys.path.insert(0, '.'); from src.utils.error_report_generator import ErrorCollector; c = ErrorCollector(); errors = c.get_latest_errors(5); [print(f'{e[\"timestamp\"]}: {e[\"type\"]} - {e[\"message\"][:50]}...') for e in errors] if errors else print('ìˆ˜ì§‘ëœ ì˜¤ë¥˜ê°€ ì—†ìŠµë‹ˆë‹¤.')"

echo.
echo ì˜¤ë¥˜ íŒŒì¼ì„ íƒìƒ‰ê¸°ì—ì„œ ì—´ê¸°:
echo explorer "%USERPROFILE%\.excel_macro_automation\collected_errors"
echo.
pause
</file>

<file path="CURRENT_STATUS.md">
# Excel Macro Automation - í˜„ì¬ êµ¬í˜„ ìƒíƒœ

## ğŸš€ ì‹¤í–‰ ë°©ë²•

```bash
# 1. ê°„ë‹¨ ì‹¤í–‰ (ê¶Œì¥)
RUN_SIMPLE.bat

# 2. ì™„ì „ ì„¤ì¹˜ ì‹¤í–‰
WINDOWS_RUN.bat

# 3. Python ì§ì ‘ ì‹¤í–‰
python run_main.py
```

## âœ… êµ¬í˜„ ì™„ë£Œëœ ê¸°ëŠ¥

### 1. Excel ì—°ë™ (T-002) âœ“
- Excel íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° (.xlsx, .xls, .csv)
- ì‹œíŠ¸ ì„ íƒ ë° ì „í™˜
- ë°ì´í„° ë¯¸ë¦¬ë³´ê¸° (ì²˜ìŒ 100í–‰)
- ì—´ ë§¤í•‘ ì„¤ì •
- ìƒíƒœ ì—´ ìë™ ì¶”ê°€/ì—…ë°ì´íŠ¸

### 2. ë§¤í¬ë¡œ ì—ë””í„° (T-003) âœ“
- **ë“œë˜ê·¸ ì•¤ ë“œë¡­** ë°©ì‹ì˜ ì§ê´€ì ì¸ UI
- ë‹¨ê³„ ì¶”ê°€/ì‚­ì œ/ìˆœì„œ ë³€ê²½
- ê° ë‹¨ê³„ë³„ ìƒì„¸ ì„¤ì •
- ì‹¤ì‹œê°„ ë§¤í¬ë¡œ ë¯¸ë¦¬ë³´ê¸°

### 3. ì§€ì›ë˜ëŠ” ë§¤í¬ë¡œ ë‹¨ê³„

#### ë§ˆìš°ìŠ¤ ë™ì‘
- **ë§ˆìš°ìŠ¤ í´ë¦­** ğŸ–±ï¸
  - ì¢Œí‘œ ì§€ì •, í´ë¦­ íšŸìˆ˜, ë²„íŠ¼ ì„ íƒ
- **ë§ˆìš°ìŠ¤ ì´ë™** â†—ï¸
  - ì¢Œí‘œë¡œ ì´ë™, ì´ë™ ì‹œê°„ ì„¤ì •

#### í‚¤ë³´ë“œ ë™ì‘
- **í…ìŠ¤íŠ¸ ì…ë ¥** âŒ¨ï¸
  - ì¼ë°˜ í…ìŠ¤íŠ¸ ì…ë ¥
  - Excel ë³€ìˆ˜ ë°”ì¸ë”© ({{ë³€ìˆ˜ëª…}})
- **ë‹¨ì¶•í‚¤** âŒ˜
  - Ctrl, Alt, Shift ì¡°í•©í‚¤ ì§€ì›

#### ëŒ€ê¸° ë™ì‘
- **ì‹œê°„ ëŒ€ê¸°** â±ï¸
  - ì´ˆ ë‹¨ìœ„ ëŒ€ê¸° ì‹œê°„ ì„¤ì •
- **ì´ë¯¸ì§€ ëŒ€ê¸°** ğŸ–¼ï¸ (T-005) âœ“
  - í™”ë©´ì—ì„œ ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ ëŒ€ê¸°
  - ROI(ê´€ì‹¬ ì˜ì—­) ì§€ì • ê°€ëŠ¥
  - ì‹ ë¢°ë„ ì„¤ì •

#### í™”ë©´ ì¸ì‹ (T-005, T-006) âœ“
- **ì´ë¯¸ì§€ ê²€ìƒ‰** ğŸ”
  - OpenCV ê¸°ë°˜ ê³ ê¸‰ ì´ë¯¸ì§€ ë§¤ì¹­
  - DPI ìŠ¤ì¼€ì¼ë§ ìë™ ì²˜ë¦¬
  - ë©€í‹° ëª¨ë‹ˆí„° ì§€ì›
- **í…ìŠ¤íŠ¸ ê²€ìƒ‰** ğŸ”¤
  - EasyOCR ê¸°ë°˜ í•œêµ­ì–´/ì˜ì–´ í…ìŠ¤íŠ¸ ì¸ì‹
  - Excel ì—´ ë°ì´í„°ì™€ ì—°ë™
  - ì°¾ì€ í…ìŠ¤íŠ¸ ìë™ í´ë¦­

#### ì œì–´ êµ¬ì¡° (T-007) ğŸš§
- **ì¡°ê±´ë¬¸** â“ (ê°œë°œ ì¤‘)
- **ë°˜ë³µë¬¸** ğŸ”„ (ì˜ˆì •)

### 4. ë§¤í¬ë¡œ ì‹¤í–‰ ì—”ì§„ (T-004) âœ“
- Excel í–‰ ë‹¨ìœ„ ìˆœì°¨ ì‹¤í–‰
- ì¼ì‹œì •ì§€/ì¬ê°œ (F9)
- ê°•ì œ ì¢…ë£Œ (ESC)
- ì‹¤í–‰ ë¡œê·¸ ê¸°ë¡
- ì§„í–‰ë¥  í‘œì‹œ

### 5. ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° (T-008) âœ“
- JSON í˜•ì‹ ì €ì¥
- ì•”í˜¸í™” ì €ì¥ ì˜µì…˜
- ìë™ ë°±ì—…
- í…œí”Œë¦¿ ì œê³µ

## ğŸ”§ ê¸°ìˆ  ìŠ¤íƒ

- **ì–¸ì–´**: Python 3.10
- **GUI**: PyQt5
- **ìë™í™”**: PyAutoGUI
- **ì´ë¯¸ì§€ ì²˜ë¦¬**: OpenCV
- **OCR**: EasyOCR
- **Excel**: pandas, openpyxl

## ğŸ“ í”„ë¡œì íŠ¸ êµ¬ì¡°

```
macro/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ automation/     # ì‹¤í–‰ ì—”ì§„
â”‚   â”œâ”€â”€ config/         # ì„¤ì • ê´€ë¦¬
â”‚   â”œâ”€â”€ core/           # í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”œâ”€â”€ excel/          # Excel ì²˜ë¦¬
â”‚   â”œâ”€â”€ logger/         # ë¡œê¹…
â”‚   â”œâ”€â”€ ui/             # ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â”œâ”€â”€ dialogs/    # ë‹¤ì´ì–¼ë¡œê·¸
â”‚   â”‚   â””â”€â”€ widgets/    # ìœ„ì ¯ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ utils/          # ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ vision/         # ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ì¸ì‹
â”œâ”€â”€ venv/               # ê°€ìƒí™˜ê²½
â”œâ”€â”€ demo_data.xlsx      # í…ŒìŠ¤íŠ¸ìš© Excel ë°ì´í„°
â””â”€â”€ run_gui.py          # GUI ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
```

## ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ (ê°œë°œ ì¤‘)

- [ ] T-007: ì¡°ê±´ë¬¸ UI ë° ì‹¤í–‰ ë¡œì§
- [ ] T-009: ì‹¤í–‰ ë¡œê¹… ê°œì„ 
- [ ] T-010: ë§¤í¬ë¡œ í…ŒìŠ¤íŠ¸ ì‹œë®¬ë ˆì´í„°
- [ ] T-011: ë‹¤í¬ ëª¨ë“œ
- [ ] T-012: ë‹¤êµ­ì–´ ì§€ì›

## ğŸ’¡ ì‚¬ìš© íŒ

1. **Excel ë°ì´í„° ì¤€ë¹„**
   - ì²« ë²ˆì§¸ í–‰ì€ ì—´ ì œëª©ìœ¼ë¡œ ì‚¬ìš©
   - 'ìƒíƒœ' ì—´ì€ ìë™ìœ¼ë¡œ ì¶”ê°€ë¨

2. **ë§¤í¬ë¡œ ë§Œë“¤ê¸°**
   - ì™¼ìª½ íŒ”ë ˆíŠ¸ì—ì„œ ë‹¨ê³„ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€
   - ê° ë‹¨ê³„ë¥¼ í´ë¦­í•˜ì—¬ ìƒì„¸ ì„¤ì •
   - {{ë³€ìˆ˜ëª…}} í˜•ì‹ìœ¼ë¡œ Excel ë°ì´í„° ì°¸ì¡°

3. **ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ê²€ìƒ‰**
   - ROI ì„ íƒ ì‹œ í™”ë©´ì´ ë°˜íˆ¬ëª…í•˜ê²Œ ë³€í•¨
   - ë“œë˜ê·¸í•˜ì—¬ ê²€ìƒ‰ ì˜ì—­ ì§€ì •
   - í…ŒìŠ¤íŠ¸ ë²„íŠ¼ìœ¼ë¡œ ë¯¸ë¦¬ í™•ì¸ ê°€ëŠ¥

## ğŸ› ì•Œë ¤ì§„ ì´ìŠˆ

- WSL í™˜ê²½ì—ì„œ tkinter ê²½ê³  (ë¬´ì‹œ ê°€ëŠ¥)
- High DPI ë””ìŠ¤í”Œë ˆì´ì—ì„œ ì¢Œí‘œ ë³´ì • í•„ìš”í•  ìˆ˜ ìˆìŒ

## ğŸ“ ë¬¸ì˜

ë¬¸ì œê°€ ë°œìƒí•˜ê±°ë‚˜ ê¸°ëŠ¥ ì œì•ˆì´ ìˆìœ¼ì‹œë©´ ì´ìŠˆë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”.
</file>

<file path="ERROR_COLLECTION_GUIDE.md">
# ì˜¤ë¥˜ ìˆ˜ì§‘ ì‹œìŠ¤í…œ ê°€ì´ë“œ

## ê°œìš”
ì˜¤ë¥˜ ìˆ˜ì§‘ ì‹œìŠ¤í…œì€ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë°œìƒí•œ ëª¨ë“  ì˜¤ë¥˜ë¥¼ ìë™ìœ¼ë¡œ ìˆ˜ì§‘í•˜ê³  JSON íŒŒì¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.

## ì£¼ìš” ê¸°ëŠ¥

### 1. ì˜¤ë¥˜ ìˆ˜ì§‘
- ì˜¤ë¥˜ ë³µêµ¬ íˆìŠ¤í† ë¦¬
- ë§¤í¬ë¡œ ì‹¤í–‰ ë¡œê·¸
- ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸

### 2. ì €ì¥ ìœ„ì¹˜
```
%USERPROFILE%\.excel_macro_automation\collected_errors\
â”œâ”€â”€ errors_20241219_143022.json   # íƒ€ì„ìŠ¤íƒ¬í”„ë³„ ì˜¤ë¥˜ íŒŒì¼
â”œâ”€â”€ errors_20241219_150512.json
â””â”€â”€ latest_errors.json            # ìµœì‹  ì˜¤ë¥˜ íŒŒì¼ ë§í¬
```

## ì‚¬ìš© ë°©ë²•

### Pythonì—ì„œ ì‚¬ìš©
```python
from utils.error_report_generator import ErrorCollector

# ì˜¤ë¥˜ ìˆ˜ì§‘ê¸° ìƒì„±
collector = ErrorCollector()

# ìµœê·¼ 7ì¼ê°„ì˜ ì˜¤ë¥˜ ìˆ˜ì§‘ ë° ì €ì¥
errors = collector.collect_errors(days=7)
print(f"ìˆ˜ì§‘ëœ ì˜¤ë¥˜: {len(errors)}ê°œ")

# ì˜¤ë¥˜ ìš”ì•½ í†µê³„ í™•ì¸
summary = collector.get_error_summary()
print(f"ì´ ì˜¤ë¥˜: {summary['total_errors']}ê°œ")
print(f"ì˜¤ë¥˜ ìœ í˜•: {summary['error_types']}")

# ìµœì‹  ì˜¤ë¥˜ 10ê°œ í™•ì¸
recent_errors = collector.get_latest_errors(count=10)
for error in recent_errors:
    print(f"{error['timestamp']}: {error['type']} - {error['message']}")

# 30ì¼ ì´ìƒ ëœ ì˜¤ë¥˜ íŒŒì¼ ì •ë¦¬
collector.clear_old_errors(days=30)
```

### ëª…ë ¹ì¤„ì—ì„œ ì‚¬ìš©
```python
# ì˜¤ë¥˜ ìˆ˜ì§‘ ìŠ¤í¬ë¦½íŠ¸ (collect_errors.py)
from utils.error_report_generator import collect_and_save_errors

# ìµœê·¼ 7ì¼ê°„ì˜ ì˜¤ë¥˜ ìˆ˜ì§‘
count = collect_and_save_errors(days=7)
print(f"{count}ê°œì˜ ì˜¤ë¥˜ê°€ ìˆ˜ì§‘ë˜ì—ˆìŠµë‹ˆë‹¤.")
```

## ì˜¤ë¥˜ íŒŒì¼ í˜•ì‹

### errors_YYYYMMDD_HHMMSS.json
```json
[
    {
        "timestamp": "2024-12-19T14:30:22.123456",
        "type": "UnicodeDecodeError",
        "message": "'cp949' codec can't decode byte 0xec",
        "source": "recovery_system",
        "pattern": "encoding_error",
        "context": {}
    },
    {
        "timestamp": "2024-12-19T14:25:10.654321",
        "type": "ExecutionError",
        "message": "Step execution failed",
        "source": "execution_log",
        "context": {
            "step": "í…ìŠ¤íŠ¸ ì…ë ¥",
            "row": "2"
        }
    }
]
```

### latest_errors.json
```json
{
    "file": "errors_20241219_143022.json",
    "timestamp": "20241219_143022",
    "count": 15,
    "days_collected": 7
}
```

## ì˜¤ë¥˜ ì†ŒìŠ¤ë³„ ì„¤ëª…

### 1. recovery_system
- ìë™ ì˜¤ë¥˜ ë³µêµ¬ ì‹œìŠ¤í…œì—ì„œ ê°ì§€ëœ ì˜¤ë¥˜
- ë³µêµ¬ ì‹œë„ ì‹¤íŒ¨ ê¸°ë¡

### 2. execution_log
- ë§¤í¬ë¡œ ì‹¤í–‰ ì¤‘ ë°œìƒí•œ ì˜¤ë¥˜
- ì‹¤í–‰ ë‹¨ê³„ì™€ Excel í–‰ ì •ë³´ í¬í•¨

### 3. app_log
- ì¼ë°˜ ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜¤ë¥˜
- ERROR ë ˆë²¨ ë¡œê·¸ë§Œ ìˆ˜ì§‘

## í´ë¡œë“œì— ì „ë‹¬í•˜ê¸°

ìˆ˜ì§‘ëœ ì˜¤ë¥˜ë¥¼ í´ë¡œë“œì— ì „ë‹¬í•  ë•Œ:

1. ìµœì‹  ì˜¤ë¥˜ íŒŒì¼ ì°¾ê¸°:
   ```
   %USERPROFILE%\.excel_macro_automation\collected_errors\latest_errors.json
   ```

2. í•´ë‹¹ íŒŒì¼ì—ì„œ ì‹¤ì œ ì˜¤ë¥˜ íŒŒì¼ëª… í™•ì¸

3. ì˜¤ë¥˜ íŒŒì¼ ë‚´ìš©ì„ ë³µì‚¬í•˜ì—¬ í´ë¡œë“œì— ì „ë‹¬

## ìë™í™” íŒ

### ë°°ì¹˜ íŒŒì¼ë¡œ ì˜¤ë¥˜ ìˆ˜ì§‘
```batch
@echo off
python -c "from utils.error_report_generator import collect_and_save_errors; print(f'{collect_and_save_errors()} errors collected')"
pause
```

### ì£¼ê¸°ì  ì˜¤ë¥˜ ì •ë¦¬
```python
# ë§¤ì£¼ ì‹¤í–‰í•  ìŠ¤í¬ë¦½íŠ¸
from utils.error_report_generator import ErrorCollector

collector = ErrorCollector()
collector.clear_old_errors(days=30)  # 30ì¼ ì´ìƒ ëœ íŒŒì¼ ì‚­ì œ
```

## ì£¼ì˜ì‚¬í•­

1. ì˜¤ë¥˜ íŒŒì¼ì€ ì‹œê°„ì´ ì§€ë‚˜ë©´ ëˆ„ì ë˜ë¯€ë¡œ ì£¼ê¸°ì ì¸ ì •ë¦¬ í•„ìš”
2. ë¯¼ê°í•œ ì •ë³´ê°€ ì˜¤ë¥˜ ë©”ì‹œì§€ì— í¬í•¨ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì£¼ì˜
3. ë””ìŠ¤í¬ ê³µê°„ì„ ê³ ë ¤í•˜ì—¬ ì ì ˆí•œ ë³´ê´€ ê¸°ê°„ ì„¤ì •
</file>

<file path="ERROR_FIXES_SUMMARY.md">
# Excel Macro Automation - Error Fixes Summary

## Fixed Issues

### 1. **Platform-Specific Qt Settings**
- **File**: `run_simple.py`
- **Fix**: Added Windows-specific QT_QPA_PLATFORM setting
- **Impact**: Prevents Qt platform errors on Windows

### 2. **Excel Manager Exception Handling**
- **File**: `src/excel/excel_manager.py`
- **Fix**: Replaced bare except clauses with specific exceptions
- **Impact**: Better error debugging and handling

### 3. **Macro Loading with Encoding Issues**
- **File**: `src/utils/macro_loader.py` (new)
- **Fix**: Added safe macro loader with encoding detection
- **Impact**: Handles corrupted macro files and encoding issues

### 4. **Multi-Monitor Support**
- **File**: `src/core/macro_types.py`
- **Fix**: Removed negative coordinate validation
- **Impact**: Allows macros to work on multi-monitor setups

### 5. **Excel-Optional Execution**
- **File**: `src/automation/engine.py`
- **Fix**: Added standalone execution mode
- **Impact**: Macros can run without Excel files

### 6. **Missing file_path Property**
- **File**: `src/excel/excel_manager.py`
- **Fix**: Added @property for file_path
- **Impact**: Fixes AttributeError during execution

### 7. **QWidget Import Error**
- **File**: `src/ui/dialogs/loop_step_dialog.py`
- **Fix**: Added QWidget to imports
- **Impact**: Fixes import error in dialogs

### 8. **Date Parsing Warnings**
- **File**: `src/excel/excel_manager.py`
- **Fix**: Suppressed pandas date parsing warnings
- **Impact**: Cleaner console output

## Remaining Considerations

### 1. **Optional Dependencies**
Some features require optional packages:
- `pynput`: For global hotkeys
- `easyocr`: For OCR functionality
- `chardet`: For encoding detection

### 2. **Windows-Specific Setup**
For Windows users:
1. Use `VALIDATE_INSTALL.bat` to check installation
2. Use `FIX_MACRO_WINDOWS.bat` to fix corrupted macros
3. Install Visual C++ Redistributables for some packages

### 3. **Resource Management**
- ROI selectors should properly release resources on error
- Thread cleanup on application exit
- File handle management in Excel operations

### 4. **Error Reporting**
Enhanced error messages now include:
- Specific exception types
- File encoding information
- Step validation details

## Testing Recommendations

1. Run `VALIDATE_INSTALL.bat` to check installation
2. Test with both Excel files and standalone macros
3. Test on multi-monitor setups
4. Test with non-ASCII characters in file paths

## Known Limitations

1. Some OCR features may not work without proper language packs
2. Global hotkeys require additional permissions on some systems
3. High DPI displays may have scaling issues (partially addressed)

## Support

For issues:
1. Check error logs in the execution log viewer
2. Run validation script to check installation
3. Use the macro fixer for corrupted files
4. Check encoding of Excel files and macro files
</file>

<file path="package.json">
{
  "name": "macro",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs"
}
</file>

<file path="pyproject.toml">
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "excel-macro-automation"
version = "1.0.0"
description = "Excel-based task automation macro desktop application"
readme = "README.md"
requires-python = ">=3.8"
license = {text = "MIT"}
authors = [
    {name = "Excel Macro Team", email = "contact@excelmacro.com"}
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: MIT License",
    "Operating System :: Microsoft :: Windows",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Topic :: Office/Business",
]

[project.scripts]
excel-macro = "main:main"

[tool.black]
line-length = 100
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''


[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true

[tool.flake8]
max-line-length = 100
exclude = [
    ".git",
    "__pycache__",
    "docs/source/conf.py",
    "old",
    "build",
    "dist",
    ".eggs",
    "*.egg",
]
</file>

<file path="QUICK_REFERENCE.md">
# ğŸš€ ìë™ ì˜¤ë¥˜ ë³µêµ¬ ì‹œìŠ¤í…œ - ë¹ ë¥¸ ì°¸ì¡°

## ğŸ¯ ì¦‰ì‹œ ì‹¤í–‰ ëª…ë ¹ì–´

### ì˜¤ë¥˜ ë°œìƒ ì‹œ
```batch
RUN_WITH_AUTOFIX.bat
```

### ì‹œìŠ¤í…œ ì ê²€
```batch
DIAGNOSE_AND_FIX.bat
```

### ì¼ë°˜ ì‹¤í–‰
```batch
RUN_ON_WINDOWS.bat
```

## ğŸ”§ ìë™ìœ¼ë¡œ í•´ê²°ë˜ëŠ” ë¬¸ì œë“¤

| ì˜¤ë¥˜ ìœ í˜• | ìë™ í•´ê²° ë°©ë²• |
|---------|-------------|
| ì¸ì½”ë”© ì˜¤ë¥˜ | UTF-8ë¡œ ìë™ ë³€í™˜ |
| ëª¨ë“ˆ ì—†ìŒ | pipë¡œ ìë™ ì„¤ì¹˜ |
| ê²½ë¡œ ì˜¤ë¥˜ | ë””ë ‰í† ë¦¬ ìë™ ìƒì„± |
| Qt í”Œë«í¼ | Windows ì„¤ì • ìë™ ì ìš© |
| ë©”ëª¨ë¦¬ ë¶€ì¡± | ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì‹¤í–‰ |
| ë””ìŠ¤í¬ ë¶€ì¡± | ì„ì‹œ íŒŒì¼ ìë™ ì •ë¦¬ |

## ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸

### ê±´ê°• ìƒíƒœ í‘œì‹œ
- ğŸŸ¢ **ì •ìƒ**: ëª¨ë“  ì‹œìŠ¤í…œ ì •ìƒ
- ğŸŸ¡ **ì£¼ì˜**: ì¼ë¶€ ì§€í‘œ ì„ê³„ê°’ ê·¼ì ‘
- ğŸ”´ **ìœ„í—˜**: ì¦‰ì‹œ ì¡°ì¹˜ í•„ìš”

### ëª¨ë‹ˆí„°ë§ ì§€í‘œ
- CPU < 80%
- ë©”ëª¨ë¦¬ < 85%
- ë””ìŠ¤í¬ < 90%
- ìŠ¤ë ˆë“œ < 100ê°œ

## ğŸ› ï¸ ë¬¸ì œë³„ í•´ê²°ë²•

### "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
â†’ ìë™ìœ¼ë¡œ ê²½ë¡œ ìƒì„±ë¨

### "ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤"
â†’ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì¬ì‹¤í–‰

### "ëª¨ë“ˆì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
â†’ ìë™ìœ¼ë¡œ pip ì„¤ì¹˜ ì‹œë„

### "ì¸ì½”ë”© ì˜¤ë¥˜"
â†’ íŒŒì¼ ì¸ì½”ë”© ìë™ ê°ì§€ ë° ë³€í™˜

## ğŸ’¡ ìœ ìš©í•œ íŒ

### 1. ì˜ˆë°©ì´ ìµœì„ 
- ì£¼ê¸°ì ìœ¼ë¡œ `DIAGNOSE_AND_FIX.bat` ì‹¤í–‰
- ë””ìŠ¤í¬ ê³µê°„ 10GB ì´ìƒ ìœ ì§€

### 2. ë¡œê·¸ í™•ì¸
```
%USERPROFILE%\.excel_macro_automation\
â”œâ”€â”€ logs\              # ì‹¤í–‰ ë¡œê·¸
â”œâ”€â”€ error_recovery_history.json  # ë³µêµ¬ ê¸°ë¡
â””â”€â”€ monitor_report.json         # ëª¨ë‹ˆí„°ë§ ë¦¬í¬íŠ¸
```

### 3. ì„±ëŠ¥ ìµœì í™”
- ë¶ˆí•„ìš”í•œ í”„ë¡œê·¸ë¨ ì¢…ë£Œ
- ì„ì‹œ íŒŒì¼ ì •ê¸° ì •ë¦¬
- ê°€ìƒí™˜ê²½ ì‚¬ìš© ê¶Œì¥

## ğŸ†˜ ê¸´ê¸‰ ìƒí™© ëŒ€ì²˜

### í”„ë¡œê·¸ë¨ì´ ì‹œì‘ë˜ì§€ ì•Šì„ ë•Œ
1. `DIAGNOSE_AND_FIX.bat` ì‹¤í–‰
2. Python ì¬ì„¤ì¹˜ ê³ ë ¤
3. ê°€ìƒí™˜ê²½ ì¬ìƒì„±

### ë°˜ë³µì ì¸ ì˜¤ë¥˜
1. ì˜¤ë¥˜ íŒ¨í„´ í™•ì¸
2. `error_recovery_history.json` ê²€í† 
3. GitHub ì´ìŠˆ ë“±ë¡

## ğŸ“ ì¶”ê°€ ë„ì›€ë§

- ë¬¸ì„œ: `AUTO_ERROR_RECOVERY_GUIDE.md`
- ë¡œê·¸ ìœ„ì¹˜: `%USERPROFILE%\.excel_macro_automation\`
- ì§€ì›: GitHub Issues

---
ğŸ’ª **Remember**: ëŒ€ë¶€ë¶„ì˜ ì˜¤ë¥˜ëŠ” ìë™ìœ¼ë¡œ í•´ê²°ë©ë‹ˆë‹¤!
</file>

<file path="README.md">
# Excel Macro Automation

Excel-based task automation macro desktop application for Windows.

## Overview

This application allows users to automate repetitive tasks by reading task lists from Excel files and executing predefined sequences of mouse, keyboard, and screen recognition actions.

## Features

- Excel file integration with sheet/column mapping
- Drag & drop macro editor
- Mouse and keyboard automation
- Image search and OCR capabilities
- Conditional logic and loops
- Execution logging
- Multi-language support (Korean/English)

## Requirements

- Windows 10/11 64-bit
- Python 3.8+
- 1280x720 minimum screen resolution

## Installation

1. Clone the repository:
```bash
git clone https://github.com/reahbi/macro.git
cd macro
```

2. Create virtual environment (requires python3-venv package):
```bash
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

## Development

Run the application:
```bash
python main.py
```

Manual testing as needed for functionality verification.

Build executable:
```bash
pyinstaller excel_macro.spec
```

## Project Structure

```
macro/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ excel/        # Excel integration modules
â”‚   â”œâ”€â”€ ui/           # PyQt5 GUI components
â”‚   â”œâ”€â”€ automation/   # Automation engine
â”‚   â”œâ”€â”€ core/         # Core business logic
â”‚   â”œâ”€â”€ plugin/       # Plugin system
â”‚   â”œâ”€â”€ utils/        # Utilities (encryption, etc.)
â”‚   â”œâ”€â”€ config/       # Configuration management
â”‚   â””â”€â”€ logger/       # Logging system
â”œâ”€â”€ resources/        # Icons, templates, locales
â”œâ”€â”€ docs/             # Documentation
â””â”€â”€ main.py           # Application entry point
```

## License

MIT License
</file>

<file path="resources/locales/en.json">
{
  "app": {
    "name": "Excel Macro Automation",
    "description": "Excel-based task automation tool"
  },
  "menu": {
    "file": "File",
    "edit": "Edit",
    "view": "View",
    "help": "Help",
    "new_project": "New Project",
    "open_project": "Open Project",
    "save_project": "Save Project",
    "exit": "Exit",
    "settings": "Settings",
    "toggle_theme": "Toggle Theme",
    "about": "About"
  },
  "tabs": {
    "excel": "Excel",
    "editor": "Editor",
    "run": "Run"
  },
  "status": {
    "ready": "Ready",
    "running": "Running",
    "paused": "Paused",
    "stopped": "Stopped",
    "error": "Error"
  },
  "dialog": {
    "confirm_exit": "Are you sure you want to exit?",
    "yes": "Yes",
    "no": "No",
    "ok": "OK",
    "cancel": "Cancel"
  }
}
</file>

<file path="resources/locales/ko.json">
{
  "app": {
    "name": "ì—‘ì…€ ë§¤í¬ë¡œ ìë™í™”",
    "description": "ì—‘ì…€ ê¸°ë°˜ ì‘ì—… ìë™í™” ë„êµ¬"
  },
  "menu": {
    "file": "íŒŒì¼",
    "edit": "í¸ì§‘",
    "view": "ë³´ê¸°",
    "help": "ë„ì›€ë§",
    "new_project": "ìƒˆ í”„ë¡œì íŠ¸",
    "open_project": "í”„ë¡œì íŠ¸ ì—´ê¸°",
    "save_project": "í”„ë¡œì íŠ¸ ì €ì¥",
    "exit": "ì¢…ë£Œ",
    "settings": "ì„¤ì •",
    "toggle_theme": "í…Œë§ˆ ì „í™˜",
    "about": "ì •ë³´"
  },
  "tabs": {
    "excel": "ì—‘ì…€",
    "editor": "í¸ì§‘ê¸°",
    "run": "ì‹¤í–‰"
  },
  "status": {
    "ready": "ì¤€ë¹„",
    "running": "ì‹¤í–‰ ì¤‘",
    "paused": "ì¼ì‹œì •ì§€",
    "stopped": "ì¤‘ì§€ë¨",
    "error": "ì˜¤ë¥˜"
  },
  "dialog": {
    "confirm_exit": "ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
    "yes": "ì˜ˆ",
    "no": "ì•„ë‹ˆì˜¤",
    "ok": "í™•ì¸",
    "cancel": "ì·¨ì†Œ"
  }
}
</file>

<file path="run_from_windows_native.ps1">
# Excel Macro Automation - Windows Native Execution
# PowerShell script for running the application directly on Windows

Write-Host "=" * 50
Write-Host "Excel Macro Automation - Windows Native Setup"
Write-Host "=" * 50

# Check if running as administrator
if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Host "ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤." -ForegroundColor Red
    Write-Host "PowerShellì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”." -ForegroundColor Yellow
    pause
    exit
}

# WSL path to Windows path conversion
$wslPath = "\\wsl.localhost\Ubuntu\home\nosky\macro"
$windowsPath = "C:\ExcelMacroAutomation"

Write-Host "`n1. í”„ë¡œì íŠ¸ íŒŒì¼ ë³µì‚¬ ì¤‘..." -ForegroundColor Green

# Create directory if not exists
if (!(Test-Path $windowsPath)) {
    New-Item -ItemType Directory -Path $windowsPath | Out-Null
}

# Copy files from WSL to Windows
Write-Host "   WSLì—ì„œ Windowsë¡œ íŒŒì¼ ë³µì‚¬ ì¤‘..."
Copy-Item -Path "$wslPath\*" -Destination $windowsPath -Recurse -Force -ErrorAction SilentlyContinue

Write-Host "`n2. Python í™•ì¸ ì¤‘..." -ForegroundColor Green

# Check Python installation
try {
    $pythonVersion = python --version 2>&1
    Write-Host "   Python ë°œê²¬: $pythonVersion" -ForegroundColor Green
} catch {
    Write-Host "   Pythonì´ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤." -ForegroundColor Red
    Write-Host "   Python ë‹¤ìš´ë¡œë“œ í˜ì´ì§€ë¥¼ ì—½ë‹ˆë‹¤..." -ForegroundColor Yellow
    Start-Process "https://www.python.org/downloads/"
    Write-Host "   Python ì„¤ì¹˜ í›„ ì´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”."
    pause
    exit
}

Write-Host "`n3. í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘..." -ForegroundColor Green

# Create virtual environment
Set-Location $windowsPath
if (!(Test-Path "venv_windows")) {
    Write-Host "   ê°€ìƒí™˜ê²½ ìƒì„± ì¤‘..."
    python -m venv venv_windows
}

# Activate virtual environment and install packages
Write-Host "   íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘ (ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤)..."
& "$windowsPath\venv_windows\Scripts\python.exe" -m pip install --upgrade pip | Out-Null
& "$windowsPath\venv_windows\Scripts\python.exe" -m pip install PyQt5 pandas openpyxl pyautogui opencv-python numpy easyocr flask

Write-Host "`n4. Windowsìš© ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì¤‘..." -ForegroundColor Green

# Create run script for Windows
$runScript = @'
import sys
import os
from pathlib import Path

# Add project paths
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# Import and run main
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    
    app = QApplication(sys.argv)
    
    from ui.main_window import MainWindow
    from config.settings import Settings
    
    settings = Settings()
    window = MainWindow(settings)
    window.show()
    
    print("\nExcel Macro Automationì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
    print("Windows ë„¤ì´í‹°ë¸Œ ëª¨ë“œë¡œ ì‹¤í–‰ ì¤‘...")
    
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"ì˜¤ë¥˜: {e}")
    import traceback
    traceback.print_exc()
    input("\nì—”í„°ë¥¼ ëˆŒëŸ¬ ì¢…ë£Œ...")
'@

$runScript | Out-File -FilePath "$windowsPath\run_windows.py" -Encoding UTF8

Write-Host "`n5. ë°°ì¹˜ íŒŒì¼ ìƒì„± ì¤‘..." -ForegroundColor Green

# Create batch file for easy execution
$batchFile = @"
@echo off
cd /d $windowsPath
call venv_windows\Scripts\activate
python run_windows.py
pause
"@

$batchFile | Out-File -FilePath "$windowsPath\ExcelMacroAutomation.bat" -Encoding ASCII

Write-Host "`n6. ë°”íƒ•í™”ë©´ ë°”ë¡œê°€ê¸° ìƒì„± ì¤‘..." -ForegroundColor Green

# Create desktop shortcut
$desktopPath = [Environment]::GetFolderPath("Desktop")
$shortcut = (New-Object -ComObject WScript.Shell).CreateShortcut("$desktopPath\Excel Macro Automation.lnk")
$shortcut.TargetPath = "$windowsPath\ExcelMacroAutomation.bat"
$shortcut.WorkingDirectory = $windowsPath
$shortcut.IconLocation = "C:\Windows\System32\shell32.dll,13"
$shortcut.Save()

Write-Host "`nâœ… ì„¤ì¹˜ ì™„ë£Œ!" -ForegroundColor Green
Write-Host "`nì‹¤í–‰ ì˜µì…˜:" -ForegroundColor Yellow
Write-Host "1. ë°”íƒ•í™”ë©´ì˜ 'Excel Macro Automation' ë°”ë¡œê°€ê¸° ë”ë¸”í´ë¦­"
Write-Host "2. $windowsPath\ExcelMacroAutomation.bat ì‹¤í–‰"
Write-Host "3. ì´ PowerShellì—ì„œ: & '$windowsPath\ExcelMacroAutomation.bat'"

Write-Host "`nì§€ê¸ˆ ì‹¤í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (Y/N): " -NoNewline
$response = Read-Host

if ($response -eq 'Y' -or $response -eq 'y') {
    Write-Host "`nì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‹¤í–‰í•©ë‹ˆë‹¤..." -ForegroundColor Green
    Start-Process "$windowsPath\ExcelMacroAutomation.bat"
}

Write-Host "`nì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì—”í„°ë¥¼ ëˆŒëŸ¬ ì¢…ë£Œ..." -ForegroundColor Green
pause
</file>

<file path="run_main_fixed.py">
#!/usr/bin/env python3
"""
Import ë¬¸ì œë¥¼ í•´ê²°í•œ ë©”ì¸ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
"""

import sys
import os
from pathlib import Path

# UTF-8 ì¸ì½”ë”© ì„¤ì •
import locale
if sys.platform == 'win32':
    # Windowsì—ì„œ UTF-8 ì„¤ì •
    os.environ['PYTHONIOENCODING'] = 'utf-8'
    try:
        locale.setlocale(locale.LC_ALL, 'ko_KR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_ALL, 'Korean_Korea.949')
        except:
            pass

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python ê²½ë¡œì— ì¶”ê°€
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# ëª¨ë“  import ë¬¸ì œ í•´ê²°
def fix_all_imports():
    """ëª¨ë“  íŒŒì¼ì˜ import ê²½ë¡œë¥¼ ìˆ˜ì •"""
    print("Import ê²½ë¡œ ìˆ˜ì • ì¤‘...")
    
    # src ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„±
    src_path.mkdir(exist_ok=True)
    
    # ëª¨ë“  Python íŒŒì¼ ì°¾ê¸°
    for py_file in src_path.rglob("*.py"):
        if py_file.is_file():
            try:
                content = py_file.read_text(encoding='utf-8')
                original_content = content
                
                # ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½
                import re
                
                # from ..module import íŒ¨í„´ ë³€ê²½
                content = re.sub(r'from \.\.\.([^.\s]+)', r'from \1', content)
                content = re.sub(r'from \.\.([^.\s]+)', r'from \1', content)
                content = re.sub(r'from \.([^.\s]+)', r'from ui.\1', content)
                
                # íŠ¹ì • import ìˆ˜ì •
                content = content.replace("from dialogs.", "from ui.dialogs.")
                content = content.replace("from widgets.", "from ui.widgets.")
                
                # ì˜ëª»ëœ ìœ„ì¹˜ ìˆ˜ì •
                content = content.replace("from ui.macro_types import", "from core.macro_types import")
                content = content.replace("from ui.macro_storage import", "from core.macro_storage import")
                content = content.replace("from ui.file_selector import", "from ui.widgets.file_selector import")
                content = content.replace("from ui.sheet_mapper import", "from ui.widgets.sheet_mapper import")
                content = content.replace("from ui.data_preview import", "from ui.widgets.data_preview import")
                content = content.replace("from ui.models import", "from excel.models import")
                content = content.replace("from ui.executor import", "from automation.executor import")
                content = content.replace("from ui.hotkey_listener import", "from automation.hotkey_listener import")
                content = content.replace("from ui.image_matcher import", "from vision.image_matcher import")
                content = content.replace("from ui.text_extractor import", "from vision.text_extractor import")
                
                # íŒŒì¼ì´ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ì €ì¥
                if content != original_content:
                    py_file.write_text(content, encoding='utf-8')
                    print(f"ìˆ˜ì •ë¨: {py_file.relative_to(src_path)}")
                    
            except Exception as e:
                print(f"íŒŒì¼ ìˆ˜ì • ì˜¤ë¥˜ {py_file}: {e}")
    
    print("Import ê²½ë¡œ ìˆ˜ì • ì™„ë£Œ")

# Import ìˆ˜ì • ì‹¤í–‰
fix_all_imports()

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
if sys.platform == 'win32':
    os.environ['QT_QPA_PLATFORM'] = 'windows'
else:
    os.environ['QT_QPA_PLATFORM'] = 'xcb'

# ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    from PyQt5.QtGui import QFont
    
    # High DPI ì§€ì›
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # í°íŠ¸ ì„¤ì •
    if sys.platform == 'win32':
        font = QFont("ë§‘ì€ ê³ ë”•", 10)
    else:
        font = QFont("Nanum Gothic", 10)
    app.setFont(font)
    
    # ë©”ì¸ ìœˆë„ìš° import ë° ì‹¤í–‰
    print("ëª¨ë“ˆ import ì¤‘...")
    
    try:
        from ui.main_window import MainWindow
        print("âœ“ MainWindow import ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— MainWindow import ì‹¤íŒ¨: {e}")
        raise
        
    try:
        from config.settings import Settings
        print("âœ“ Settings import ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Settings import ì‹¤íŒ¨: {e}")
        raise
        
    try:
        from logger.app_logger import setup_logger
        print("âœ“ Logger import ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Logger import ì‹¤íŒ¨: {e}")
        raise
    
    # ë¡œê±° ì„¤ì •
    try:
        logger = setup_logger()
        logger.info("Starting Excel Macro Automation Application")
        print("âœ“ Logger ì„¤ì • ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Logger ì„¤ì • ì‹¤íŒ¨: {e}")
        # Logger ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
        logger = None
    
    # ì„¤ì • ì´ˆê¸°í™”
    try:
        settings = Settings()
        print("âœ“ Settings ì´ˆê¸°í™” ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Settings ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        raise
    
    # ë©”ì¸ ìœˆë„ìš° ìƒì„± ë° í‘œì‹œ
    try:
        print("âœ“ MainWindow ê°ì²´ ìƒì„± ì¤‘...")
        window = MainWindow(settings)
        print("âœ“ MainWindow ê°ì²´ ìƒì„± ì™„ë£Œ")
        
        print("âœ“ ìœˆë„ìš° íƒ€ì´í‹€ ì„¤ì • ì¤‘...")
        window.setWindowTitle("Excel ê¸°ë°˜ ì‘ì—… ìë™í™” ë§¤í¬ë¡œ")
        print("âœ“ ìœˆë„ìš° íƒ€ì´í‹€ ì„¤ì • ì™„ë£Œ")
        
        print("âœ“ ìœˆë„ìš° í‘œì‹œ ì¤‘...")
        window.show()
        print("âœ“ ìœˆë„ìš° í‘œì‹œ ì™„ë£Œ")
        
        print("\nâœ“ Excel Macro Automation ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
        print("âœ“ ëª¨ë“  GUI ì»´í¬ë„ŒíŠ¸ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.")
        print("\nê¸°ëŠ¥:")
        print("- Excel íƒ­: íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°, ì‹œíŠ¸ ì„ íƒ, ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°")
        print("- Editor íƒ­: ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë§¤í¬ë¡œ í¸ì§‘")
        print("- Run íƒ­: ë§¤í¬ë¡œ ì‹¤í–‰ ë° ëª¨ë‹ˆí„°ë§")
        print("\nì°½ì„ ë‹«ìœ¼ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.")
        print("\nâœ“ ì´ë²¤íŠ¸ ë£¨í”„ ì‹œì‘ ì¤‘...")
        
        # ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰
        result = app.exec_()
        print(f"\nâœ“ ì´ë²¤íŠ¸ ë£¨í”„ ì¢…ë£Œë¨ (ì½”ë“œ: {result})")
        sys.exit(result)
        
    except Exception as window_error:
        print(f"\në©”ì¸ ìœˆë„ìš° ìƒì„± ì¤‘ ì˜¤ë¥˜: {window_error}")
        import traceback
        traceback.print_exc()
        raise
    
except Exception as e:
    print(f"\nì˜¤ë¥˜ ë°œìƒ: {e}")
    print("\nìì„¸í•œ ì˜¤ë¥˜ ì •ë³´:")
    import traceback
    traceback.print_exc()
    
    print("\në””ë²„ê¹… ì •ë³´:")
    print(f"Project root: {project_root}")
    print(f"Src path: {src_path}")
    print(f"Python path: {sys.path[:3]}")
    print(f"Platform: {sys.platform}")
    
    input("\nPress Enter to exit...")
</file>

<file path="run_windows_wsl.sh">
#!/bin/bash
# Windows + WSL2 í™˜ê²½ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

echo "Windows + WSL2 í™˜ê²½ì—ì„œ Excel Macro Automation ì‹¤í–‰"
echo "=================================================="

# Windows IP ì£¼ì†Œ ê°€ì ¸ì˜¤ê¸°
WINDOWS_IP=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}')
export DISPLAY=$WINDOWS_IP:0.0
export LIBGL_ALWAYS_INDIRECT=1

echo "Windows IP: $WINDOWS_IP"
echo "DISPLAY ì„¤ì •: $DISPLAY"
echo ""

# X Server ì—°ê²° í…ŒìŠ¤íŠ¸
echo "X Server ì—°ê²° í…ŒìŠ¤íŠ¸ ì¤‘..."
if command -v xset &> /dev/null; then
    if xset q &>/dev/null; then
        echo "âœ“ X Server ì—°ê²° ì„±ê³µ!"
    else
        echo "âœ— X Serverì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        echo ""
        echo "ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:"
        echo "1. Windowsì—ì„œ VcXsrv ë˜ëŠ” MobaXtermì´ ì‹¤í–‰ ì¤‘ì¸ê°€?"
        echo "2. VcXsrv ì„¤ì •ì—ì„œ 'Disable access control'ì´ ì²´í¬ë˜ì–´ ìˆëŠ”ê°€?"
        echo "3. Windows ë°©í™”ë²½ì´ X Serverë¥¼ ì°¨ë‹¨í•˜ê³  ìˆì§€ ì•Šì€ê°€?"
        echo ""
        echo "VcXsrv ë‹¤ìš´ë¡œë“œ: https://sourceforge.net/projects/vcxsrv/"
        exit 1
    fi
else
    echo "xsetì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. X Server í…ŒìŠ¤íŠ¸ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤."
fi

echo ""
echo "ê°€ìƒí™˜ê²½ í™œì„±í™”..."
source venv/bin/activate

echo "Python ê²½ë¡œ: $(which python)"
echo "Python ë²„ì „: $(python --version)"
echo ""

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
echo "ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‹¤í–‰í•©ë‹ˆë‹¤..."
python run_simple.py
</file>

<file path="run_windows.ps1">
# PowerShell script to run the macro application on Windows
# This script helps run the WSL-developed app in native Windows environment

Write-Host "=== Excel Macro Automation Tool - Windows Runner ===" -ForegroundColor Cyan

# Check if Python is installed
try {
    $pythonVersion = python --version 2>&1
    Write-Host "Found Python: $pythonVersion" -ForegroundColor Green
} catch {
    Write-Host "Python is not installed or not in PATH!" -ForegroundColor Red
    Write-Host "Please install Python from python.org" -ForegroundColor Yellow
    exit 1
}

# Get the script directory
$scriptPath = $PSScriptRoot
if (-not $scriptPath) {
    $scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
}

# Handle UNC/WSL paths
if ($scriptPath -like "\\wsl*" -or $scriptPath -like "\\\\*") {
    Write-Host "Detected WSL/UNC path. Creating temporary copy..." -ForegroundColor Yellow
    
    $tempDir = Join-Path $env:TEMP "excel_macro_tool"
    if (Test-Path $tempDir) {
        Remove-Item $tempDir -Recurse -Force
    }
    
    # Create the directory first
    New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
    
    Write-Host "Copying files to: $tempDir" -ForegroundColor Yellow
    
    # Copy files and directories separately to avoid errors
    Get-ChildItem -Path $scriptPath -File | ForEach-Object {
        Copy-Item -Path $_.FullName -Destination $tempDir -Force
    }
    
    # Copy src directory
    if (Test-Path (Join-Path $scriptPath "src")) {
        Copy-Item -Path (Join-Path $scriptPath "src") -Destination $tempDir -Recurse -Force
    }
    
    # Copy other important directories if they exist
    @("resources", "captures", "docs") | ForEach-Object {
        $dirPath = Join-Path $scriptPath $_
        if (Test-Path $dirPath) {
            Copy-Item -Path $dirPath -Destination $tempDir -Recurse -Force
        }
    }
    
    $scriptPath = $tempDir
}

# Change to the script directory
Set-Location $scriptPath
Write-Host "Working directory: $(Get-Location)" -ForegroundColor Green

# Check if virtual environment exists
$venvPath = Join-Path $scriptPath "venv"
$venvActivate = Join-Path $venvPath "Scripts\Activate.ps1"

if (Test-Path $venvActivate) {
    Write-Host "Activating virtual environment..." -ForegroundColor Yellow
    & $venvActivate
} else {
    Write-Host "No virtual environment found. Creating one..." -ForegroundColor Yellow
    python -m venv venv
    & $venvActivate
}

# Install/update dependencies
Write-Host "`nChecking dependencies..." -ForegroundColor Yellow
$requirementsPath = Join-Path $scriptPath "requirements.txt"

if (Test-Path $requirementsPath) {
    Write-Host "Installing requirements..." -ForegroundColor Yellow
    pip install -r requirements.txt --quiet
} else {
    Write-Host "No requirements.txt found. Installing core packages..." -ForegroundColor Yellow
    pip install PyQt5 pandas openpyxl pyautogui pillow screeninfo cryptography --quiet
}

# Set environment variables for better Windows compatibility
$env:QT_AUTO_SCREEN_SCALE_FACTOR = "1"
$env:QT_ENABLE_HIGHDPI_SCALING = "1"

# Run the application
Write-Host "`nStarting Excel Macro Automation Tool..." -ForegroundColor Green
Write-Host "Note: Running in native Windows mode for better GUI compatibility" -ForegroundColor Cyan

try {
    python run_main_fixed.py
} catch {
    Write-Host "`nError running application: $_" -ForegroundColor Red
    Write-Host "Press any key to exit..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}
</file>

<file path="run_with_debug.py">
#!/usr/bin/env python3
"""
ë””ë²„ê·¸ ëª¨ë“œë¡œ ì‹¤í–‰
"""

import sys
import os
from pathlib import Path

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# Windows IP ìë™ ê°ì§€
import subprocess
result = subprocess.run(['cat', '/etc/resolv.conf'], capture_output=True, text=True)
for line in result.stdout.split('\n'):
    if 'nameserver' in line:
        windows_ip = line.split()[1]
        break

# ì—¬ëŸ¬ DISPLAY ì„¤ì • ì‹œë„
display_options = [
    f"{windows_ip}:0.0",
    f"{windows_ip}:0",
    "localhost:0.0",
    "localhost:0",
    ":0.0",
    ":0"
]

print("=== GUI ì‹¤í–‰ ì‹œë„ ===")
print(f"Windows IP: {windows_ip}")

for display in display_options:
    print(f"\nDISPLAY={display} ì‹œë„ ì¤‘...")
    os.environ['DISPLAY'] = display
    os.environ['LIBGL_ALWAYS_INDIRECT'] = '1'
    
    try:
        from PyQt5.QtWidgets import QApplication, QMessageBox
        from PyQt5.QtCore import Qt, QTimer
        
        # High DPI ì„¤ì •
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        
        app = QApplication(sys.argv)
        
        # ê°„ë‹¨í•œ ë©”ì‹œì§€ ë°•ìŠ¤ í‘œì‹œ
        msg = QMessageBox()
        msg.setWindowTitle("ì—°ê²° ì„±ê³µ!")
        msg.setText(f"X Server ì—°ê²° ì„±ê³µ!\nDISPLAY: {display}")
        msg.setIcon(QMessageBox.Information)
        msg.setStandardButtons(QMessageBox.Ok)
        
        # 3ì´ˆ í›„ ìë™ ë‹«ê¸°
        QTimer.singleShot(3000, msg.close)
        
        msg.show()
        
        print(f"âœ“ ì„±ê³µ! DISPLAY={display}")
        print("\nì˜¬ë°”ë¥¸ DISPLAY ì„¤ì •ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
        print(f"ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì‹¤í–‰í•˜ì„¸ìš”:")
        print(f"export DISPLAY={display}")
        print(f"source venv/bin/activate")
        print(f"python run_simple.py")
        
        app.exec_()
        break
        
    except Exception as e:
        print(f"âœ— ì‹¤íŒ¨: {e}")
        continue
else:
    print("\nëª¨ë“  DISPLAY ì„¤ì •ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
    print("\nVcXsrv ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”:")
    print("1. VcXsrvê°€ ì‹¤í–‰ ì¤‘ì¸ê°€?")
    print("2. 'Disable access control' ì˜µì…˜ì´ ì²´í¬ë˜ì–´ ìˆëŠ”ê°€?")
    print("3. Windows ë°©í™”ë²½ì´ ì°¨ë‹¨í•˜ê³  ìˆì§€ ì•Šì€ê°€?")
</file>

<file path="run_with_recovery.py">
#!/usr/bin/env python3
"""
ì˜¤ë¥˜ ìë™ ë³µêµ¬ ê¸°ëŠ¥ì´ í¬í•¨ëœ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
"""

import sys
import os
from pathlib import Path
import traceback
import time
from datetime import datetime

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python ê²½ë¡œì— ì¶”ê°€
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

def setup_environment():
    """í™˜ê²½ ì„¤ì •"""
    # Windows í™˜ê²½ ì„¤ì •
    if sys.platform == 'win32':
        os.environ['QT_QPA_PLATFORM'] = 'windows'
        os.environ['PYTHONUTF8'] = '1'
    elif sys.platform.startswith('linux'):
        os.environ['QT_QPA_PLATFORM'] = 'xcb'
        if 'DISPLAY' not in os.environ:
            os.environ['DISPLAY'] = ':0'

def run_diagnosis():
    """ì§„ë‹¨ ì‹¤í–‰"""
    print("=" * 60)
    print("ì‹œìŠ¤í…œ ì§„ë‹¨ ì¤‘...")
    print("=" * 60)
    
    try:
        from utils.self_diagnosis import SelfDiagnosis
        diagnosis = SelfDiagnosis()
        summary = diagnosis.run_full_diagnosis()
        
        if summary['failed'] > 0:
            print(f"\nâš ï¸  {summary['failed']}ê°œì˜ ë¬¸ì œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.")
            print("ìë™ ìˆ˜ì •ì„ ì ìš©í–ˆìŠµë‹ˆë‹¤.")
            time.sleep(2)
        else:
            print("âœ… ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤.")
            
        return True
        
    except Exception as e:
        print(f"âŒ ì§„ë‹¨ ì¤‘ ì˜¤ë¥˜: {e}")
        return False

def run_application():
    """ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰"""
    try:
        from PyQt5.QtWidgets import QApplication
        from PyQt5.QtCore import Qt
        
        # ì˜¤ë¥˜ ë³µêµ¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        from utils.error_recovery import get_recovery_manager
        recovery_manager = get_recovery_manager()
        
        # High DPI ì„¤ì •
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        
        # ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒì„±
        app = QApplication(sys.argv)
        app.setApplicationName("Excel Macro Automation")
        app.setOrganizationName("ExcelMacro")
        
        # ì „ì—­ ì˜ˆì™¸ ì²˜ë¦¬ê¸° ì„¤ì •
        def handle_exception(exc_type, exc_value, exc_traceback):
            """ì „ì—­ ì˜ˆì™¸ ì²˜ë¦¬"""
            if issubclass(exc_type, KeyboardInterrupt):
                sys.__excepthook__(exc_type, exc_value, exc_traceback)
                return
                
            # ì˜¤ë¥˜ ë¡œê¹…
            error_msg = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
            print(f"\n{'=' * 60}")
            print("ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!")
            print(f"{'=' * 60}")
            print(error_msg)
            
            # ë³µêµ¬ ì‹œë„
            if recovery_manager.try_recover(exc_value):
                print("âœ… ì˜¤ë¥˜ê°€ ìë™ìœ¼ë¡œ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.")
            else:
                print("âŒ ì˜¤ë¥˜ë¥¼ ìë™ìœ¼ë¡œ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                
                # ì˜¤ë¥˜ ë³´ê³  ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
                try:
                    from ui.dialogs.error_report_dialog import ErrorReportDialog
                    ErrorReportDialog.show_error(
                        "ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜¤ë¥˜",
                        str(exc_value),
                        detailed_error=error_msg
                    )
                except:
                    pass
                    
        sys.excepthook = handle_exception
        
        # ë©”ì¸ ìœˆë„ìš° ìƒì„±
        from ui.main_window import MainWindow
        from utils.error_decorator import auto_recover
        
        # ë©”ì¸ ìœˆë„ìš° ìƒì„±ì„ ì˜¤ë¥˜ ë³µêµ¬ë¡œ ê°ì‹¸ê¸°
        @auto_recover(retry_count=2)
        def create_main_window():
            return MainWindow()
            
        window = create_main_window()
        window.show()
        
        # ë³µêµ¬ í†µê³„ í‘œì‹œ
        stats = recovery_manager.get_statistics()
        if stats['total_recoveries'] > 0:
            print(f"\në³µêµ¬ í†µê³„: {stats['success_rate']:.1f}% ì„±ê³µë¥ ")
            
        # ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
        return app.exec_()
        
    except Exception as e:
        print(f"\nâŒ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹¤íŒ¨: {e}")
        traceback.print_exc()
        
        # ì§„ë‹¨ ë„êµ¬ ì‹¤í–‰ ì œì•ˆ
        print("\në‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì‹œìŠ¤í…œ ì§„ë‹¨ì„ ì‹¤í–‰í•´ë³´ì„¸ìš”:")
        print("python -m utils.self_diagnosis")
        
        return 1

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("=" * 60)
    print("Excel Macro Automation - ìë™ ë³µêµ¬ ëª¨ë“œ")
    print(f"ì‹œì‘ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)
    
    # í™˜ê²½ ì„¤ì •
    setup_environment()
    
    # ì§„ë‹¨ ì‹¤í–‰
    if not run_diagnosis():
        print("\nì‹œìŠ¤í…œ ì§„ë‹¨ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
        response = input("ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ")
        if response.lower() != 'y':
            return 1
            
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
    print("\nì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤...")
    return run_application()

if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="RUNNING_GUIDE.md">
# Excel Macro Automation - ì‹¤í–‰ ê°€ì´ë“œ (Cë“œë¼ì´ë¸Œ ë²„ì „)

## ğŸ“‹ ê°œìš”

í”„ë¡œì íŠ¸ê°€ Cë“œë¼ì´ë¸Œë¡œ ì´ë™ë˜ì–´ WSL í™˜ê²½ì—ì„œ íŒŒì¼ ë³µì‚¬ ì—†ì´ ì§ì ‘ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

### 1ë‹¨ê³„: ì˜ì¡´ì„± ì„¤ì¹˜ (ìµœì´ˆ 1íšŒ)
```bash
# Windows ë°°ì¹˜ íŒŒì¼ë¡œ ìë™ ì„¤ì¹˜
INSTALL_DEPENDENCIES.bat

# ë˜ëŠ” ìˆ˜ë™ ì„¤ì¹˜
pip install -r requirements.txt
```

### 2ë‹¨ê³„: ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
```bash
# ë°©ë²• 1: ê°„ë‹¨í•œ ì‹¤í–‰ (ê¶Œì¥)
RUN_SIMPLE.bat

# ë°©ë²• 2: ì™„ì „í•œ ì„¤ì¹˜ ë° ì‹¤í–‰
WINDOWS_RUN.bat

# ë°©ë²• 3: Python ì§ì ‘ ì‹¤í–‰
python run_main.py
```

## ğŸ“ ì‹¤í–‰ íŒŒì¼ ì„¤ëª…

### ğŸ¯ ì£¼ìš” ì‹¤í–‰ íŒŒì¼
- **`RUN_SIMPLE.bat`** - ê°€ì¥ ê°„ë‹¨í•œ ì‹¤í–‰ ë°©ë²• (ì¶”ì²œ)
- **`WINDOWS_RUN.bat`** - ì˜ì¡´ì„± ì„¤ì¹˜ í¬í•¨ ì™„ì „ ì‹¤í–‰
- **`INSTALL_DEPENDENCIES.bat`** - ì˜ì¡´ì„±ë§Œ ì„¤ì¹˜

### ğŸ Python ì‹¤í–‰ íŒŒì¼
- **`run_main.py`** - ê¸°ë³¸ ì‹¤í–‰ íŒŒì¼ (import ë¬¸ì œ ìë™ í•´ê²°)
- **`run_main_fixed.py`** - ëŒ€ì²´ ì‹¤í–‰ íŒŒì¼
- **`run_simple.py`** - ìµœì†Œ ì‹¤í–‰ íŒŒì¼

## ğŸ”§ ì„¤ì¹˜ ìš”êµ¬ì‚¬í•­

### í•„ìˆ˜ ìš”êµ¬ì‚¬í•­
- **Windows 10/11 64-bit**
- **Python 3.8+** (í˜„ì¬ 3.13.1 í™•ì¸ë¨)
- **ìµœì†Œ í™”ë©´ í•´ìƒë„**: 1280x720

### Python ì„¤ì¹˜ í™•ì¸
```bash
# Python ë²„ì „ í™•ì¸
python --version

# Python ê²½ë¡œ í™•ì¸  
python -c "import sys; print(sys.executable)"
```

## ğŸ“¦ ì˜ì¡´ì„± íŒ¨í‚¤ì§€

### í•µì‹¬ íŒ¨í‚¤ì§€
- **PyQt5** - GUI í”„ë ˆì„ì›Œí¬
- **pandas, openpyxl** - Excel íŒŒì¼ ì²˜ë¦¬
- **pyautogui, opencv-python** - í™”ë©´ ìë™í™”
- **easyocr** - í…ìŠ¤íŠ¸ ì¸ì‹ (OCR)
- **cryptography** - ë³´ì•ˆ/ì•”í˜¸í™”

### ê°œë°œ ë„êµ¬ (ì„ íƒì‚¬í•­)
- **pytest, pytest-qt** - í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬
- **black, flake8** - ì½”ë“œ í¬ë§·íŒ…/ë¦°íŒ…

## ğŸ® ì‹¤í–‰ ë°©ë²•

### ğŸŸ¢ ë°©ë²• 1: ê°„ë‹¨ ì‹¤í–‰ (ê¶Œì¥)
```bash
# í”„ë¡œì íŠ¸ í´ë”ì—ì„œ
RUN_SIMPLE.bat
```
- Pythonë§Œ ì„¤ì¹˜ë˜ì–´ ìˆìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰
- ì˜ì¡´ì„±ì´ ì—†ìœ¼ë©´ ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ

### ğŸŸ¡ ë°©ë²• 2: ì™„ì „ ì‹¤í–‰
```bash
# í”„ë¡œì íŠ¸ í´ë”ì—ì„œ  
WINDOWS_RUN.bat
```
- ì˜ì¡´ì„± ìë™ ì„¤ì¹˜ í¬í•¨
- ìµœì´ˆ ì‹¤í–‰ ì‹œ íŒ¨í‚¤ì§€ ì„¤ì¹˜ì— ì‹œê°„ ì†Œìš”

### ğŸ”µ ë°©ë²• 3: Python ì§ì ‘ ì‹¤í–‰
```bash
# ê¸°ë³¸ ë°©ë²•
python run_main.py

# ëŒ€ì²´ ë°©ë²•
python run_main_fixed.py
```

## ğŸ”§ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### Python ê´€ë ¨
```bash
# Python ì„¤ì¹˜ í™•ì¸
python --version

# pip ì—…ê·¸ë ˆì´ë“œ
python -m pip install --upgrade pip

# ì˜ì¡´ì„± ì¬ì„¤ì¹˜
pip install -r requirements.txt --force-reinstall
```

### ì¼ë°˜ì ì¸ ë¬¸ì œ

#### 1. "Pythonì„ ì°¾ì„ ìˆ˜ ì—†ìŒ"
- Pythonì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ê±°ë‚˜ PATHì— ë“±ë¡ë˜ì§€ ì•ŠìŒ
- https://python.org ì—ì„œ Python ì„¤ì¹˜
- ì„¤ì¹˜ ì‹œ "Add Python to PATH" ì²´í¬ í•„ìˆ˜

#### 2. "PyQt5 import ì˜¤ë¥˜"
```bash
# PyQt5 ì¬ì„¤ì¹˜
pip install PyQt5 --force-reinstall
```

#### 3. "opencv-python ì˜¤ë¥˜" 
```bash
# OpenCV ì¬ì„¤ì¹˜
pip install opencv-python --force-reinstall
```

#### 4. "easyocr ì„¤ì¹˜ ì‹¤íŒ¨"
- ì¸í„°ë„· ì—°ê²° í™•ì¸ (ëª¨ë¸ ë‹¤ìš´ë¡œë“œ í•„ìš”)
- ì¶©ë¶„í•œ ë””ìŠ¤í¬ ê³µê°„ í™•ì¸
- ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¤„ì´ê¸°
- í° Excel íŒŒì¼ ì²˜ë¦¬ ì‹œ ë°°ì¹˜ ì²˜ë¦¬ í™œìš©
- ì‹¤í–‰ í›„ ë¶ˆí•„ìš”í•œ í”„ë¡œê·¸ë¨ ì¢…ë£Œ

### ì‹¤í–‰ ì†ë„ í–¥ìƒ
- SSD ì‚¬ìš© ê¶Œì¥
- ì•ˆí‹°ë°”ì´ëŸ¬ìŠ¤ ì‹¤ì‹œê°„ ê²€ì‚¬ ì˜ˆì™¸ ë“±ë¡

## ğŸ”’ ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

- ë§¤í¬ë¡œ íŒŒì¼(.emf)ì€ AES-256ìœ¼ë¡œ ì•”í˜¸í™”ë¨
- ë¯¼ê°í•œ ì •ë³´ëŠ” ë¡œê·¸ì— ê¸°ë¡ë˜ì§€ ì•ŠìŒ
- ì¸í„°ë„· ì—°ê²° ë¶ˆí•„ìš” (ì™„ì „ ì˜¤í”„ë¼ì¸ ë™ì‘)

## ğŸ“ ë¡œê·¸ ë° ë””ë²„ê¹…

### ë¡œê·¸ ìœ„ì¹˜
- **ì‹¤í–‰ ë¡œê·¸**: `uploads/execution_logs/`
- **ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸**: ì½˜ì†” ì¶œë ¥
- **ì˜¤ë¥˜ ë¡œê·¸**: `COLLECT_ERRORS_WINDOWS.bat` ì‹¤í–‰

### ë””ë²„ê·¸ ëª¨ë“œ
```bash
# ë””ë²„ê·¸ ì •ë³´ í¬í•¨ ì‹¤í–‰
python run_with_debug.py
```

## ğŸ†˜ ì§€ì›

### ì˜¤ë¥˜ ë³´ê³ 
1. `COLLECT_ERRORS_WINDOWS.bat` ì‹¤í–‰
2. ìƒì„±ëœ ì˜¤ë¥˜ ë³´ê³ ì„œ í™•ì¸
3. ìŠ¤í¬ë¦°ìƒ·ê³¼ í•¨ê»˜ ë¬¸ì œ ë³´ê³ 

### ì¶”ê°€ ë„ì›€ë§
- `tests/manual_test_checklist.md` - ìˆ˜ë™ í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ
- `README.md` - ê¸°ë³¸ í”„ë¡œì íŠ¸ ì •ë³´
- ì†ŒìŠ¤ì½”ë“œ ì£¼ì„ ë° docstring

---

**âœ… ëª¨ë“  ì¤€ë¹„ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!**

ì´ì œ WSL í™˜ê²½ì—ì„œ íŒŒì¼ ë³µì‚¬ ì—†ì´ Cë“œë¼ì´ë¸Œì—ì„œ ì§ì ‘ Excel Macro Automationì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
</file>

<file path="setup_wsl_gui.sh">
#!/bin/bash
# WSL GUI ì„¤ì • ìŠ¤í¬ë¦½íŠ¸

echo "=== WSL GUI í™˜ê²½ ì„¤ì • ==="

# 1. Windows IP ìë™ ê°ì§€
WINDOWS_IP=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2; exit;}')
echo "Windows IP: $WINDOWS_IP"

# 2. DISPLAY í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
export DISPLAY=$WINDOWS_IP:0.0
export LIBGL_ALWAYS_INDIRECT=1

echo "DISPLAY ì„¤ì •: $DISPLAY"

# 3. .bashrcì— ì˜êµ¬ ì„¤ì • ì¶”ê°€ (ì´ë¯¸ ì—†ëŠ” ê²½ìš°ë§Œ)
if ! grep -q "export DISPLAY=" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "# WSL GUI Support" >> ~/.bashrc
    echo "export DISPLAY=\$(cat /etc/resolv.conf | grep nameserver | awk '{print \$2; exit;}'):0.0" >> ~/.bashrc
    echo "export LIBGL_ALWAYS_INDIRECT=1" >> ~/.bashrc
    echo "âœ“ ~/.bashrcì— DISPLAY ì„¤ì •ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤."
else
    echo "âœ“ ~/.bashrcì— ì´ë¯¸ DISPLAY ì„¤ì •ì´ ìˆìŠµë‹ˆë‹¤."
fi

# 4. í•„ìš”í•œ íŒ¨í‚¤ì§€ í™•ì¸
echo ""
echo "í•„ìš”í•œ íŒ¨í‚¤ì§€ í™•ì¸ ì¤‘..."

# PyQt5 í™•ì¸
if python3 -c "import PyQt5" 2>/dev/null; then
    echo "âœ“ PyQt5ê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
else
    echo "âœ— PyQt5ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
fi

# 5. X Server ì—°ê²° í…ŒìŠ¤íŠ¸
echo ""
echo "X Server ì—°ê²° í…ŒìŠ¤íŠ¸..."
if command -v xeyes &> /dev/null; then
    timeout 2 xeyes 2>/dev/null &
    XEYES_PID=$!
    sleep 1
    if kill -0 $XEYES_PID 2>/dev/null; then
        echo "âœ“ X Server ì—°ê²° ì„±ê³µ! (xeyesê°€ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤)"
        kill $XEYES_PID 2>/dev/null
    else
        echo "âœ— X Server ì—°ê²° ì‹¤íŒ¨"
        echo ""
        echo "ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:"
        echo "1. Windowsì—ì„œ VcXsrvê°€ ì‹¤í–‰ ì¤‘ì¸ê°€?"
        echo "2. VcXsrv ì„¤ì •ì—ì„œ 'Disable access control'ì´ ì²´í¬ë˜ì–´ ìˆëŠ”ê°€?"
        echo "3. Windows ë°©í™”ë²½ì´ VcXsrvë¥¼ ì°¨ë‹¨í•˜ê³  ìˆì§€ ì•Šì€ê°€?"
    fi
fi

echo ""
echo "ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
echo "ìƒˆ í„°ë¯¸ë„ì„ ì—´ê±°ë‚˜ ë‹¤ìŒ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì„¸ìš”:"
echo "source ~/.bashrc"
</file>

<file path="src/__init__.py">
# Excel Macro Automation Package
</file>

<file path="src/automation/__init__.py">
# Automation module
</file>

<file path="src/automation/hotkey_listener.py">
"""
Global hotkey listener for execution control
"""

import threading
from typing import Optional, Dict, Callable
from PyQt5.QtCore import QObject, pyqtSignal
try:
    from pynput import keyboard
except ImportError:
    # Fallback for systems without pynput
    keyboard = None
from config.settings import Settings
from logger.app_logger import get_logger

class HotkeyListener(QObject):
    """Listens for global hotkeys"""
    
    # Signals
    pausePressed = pyqtSignal()
    stopPressed = pyqtSignal()
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        self._listener: Optional[keyboard.Listener] = None
        self._running = False
        
        # Get hotkey settings
        self.pause_key = self._parse_key(settings.get("hotkeys.pause", "F9"))
        self.stop_key = self._parse_key(settings.get("hotkeys.stop", "Escape"))
        
        # Current key states
        self._pressed_keys = set()
        
    def _parse_key(self, key_string: str):
        """Parse key string to pynput key"""
        if not keyboard:
            return None
            
        # Map common key names
        key_map = {
            "F1": keyboard.Key.f1,
            "F2": keyboard.Key.f2,
            "F3": keyboard.Key.f3,
            "F4": keyboard.Key.f4,
            "F5": keyboard.Key.f5,
            "F6": keyboard.Key.f6,
            "F7": keyboard.Key.f7,
            "F8": keyboard.Key.f8,
            "F9": keyboard.Key.f9,
            "F10": keyboard.Key.f10,
            "F11": keyboard.Key.f11,
            "F12": keyboard.Key.f12,
            "Escape": keyboard.Key.esc,
            "Space": keyboard.Key.space,
            "Enter": keyboard.Key.enter,
            "Tab": keyboard.Key.tab,
            "Backspace": keyboard.Key.backspace,
            "Delete": keyboard.Key.delete,
            "Home": keyboard.Key.home,
            "End": keyboard.Key.end,
            "PageUp": keyboard.Key.page_up,
            "PageDown": keyboard.Key.page_down,
            "Left": keyboard.Key.left,
            "Right": keyboard.Key.right,
            "Up": keyboard.Key.up,
            "Down": keyboard.Key.down,
        }
        
        return key_map.get(key_string, key_string.lower())
        
    def start(self):
        """Start listening for hotkeys"""
        if not keyboard:
            self.logger.warning("pynput not available, hotkeys disabled")
            return
            
        if self._running:
            return
            
        self._running = True
        
        try:
            self._listener = keyboard.Listener(
                on_press=self._on_press,
                on_release=self._on_release
            )
            self._listener.start()
            self.logger.info(f"Hotkey listener started (Pause: {self.pause_key}, Stop: {self.stop_key})")
        except Exception as e:
            self.logger.error(f"Failed to start hotkey listener: {e}")
            
    def stop(self):
        """Stop listening for hotkeys"""
        if not self._running:
            return
            
        self._running = False
        
        if self._listener:
            self._listener.stop()
            self._listener = None
            
        self.logger.info("Hotkey listener stopped")
        
    def _on_press(self, key):
        """Handle key press"""
        try:
            # Add to pressed keys
            self._pressed_keys.add(key)
            
            # Check for pause hotkey
            if self._check_key(key, self.pause_key):
                self.logger.debug("Pause hotkey pressed")
                self.pausePressed.emit()
                
            # Check for stop hotkey
            elif self._check_key(key, self.stop_key):
                self.logger.debug("Stop hotkey pressed")
                self.stopPressed.emit()
                
        except Exception as e:
            self.logger.error(f"Error in key press handler: {e}")
            
    def _on_release(self, key):
        """Handle key release"""
        try:
            # Remove from pressed keys
            self._pressed_keys.discard(key)
        except Exception as e:
            self.logger.error(f"Error in key release handler: {e}")
            
    def _check_key(self, key, target_key) -> bool:
        """Check if pressed key matches target"""
        if not target_key:
            return False
            
        # Direct key comparison
        if key == target_key:
            return True
            
        # String comparison for character keys
        try:
            if hasattr(key, 'char') and key.char == target_key:
                return True
        except:
            pass
            
        return False

class SimpleHotkeyListener(QObject):
    """Simple hotkey listener using QShortcut (fallback)"""
    
    pausePressed = pyqtSignal()
    stopPressed = pyqtSignal()
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
    def start(self):
        """Start listening (no-op for simple listener)"""
        self.logger.info("Using simple hotkey listener (widget must have focus)")
        
    def stop(self):
        """Stop listening (no-op for simple listener)"""
        pass
</file>

<file path="src/excel/models.py">
"""
Excel data models and types
"""

from dataclasses import dataclass
from typing import List, Dict, Any, Optional
from enum import Enum
import pandas as pd

class ColumnType(Enum):
    """Excel column data types"""
    TEXT = "text"
    NUMBER = "number"
    DATE = "date"
    BOOLEAN = "boolean"
    MIXED = "mixed"
    EMPTY = "empty"

@dataclass
class ColumnInfo:
    """Information about an Excel column"""
    name: str
    index: int
    data_type: ColumnType
    sample_values: List[Any]
    null_count: int
    unique_count: int

@dataclass
class SheetInfo:
    """Information about an Excel sheet"""
    name: str
    row_count: int
    column_count: int
    columns: List[ColumnInfo]

@dataclass
class ExcelFileInfo:
    """Information about an Excel file"""
    file_path: str
    file_size: int
    sheet_count: int
    sheets: List[SheetInfo]
    
@dataclass
class ColumnMapping:
    """Maps Excel columns to macro variables"""
    excel_column: str
    variable_name: str
    data_type: ColumnType
    is_required: bool = True
    default_value: Any = None

class ExcelData:
    """Container for Excel data with metadata"""
    
    def __init__(self, dataframe: pd.DataFrame, sheet_name: str, file_path: str):
        self.dataframe = dataframe
        self.sheet_name = sheet_name
        self.file_path = file_path
        self._status_column = None
        
    @property
    def row_count(self) -> int:
        return len(self.dataframe)
    
    @property
    def column_count(self) -> int:
        return len(self.dataframe.columns)
    
    @property
    def columns(self) -> List[str]:
        return self.dataframe.columns.tolist()
    
    def get_status_column(self) -> Optional[str]:
        """Get the status column name"""
        return self._status_column
    
    def set_status_column(self, column_name: str):
        """Set the status column"""
        if column_name not in self.columns:
            self.dataframe[column_name] = ""
        self._status_column = column_name
    
    def update_row_status(self, row_index: int, status: str):
        """Update status for a specific row"""
        if self._status_column:
            self.dataframe.at[row_index, self._status_column] = status
    
    def get_incomplete_rows(self) -> pd.DataFrame:
        """Get rows that haven't been completed"""
        if not self._status_column:
            return self.dataframe
        
        return self.dataframe[
            (self.dataframe[self._status_column] != "ì™„ë£Œ") & 
            (self.dataframe[self._status_column] != "Completed")
        ]
    
    def get_row_data(self, row_index: int) -> Dict[str, Any]:
        """Get data for a specific row as dictionary"""
        return self.dataframe.iloc[row_index].to_dict()
</file>

<file path="src/logger/app_logger.py">
"""
Application logging configuration
"""

import logging
import sys
from pathlib import Path
from datetime import datetime
from logging.handlers import RotatingFileHandler
from typing import Optional

def setup_logger(log_dir: Optional[Path] = None, level: int = logging.INFO) -> logging.Logger:
    """Setup application logger with file and console handlers"""
    # Create logs directory
    if log_dir is None:
        log_dir = Path.home() / ".excel_macro_automation" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    
    # Create logger
    logger = logging.getLogger("excel_macro")
    logger.setLevel(level)
    
    # Clear existing handlers
    logger.handlers.clear()
    
    # Create formatters
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_formatter = logging.Formatter(
        '%(levelname)s: %(message)s'
    )
    
    # File handler with rotation
    log_file = log_dir / f"app_{datetime.now().strftime('%Y%m%d')}.log"
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=10 * 1024 * 1024,  # 10MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)
    
    return logger

def get_logger(name: str) -> logging.Logger:
    """Get a logger instance for a specific module"""
    return logging.getLogger(f"excel_macro.{name}")
</file>

<file path="src/logger/execution_logger.py">
"""
CSV execution logger for macro runs
"""

import csv
import os
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any
import threading
from queue import Queue
import atexit

class ExecutionLogger:
    """Logs macro execution details to CSV files"""
    
    def __init__(self, log_dir: Optional[Path] = None):
        """Initialize execution logger
        
        Args:
            log_dir: Directory to save log files. Defaults to user logs directory.
        """
        # Set log directory
        if log_dir is None:
            self.log_dir = Path.home() / ".excel_macro_automation" / "execution_logs"
        else:
            self.log_dir = Path(log_dir)
            
        # Create directory if not exists
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Current log file
        self.current_file: Optional[Path] = None
        self.csv_writer: Optional[csv.DictWriter] = None
        self.file_handle = None
        
        # Buffering for performance
        self.write_queue = Queue()
        self.writer_thread = None
        self.running = False
        
        # Register cleanup on exit
        atexit.register(self.close)
        
    def start_session(self, macro_name: str, excel_file: str) -> Path:
        """Start a new logging session
        
        Args:
            macro_name: Name of the macro being executed
            excel_file: Path to the Excel file being processed
            
        Returns:
            Path to the created log file
        """
        # Close previous session if any
        self.close()
        
        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_macro_name = "".join(c for c in macro_name if c.isalnum() or c in "._- ")[:50]
        filename = f"execution_{safe_macro_name}_{timestamp}.csv"
        self.current_file = self.log_dir / filename
        
        # Open file and create CSV writer
        self.file_handle = open(self.current_file, 'w', newline='', encoding='utf-8')
        
        # Define CSV fields
        self.fieldnames = [
            'timestamp',
            'elapsed_ms',
            'row_index',
            'row_data',
            'step_index',
            'step_name',
            'step_type',
            'status',
            'error_message',
            'duration_ms',
            'details'
        ]
        
        self.csv_writer = csv.DictWriter(self.file_handle, fieldnames=self.fieldnames)
        self.csv_writer.writeheader()
        
        # Write session info
        self.csv_writer.writerow({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': 0,
            'row_index': -1,
            'row_data': f"Session Start - Macro: {macro_name}",
            'step_index': -1,
            'step_name': "SESSION_START",
            'step_type': "INFO",
            'status': "INFO",
            'error_message': "",
            'duration_ms': 0,
            'details': f"Excel: {excel_file}"
        })
        
        # Start writer thread
        self.running = True
        self.writer_thread = threading.Thread(target=self._writer_loop, daemon=True)
        self.writer_thread.start()
        
        self.session_start_time = datetime.now()
        
        return self.current_file
        
    def log_row_start(self, row_index: int, row_data: Dict[str, Any]):
        """Log the start of processing a row"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': str(row_data),
            'step_index': -1,
            'step_name': "ROW_START",
            'step_type': "INFO",
            'status': "START",
            'error_message': "",
            'duration_ms': 0,
            'details': f"Processing row {row_index + 1}"
        })
        
    def log_step_execution(self, row_index: int, step_index: int, step_name: str, 
                          step_type: str, success: bool, duration_ms: float,
                          error_message: str = "", details: str = ""):
        """Log execution of a single step"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': "",
            'step_index': step_index,
            'step_name': step_name,
            'step_type': step_type,
            'status': "SUCCESS" if success else "FAILED",
            'error_message': error_message,
            'duration_ms': round(duration_ms, 2),
            'details': details
        })
        
    def log_row_complete(self, row_index: int, success: bool, total_duration_ms: float,
                        error_message: str = ""):
        """Log completion of a row"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': "",
            'step_index': -1,
            'step_name': "ROW_COMPLETE",
            'step_type': "INFO",
            'status': "SUCCESS" if success else "FAILED",
            'error_message': error_message,
            'duration_ms': round(total_duration_ms, 2),
            'details': f"Row {row_index + 1} completed"
        })
        
    def log_session_end(self, total_rows: int, successful_rows: int, failed_rows: int):
        """Log end of session with summary"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': -1,
            'row_data': f"Session End - Total: {total_rows}, Success: {successful_rows}, Failed: {failed_rows}",
            'step_index': -1,
            'step_name': "SESSION_END",
            'step_type': "INFO",
            'status': "INFO",
            'error_message': "",
            'duration_ms': self._get_elapsed_ms(),
            'details': f"Success rate: {(successful_rows/total_rows*100) if total_rows > 0 else 0:.1f}%"
        })
        
    def log_error(self, error_type: str, error_message: str, details: str = ""):
        """Log a general error"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': -1,
            'row_data': "",
            'step_index': -1,
            'step_name': error_type,
            'step_type': "ERROR",
            'status': "ERROR",
            'error_message': error_message,
            'duration_ms': 0,
            'details': details
        })
        
    def flush(self):
        """Force flush any pending logs"""
        if self.file_handle:
            # Wait for queue to empty
            self.write_queue.join()
            self.file_handle.flush()
            
    def close(self):
        """Close the current logging session"""
        if self.running:
            # Signal thread to stop
            self.running = False
            self._enqueue_log(None)  # Sentinel value
            
            # Wait for thread to finish
            if self.writer_thread and self.writer_thread.is_alive():
                self.writer_thread.join(timeout=5.0)
                
        # Close file
        if self.file_handle:
            self.file_handle.close()
            self.file_handle = None
            self.csv_writer = None
            
    def get_current_log_file(self) -> Optional[Path]:
        """Get path to current log file"""
        return self.current_file
        
    def _enqueue_log(self, log_entry: Optional[Dict[str, Any]]):
        """Add log entry to write queue"""
        self.write_queue.put(log_entry)
        
    def _writer_loop(self):
        """Background thread for writing logs"""
        while self.running:
            try:
                # Get log entry from queue
                log_entry = self.write_queue.get(timeout=0.1)
                
                # Check for sentinel
                if log_entry is None:
                    break
                    
                # Write to CSV
                if self.csv_writer:
                    self.csv_writer.writerow(log_entry)
                    
                # Mark task done
                self.write_queue.task_done()
                
            except:
                # Timeout or error, continue
                pass
                
    def _get_elapsed_ms(self) -> float:
        """Get elapsed time since session start"""
        if hasattr(self, 'session_start_time'):
            elapsed = datetime.now() - self.session_start_time
            return elapsed.total_seconds() * 1000
        return 0

# Global instance
_execution_logger = None

def get_execution_logger() -> ExecutionLogger:
    """Get the global execution logger instance"""
    global _execution_logger
    if _execution_logger is None:
        _execution_logger = ExecutionLogger()
    return _execution_logger
</file>

<file path="src/ui/dialogs/__init__.py">
# UI dialogs module
</file>

<file path="src/ui/dialogs/error_report_dialog.py">
"""
Error reporting dialog with detailed information and solutions
"""

import traceback
import os
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTextEdit,
    QPushButton, QLabel, QGroupBox, QTabWidget,
    QWidget, QCheckBox, QMessageBox
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont, QIcon
import pyautogui

class ErrorReportDialog(QDialog):
    """Dialog for displaying detailed error information"""
    
    # Error solutions database
    ERROR_SOLUTIONS = {
        "Image not found": {
            "ì›ì¸": [
                "í™”ë©´ í•´ìƒë„ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ëŒ€ìƒ í”„ë¡œê·¸ë¨ì˜ UIê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ì´ë¯¸ì§€ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤",
                "í™”ë©´ ë°°ìœ¨(DPI) ì„¤ì •ì´ ë‹¤ë¦…ë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ìº¡ì²˜í•˜ì„¸ìš”",
                "í™”ë©´ í•´ìƒë„ë¥¼ ì›ë˜ëŒ€ë¡œ ë³µì›í•˜ì„¸ìš”",
                "Windows ë””ìŠ¤í”Œë ˆì´ ì„¤ì •ì—ì„œ ë°°ìœ¨ì„ 100%ë¡œ ì„¤ì •í•˜ì„¸ìš”",
                "ëŒ€ìƒ í”„ë¡œê·¸ë¨ì„ ìµœëŒ€í™”í•˜ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”"
            ]
        },
        "Text not found": {
            "ì›ì¸": [
                "í…ìŠ¤íŠ¸ê°€ í™”ë©´ì— í‘œì‹œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤",
                "OCR ì¸ì‹ ì‹¤íŒ¨",
                "í°íŠ¸ë‚˜ í…ìŠ¤íŠ¸ í¬ê¸°ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ê²€ìƒ‰ ì˜ì—­ì´ ì˜ëª» ì§€ì •ë˜ì—ˆìŠµë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ê°€ í™”ë©´ì— í‘œì‹œë˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”",
                "ê²€ìƒ‰ ì˜ì—­ì„ ë‹¤ì‹œ ì§€ì •í•˜ì„¸ìš”",
                "ì •í™•í•œ í…ìŠ¤íŠ¸ ëŒ€ì‹  ë¶€ë¶„ ì¼ì¹˜ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”",
                "ëŒ€ê¸° ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”"
            ]
        },
        "Permission denied": {
            "ì›ì¸": [
                "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤",
                "íŒŒì¼ì´ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤",
                "í´ë”ì— ì“°ê¸° ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "í”„ë¡œê·¸ë¨ì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰í•˜ì„¸ìš”",
                "ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ íŒŒì¼ì„ ë‹«ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”",
                "ë‹¤ë¥¸ ìœ„ì¹˜ì— ì €ì¥í•´ë³´ì„¸ìš”"
            ]
        },
        "Excel": {
            "ì›ì¸": [
                "Excel íŒŒì¼ì´ ì—´ë ¤ìˆìŠµë‹ˆë‹¤",
                "ì‹œíŠ¸ ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ì—´ ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "Excel íŒŒì¼ì„ ë‹«ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”",
                "ì‹œíŠ¸ ë§¤í•‘ì„ ë‹¤ì‹œ ì„¤ì •í•˜ì„¸ìš”",
                "ì—´ ë§¤í•‘ì„ í™•ì¸í•˜ì„¸ìš”"
            ]
        }
    }
    
    def __init__(self, error_type: str, error_message: str, 
                 error_details: Optional[str] = None,
                 log_file: Optional[Path] = None,
                 parent=None):
        super().__init__(parent)
        self.error_type = error_type
        self.error_message = error_message
        self.error_details = error_details or traceback.format_exc()
        self.log_file = log_file
        self.screenshot_path = None
        
        self.init_ui()
        self.load_error_info()
        
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("ì˜¤ë¥˜ ë³´ê³ ì„œ")
        self.setModal(True)
        self.resize(700, 500)
        
        layout = QVBoxLayout()
        
        # Error summary
        error_group = QGroupBox("ì˜¤ë¥˜ ìš”ì•½")
        error_layout = QVBoxLayout()
        
        # Error icon and message
        message_layout = QHBoxLayout()
        
        # Error type label with red color
        type_label = QLabel(f"âŒ {self.error_type}")
        type_label.setStyleSheet("color: red; font-size: 14px; font-weight: bold;")
        error_layout.addWidget(type_label)
        
        # Error message
        message_label = QLabel(self.error_message)
        message_label.setWordWrap(True)
        message_label.setStyleSheet("font-size: 12px; margin: 10px 0;")
        error_layout.addWidget(message_label)
        
        error_group.setLayout(error_layout)
        layout.addWidget(error_group)
        
        # Tab widget for details
        self.tabs = QTabWidget()
        
        # Solutions tab
        self.solutions_widget = self.create_solutions_tab()
        self.tabs.addTab(self.solutions_widget, "í•´ê²° ë°©ë²•")
        
        # Details tab
        self.details_widget = self.create_details_tab()
        self.tabs.addTab(self.details_widget, "ìƒì„¸ ì •ë³´")
        
        # Log tab
        if self.log_file:
            self.log_widget = self.create_log_tab()
            self.tabs.addTab(self.log_widget, "ì‹¤í–‰ ë¡œê·¸")
            
        layout.addWidget(self.tabs)
        
        # Actions
        action_layout = QHBoxLayout()
        
        # Screenshot checkbox
        self.screenshot_check = QCheckBox("ì˜¤ë¥˜ í™”ë©´ ìº¡ì²˜ í¬í•¨")
        self.screenshot_check.setChecked(True)
        action_layout.addWidget(self.screenshot_check)
        
        action_layout.addStretch()
        
        # Copy button
        copy_btn = QPushButton("ì˜¤ë¥˜ ì •ë³´ ë³µì‚¬")
        copy_btn.clicked.connect(self.copy_error_info)
        action_layout.addWidget(copy_btn)
        
        # Save button
        save_btn = QPushButton("ë³´ê³ ì„œ ì €ì¥")
        save_btn.clicked.connect(self.save_report)
        action_layout.addWidget(save_btn)
        
        layout.addLayout(action_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        # Open log folder button
        if self.log_file:
            log_folder_btn = QPushButton("ë¡œê·¸ í´ë” ì—´ê¸°")
            log_folder_btn.clicked.connect(self.open_log_folder)
            button_layout.addWidget(log_folder_btn)
        
        # OK button
        ok_btn = QPushButton("í™•ì¸")
        ok_btn.setDefault(True)
        ok_btn.clicked.connect(self.accept)
        button_layout.addWidget(ok_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def create_solutions_tab(self) -> QWidget:
        """Create solutions tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Find matching error type
        matching_solution = None
        for key, solution in self.ERROR_SOLUTIONS.items():
            if key.lower() in self.error_message.lower():
                matching_solution = solution
                break
                
        if matching_solution:
            # Possible causes
            causes_group = QGroupBox("ê°€ëŠ¥í•œ ì›ì¸")
            causes_layout = QVBoxLayout()
            
            for cause in matching_solution["ì›ì¸"]:
                cause_label = QLabel(f"â€¢ {cause}")
                cause_label.setWordWrap(True)
                causes_layout.addWidget(cause_label)
                
            causes_group.setLayout(causes_layout)
            layout.addWidget(causes_group)
            
            # Solutions
            solutions_group = QGroupBox("í•´ê²° ë°©ë²•")
            solutions_layout = QVBoxLayout()
            
            for i, solution in enumerate(matching_solution["í•´ê²° ë°©ë²•"], 1):
                solution_label = QLabel(f"{i}. {solution}")
                solution_label.setWordWrap(True)
                solution_label.setStyleSheet("margin: 5px 0;")
                solutions_layout.addWidget(solution_label)
                
            solutions_group.setLayout(solutions_layout)
            layout.addWidget(solutions_group)
        else:
            # Generic solutions
            generic_label = QLabel(
                "ì¼ë°˜ì ì¸ í•´ê²° ë°©ë²•:\n\n"
                "1. í”„ë¡œê·¸ë¨ì„ ë‹¤ì‹œ ì‹œì‘í•´ë³´ì„¸ìš”\n"
                "2. ëŒ€ìƒ í”„ë¡œê·¸ë¨ì´ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”\n"
                "3. í™”ë©´ í•´ìƒë„ë‚˜ ë°°ìœ¨ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”\n"
                "4. ë§¤í¬ë¡œ ë‹¨ê³„ë¥¼ ë‹¤ì‹œ ì„¤ì •í•´ë³´ì„¸ìš”\n"
                "5. ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ë¡œê·¸ íŒŒì¼ê³¼ í•¨ê»˜ ë¬¸ì˜í•˜ì„¸ìš”"
            )
            generic_label.setWordWrap(True)
            layout.addWidget(generic_label)
            
        layout.addStretch()
        widget.setLayout(layout)
        return widget
        
    def create_details_tab(self) -> QWidget:
        """Create error details tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Error details text
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        self.details_text.setFont(QFont("Consolas", 9))
        self.details_text.setPlainText(self.error_details)
        
        layout.addWidget(self.details_text)
        widget.setLayout(layout)
        return widget
        
    def create_log_tab(self) -> QWidget:
        """Create log file tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Log file path
        path_label = QLabel(f"ë¡œê·¸ íŒŒì¼: {self.log_file}")
        path_label.setWordWrap(True)
        layout.addWidget(path_label)
        
        # Log preview (last 50 lines)
        log_text = QTextEdit()
        log_text.setReadOnly(True)
        log_text.setFont(QFont("Consolas", 9))
        
        try:
            with open(self.log_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                # Show last 50 lines
                last_lines = lines[-50:] if len(lines) > 50 else lines
                log_text.setPlainText(''.join(last_lines))
        except Exception as e:
            log_text.setPlainText(f"ë¡œê·¸ íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
            
        layout.addWidget(log_text)
        widget.setLayout(layout)
        return widget
        
    def load_error_info(self):
        """Load additional error information"""
        # Could load more context here
        pass
        
    def copy_error_info(self):
        """Copy error information to clipboard"""
        from PyQt5.QtWidgets import QApplication
        
        info = f"""ì˜¤ë¥˜ íƒ€ì…: {self.error_type}
ì˜¤ë¥˜ ë©”ì‹œì§€: {self.error_message}
ë°œìƒ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

ìƒì„¸ ì •ë³´:
{self.error_details}
"""
        
        if self.log_file:
            info += f"\në¡œê·¸ íŒŒì¼: {self.log_file}"
            
        QApplication.clipboard().setText(info)
        QMessageBox.information(self, "ë³µì‚¬ ì™„ë£Œ", "ì˜¤ë¥˜ ì •ë³´ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.")
        
    def save_report(self):
        """Save error report to file"""
        from PyQt5.QtWidgets import QFileDialog
        
        # Take screenshot if requested
        if self.screenshot_check.isChecked():
            self.capture_screenshot()
            
        # Get save location
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_name = f"error_report_{timestamp}.txt"
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "ì˜¤ë¥˜ ë³´ê³ ì„œ ì €ì¥",
            default_name,
            "Text Files (*.txt);;All Files (*.*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(f"ì˜¤ë¥˜ ë³´ê³ ì„œ\n")
                    f.write(f"=" * 50 + "\n\n")
                    f.write(f"ë°œìƒ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"ì˜¤ë¥˜ íƒ€ì…: {self.error_type}\n")
                    f.write(f"ì˜¤ë¥˜ ë©”ì‹œì§€: {self.error_message}\n\n")
                    
                    # Add solutions if available
                    for key, solution in self.ERROR_SOLUTIONS.items():
                        if key.lower() in self.error_message.lower():
                            f.write("\nê°€ëŠ¥í•œ ì›ì¸:\n")
                            for cause in solution["ì›ì¸"]:
                                f.write(f"  â€¢ {cause}\n")
                            f.write("\ní•´ê²° ë°©ë²•:\n")
                            for i, sol in enumerate(solution["í•´ê²° ë°©ë²•"], 1):
                                f.write(f"  {i}. {sol}\n")
                            break
                            
                    f.write(f"\nìƒì„¸ ì •ë³´:\n")
                    f.write(f"{self.error_details}\n")
                    
                    if self.log_file:
                        f.write(f"\në¡œê·¸ íŒŒì¼: {self.log_file}\n")
                        
                    if self.screenshot_path:
                        f.write(f"\nìŠ¤í¬ë¦°ìƒ·: {self.screenshot_path}\n")
                        
                QMessageBox.information(self, "ì €ì¥ ì™„ë£Œ", f"ì˜¤ë¥˜ ë³´ê³ ì„œê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:\n{file_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "ì €ì¥ ì‹¤íŒ¨", f"ë³´ê³ ì„œ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
                
    def capture_screenshot(self):
        """Capture screenshot of current screen"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            screenshot_dir = Path.home() / ".excel_macro_automation" / "error_screenshots"
            screenshot_dir.mkdir(parents=True, exist_ok=True)
            
            self.screenshot_path = screenshot_dir / f"error_{timestamp}.png"
            pyautogui.screenshot(str(self.screenshot_path))
            
        except Exception as e:
            self.screenshot_path = None
            
    def open_log_folder(self):
        """Open log folder in file explorer"""
        if self.log_file:
            log_dir = os.path.dirname(self.log_file)
            os.startfile(log_dir)  # Windows only
            
    @staticmethod
    def show_error(error_type: str, error_message: str, 
                   error_details: Optional[str] = None,
                   log_file: Optional[Path] = None,
                   parent=None):
        """Static method to show error dialog"""
        dialog = ErrorReportDialog(error_type, error_message, error_details, log_file, parent)
        dialog.exec_()
        return dialog
</file>

<file path="src/ui/dialogs/keyboard_hotkey_step_dialog.py">
"""
Keyboard hotkey step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QListWidget, QListWidgetItem, QMessageBox
)
from PyQt5.QtCore import Qt, QEvent
from PyQt5.QtGui import QKeySequence
from core.macro_types import KeyboardHotkeyStep


class KeyCaptureButton(QPushButton):
    """Button that captures key combinations"""
    
    def __init__(self, text="í´ë¦­í•˜ê³  í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”"):
        super().__init__(text)
        self.keys = []
        self.recording = False
        self.default_text = text
        
    def mousePressEvent(self, event):
        """Start recording on click"""
        super().mousePressEvent(event)
        if event.button() == Qt.LeftButton:
            self.recording = True
            self.keys = []
            self.setText("í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”...")
            self.setFocus()
            
    def keyPressEvent(self, event):
        """Capture key press"""
        if not self.recording:
            return
            
        key = event.key()
        key_name = QKeySequence(key).toString()
        
        # Handle modifiers
        modifiers = event.modifiers()
        if modifiers & Qt.ControlModifier and 'ctrl' not in self.keys:
            self.keys.append('ctrl')
        if modifiers & Qt.AltModifier and 'alt' not in self.keys:
            self.keys.append('alt')
        if modifiers & Qt.ShiftModifier and 'shift' not in self.keys:
            self.keys.append('shift')
        if modifiers & Qt.MetaModifier and 'win' not in self.keys:
            self.keys.append('win')
            
        # Add regular key if not a modifier
        if key not in [Qt.Key_Control, Qt.Key_Alt, Qt.Key_Shift, Qt.Key_Meta] and key_name:
            self.keys.append(key_name.lower())
            
        self.update_display()
        
    def keyReleaseEvent(self, event):
        """Stop recording on key release"""
        if self.recording and self.keys:
            self.recording = False
            
    def focusOutEvent(self, event):
        """Stop recording when focus lost"""
        super().focusOutEvent(event)
        self.recording = False
        
    def update_display(self):
        """Update button text with captured keys"""
        if self.keys:
            self.setText(" + ".join(self.keys))
        else:
            self.setText(self.default_text)
            
    def get_keys(self):
        """Get captured keys"""
        return self.keys
        
    def set_keys(self, keys):
        """Set keys programmatically"""
        self.keys = keys
        self.update_display()


class KeyboardHotkeyStepDialog(QDialog):
    """Dialog for configuring keyboard hotkey step"""
    
    def __init__(self, step: KeyboardHotkeyStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ë‹¨ì¶•í‚¤ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Hotkey capture
        hotkey_group = QGroupBox("ë‹¨ì¶•í‚¤")
        hotkey_layout = QVBoxLayout()
        
        # Capture button
        self.capture_button = KeyCaptureButton()
        hotkey_layout.addWidget(self.capture_button)
        
        # Common hotkeys
        common_label = QLabel("ì¼ë°˜ì ì¸ ë‹¨ì¶•í‚¤:")
        common_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        hotkey_layout.addWidget(common_label)
        
        # Hotkey list
        self.hotkey_list = QListWidget()
        self.hotkey_list.setMaximumHeight(150)
        
        common_hotkeys = [
            ("ë³µì‚¬", ["ctrl", "c"]),
            ("ë¶™ì—¬ë„£ê¸°", ["ctrl", "v"]),
            ("ì˜ë¼ë‚´ê¸°", ["ctrl", "x"]),
            ("ì‹¤í–‰ ì·¨ì†Œ", ["ctrl", "z"]),
            ("ë‹¤ì‹œ ì‹¤í–‰", ["ctrl", "y"]),
            ("ëª¨ë‘ ì„ íƒ", ["ctrl", "a"]),
            ("ì €ì¥", ["ctrl", "s"]),
            ("ìƒˆë¡œ ë§Œë“¤ê¸°", ["ctrl", "n"]),
            ("ì—´ê¸°", ["ctrl", "o"]),
            ("ì¸ì‡„", ["ctrl", "p"]),
            ("ì°¾ê¸°", ["ctrl", "f"]),
            ("íƒ­ ì „í™˜", ["alt", "tab"]),
            ("ì°½ ë‹«ê¸°", ["alt", "f4"]),
        ]
        
        for name, keys in common_hotkeys:
            item = QListWidgetItem(f"{name}: {' + '.join(keys)}")
            item.setData(Qt.UserRole, keys)
            self.hotkey_list.addItem(item)
            
        self.hotkey_list.itemDoubleClicked.connect(self.use_common_hotkey)
        hotkey_layout.addWidget(self.hotkey_list)
        
        hotkey_group.setLayout(hotkey_layout)
        layout.addWidget(hotkey_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        if self.step.keys:
            self.capture_button.set_keys(self.step.keys)
            
    def use_common_hotkey(self, item):
        """Use a common hotkey"""
        keys = item.data(Qt.UserRole)
        self.capture_button.set_keys(keys)
        
    def validate_and_accept(self):
        """Validate input and accept"""
        if not self.capture_button.get_keys():
            QMessageBox.warning(
                self, "ê²½ê³ ",
                "ë‹¨ì¶•í‚¤ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”."
            )
            return
            
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'keys': self.capture_button.get_keys()
        }
</file>

<file path="src/ui/dialogs/keyboard_type_step_dialog.py">
"""
Keyboard type step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QDialogButtonBox, QTextEdit,
    QFormLayout, QGroupBox, QCheckBox, QListWidget
)
from PyQt5.QtCore import Qt
from core.macro_types import KeyboardTypeStep


class KeyboardTypeStepDialog(QDialog):
    """Dialog for configuring keyboard type step"""
    
    def __init__(self, step: KeyboardTypeStep, excel_columns=None, parent=None):
        super().__init__(parent)
        self.step = step
        self.excel_columns = excel_columns or []
        self.setWindowTitle("í…ìŠ¤íŠ¸ ì…ë ¥ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Text input
        text_group = QGroupBox("ì…ë ¥í•  í…ìŠ¤íŠ¸")
        text_layout = QVBoxLayout()
        
        # Text edit
        self.text_edit = QTextEdit()
        self.text_edit.setPlaceholderText("ì…ë ¥í•  í…ìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ì„¸ìš”.\në³€ìˆ˜ëŠ” {{ë³€ìˆ˜ëª…}} í˜•ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        text_layout.addWidget(self.text_edit)
        
        # Variable help
        if self.excel_columns:
            help_layout = QHBoxLayout()
            help_layout.addWidget(QLabel("ì‚¬ìš© ê°€ëŠ¥í•œ Excel ì—´:"))
            
            # Variable list
            self.var_list = QListWidget()
            self.var_list.setMaximumHeight(100)
            for col in self.excel_columns:
                self.var_list.addItem(f"{{{{{col}}}}}")
            self.var_list.itemDoubleClicked.connect(self.insert_variable)
            help_layout.addWidget(self.var_list)
            
            text_layout.addLayout(help_layout)
        
        text_group.setLayout(text_layout)
        layout.addWidget(text_group)
        
        # Typing options
        options_group = QGroupBox("ì…ë ¥ ì˜µì…˜")
        options_layout = QFormLayout()
        
        # Typing interval
        self.interval_spin = QSpinBox()
        self.interval_spin.setRange(0, 1000)
        self.interval_spin.setSuffix(" ms")
        self.interval_spin.setValue(0)
        options_layout.addRow("í‚¤ ì…ë ¥ ê°„ê²©:", self.interval_spin)
        
        # Use variables checkbox
        self.use_variables_check = QCheckBox("ë³€ìˆ˜ ì¹˜í™˜ ì‚¬ìš©")
        self.use_variables_check.setChecked(True)
        options_layout.addRow("", self.use_variables_check)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.text_edit.setPlainText(self.step.text)
        self.interval_spin.setValue(int(self.step.interval * 1000))
        self.use_variables_check.setChecked(self.step.use_variables)
        
    def insert_variable(self, item):
        """Insert variable at cursor position"""
        cursor = self.text_edit.textCursor()
        cursor.insertText(item.text())
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'text': self.text_edit.toPlainText(),
            'interval': self.interval_spin.value() / 1000.0,
            'use_variables': self.use_variables_check.isChecked()
        }
</file>

<file path="src/ui/dialogs/log_viewer_dialog.py">
"""
CSV log viewer dialog for analyzing execution logs
"""

import csv
import os
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QGroupBox, QComboBox, QLineEdit,
    QWidget, QSplitter, QTextEdit, QFileDialog, QMessageBox,
    QHeaderView, QProgressBar
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QColor, QFont
try:
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
    from matplotlib.figure import Figure
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False

class LogStatisticsWidget(QWidget):
    """Widget showing log statistics and charts"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Summary statistics
        self.stats_group = QGroupBox("ì‹¤í–‰ í†µê³„")
        stats_layout = QVBoxLayout()
        
        self.total_rows_label = QLabel("ì „ì²´ í–‰: 0")
        self.success_rows_label = QLabel("ì„±ê³µ: 0 (0.0%)")
        self.failed_rows_label = QLabel("ì‹¤íŒ¨: 0 (0.0%)")
        self.total_time_label = QLabel("ì´ ì‹¤í–‰ ì‹œê°„: 0ë¶„ 0ì´ˆ")
        self.avg_time_label = QLabel("í‰ê·  í–‰ ì²˜ë¦¬ ì‹œê°„: 0.0ì´ˆ")
        
        stats_layout.addWidget(self.total_rows_label)
        stats_layout.addWidget(self.success_rows_label)
        stats_layout.addWidget(self.failed_rows_label)
        stats_layout.addWidget(self.total_time_label)
        stats_layout.addWidget(self.avg_time_label)
        
        self.stats_group.setLayout(stats_layout)
        layout.addWidget(self.stats_group)
        
        # Chart (if matplotlib available)
        if HAS_MATPLOTLIB:
            self.figure = Figure(figsize=(5, 3))
            self.canvas = FigureCanvas(self.figure)
            layout.addWidget(self.canvas)
        else:
            no_chart_label = QLabel("ì°¨íŠ¸ë¥¼ í‘œì‹œí•˜ë ¤ë©´ matplotlibë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”")
            no_chart_label.setStyleSheet("color: #666; padding: 20px;")
            no_chart_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(no_chart_label)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def update_statistics(self, log_data: List[Dict[str, Any]]):
        """Update statistics from log data"""
        if not log_data:
            return
            
        # Calculate statistics
        total_rows = 0
        successful_rows = 0
        failed_rows = 0
        total_elapsed_ms = 0
        row_times = []
        
        # Process log entries
        processed_rows = set()
        for entry in log_data:
            if entry['row_index'] and entry['row_index'] != '-1':
                row_idx = int(entry['row_index'])
                
                if entry['step_name'] == 'ROW_COMPLETE' and row_idx not in processed_rows:
                    processed_rows.add(row_idx)
                    total_rows += 1
                    
                    if entry['status'] == 'SUCCESS':
                        successful_rows += 1
                    else:
                        failed_rows += 1
                        
                    if entry['duration_ms']:
                        row_times.append(float(entry['duration_ms']))
                        
            # Get total elapsed time from session end
            if entry['step_name'] == 'SESSION_END' and entry['elapsed_ms']:
                total_elapsed_ms = float(entry['elapsed_ms'])
                
        # Update labels
        self.total_rows_label.setText(f"ì „ì²´ í–‰: {total_rows}")
        
        if total_rows > 0:
            success_rate = (successful_rows / total_rows) * 100
            self.success_rows_label.setText(f"ì„±ê³µ: {successful_rows} ({success_rate:.1f}%)")
            self.failed_rows_label.setText(f"ì‹¤íŒ¨: {failed_rows} ({100-success_rate:.1f}%)")
        else:
            self.success_rows_label.setText("ì„±ê³µ: 0 (0.0%)")
            self.failed_rows_label.setText("ì‹¤íŒ¨: 0 (0.0%)")
            
        # Time statistics
        if total_elapsed_ms > 0:
            total_seconds = total_elapsed_ms / 1000
            minutes = int(total_seconds // 60)
            seconds = int(total_seconds % 60)
            self.total_time_label.setText(f"ì´ ì‹¤í–‰ ì‹œê°„: {minutes}ë¶„ {seconds}ì´ˆ")
            
        if row_times:
            avg_time = sum(row_times) / len(row_times) / 1000  # Convert to seconds
            self.avg_time_label.setText(f"í‰ê·  í–‰ ì²˜ë¦¬ ì‹œê°„: {avg_time:.1f}ì´ˆ")
            
        # Update chart
        self.update_chart(successful_rows, failed_rows)
        
    def update_chart(self, success: int, failed: int):
        """Update pie chart"""
        if not HAS_MATPLOTLIB:
            return
            
        self.figure.clear()
        
        if success == 0 and failed == 0:
            return
            
        ax = self.figure.add_subplot(111)
        
        # Data
        sizes = [success, failed]
        labels = ['ì„±ê³µ', 'ì‹¤íŒ¨']
        colors = ['#4CAF50', '#F44336']
        
        # Create pie chart
        wedges, texts, autotexts = ax.pie(
            sizes, labels=labels, colors=colors, autopct='%1.1f%%',
            shadow=True, startangle=90
        )
        
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax.axis('equal')
        ax.set_title('ì‹¤í–‰ ê²°ê³¼ ë¶„í¬')
        
        self.canvas.draw()

class LogViewerDialog(QDialog):
    """Dialog for viewing and analyzing CSV execution logs"""
    
    def __init__(self, log_file: Optional[Path] = None, parent=None):
        super().__init__(parent)
        self.log_data: List[Dict[str, Any]] = []
        self.filtered_data: List[Dict[str, Any]] = []
        
        self.init_ui()
        
        if log_file:
            self.load_log_file(log_file)
            
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("ì‹¤í–‰ ë¡œê·¸ ë·°ì–´")
        self.setModal(False)  # Non-modal to allow interaction with main window
        self.resize(1200, 700)
        
        layout = QVBoxLayout()
        
        # Toolbar
        toolbar_layout = QHBoxLayout()
        
        # Open file button
        open_btn = QPushButton("ë¡œê·¸ íŒŒì¼ ì—´ê¸°...")
        open_btn.clicked.connect(self.open_log_file)
        toolbar_layout.addWidget(open_btn)
        
        # Refresh button
        self.refresh_btn = QPushButton("ìƒˆë¡œê³ ì¹¨")
        self.refresh_btn.clicked.connect(self.refresh_current_file)
        self.refresh_btn.setEnabled(False)
        toolbar_layout.addWidget(self.refresh_btn)
        
        toolbar_layout.addWidget(QLabel("í•„í„°:"))
        
        # Status filter
        self.status_filter = QComboBox()
        self.status_filter.addItems(["ì „ì²´", "ì„±ê³µ", "ì‹¤íŒ¨", "ì˜¤ë¥˜"])
        self.status_filter.currentTextChanged.connect(self.apply_filters)
        toolbar_layout.addWidget(self.status_filter)
        
        # Search
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("ê²€ìƒ‰...")
        self.search_edit.textChanged.connect(self.apply_filters)
        toolbar_layout.addWidget(self.search_edit)
        
        # Export button
        export_btn = QPushButton("ë‚´ë³´ë‚´ê¸°...")
        export_btn.clicked.connect(self.export_filtered_data)
        toolbar_layout.addWidget(export_btn)
        
        toolbar_layout.addStretch()
        layout.addLayout(toolbar_layout)
        
        # Current file label
        self.file_label = QLabel("ë¡œê·¸ íŒŒì¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        self.file_label.setStyleSheet("color: #666; padding: 5px;")
        layout.addWidget(self.file_label)
        
        # Main content splitter
        splitter = QSplitter(Qt.Horizontal)
        
        # Statistics widget
        self.stats_widget = LogStatisticsWidget()
        splitter.addWidget(self.stats_widget)
        
        # Log table
        self.log_table = QTableWidget()
        self.setup_table()
        splitter.addWidget(self.log_table)
        
        # Set splitter sizes (30% stats, 70% table)
        splitter.setSizes([300, 700])
        
        layout.addWidget(splitter)
        
        # Status bar
        self.status_label = QLabel("ì¤€ë¹„")
        layout.addWidget(self.status_label)
        
        self.setLayout(layout)
        
        # Auto-refresh timer
        self.auto_refresh_timer = QTimer()
        self.auto_refresh_timer.timeout.connect(self.refresh_current_file)
        
    def setup_table(self):
        """Setup log table"""
        headers = [
            "ì‹œê°„", "ê²½ê³¼(ì´ˆ)", "í–‰", "ë‹¨ê³„", "íƒ€ì…", 
            "ìƒíƒœ", "ì†Œìš”ì‹œê°„(ms)", "ì˜¤ë¥˜ ë©”ì‹œì§€", "ìƒì„¸"
        ]
        
        self.log_table.setColumnCount(len(headers))
        self.log_table.setHorizontalHeaderLabels(headers)
        
        # Set column widths
        header = self.log_table.horizontalHeader()
        header.setStretchLastSection(True)
        self.log_table.setColumnWidth(0, 150)  # Time
        self.log_table.setColumnWidth(1, 80)   # Elapsed
        self.log_table.setColumnWidth(2, 60)   # Row
        self.log_table.setColumnWidth(3, 150)  # Step
        self.log_table.setColumnWidth(4, 100)  # Type
        self.log_table.setColumnWidth(5, 80)   # Status
        self.log_table.setColumnWidth(6, 100)  # Duration
        self.log_table.setColumnWidth(7, 200)  # Error
        
        # Enable sorting
        self.log_table.setSortingEnabled(True)
        
        # Row selection
        self.log_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.log_table.itemSelectionChanged.connect(self.on_selection_changed)
        
    def open_log_file(self):
        """Open a log file"""
        log_dir = Path.home() / ".excel_macro_automation" / "execution_logs"
        log_dir.mkdir(parents=True, exist_ok=True)
        
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "ì‹¤í–‰ ë¡œê·¸ íŒŒì¼ ì„ íƒ",
            str(log_dir),
            "CSV Files (*.csv);;All Files (*.*)"
        )
        
        if file_path:
            self.load_log_file(Path(file_path))
            
    def load_log_file(self, file_path: Path):
        """Load CSV log file"""
        self.current_file = file_path
        self.file_label.setText(f"ë¡œê·¸ íŒŒì¼: {file_path.name}")
        self.refresh_btn.setEnabled(True)
        
        try:
            self.log_data = []
            
            with open(file_path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    self.log_data.append(row)
                    
            self.apply_filters()
            self.status_label.setText(f"{len(self.log_data)}ê°œ í•­ëª© ë¡œë“œë¨")
            
            # Update statistics
            self.stats_widget.update_statistics(self.log_data)
            
            # Enable auto-refresh for current session
            if self.is_current_session():
                self.auto_refresh_timer.start(2000)  # Refresh every 2 seconds
            else:
                self.auto_refresh_timer.stop()
                
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ë¡œê·¸ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨:\n{str(e)}")
            
    def is_current_session(self) -> bool:
        """Check if loaded file is from current session"""
        if not hasattr(self, 'current_file'):
            return False
            
        # Check if file was modified recently (within last minute)
        try:
            mtime = os.path.getmtime(self.current_file)
            age = datetime.now().timestamp() - mtime
            return age < 60  # Less than 1 minute old
        except:
            return False
            
    def refresh_current_file(self):
        """Refresh current log file"""
        if hasattr(self, 'current_file'):
            self.load_log_file(self.current_file)
            
    def apply_filters(self):
        """Apply filters to log data"""
        # Get filter criteria
        status_filter = self.status_filter.currentText()
        search_text = self.search_edit.text().lower()
        
        # Filter data
        self.filtered_data = []
        
        for entry in self.log_data:
            # Status filter
            if status_filter != "ì „ì²´":
                if status_filter == "ì„±ê³µ" and entry['status'] != 'SUCCESS':
                    continue
                elif status_filter == "ì‹¤íŒ¨" and entry['status'] != 'FAILED':
                    continue
                elif status_filter == "ì˜¤ë¥˜" and entry['status'] != 'ERROR':
                    continue
                    
            # Search filter
            if search_text:
                found = False
                for value in entry.values():
                    if search_text in str(value).lower():
                        found = True
                        break
                if not found:
                    continue
                    
            self.filtered_data.append(entry)
            
        # Update table
        self.update_table()
        
    def update_table(self):
        """Update table with filtered data"""
        self.log_table.setRowCount(len(self.filtered_data))
        
        for i, entry in enumerate(self.filtered_data):
            # Timestamp
            timestamp = entry.get('timestamp', '')
            if timestamp:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    timestamp = dt.strftime('%Y-%m-%d %H:%M:%S')
                except:
                    pass
            self.log_table.setItem(i, 0, QTableWidgetItem(timestamp))
            
            # Elapsed time in seconds
            elapsed_ms = entry.get('elapsed_ms', '')
            if elapsed_ms:
                try:
                    elapsed_sec = float(elapsed_ms) / 1000
                    elapsed_str = f"{elapsed_sec:.1f}"
                except:
                    elapsed_str = elapsed_ms
            else:
                elapsed_str = ""
            self.log_table.setItem(i, 1, QTableWidgetItem(elapsed_str))
            
            # Row index (1-based for display)
            row_idx = entry.get('row_index', '')
            if row_idx and row_idx != '-1':
                try:
                    row_display = str(int(row_idx) + 1)
                except:
                    row_display = row_idx
            else:
                row_display = ""
            self.log_table.setItem(i, 2, QTableWidgetItem(row_display))
            
            # Step name
            self.log_table.setItem(i, 3, QTableWidgetItem(entry.get('step_name', '')))
            
            # Step type
            self.log_table.setItem(i, 4, QTableWidgetItem(entry.get('step_type', '')))
            
            # Status with color
            status = entry.get('status', '')
            status_item = QTableWidgetItem(status)
            if status == 'SUCCESS':
                status_item.setForeground(QColor(0, 128, 0))
            elif status in ['FAILED', 'ERROR']:
                status_item.setForeground(QColor(255, 0, 0))
            self.log_table.setItem(i, 5, status_item)
            
            # Duration
            self.log_table.setItem(i, 6, QTableWidgetItem(entry.get('duration_ms', '')))
            
            # Error message
            self.log_table.setItem(i, 7, QTableWidgetItem(entry.get('error_message', '')))
            
            # Details
            self.log_table.setItem(i, 8, QTableWidgetItem(entry.get('details', '')))
            
        self.status_label.setText(f"{len(self.filtered_data)}ê°œ í•­ëª© í‘œì‹œ ì¤‘")
        
    def on_selection_changed(self):
        """Handle row selection"""
        # Could show more details in a separate panel
        pass
        
    def export_filtered_data(self):
        """Export filtered data to CSV"""
        if not self.filtered_data:
            QMessageBox.information(self, "ë‚´ë³´ë‚´ê¸°", "ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return
            
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "ë¡œê·¸ ë‚´ë³´ë‚´ê¸°",
            f"filtered_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            "CSV Files (*.csv);;All Files (*.*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', newline='', encoding='utf-8') as f:
                    if self.filtered_data:
                        writer = csv.DictWriter(f, fieldnames=self.filtered_data[0].keys())
                        writer.writeheader()
                        writer.writerows(self.filtered_data)
                        
                QMessageBox.information(self, "ë‚´ë³´ë‚´ê¸° ì™„ë£Œ", f"ë¡œê·¸ê°€ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤:\n{file_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨", f"ë¡œê·¸ ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜:\n{str(e)}")
                
    def closeEvent(self, event):
        """Handle dialog close"""
        self.auto_refresh_timer.stop()
        super().closeEvent(event)
</file>

<file path="src/ui/dialogs/macro_save_dialog.py">
"""
Macro save and load dialogs
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QTextEdit, QRadioButton, QButtonGroup, QPushButton,
    QCheckBox, QSpinBox, QGroupBox, QProgressBar,
    QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from core.macro_types import Macro, MacroStep
from typing import List, Optional


class MacroSaveDialog(QDialog):
    """Dialog for saving macro with options"""
    
    def __init__(self, macro: Macro, parent=None):
        super().__init__(parent)
        self.macro = macro
        self.setWindowTitle("Save Macro")
        self.setModal(True)
        self.resize(400, 300)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Macro name
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("Name:"))
        self.name_edit = QLineEdit(self.macro.name)
        name_layout.addWidget(self.name_edit)
        layout.addLayout(name_layout)
        
        # Description
        layout.addWidget(QLabel("Description:"))
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.macro.description)
        self.desc_edit.setMaximumHeight(80)
        layout.addWidget(self.desc_edit)
        
        # Format selection
        format_group = QGroupBox("File Format")
        format_layout = QVBoxLayout()
        
        self.format_group = QButtonGroup()
        self.json_radio = QRadioButton("JSON (Human readable)")
        self.json_radio.setChecked(True)
        self.encrypted_radio = QRadioButton("Encrypted (Secure)")
        
        self.format_group.addButton(self.json_radio, 0)
        self.format_group.addButton(self.encrypted_radio, 1)
        
        format_layout.addWidget(self.json_radio)
        format_layout.addWidget(self.encrypted_radio)
        format_group.setLayout(format_layout)
        layout.addWidget(format_group)
        
        # Options
        options_group = QGroupBox("Options")
        options_layout = QVBoxLayout()
        
        self.include_vars_cb = QCheckBox("Include variables")
        self.include_vars_cb.setChecked(True)
        options_layout.addWidget(self.include_vars_cb)
        
        self.compress_cb = QCheckBox("Compress file")
        self.compress_cb.setChecked(False)
        options_layout.addWidget(self.compress_cb)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        save_btn.setDefault(True)
        btn_layout.addWidget(save_btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        
    def get_options(self) -> dict:
        """Get save options"""
        return {
            'name': self.name_edit.text(),
            'description': self.desc_edit.toPlainText(),
            'format': 'encrypted' if self.encrypted_radio.isChecked() else 'json',
            'include_variables': self.include_vars_cb.isChecked(),
            'compress': self.compress_cb.isChecked()
        }


class PartialMacroExportDialog(QDialog):
    """Dialog for exporting selected macro steps"""
    
    def __init__(self, selected_steps: List[MacroStep], all_variables: dict, parent=None):
        super().__init__(parent)
        self.selected_steps = selected_steps
        self.all_variables = all_variables
        self.setWindowTitle("Export Macro Steps")
        self.setModal(True)
        self.resize(450, 400)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Info
        info_label = QLabel(f"Exporting {len(self.selected_steps)} selected steps")
        info_label.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(info_label)
        
        # Name
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("Export Name:"))
        self.name_edit = QLineEdit("Partial Macro Export")
        name_layout.addWidget(self.name_edit)
        layout.addLayout(name_layout)
        
        # Description
        layout.addWidget(QLabel("Description:"))
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText("Exported macro steps")
        self.desc_edit.setMaximumHeight(60)
        layout.addWidget(self.desc_edit)
        
        # Variable dependencies
        var_group = QGroupBox("Variable Dependencies")
        var_layout = QVBoxLayout()
        
        # Check which variables are used
        used_vars = self._check_variable_usage()
        
        if used_vars:
            var_label = QLabel(f"The following variables are used in selected steps:")
            var_layout.addWidget(var_label)
            
            for var_name in used_vars:
                cb = QCheckBox(f"Include '{var_name}'")
                cb.setChecked(True)
                cb.setObjectName(var_name)
                var_layout.addWidget(cb)
        else:
            var_label = QLabel("No variables are used in selected steps")
            var_layout.addWidget(var_label)
            
        var_group.setLayout(var_layout)
        layout.addWidget(var_group)
        
        # Format
        format_group = QGroupBox("Export Format")
        format_layout = QVBoxLayout()
        
        self.format_group = QButtonGroup()
        self.json_radio = QRadioButton("JSON (Human readable)")
        self.json_radio.setChecked(True)
        self.encrypted_radio = QRadioButton("Encrypted (Secure)")
        
        self.format_group.addButton(self.json_radio, 0)
        self.format_group.addButton(self.encrypted_radio, 1)
        
        format_layout.addWidget(self.json_radio)
        format_layout.addWidget(self.encrypted_radio)
        format_group.setLayout(format_layout)
        layout.addWidget(format_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        export_btn = QPushButton("Export")
        export_btn.clicked.connect(self.accept)
        export_btn.setDefault(True)
        btn_layout.addWidget(export_btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        
    def _check_variable_usage(self) -> List[str]:
        """Check which variables are used in selected steps"""
        used_vars = set()
        
        for step in self.selected_steps:
            # Check various step properties for variable usage
            step_dict = step.to_dict()
            self._find_variables_in_dict(step_dict, used_vars)
            
        return sorted(list(used_vars))
        
    def _find_variables_in_dict(self, d: dict, used_vars: set):
        """Recursively find variable references in dictionary"""
        for key, value in d.items():
            if isinstance(value, str) and value.startswith('${') and value.endswith('}'):
                var_name = value[2:-1]
                if var_name in self.all_variables:
                    used_vars.add(var_name)
            elif isinstance(value, dict):
                self._find_variables_in_dict(value, used_vars)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, dict):
                        self._find_variables_in_dict(item, used_vars)
                        
    def get_export_data(self) -> dict:
        """Get export data"""
        # Collect selected variables
        selected_vars = {}
        var_group = self.findChild(QGroupBox, "Variable Dependencies")
        if var_group:
            for cb in var_group.findChildren(QCheckBox):
                if cb.isChecked():
                    var_name = cb.objectName()
                    if var_name in self.all_variables:
                        selected_vars[var_name] = self.all_variables[var_name]
                        
        return {
            'name': self.name_edit.text(),
            'description': self.desc_edit.toPlainText(),
            'format': 'encrypted' if self.encrypted_radio.isChecked() else 'json',
            'steps': self.selected_steps,
            'variables': selected_vars
        }


class MacroLoadProgressDialog(QDialog):
    """Progress dialog for loading macros"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Loading Macro")
        self.setModal(True)
        self.setFixedSize(300, 100)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        self.label = QLabel("Loading macro file...")
        layout.addWidget(self.label)
        
        self.progress = QProgressBar()
        self.progress.setRange(0, 0)  # Indeterminate
        layout.addWidget(self.progress)
        
        self.setLayout(layout)
        
    def set_message(self, message: str):
        """Set progress message"""
        self.label.setText(message)
</file>

<file path="src/ui/dialogs/mouse_click_step_dialog.py">
"""
Mouse click step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QComboBox, QDialogButtonBox,
    QFormLayout, QGroupBox, QCheckBox, QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QCursor
import pyautogui
from core.macro_types import MouseClickStep, MouseButton
from ui.widgets.roi_selector import ROISelectorWidget
from utils.monitor_utils import get_monitor_name_for_position, get_monitor_info


class MouseClickStepDialog(QDialog):
    """Dialog for configuring mouse click step"""
    
    def __init__(self, step: MouseClickStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ë§ˆìš°ìŠ¤ í´ë¦­ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Position group
        position_group = QGroupBox("í´ë¦­ ìœ„ì¹˜")
        position_layout = QVBoxLayout()
        
        # Position inputs
        coord_layout = QHBoxLayout()
        coord_layout.addWidget(QLabel("X:"))
        self.x_spin = QSpinBox()
        self.x_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.x_spin)
        
        coord_layout.addWidget(QLabel("Y:"))
        self.y_spin = QSpinBox()
        self.y_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.y_spin)
        
        coord_layout.addStretch()
        position_layout.addLayout(coord_layout)
        
        # Capture button
        self.capture_button = QPushButton("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)")
        self.capture_button.clicked.connect(self.capture_position)
        position_layout.addWidget(self.capture_button)
        
        # Set up F3 shortcut
        from PyQt5.QtWidgets import QShortcut
        from PyQt5.QtGui import QKeySequence
        self.capture_shortcut = QShortcut(QKeySequence("F3"), self)
        self.capture_shortcut.activated.connect(self.capture_position)
        
        # Select area button
        self.select_area_button = QPushButton("í™”ë©´ì—ì„œ ì„ íƒ...")
        self.select_area_button.clicked.connect(self.select_from_screen)
        position_layout.addWidget(self.select_area_button)
        
        position_group.setLayout(position_layout)
        layout.addWidget(position_group)
        
        # Help text for F3
        help_label = QLabel("ğŸ’¡ íŒ: F3 í‚¤ë¥¼ ëˆ„ë¥´ë©´ í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì¦‰ì‹œ ìº¡ì²˜í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        layout.addWidget(help_label)
        
        # Monitor info
        self.add_monitor_info(layout)
        
        # Click options
        options_group = QGroupBox("í´ë¦­ ì˜µì…˜")
        options_layout = QFormLayout()
        
        # Button selection
        self.button_combo = QComboBox()
        self.button_combo.addItems(["ì™¼ìª½ ë²„íŠ¼", "ì˜¤ë¥¸ìª½ ë²„íŠ¼", "ê°€ìš´ë° ë²„íŠ¼"])
        options_layout.addRow("ë§ˆìš°ìŠ¤ ë²„íŠ¼:", self.button_combo)
        
        # Click count
        self.clicks_spin = QSpinBox()
        self.clicks_spin.setRange(1, 10)
        self.clicks_spin.setValue(1)
        options_layout.addRow("í´ë¦­ íšŸìˆ˜:", self.clicks_spin)
        
        # Interval
        self.interval_spin = QSpinBox()
        self.interval_spin.setRange(0, 5000)
        self.interval_spin.setSuffix(" ms")
        self.interval_spin.setValue(0)
        options_layout.addRow("í´ë¦­ ê°„ê²©:", self.interval_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def add_monitor_info(self, parent_layout):
        """Add monitor information display"""
        monitors = get_monitor_info()
        
        if len(monitors) > 1:
            monitor_group = QGroupBox("ëª¨ë‹ˆí„° ì •ë³´")
            monitor_layout = QVBoxLayout()
            
            info_text = f"ê°ì§€ëœ ëª¨ë‹ˆí„°: {len(monitors)}ê°œ\n"
            for i, monitor in enumerate(monitors):
                name = "ì£¼ ëª¨ë‹ˆí„°" if monitor['is_primary'] else f"ëª¨ë‹ˆí„° {i+1}"
                info_text += f"â€¢ {name}: {monitor['width']}x{monitor['height']} (ìœ„ì¹˜: {monitor['x']}, {monitor['y']})\n"
            
            monitor_label = QLabel(info_text.strip())
            monitor_label.setStyleSheet("color: #666; font-size: 11px;")
            monitor_layout.addWidget(monitor_label)
            
            monitor_group.setLayout(monitor_layout)
            parent_layout.addWidget(monitor_group)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.x_spin.setValue(self.step.x)
        self.y_spin.setValue(self.step.y)
        
        # Set button
        button_map = {
            MouseButton.LEFT: 0,
            MouseButton.RIGHT: 1,
            MouseButton.MIDDLE: 2
        }
        self.button_combo.setCurrentIndex(button_map.get(self.step.button, 0))
        
        self.clicks_spin.setValue(self.step.clicks)
        self.interval_spin.setValue(int(self.step.interval * 1000))
        
    def capture_position(self):
        """Capture current mouse position"""
        # Capture immediately when F3 is pressed
        x, y = pyautogui.position()
        self.x_spin.setValue(x)
        self.y_spin.setValue(y)
        
        # Get monitor name for the position
        monitor_name = get_monitor_name_for_position(x, y)
        
        # Flash the button to indicate capture with monitor info
        self.capture_button.setText(f"ìº¡ì²˜ë¨! ({monitor_name}: {x}, {y})")
        QTimer.singleShot(1500, lambda: self.capture_button.setText("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)"))
        
        
    def select_from_screen(self):
        """Select position from screen"""
        self.hide()
        
        selector = ROISelectorWidget()
        # For now, just use capture position
        # TODO: Implement proper screen selection
        self.capture_position()
        return
        
        self.show()
        
        if result:
            x, y = result
            self.x_spin.setValue(x)
            self.y_spin.setValue(y)
            
    def get_step_data(self):
        """Get configured step data"""
        # Map combo index to button
        button_map = {
            0: MouseButton.LEFT,
            1: MouseButton.RIGHT,
            2: MouseButton.MIDDLE
        }
        
        return {
            'name': self.name_edit.text(),
            'x': self.x_spin.value(),
            'y': self.y_spin.value(),
            'button': button_map[self.button_combo.currentIndex()],
            'clicks': self.clicks_spin.value(),
            'interval': self.interval_spin.value() / 1000.0
        }
</file>

<file path="src/ui/dialogs/mouse_move_step_dialog.py">
"""
Mouse move step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QDoubleSpinBox, QDialogButtonBox,
    QFormLayout, QGroupBox, QMessageBox
)
from PyQt5.QtCore import Qt, QTimer
import pyautogui
from core.macro_types import MouseMoveStep
from ui.widgets.roi_selector import ROISelectorWidget
from utils.monitor_utils import get_monitor_name_for_position, get_monitor_info


class MouseMoveStepDialog(QDialog):
    """Dialog for configuring mouse move step"""
    
    def __init__(self, step: MouseMoveStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ë§ˆìš°ìŠ¤ ì´ë™ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Position group
        position_group = QGroupBox("ì´ë™ ìœ„ì¹˜")
        position_layout = QVBoxLayout()
        
        # Position inputs
        coord_layout = QHBoxLayout()
        coord_layout.addWidget(QLabel("X:"))
        self.x_spin = QSpinBox()
        self.x_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.x_spin)
        
        coord_layout.addWidget(QLabel("Y:"))
        self.y_spin = QSpinBox()
        self.y_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.y_spin)
        
        coord_layout.addStretch()
        position_layout.addLayout(coord_layout)
        
        # Capture button
        self.capture_button = QPushButton("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)")
        self.capture_button.clicked.connect(self.capture_position)
        position_layout.addWidget(self.capture_button)
        
        # Set up F3 shortcut
        from PyQt5.QtWidgets import QShortcut
        from PyQt5.QtGui import QKeySequence
        self.capture_shortcut = QShortcut(QKeySequence("F3"), self)
        self.capture_shortcut.activated.connect(self.capture_position)
        
        # Select area button
        self.select_area_button = QPushButton("í™”ë©´ì—ì„œ ì„ íƒ...")
        self.select_area_button.clicked.connect(self.select_from_screen)
        position_layout.addWidget(self.select_area_button)
        
        position_group.setLayout(position_layout)
        layout.addWidget(position_group)
        
        # Help text for F3
        help_label = QLabel("ğŸ’¡ íŒ: F3 í‚¤ë¥¼ ëˆ„ë¥´ë©´ í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì¦‰ì‹œ ìº¡ì²˜í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        layout.addWidget(help_label)
        
        # Monitor info
        self.add_monitor_info(layout)
        
        # Move options
        options_group = QGroupBox("ì´ë™ ì˜µì…˜")
        options_layout = QFormLayout()
        
        # Duration
        self.duration_spin = QDoubleSpinBox()
        self.duration_spin.setRange(0, 10.0)
        self.duration_spin.setSingleStep(0.1)
        self.duration_spin.setDecimals(1)
        self.duration_spin.setSuffix(" ì´ˆ")
        self.duration_spin.setValue(0.0)
        options_layout.addRow("ì´ë™ ì‹œê°„:", self.duration_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Help text
        help_label = QLabel("ì´ë™ ì‹œê°„ì„ 0ìœ¼ë¡œ ì„¤ì •í•˜ë©´ ì¦‰ì‹œ ì´ë™í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-size: 12px;")
        layout.addWidget(help_label)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def add_monitor_info(self, parent_layout):
        """Add monitor information display"""
        monitors = get_monitor_info()
        
        if len(monitors) > 1:
            monitor_group = QGroupBox("ëª¨ë‹ˆí„° ì •ë³´")
            monitor_layout = QVBoxLayout()
            
            info_text = f"ê°ì§€ëœ ëª¨ë‹ˆí„°: {len(monitors)}ê°œ\n"
            for i, monitor in enumerate(monitors):
                name = "ì£¼ ëª¨ë‹ˆí„°" if monitor['is_primary'] else f"ëª¨ë‹ˆí„° {i+1}"
                info_text += f"â€¢ {name}: {monitor['width']}x{monitor['height']} (ìœ„ì¹˜: {monitor['x']}, {monitor['y']})\n"
            
            monitor_label = QLabel(info_text.strip())
            monitor_label.setStyleSheet("color: #666; font-size: 11px;")
            monitor_layout.addWidget(monitor_label)
            
            monitor_group.setLayout(monitor_layout)
            parent_layout.addWidget(monitor_group)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.x_spin.setValue(self.step.x)
        self.y_spin.setValue(self.step.y)
        self.duration_spin.setValue(self.step.duration)
        
    def capture_position(self):
        """Capture current mouse position"""
        # Capture immediately when F3 is pressed
        x, y = pyautogui.position()
        self.x_spin.setValue(x)
        self.y_spin.setValue(y)
        
        # Get monitor name for the position
        monitor_name = get_monitor_name_for_position(x, y)
        
        # Flash the button to indicate capture with monitor info
        self.capture_button.setText(f"ìº¡ì²˜ë¨! ({monitor_name}: {x}, {y})")
        QTimer.singleShot(1500, lambda: self.capture_button.setText("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)"))
        
        
    def select_from_screen(self):
        """Select position from screen"""
        self.hide()
        
        selector = ROISelectorWidget()
        # For now, just use capture position
        # TODO: Implement proper screen selection
        self.capture_position()
        return
        
        self.show()
        
        if result:
            x, y = result
            self.x_spin.setValue(x)
            self.y_spin.setValue(y)
            
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'x': self.x_spin.value(),
            'y': self.y_spin.value(),
            'duration': self.duration_spin.value()
        }
</file>

<file path="src/ui/dialogs/screenshot_step_dialog.py">
"""
Screenshot step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QComboBox, QCheckBox, QFileDialog, QMessageBox
)
from PyQt5.QtCore import Qt
from core.macro_types import ScreenshotStep
import os
from datetime import datetime


class ScreenshotStepDialog(QDialog):
    """Dialog for configuring screenshot step"""
    
    def __init__(self, step: ScreenshotStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("í™”ë©´ ìº¡ì²˜ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # File settings group
        file_group = QGroupBox("íŒŒì¼ ì„¤ì •")
        file_layout = QVBoxLayout()
        
        # Filename pattern
        pattern_layout = QHBoxLayout()
        pattern_layout.addWidget(QLabel("íŒŒì¼ëª… íŒ¨í„´:"))
        self.filename_edit = QLineEdit()
        self.filename_edit.setPlaceholderText("ì˜ˆ: screenshot_{timestamp}.png")
        pattern_layout.addWidget(self.filename_edit)
        file_layout.addLayout(pattern_layout)
        
        # Help text for filename patterns
        help_text = QLabel(
            "ì‚¬ìš© ê°€ëŠ¥í•œ ë³€ìˆ˜:\n"
            "â€¢ {timestamp} - í˜„ì¬ ì‹œê°„ (YYYYMMDD_HHMMSS)\n"
            "â€¢ {date} - í˜„ì¬ ë‚ ì§œ (YYYYMMDD)\n"
            "â€¢ {time} - í˜„ì¬ ì‹œê°„ (HHMMSS)\n"
            "â€¢ {index} - ìˆœë²ˆ (ìë™ ì¦ê°€)"
        )
        help_text.setWordWrap(True)
        help_text.setStyleSheet("color: #666; font-size: 11px; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        file_layout.addWidget(help_text)
        
        # Save directory
        dir_layout = QHBoxLayout()
        dir_layout.addWidget(QLabel("ì €ì¥ ê²½ë¡œ:"))
        self.directory_edit = QLineEdit()
        self.directory_edit.setPlaceholderText("ê¸°ë³¸: ./screenshots/")
        dir_layout.addWidget(self.directory_edit)
        
        self.browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°...")
        self.browse_btn.clicked.connect(self.browse_directory)
        dir_layout.addWidget(self.browse_btn)
        file_layout.addLayout(dir_layout)
        
        file_group.setLayout(file_layout)
        layout.addWidget(file_group)
        
        # Capture options group
        options_group = QGroupBox("ìº¡ì²˜ ì˜µì…˜")
        options_layout = QVBoxLayout()
        
        # Full screen or region
        self.full_screen_checkbox = QCheckBox("ì „ì²´ í™”ë©´ ìº¡ì²˜")
        self.full_screen_checkbox.setChecked(True)
        self.full_screen_checkbox.toggled.connect(self.on_full_screen_toggled)
        options_layout.addWidget(self.full_screen_checkbox)
        
        # Region settings (disabled by default)
        region_layout = QHBoxLayout()
        region_layout.addWidget(QLabel("ì˜ì—­:"))
        
        self.x_edit = QLineEdit("0")
        self.x_edit.setMaximumWidth(80)
        self.x_edit.setEnabled(False)
        region_layout.addWidget(QLabel("X:"))
        region_layout.addWidget(self.x_edit)
        
        self.y_edit = QLineEdit("0")
        self.y_edit.setMaximumWidth(80)
        self.y_edit.setEnabled(False)
        region_layout.addWidget(QLabel("Y:"))
        region_layout.addWidget(self.y_edit)
        
        self.width_edit = QLineEdit("0")
        self.width_edit.setMaximumWidth(80)
        self.width_edit.setEnabled(False)
        region_layout.addWidget(QLabel("ë„ˆë¹„:"))
        region_layout.addWidget(self.width_edit)
        
        self.height_edit = QLineEdit("0")
        self.height_edit.setMaximumWidth(80)
        self.height_edit.setEnabled(False)
        region_layout.addWidget(QLabel("ë†’ì´:"))
        region_layout.addWidget(self.height_edit)
        
        region_layout.addStretch()
        options_layout.addLayout(region_layout)
        
        # Select region button
        self.select_region_btn = QPushButton("í™”ë©´ì—ì„œ ì˜ì—­ ì„ íƒ...")
        self.select_region_btn.setEnabled(False)
        self.select_region_btn.clicked.connect(self.select_region)
        options_layout.addWidget(self.select_region_btn)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.filename_edit.setText(self.step.filename_pattern)
        self.directory_edit.setText(self.step.save_directory)
        
        if self.step.region:
            self.full_screen_checkbox.setChecked(False)
            x, y, width, height = self.step.region
            self.x_edit.setText(str(x))
            self.y_edit.setText(str(y))
            self.width_edit.setText(str(width))
            self.height_edit.setText(str(height))
        else:
            self.full_screen_checkbox.setChecked(True)
            
    def on_full_screen_toggled(self, checked):
        """Handle full screen checkbox toggle"""
        self.x_edit.setEnabled(not checked)
        self.y_edit.setEnabled(not checked)
        self.width_edit.setEnabled(not checked)
        self.height_edit.setEnabled(not checked)
        self.select_region_btn.setEnabled(not checked)
        
    def browse_directory(self):
        """Browse for save directory"""
        directory = QFileDialog.getExistingDirectory(
            self,
            "ì €ì¥ ê²½ë¡œ ì„ íƒ",
            self.directory_edit.text() or "./screenshots/"
        )
        if directory:
            self.directory_edit.setText(directory)
            
    def select_region(self):
        """Select region from screen"""
        # TODO: Implement screen region selection
        # For now, just show a message
        QMessageBox.information(
            self,
            "ê¸°ëŠ¥ êµ¬í˜„ ì˜ˆì •",
            "í™”ë©´ ì˜ì—­ ì„ íƒ ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.\nìˆ˜ë™ìœ¼ë¡œ ì¢Œí‘œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."
        )
        
    def validate_and_accept(self):
        """Validate input and accept"""
        # Default filename if empty
        if not self.filename_edit.text():
            self.filename_edit.setText("screenshot_{timestamp}.png")
            
        # Default directory if empty
        if not self.directory_edit.text():
            self.directory_edit.setText("./screenshots/")
            
        # Validate region if not full screen
        if not self.full_screen_checkbox.isChecked():
            try:
                x = int(self.x_edit.text())
                y = int(self.y_edit.text())
                width = int(self.width_edit.text())
                height = int(self.height_edit.text())
                
                if width <= 0 or height <= 0:
                    raise ValueError("ë„ˆë¹„ì™€ ë†’ì´ëŠ” 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤")
                    
            except ValueError as e:
                QMessageBox.warning(
                    self, "ê²½ê³ ",
                    f"ì˜ëª»ëœ ì˜ì—­ ì„¤ì •: {str(e)}"
                )
                return
                
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        region = None
        if not self.full_screen_checkbox.isChecked():
            region = (
                int(self.x_edit.text()),
                int(self.y_edit.text()),
                int(self.width_edit.text()),
                int(self.height_edit.text())
            )
            
        return {
            'name': self.name_edit.text() or "í™”ë©´ ìº¡ì²˜",
            'filename_pattern': self.filename_edit.text() or "screenshot_{timestamp}.png",
            'save_directory': self.directory_edit.text() or "./screenshots/",
            'region': region
        }
</file>

<file path="src/ui/dialogs/wait_time_step_dialog.py">
"""
Wait time step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, 
    QDoubleSpinBox, QDialogButtonBox, QFormLayout
)
from PyQt5.QtCore import Qt
from core.macro_types import WaitTimeStep


class WaitTimeStepDialog(QDialog):
    """Dialog for configuring wait time step"""
    
    def __init__(self, step: WaitTimeStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ëŒ€ê¸° ì‹œê°„ ì„¤ì •")
        self.setModal(True)
        self.setFixedWidth(300)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Form layout
        form_layout = QFormLayout()
        
        # Step name
        self.name_edit = QLineEdit()
        form_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        
        # Wait time
        self.seconds_spin = QDoubleSpinBox()
        self.seconds_spin.setRange(0.1, 3600.0)
        self.seconds_spin.setSingleStep(0.5)
        self.seconds_spin.setDecimals(1)
        self.seconds_spin.setSuffix(" ì´ˆ")
        self.seconds_spin.setValue(1.0)
        form_layout.addRow("ëŒ€ê¸° ì‹œê°„:", self.seconds_spin)
        
        layout.addLayout(form_layout)
        
        # Help text
        help_label = QLabel("ì§€ì •ëœ ì‹œê°„ ë™ì•ˆ ì‹¤í–‰ì„ ì¼ì‹œ ì •ì§€í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-size: 12px;")
        layout.addWidget(help_label)
        
        layout.addStretch()
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.seconds_spin.setValue(self.step.seconds)
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'seconds': self.seconds_spin.value()
        }
</file>

<file path="src/ui/widgets/__init__.py">
# UI Widgets
</file>

<file path="src/ui/widgets/data_preview.py">
"""
Excel data preview widget with pagination
"""

from typing import Optional, List
import pandas as pd
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, 
    QTableWidgetItem, QPushButton, QLabel, QSpinBox,
    QComboBox, QLineEdit, QCheckBox, QHeaderView,
    QGroupBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QColor, QBrush
from excel.models import ExcelData, ColumnType

class DataPreviewTable(QTableWidget):
    """Table widget for previewing Excel data"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Configure table appearance
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QTableWidget.SelectRows)
        self.horizontalHeader().setStretchLastSection(True)
        self.verticalHeader().setDefaultSectionSize(24)
        
    def load_data(self, dataframe: pd.DataFrame, start_row: int = 0, 
                  rows_per_page: int = 100, highlight_status: bool = True):
        """Load data into table"""
        # Clear existing data
        self.clear()
        
        # Set columns
        columns = dataframe.columns.tolist()
        self.setColumnCount(len(columns))
        self.setHorizontalHeaderLabels(columns)
        
        # Determine rows to display
        end_row = min(start_row + rows_per_page, len(dataframe))
        display_rows = end_row - start_row
        self.setRowCount(display_rows)
        
        # Find status column
        status_col_idx = None
        if highlight_status:
            status_columns = ['ìƒíƒœ', 'Status', 'ì™„ë£Œì—¬ë¶€', 'ì²˜ë¦¬ìƒíƒœ', 'status', 'STATUS']
            for idx, col in enumerate(columns):
                if col in status_columns:
                    status_col_idx = idx
                    break
        
        # Populate data
        for row in range(display_rows):
            df_row = start_row + row
            
            # Set row header to show actual row number
            self.setVerticalHeaderItem(row, QTableWidgetItem(str(df_row + 1)))
            
            for col in range(len(columns)):
                value = dataframe.iloc[df_row, col]
                
                # Handle different data types
                if pd.isna(value):
                    item_text = ""
                elif isinstance(value, float):
                    item_text = f"{value:.2f}" if value % 1 else str(int(value))
                else:
                    item_text = str(value)
                
                item = QTableWidgetItem(item_text)
                
                # Apply status highlighting
                if col == status_col_idx and highlight_status:
                    if value in ['ì™„ë£Œ', 'Completed', 'Complete', 'Done']:
                        item.setBackground(QBrush(QColor(200, 255, 200)))
                    elif value in ['ì‹¤íŒ¨', 'Failed', 'Error']:
                        item.setBackground(QBrush(QColor(255, 200, 200)))
                    elif value in ['ì§„í–‰ì¤‘', 'Processing', 'In Progress']:
                        item.setBackground(QBrush(QColor(255, 255, 200)))
                
                self.setItem(row, col, item)
        
        # Resize columns to content
        self.resizeColumnsToContents()

class DataPreviewWidget(QWidget):
    """Complete data preview widget with controls"""
    
    rowSelected = pyqtSignal(int)  # Emit actual dataframe row index
    
    def __init__(self):
        super().__init__()
        self.excel_data: Optional[ExcelData] = None
        self.current_page = 0
        self.rows_per_page = 100
        self.filtered_indices: Optional[List[int]] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Filter controls
        filter_group = QGroupBox("í•„í„° ì˜µì…˜")
        filter_layout = QHBoxLayout()
        
        # Status filter
        self.incomplete_only = QCheckBox("ë¯¸ì™„ë£Œ í•­ëª©ë§Œ í‘œì‹œ")
        self.incomplete_only.stateChanged.connect(self._apply_filter)
        filter_layout.addWidget(self.incomplete_only)
        
        # Search
        filter_layout.addWidget(QLabel("ê²€ìƒ‰:"))
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("ê²€ìƒ‰ì–´ ì…ë ¥...")
        self.search_input.textChanged.connect(self._apply_filter)
        filter_layout.addWidget(self.search_input)
        
        filter_layout.addStretch()
        filter_group.setLayout(filter_layout)
        layout.addWidget(filter_group)
        
        # Data table
        self.data_table = DataPreviewTable()
        self.data_table.cellDoubleClicked.connect(self._on_cell_double_clicked)
        layout.addWidget(self.data_table)
        
        # Pagination controls
        pagination_layout = QHBoxLayout()
        
        # Page size
        pagination_layout.addWidget(QLabel("í–‰/í˜ì´ì§€:"))
        self.page_size_spin = QSpinBox()
        self.page_size_spin.setRange(10, 1000)
        self.page_size_spin.setSingleStep(50)
        self.page_size_spin.setValue(self.rows_per_page)
        self.page_size_spin.valueChanged.connect(self._on_page_size_changed)
        pagination_layout.addWidget(self.page_size_spin)
        
        pagination_layout.addStretch()
        
        # Page navigation
        self.prev_btn = QPushButton("â—€ ì´ì „")
        self.prev_btn.clicked.connect(self._prev_page)
        pagination_layout.addWidget(self.prev_btn)
        
        self.page_label = QLabel("1 / 1")
        pagination_layout.addWidget(self.page_label)
        
        self.next_btn = QPushButton("ë‹¤ìŒ â–¶")
        self.next_btn.clicked.connect(self._next_page)
        pagination_layout.addWidget(self.next_btn)
        
        pagination_layout.addStretch()
        
        # Row count info
        self.row_info_label = QLabel()
        pagination_layout.addWidget(self.row_info_label)
        
        layout.addLayout(pagination_layout)
        self.setLayout(layout)
        
    def load_excel_data(self, excel_data: ExcelData):
        """Load Excel data for preview"""
        self.excel_data = excel_data
        self.current_page = 0
        self.filtered_indices = None
        self._apply_filter()
        
    def _apply_filter(self):
        """Apply current filter settings"""
        if not self.excel_data:
            return
            
        df = self.excel_data.dataframe
        
        # Start with all rows
        mask = pd.Series([True] * len(df))
        
        # Apply incomplete filter
        if self.incomplete_only.isChecked():
            status_col = self.excel_data.get_status_column()
            if status_col:
                mask &= ~df[status_col].isin(['ì™„ë£Œ', 'Completed', 'Complete', 'Done'])
        
        # Apply search filter
        search_text = self.search_input.text().strip()
        if search_text:
            search_mask = pd.Series([False] * len(df))
            for col in df.columns:
                if df[col].dtype == 'object':  # String columns only
                    search_mask |= df[col].astype(str).str.contains(
                        search_text, case=False, na=False
                    )
            mask &= search_mask
        
        # Get filtered indices
        self.filtered_indices = df[mask].index.tolist()
        
        # Reset to first page
        self.current_page = 0
        self._update_display()
        
    def _update_display(self):
        """Update table display"""
        if not self.excel_data:
            return
            
        df = self.excel_data.dataframe
        
        # Use filtered data if available
        if self.filtered_indices is not None:
            if not self.filtered_indices:
                self.data_table.setRowCount(0)
                self._update_pagination_controls()
                return
            display_df = df.loc[self.filtered_indices]
        else:
            display_df = df
        
        # Calculate page boundaries
        start_idx = self.current_page * self.rows_per_page
        
        # Load data into table
        self.data_table.load_data(
            display_df,
            start_row=start_idx,
            rows_per_page=self.rows_per_page
        )
        
        self._update_pagination_controls()
        
    def _update_pagination_controls(self):
        """Update pagination control states"""
        if not self.excel_data:
            return
            
        # Calculate total pages
        if self.filtered_indices is not None:
            total_rows = len(self.filtered_indices)
        else:
            total_rows = len(self.excel_data.dataframe)
            
        total_pages = max(1, (total_rows + self.rows_per_page - 1) // self.rows_per_page)
        
        # Update label
        self.page_label.setText(f"{self.current_page + 1} / {total_pages}")
        
        # Update button states
        self.prev_btn.setEnabled(self.current_page > 0)
        self.next_btn.setEnabled(self.current_page < total_pages - 1)
        
        # Update row info
        if self.filtered_indices is not None:
            self.row_info_label.setText(
                f"í‘œì‹œ: {len(self.filtered_indices)} / ì „ì²´: {len(self.excel_data.dataframe)} í–‰"
            )
        else:
            self.row_info_label.setText(f"ì „ì²´: {total_rows} í–‰")
        
    def _on_page_size_changed(self, value: int):
        """Handle page size change"""
        self.rows_per_page = value
        self.current_page = 0
        self._update_display()
        
    def _prev_page(self):
        """Go to previous page"""
        if self.current_page > 0:
            self.current_page -= 1
            self._update_display()
            
    def _next_page(self):
        """Go to next page"""
        self.current_page += 1
        self._update_display()
        
    def _on_cell_double_clicked(self, row: int, column: int):
        """Handle cell double click"""
        # Calculate actual dataframe row index
        actual_row = self.current_page * self.rows_per_page + row
        
        if self.filtered_indices is not None:
            if actual_row < len(self.filtered_indices):
                df_row_index = self.filtered_indices[actual_row]
                self.rowSelected.emit(df_row_index)
        else:
            self.rowSelected.emit(actual_row)
</file>

<file path="src/ui/widgets/file_selector.py">
"""
Excel file selection widget with drag-drop support
"""

import os
from pathlib import Path
from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
    QLabel, QListWidget, QListWidgetItem, QFileDialog,
    QGroupBox, QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QMimeData
from PyQt5.QtGui import QDragEnterEvent, QDropEvent, QIcon

class FileDropArea(QLabel):
    """Drag and drop area for Excel files"""
    
    fileDropped = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setAcceptDrops(True)
        self.setAlignment(Qt.AlignCenter)
        self.setStyleSheet("""
            QLabel {
                border: 2px dashed #aaa;
                border-radius: 5px;
                padding: 20px;
                background-color: #f5f5f5;
                min-height: 100px;
            }
            QLabel:hover {
                border-color: #555;
                background-color: #e8e8e8;
            }
        """)
        self.setText("ì—‘ì…€ íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ê±°ë‚˜\nì•„ë˜ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”")
        
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event"""
        if event.mimeData().hasUrls():
            # Check if any file is Excel
            for url in event.mimeData().urls():
                if url.isLocalFile():
                    path = url.toLocalFile()
                    if path.lower().endswith(('.xlsx', '.xls', '.xlsm')):
                        event.acceptProposedAction()
                        self.setStyleSheet("""
                            QLabel {
                                border: 2px solid #4CAF50;
                                border-radius: 5px;
                                padding: 20px;
                                background-color: #e8f5e9;
                                min-height: 100px;
                            }
                        """)
                        return
        event.ignore()
        
    def dragLeaveEvent(self, event):
        """Handle drag leave event"""
        self.setStyleSheet("""
            QLabel {
                border: 2px dashed #aaa;
                border-radius: 5px;
                padding: 20px;
                background-color: #f5f5f5;
                min-height: 100px;
            }
        """)
        
    def dropEvent(self, event: QDropEvent):
        """Handle drop event"""
        for url in event.mimeData().urls():
            if url.isLocalFile():
                path = url.toLocalFile()
                if path.lower().endswith(('.xlsx', '.xls', '.xlsm')):
                    self.fileDropped.emit(path)
                    event.acceptProposedAction()
                    self.dragLeaveEvent(None)
                    return

class RecentFilesList(QListWidget):
    """List of recently opened Excel files"""
    
    fileSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setMaximumHeight(150)
        self.itemDoubleClicked.connect(self._on_item_double_clicked)
        
    def add_recent_file(self, file_path: str):
        """Add file to recent files list"""
        # Check if already exists
        for i in range(self.count()):
            if self.item(i).data(Qt.UserRole) == file_path:
                # Move to top
                item = self.takeItem(i)
                self.insertItem(0, item)
                return
        
        # Add new item
        file_name = os.path.basename(file_path)
        item = QListWidgetItem(file_name)
        item.setData(Qt.UserRole, file_path)
        item.setToolTip(file_path)
        self.insertItem(0, item)
        
        # Keep only 10 recent files
        while self.count() > 10:
            self.takeItem(self.count() - 1)
            
    def _on_item_double_clicked(self, item: QListWidgetItem):
        """Handle double click on item"""
        file_path = item.data(Qt.UserRole)
        if file_path and os.path.exists(file_path):
            self.fileSelected.emit(file_path)

class FileSelectorWidget(QWidget):
    """Excel file selection widget"""
    
    fileSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.current_file: Optional[str] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Current file info
        self.file_info_label = QLabel("ì„ íƒëœ íŒŒì¼: ì—†ìŒ")
        self.file_info_label.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(self.file_info_label)
        
        # Drop area
        self.drop_area = FileDropArea()
        self.drop_area.fileDropped.connect(self._on_file_selected)
        layout.addWidget(self.drop_area)
        
        # Browse button
        browse_button = QPushButton("íŒŒì¼ ì°¾ì•„ë³´ê¸°...")
        browse_button.clicked.connect(self._browse_file)
        layout.addWidget(browse_button)
        
        # Recent files
        recent_group = QGroupBox("ìµœê·¼ íŒŒì¼")
        recent_layout = QVBoxLayout()
        self.recent_files = RecentFilesList()
        self.recent_files.fileSelected.connect(self._on_file_selected)
        recent_layout.addWidget(self.recent_files)
        recent_group.setLayout(recent_layout)
        layout.addWidget(recent_group)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def _browse_file(self):
        """Open file dialog to select Excel file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "ì—‘ì…€ íŒŒì¼ ì„ íƒ",
            "",
            "Excel Files (*.xlsx *.xls *.xlsm);;All Files (*.*)"
        )
        
        if file_path:
            self._on_file_selected(file_path)
            
    def _on_file_selected(self, file_path: str):
        """Handle file selection"""
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "íŒŒì¼ ì˜¤ë¥˜", f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n{file_path}")
            return
            
        self.current_file = file_path
        self.file_info_label.setText(f"ì„ íƒëœ íŒŒì¼: {os.path.basename(file_path)}")
        self.recent_files.add_recent_file(file_path)
        self.fileSelected.emit(file_path)
        
    def get_recent_files(self) -> list:
        """Get list of recent files"""
        files = []
        for i in range(self.recent_files.count()):
            item = self.recent_files.item(i)
            files.append(item.data(Qt.UserRole))
        return files
        
    def set_recent_files(self, files: list):
        """Set recent files list"""
        self.recent_files.clear()
        for file_path in files:
            if os.path.exists(file_path):
                self.recent_files.add_recent_file(file_path)
</file>

<file path="src/ui/widgets/monitor_widget.py">
"""
ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ìœ„ì ¯
"""

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
    QProgressBar, QGroupBox, QTextEdit, QPushButton,
    QListWidget, QListWidgetItem, QGridLayout
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QColor, QPalette
from utils.background_monitor import get_monitor
from datetime import datetime

class SystemHealthWidget(QWidget):
    """ì‹œìŠ¤í…œ ê±´ê°• ìƒíƒœ í‘œì‹œ ìœ„ì ¯"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        layout = QHBoxLayout()
        
        # ìƒíƒœ ì¸ë””ì¼€ì´í„°
        self.status_indicator = QLabel("â—")
        self.status_indicator.setStyleSheet("font-size: 24px;")
        layout.addWidget(self.status_indicator)
        
        # ìƒíƒœ í…ìŠ¤íŠ¸
        self.status_label = QLabel("ì‹œìŠ¤í…œ ìƒíƒœ: ì •ìƒ")
        self.status_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(self.status_label)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def update_status(self, status: str):
        """ìƒíƒœ ì—…ë°ì´íŠ¸"""
        colors = {
            "ì •ìƒ": "#4CAF50",
            "ì£¼ì˜": "#FF9800",
            "ìœ„í—˜": "#F44336"
        }
        
        color = colors.get(status, "#757575")
        self.status_indicator.setStyleSheet(f"font-size: 24px; color: {color};")
        self.status_label.setText(f"ì‹œìŠ¤í…œ ìƒíƒœ: {status}")

class MetricsWidget(QWidget):
    """ë©”íŠ¸ë¦­ í‘œì‹œ ìœ„ì ¯"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        layout = QGridLayout()
        
        # CPU ì‚¬ìš©ë¥ 
        layout.addWidget(QLabel("CPU:"), 0, 0)
        self.cpu_bar = QProgressBar()
        self.cpu_bar.setTextVisible(True)
        layout.addWidget(self.cpu_bar, 0, 1)
        
        # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
        layout.addWidget(QLabel("ë©”ëª¨ë¦¬:"), 1, 0)
        self.memory_bar = QProgressBar()
        self.memory_bar.setTextVisible(True)
        layout.addWidget(self.memory_bar, 1, 1)
        
        # ë””ìŠ¤í¬ ì‚¬ìš©ë¥ 
        layout.addWidget(QLabel("ë””ìŠ¤í¬:"), 2, 0)
        self.disk_bar = QProgressBar()
        self.disk_bar.setTextVisible(True)
        layout.addWidget(self.disk_bar, 2, 1)
        
        # ìŠ¤ë ˆë“œ ìˆ˜
        layout.addWidget(QLabel("ìŠ¤ë ˆë“œ:"), 3, 0)
        self.thread_label = QLabel("0")
        layout.addWidget(self.thread_label, 3, 1)
        
        self.setLayout(layout)
        
    def update_metrics(self, metrics: dict):
        """ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸"""
        if 'cpu_percent' in metrics:
            self.cpu_bar.setValue(int(metrics['cpu_percent']))
            
        if 'memory_percent' in metrics:
            self.memory_bar.setValue(int(metrics['memory_percent']))
            
        if 'disk_percent' in metrics:
            self.disk_bar.setValue(int(metrics['disk_percent']))
            
        if 'thread_count' in metrics:
            self.thread_label.setText(f"{metrics['thread_count']}ê°œ")

class AlertListWidget(QListWidget):
    """ì•Œë¦¼ ëª©ë¡ ìœ„ì ¯"""
    
    def __init__(self):
        super().__init__()
        self.setMaximumHeight(150)
        
    def add_alert(self, rule_name: str, message: str):
        """ì•Œë¦¼ ì¶”ê°€"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        item = QListWidgetItem(f"[{timestamp}] {message}")
        
        # ê·œì¹™ì— ë”°ë¥¸ ìƒ‰ìƒ
        if "high" in rule_name or "ìœ„í—˜" in message:
            item.setForeground(QColor("#F44336"))
        elif "ì£¼ì˜" in message:
            item.setForeground(QColor("#FF9800"))
            
        self.insertItem(0, item)
        
        # ìµœëŒ€ 20ê°œë§Œ ìœ ì§€
        while self.count() > 20:
            self.takeItem(self.count() - 1)

class MonitorWidget(QWidget):
    """ëª¨ë‹ˆí„°ë§ í†µí•© ìœ„ì ¯"""
    
    def __init__(self):
        super().__init__()
        self.monitor = get_monitor()
        self.init_ui()
        self.setup_connections()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # ê±´ê°• ìƒíƒœ
        self.health_widget = SystemHealthWidget()
        layout.addWidget(self.health_widget)
        
        # ë©”íŠ¸ë¦­
        metrics_group = QGroupBox("ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­")
        metrics_layout = QVBoxLayout()
        self.metrics_widget = MetricsWidget()
        metrics_layout.addWidget(self.metrics_widget)
        metrics_group.setLayout(metrics_layout)
        layout.addWidget(metrics_group)
        
        # ì•Œë¦¼
        alerts_group = QGroupBox("ìµœê·¼ ì•Œë¦¼")
        alerts_layout = QVBoxLayout()
        self.alert_list = AlertListWidget()
        alerts_layout.addWidget(self.alert_list)
        alerts_group.setLayout(alerts_layout)
        layout.addWidget(alerts_group)
        
        # ì»¨íŠ¸ë¡¤ ë²„íŠ¼
        control_layout = QHBoxLayout()
        
        self.start_btn = QPushButton("ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        self.start_btn.clicked.connect(self.start_monitoring)
        control_layout.addWidget(self.start_btn)
        
        self.stop_btn = QPushButton("ëª¨ë‹ˆí„°ë§ ì¤‘ì§€")
        self.stop_btn.clicked.connect(self.stop_monitoring)
        self.stop_btn.setEnabled(False)
        control_layout.addWidget(self.stop_btn)
        
        self.report_btn = QPushButton("ë¦¬í¬íŠ¸ ë³´ê¸°")
        self.report_btn.clicked.connect(self.show_report)
        control_layout.addWidget(self.report_btn)
        
        control_layout.addStretch()
        layout.addLayout(control_layout)
        
        self.setLayout(layout)
        
    def setup_connections(self):
        """ì‹œê·¸ë„ ì—°ê²°"""
        self.monitor.health_status_changed.connect(self.health_widget.update_status)
        self.monitor.metrics_updated.connect(self.metrics_widget.update_metrics)
        self.monitor.alert_signal.connect(self.alert_list.add_alert)
        
    def start_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        self.monitor.start()
        self.start_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        
    def stop_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.monitor.stop()
        self.start_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        
    def show_report(self):
        """ë¦¬í¬íŠ¸ í‘œì‹œ"""
        report = self.monitor.get_status_report()
        
        # ë¦¬í¬íŠ¸ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
        from PyQt5.QtWidgets import QDialog, QTextEdit, QVBoxLayout
        import json
        
        dialog = QDialog(self)
        dialog.setWindowTitle("ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ë¦¬í¬íŠ¸")
        dialog.resize(600, 400)
        
        layout = QVBoxLayout()
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setPlainText(json.dumps(report, ensure_ascii=False, indent=2))
        layout.addWidget(text_edit)
        
        dialog.setLayout(layout)
        dialog.exec_()
</file>

<file path="src/ui/widgets/sheet_mapper.py">
"""
Sheet and column mapping UI widget
"""

from typing import Dict, List, Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QComboBox, 
    QTableWidget, QTableWidgetItem, QPushButton,
    QLabel, QGroupBox, QHeaderView, QCheckBox,
    QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from excel.models import SheetInfo, ColumnInfo, ColumnMapping, ColumnType

class SheetSelectorWidget(QWidget):
    """Widget for selecting Excel sheet"""
    
    sheetSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.sheets: List[SheetInfo] = []
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        layout.addWidget(QLabel("ì‹œíŠ¸ ì„ íƒ:"))
        
        self.sheet_combo = QComboBox()
        self.sheet_combo.setMinimumWidth(200)
        self.sheet_combo.currentTextChanged.connect(self.sheetSelected.emit)
        layout.addWidget(self.sheet_combo)
        
        self.info_label = QLabel()
        layout.addWidget(self.info_label)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def set_sheets(self, sheets: List[SheetInfo]):
        """Set available sheets"""
        self.sheets = sheets
        self.sheet_combo.clear()
        
        for sheet in sheets:
            display_text = f"{sheet.name} ({sheet.row_count}í–‰ Ã— {sheet.column_count}ì—´)"
            self.sheet_combo.addItem(display_text, sheet.name)
            
        if sheets:
            self.sheetSelected.emit(sheets[0].name)
            
    def get_selected_sheet(self) -> Optional[str]:
        """Get currently selected sheet name"""
        if self.sheet_combo.currentData():
            return self.sheet_combo.currentData()
        return None

class ColumnMappingTable(QTableWidget):
    """Table widget for column mapping"""
    
    mappingChanged = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        self.columns: List[ColumnInfo] = []
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Set headers
        self.setColumnCount(6)
        self.setHorizontalHeaderLabels([
            "ì‚¬ìš©", "ì—‘ì…€ ì—´", "ë³€ìˆ˜ëª…", "ë°ì´í„° íƒ€ì…", "ìƒ˜í”Œ ë°ì´í„°", "í•„ìˆ˜"
        ])
        
        # Configure table
        self.horizontalHeader().setStretchLastSection(False)
        self.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(5, QHeaderView.Fixed)
        
        self.setColumnWidth(0, 50)  # ì‚¬ìš©
        self.setColumnWidth(5, 50)  # í•„ìˆ˜
        
        # Enable sorting
        self.setSortingEnabled(True)
        
    def set_columns(self, columns: List[ColumnInfo]):
        """Set columns for mapping"""
        self.columns = columns
        self.setRowCount(len(columns))
        
        for row, col_info in enumerate(columns):
            # Use checkbox
            use_checkbox = QCheckBox()
            use_checkbox.setChecked(True)
            use_checkbox.stateChanged.connect(self.mappingChanged.emit)
            self.setCellWidget(row, 0, use_checkbox)
            
            # Excel column name
            col_item = QTableWidgetItem(col_info.name)
            col_item.setFlags(col_item.flags() & ~Qt.ItemIsEditable)
            self.setItem(row, 1, col_item)
            
            # Variable name (editable)
            var_name = self._generate_variable_name(col_info.name)
            var_item = QTableWidgetItem(var_name)
            self.setItem(row, 2, var_item)
            
            # Data type
            type_combo = QComboBox()
            type_combo.addItems([t.value for t in ColumnType])
            type_combo.setCurrentText(col_info.data_type.value)
            self.setCellWidget(row, 3, type_combo)
            
            # Sample data
            sample_text = ", ".join(str(v) for v in col_info.sample_values[:3])
            if len(col_info.sample_values) > 3:
                sample_text += "..."
            sample_item = QTableWidgetItem(sample_text)
            sample_item.setFlags(sample_item.flags() & ~Qt.ItemIsEditable)
            sample_item.setToolTip("\n".join(str(v) for v in col_info.sample_values))
            self.setItem(row, 4, sample_item)
            
            # Required checkbox
            required_checkbox = QCheckBox()
            required_checkbox.setChecked(False)
            self.setCellWidget(row, 5, required_checkbox)
            
    def _generate_variable_name(self, column_name: str) -> str:
        """Generate variable name from column name"""
        # Remove special characters and convert to snake_case
        import re
        var_name = re.sub(r'[^\w\s]', '', column_name)
        var_name = var_name.strip().lower().replace(' ', '_')
        
        # Ensure it starts with letter
        if var_name and not var_name[0].isalpha():
            var_name = 'col_' + var_name
            
        return var_name or 'column'
        
    def get_mappings(self) -> List[ColumnMapping]:
        """Get current column mappings"""
        mappings = []
        
        for row in range(self.rowCount()):
            use_checkbox = self.cellWidget(row, 0)
            if not use_checkbox.isChecked():
                continue
                
            excel_col = self.item(row, 1).text()
            var_name = self.item(row, 2).text()
            type_combo = self.cellWidget(row, 3)
            required_checkbox = self.cellWidget(row, 5)
            
            if var_name.strip():  # Only add if variable name is not empty
                mapping = ColumnMapping(
                    excel_column=excel_col,
                    variable_name=var_name.strip(),
                    data_type=ColumnType(type_combo.currentText()),
                    is_required=required_checkbox.isChecked()
                )
                mappings.append(mapping)
                
        return mappings

class SheetMapperWidget(QWidget):
    """Complete sheet and column mapping widget"""
    
    mappingComplete = pyqtSignal(str, list)  # sheet_name, mappings
    
    def __init__(self):
        super().__init__()
        self.current_sheet: Optional[SheetInfo] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Sheet selector
        self.sheet_selector = SheetSelectorWidget()
        self.sheet_selector.sheetSelected.connect(self._on_sheet_selected)
        layout.addWidget(self.sheet_selector)
        
        # Column mapping
        mapping_group = QGroupBox("ì—´ ë§¤í•‘ ì„¤ì •")
        mapping_layout = QVBoxLayout()
        
        # Mapping table
        self.mapping_table = ColumnMappingTable()
        mapping_layout.addWidget(self.mapping_table)
        
        # Auto-detect status column
        auto_layout = QHBoxLayout()
        self.auto_detect_btn = QPushButton("ìƒíƒœ ì—´ ìë™ ê°ì§€")
        self.auto_detect_btn.clicked.connect(self._auto_detect_status)
        auto_layout.addWidget(self.auto_detect_btn)
        
        self.status_label = QLabel()
        auto_layout.addWidget(self.status_label)
        auto_layout.addStretch()
        
        mapping_layout.addLayout(auto_layout)
        mapping_group.setLayout(mapping_layout)
        layout.addWidget(mapping_group)
        
        # Apply button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        self.apply_btn = QPushButton("ë§¤í•‘ ì ìš©")
        self.apply_btn.clicked.connect(self._apply_mapping)
        button_layout.addWidget(self.apply_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def set_file_info(self, sheets: List[SheetInfo]):
        """Set file information"""
        self.sheet_selector.set_sheets(sheets)
        
    def _on_sheet_selected(self, sheet_name: str):
        """Handle sheet selection"""
        # Find sheet info
        for sheet in self.sheet_selector.sheets:
            if sheet.name == sheet_name:
                self.current_sheet = sheet
                self.mapping_table.set_columns(sheet.columns)
                self._auto_detect_status()
                break
                
    def _auto_detect_status(self):
        """Auto-detect status column"""
        if not self.current_sheet:
            return
            
        status_keywords = ['ìƒíƒœ', 'Status', 'ì™„ë£Œ', 'ì²˜ë¦¬', 'status', 'STATUS']
        
        for row in range(self.mapping_table.rowCount()):
            col_name = self.mapping_table.item(row, 1).text()
            
            # Check if column name contains status keywords
            for keyword in status_keywords:
                if keyword in col_name:
                    # Set as status column
                    self.mapping_table.item(row, 2).setText('status')
                    required_checkbox = self.mapping_table.cellWidget(row, 5)
                    required_checkbox.setChecked(True)
                    self.status_label.setText(f"ìƒíƒœ ì—´ ê°ì§€ë¨: {col_name}")
                    return
                    
        self.status_label.setText("ìƒíƒœ ì—´ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ (ìë™ ìƒì„±ë¨)")
        
    def _apply_mapping(self):
        """Apply current mapping"""
        if not self.sheet_selector.get_selected_sheet():
            QMessageBox.warning(self, "ê²½ê³ ", "ì‹œíŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return
            
        mappings = self.mapping_table.get_mappings()
        if not mappings:
            QMessageBox.warning(self, "ê²½ê³ ", "ìµœì†Œ í•˜ë‚˜ ì´ìƒì˜ ì—´ì„ ë§¤í•‘í•´ì£¼ì„¸ìš”.")
            return
            
        # Check for duplicate variable names
        var_names = [m.variable_name for m in mappings]
        if len(var_names) != len(set(var_names)):
            QMessageBox.warning(self, "ê²½ê³ ", "ë³€ìˆ˜ëª…ì´ ì¤‘ë³µë˜ì—ˆìŠµë‹ˆë‹¤.")
            return
            
        self.mappingComplete.emit(
            self.sheet_selector.get_selected_sheet(),
            mappings
        )
</file>

<file path="src/utils/apply_recovery_example.py">
"""
ì˜¤ë¥˜ ë³µêµ¬ ì‹œìŠ¤í…œ ì ìš© ì˜ˆì‹œ
"""

from utils.error_decorator import auto_recover, ErrorContext, file_context, excel_context

# ì˜ˆì‹œ 1: íŒŒì¼ ì‘ì—…ì— ìë™ ë³µêµ¬ ì ìš©
@auto_recover(retry_count=2, context_func=file_context)
def load_macro_file(file_path: str):
    """ë§¤í¬ë¡œ íŒŒì¼ ë¡œë“œ - ì¸ì½”ë”© ì˜¤ë¥˜ ìë™ ë³µêµ¬"""
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)

# ì˜ˆì‹œ 2: ì—‘ì…€ ì‘ì—…ì— ìë™ ë³µêµ¬ ì ìš©
@auto_recover(retry_count=1, context_func=excel_context)
def load_excel_data(excel_manager, sheet_name):
    """ì—‘ì…€ ë°ì´í„° ë¡œë“œ - ê¶Œí•œ/ê²½ë¡œ ì˜¤ë¥˜ ìë™ ë³µêµ¬"""
    return excel_manager.read_sheet(sheet_name)

# ì˜ˆì‹œ 3: UI ì‘ì—…ì— ì˜¤ë¥˜ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©
def create_dialog(parent_window):
    """ë‹¤ì´ì–¼ë¡œê·¸ ìƒì„± - Qt ì˜¤ë¥˜ ìë™ ì²˜ë¦¬"""
    with ErrorContext("ë‹¤ì´ì–¼ë¡œê·¸ ìƒì„±", window=parent_window):
        dialog = SomeDialog(parent_window)
        dialog.show()
        return dialog

# ì˜ˆì‹œ 4: ê¸°ì¡´ í´ë˜ìŠ¤ ë©”ì„œë“œì— ì ìš©
class EnhancedExcelManager:
    @auto_recover(retry_count=2)
    def save_file(self, file_path=None):
        """íŒŒì¼ ì €ì¥ - ê¶Œí•œ/ê²½ë¡œ ì˜¤ë¥˜ ìë™ ë³µêµ¬"""
        # ê¸°ì¡´ save_file ë¡œì§
        pass
        
    @auto_recover(retry_count=1)
    def load_file(self, file_path):
        """íŒŒì¼ ë¡œë“œ - ì¸ì½”ë”© ì˜¤ë¥˜ ìë™ ë³µêµ¬"""
        # ê¸°ì¡´ load_file ë¡œì§
        pass

# ì˜ˆì‹œ 5: ì‹¤í–‰ ì—”ì§„ì— ì ìš©
class EnhancedExecutionEngine:
    @auto_recover(retry_count=3)
    def execute_step(self, step):
        """ë‹¨ê³„ ì‹¤í–‰ - ì¼ì‹œì  ì˜¤ë¥˜ ìë™ ì¬ì‹œë„"""
        # ê¸°ì¡´ execute_step ë¡œì§
        pass
        
# ì‚¬ìš© ë°©ë²•:
# 1. ê¸°ì¡´ í•¨ìˆ˜/ë©”ì„œë“œì— @auto_recover ë°ì½”ë ˆì´í„° ì¶”ê°€
# 2. context_func ë§¤ê°œë³€ìˆ˜ë¡œ ì˜¤ë¥˜ ì»¨í…ìŠ¤íŠ¸ ì œê³µ (ì„ íƒì‚¬í•­)
# 3. retry_countë¡œ ì¬ì‹œë„ íšŸìˆ˜ ì„¤ì •
# 4. ErrorContext ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì‚¬ìš© (ë¸”ë¡ ë‹¨ìœ„ ë³´í˜¸)
</file>

<file path="src/utils/background_monitor.py">
"""
ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì‹œí•˜ê³  ë¬¸ì œë¥¼ ì‚¬ì „ì— ê°ì§€/í•´ê²°
"""

import threading
import time
import psutil
import os
import sys
from pathlib import Path
from typing import Dict, List, Callable, Any, Optional
from datetime import datetime, timedelta
from collections import deque
import json

from PyQt5.QtCore import QObject, pyqtSignal, QTimer
from logger.app_logger import get_logger
from utils.error_recovery import get_recovery_manager
from utils.self_diagnosis import SelfDiagnosis

class MonitoringRule:
    """ëª¨ë‹ˆí„°ë§ ê·œì¹™"""
    def __init__(self, name: str, check_func: Callable, 
                 threshold: Any, action_func: Callable = None,
                 check_interval: int = 30):
        self.name = name
        self.check_func = check_func
        self.threshold = threshold
        self.action_func = action_func
        self.check_interval = check_interval
        self.last_check = datetime.now()
        self.violation_count = 0
        self.last_value = None
        
class SystemMetrics:
    """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
    def __init__(self, history_size: int = 100):
        self.history_size = history_size
        self.cpu_history = deque(maxlen=history_size)
        self.memory_history = deque(maxlen=history_size)
        self.disk_history = deque(maxlen=history_size)
        self.thread_count_history = deque(maxlen=history_size)
        
    def collect(self):
        """í˜„ì¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        metrics = {
            'timestamp': datetime.now().isoformat(),
            'cpu_percent': psutil.cpu_percent(interval=0.1),
            'memory_percent': psutil.virtual_memory().percent,
            'memory_available_mb': psutil.virtual_memory().available / 1024 / 1024,
            'disk_percent': psutil.disk_usage('/').percent,
            'disk_free_gb': psutil.disk_usage('/').free / 1024 / 1024 / 1024,
            'thread_count': threading.active_count(),
            'process_count': len(psutil.pids())
        }
        
        # íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
        self.cpu_history.append(metrics['cpu_percent'])
        self.memory_history.append(metrics['memory_percent'])
        self.disk_history.append(metrics['disk_percent'])
        self.thread_count_history.append(metrics['thread_count'])
        
        return metrics
        
    def get_average(self, metric_name: str, window: int = 10) -> float:
        """ìµœê·¼ Nê°œ ìƒ˜í”Œì˜ í‰ê· """
        history_map = {
            'cpu': self.cpu_history,
            'memory': self.memory_history,
            'disk': self.disk_history,
            'threads': self.thread_count_history
        }
        
        history = history_map.get(metric_name, [])
        if not history:
            return 0
            
        recent = list(history)[-window:]
        return sum(recent) / len(recent) if recent else 0

class BackgroundMonitor(QObject):
    """ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ"""
    
    # ì‹œê·¸ë„
    alert_signal = pyqtSignal(str, str)  # (ê·œì¹™ëª…, ë©”ì‹œì§€)
    metrics_updated = pyqtSignal(dict)   # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
    health_status_changed = pyqtSignal(str)  # ìƒíƒœ ë³€ê²½
    
    def __init__(self):
        super().__init__()
        self.logger = get_logger(__name__)
        self.recovery_manager = get_recovery_manager()
        self.diagnosis = SelfDiagnosis()
        
        self.is_running = False
        self.rules: List[MonitoringRule] = []
        self.metrics = SystemMetrics()
        self.health_status = "ì •ìƒ"
        self.alert_history = deque(maxlen=50)
        
        # ëª¨ë‹ˆí„°ë§ íƒ€ì´ë¨¸
        self.monitor_timer = QTimer()
        self.monitor_timer.timeout.connect(self._run_checks)
        
        # ì´ˆê¸° ê·œì¹™ ì„¤ì •
        self._setup_default_rules()
        
    def _setup_default_rules(self):
        """ê¸°ë³¸ ëª¨ë‹ˆí„°ë§ ê·œì¹™ ì„¤ì •"""
        # CPU ì‚¬ìš©ë¥  ëª¨ë‹ˆí„°ë§
        self.add_rule(
            "high_cpu",
            lambda: self.metrics.get_average('cpu', 5),
            80.0,  # 80% ì´ìƒ
            self._handle_high_cpu,
            check_interval=10
        )
        
        # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ëª¨ë‹ˆí„°ë§
        self.add_rule(
            "high_memory",
            lambda: self.metrics.get_average('memory', 5),
            85.0,  # 85% ì´ìƒ
            self._handle_high_memory,
            check_interval=15
        )
        
        # ë””ìŠ¤í¬ ê³µê°„ ëª¨ë‹ˆí„°ë§
        self.add_rule(
            "low_disk",
            lambda: psutil.disk_usage('/').percent,
            90.0,  # 90% ì´ìƒ ì‚¬ìš©
            self._handle_low_disk,
            check_interval=60
        )
        
        # ìŠ¤ë ˆë“œ ìˆ˜ ëª¨ë‹ˆí„°ë§
        self.add_rule(
            "thread_leak",
            lambda: threading.active_count(),
            100,  # 100ê°œ ì´ìƒ
            self._handle_thread_leak,
            check_interval=30
        )
        
        # ë¡œê·¸ íŒŒì¼ í¬ê¸° ëª¨ë‹ˆí„°ë§
        self.add_rule(
            "log_size",
            self._check_log_size,
            100,  # 100MB ì´ìƒ
            self._handle_large_logs,
            check_interval=300  # 5ë¶„ë§ˆë‹¤
        )
        
        # ì„ì‹œ íŒŒì¼ ëª¨ë‹ˆí„°ë§
        self.add_rule(
            "temp_files",
            self._count_temp_files,
            50,  # 50ê°œ ì´ìƒ
            self._clean_temp_files,
            check_interval=600  # 10ë¶„ë§ˆë‹¤
        )
        
    def add_rule(self, name: str, check_func: Callable, 
                 threshold: Any, action_func: Callable = None,
                 check_interval: int = 30):
        """ëª¨ë‹ˆí„°ë§ ê·œì¹™ ì¶”ê°€"""
        rule = MonitoringRule(name, check_func, threshold, action_func, check_interval)
        self.rules.append(rule)
        self.logger.info(f"ëª¨ë‹ˆí„°ë§ ê·œì¹™ ì¶”ê°€: {name}")
        
    def start(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if self.is_running:
            return
            
        self.is_running = True
        self.logger.info("ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        
        # íƒ€ì´ë¨¸ ì‹œì‘ (5ì´ˆë§ˆë‹¤ ì²´í¬)
        self.monitor_timer.start(5000)
        
        # ì´ˆê¸° ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        self._collect_metrics()
        
    def stop(self):
        """ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.is_running = False
        self.monitor_timer.stop()
        self.logger.info("ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€")
        
        # ìµœì¢… ë¦¬í¬íŠ¸ ì €ì¥
        self._save_report()
        
    def _run_checks(self):
        """ëª¨ë“  ì²´í¬ ì‹¤í–‰"""
        if not self.is_running:
            return
            
        try:
            # ë©”íŠ¸ë¦­ ìˆ˜ì§‘
            current_metrics = self._collect_metrics()
            
            # ê·œì¹™ ê²€ì‚¬
            alerts = []
            for rule in self.rules:
                # ì²´í¬ ê°„ê²© í™•ì¸
                elapsed = (datetime.now() - rule.last_check).total_seconds()
                if elapsed < rule.check_interval:
                    continue
                    
                rule.last_check = datetime.now()
                
                try:
                    # ì²´í¬ ì‹¤í–‰
                    value = rule.check_func()
                    rule.last_value = value
                    
                    # ì„ê³„ê°’ ìœ„ë°˜ ì²´í¬
                    violated = False
                    if isinstance(rule.threshold, (int, float)):
                        violated = value > rule.threshold
                    elif callable(rule.threshold):
                        violated = rule.threshold(value)
                        
                    if violated:
                        rule.violation_count += 1
                        self.logger.warning(f"ê·œì¹™ ìœ„ë°˜: {rule.name} (ê°’: {value}, ì„ê³„ê°’: {rule.threshold})")
                        
                        # ì•¡ì…˜ ì‹¤í–‰
                        if rule.action_func and rule.violation_count >= 3:
                            self.logger.info(f"ë³µêµ¬ ì•¡ì…˜ ì‹¤í–‰: {rule.name}")
                            rule.action_func()
                            rule.violation_count = 0
                            
                        alerts.append((rule.name, f"{rule.name}: {value}"))
                    else:
                        rule.violation_count = 0
                        
                except Exception as e:
                    self.logger.error(f"ê·œì¹™ ì²´í¬ ì‹¤íŒ¨ ({rule.name}): {e}")
                    
            # ìƒíƒœ ì—…ë°ì´íŠ¸
            self._update_health_status(alerts)
            
            # ì‹œê·¸ë„ ë°œì†¡
            self.metrics_updated.emit(current_metrics)
            
            for alert in alerts:
                self.alert_signal.emit(*alert)
                self._add_alert(*alert)
                
        except Exception as e:
            self.logger.error(f"ëª¨ë‹ˆí„°ë§ ì²´í¬ ì¤‘ ì˜¤ë¥˜: {e}")
            
    def _collect_metrics(self) -> dict:
        """ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            return self.metrics.collect()
        except Exception as e:
            self.logger.error(f"ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
            
    def _update_health_status(self, alerts: List[tuple]):
        """ê±´ê°• ìƒíƒœ ì—…ë°ì´íŠ¸"""
        old_status = self.health_status
        
        if not alerts:
            self.health_status = "ì •ìƒ"
        elif len(alerts) < 3:
            self.health_status = "ì£¼ì˜"
        else:
            self.health_status = "ìœ„í—˜"
            
        if old_status != self.health_status:
            self.health_status_changed.emit(self.health_status)
            self.logger.info(f"ì‹œìŠ¤í…œ ìƒíƒœ ë³€ê²½: {old_status} -> {self.health_status}")
            
    def _add_alert(self, rule_name: str, message: str):
        """ì•Œë¦¼ ê¸°ë¡ ì¶”ê°€"""
        alert = {
            'timestamp': datetime.now().isoformat(),
            'rule': rule_name,
            'message': message
        }
        self.alert_history.append(alert)
        
    # ì²´í¬ í•¨ìˆ˜ë“¤
    def _check_log_size(self) -> float:
        """ë¡œê·¸ íŒŒì¼ í¬ê¸° ì²´í¬ (MB)"""
        log_dir = Path.home() / '.excel_macro_automation' / 'logs'
        if not log_dir.exists():
            return 0
            
        total_size = 0
        for log_file in log_dir.glob('*.log*'):
            total_size += log_file.stat().st_size
            
        return total_size / 1024 / 1024  # MB
        
    def _count_temp_files(self) -> int:
        """ì„ì‹œ íŒŒì¼ ê°œìˆ˜"""
        temp_dir = Path(os.environ.get('TEMP', '/tmp'))
        count = 0
        
        try:
            for f in temp_dir.glob('tmp*'):
                if f.is_file():
                    count += 1
        except:
            pass
            
        return count
        
    # ì•¡ì…˜ í•¨ìˆ˜ë“¤
    def _handle_high_cpu(self):
        """ë†’ì€ CPU ì‚¬ìš©ë¥  ì²˜ë¦¬"""
        self.logger.warning("ë†’ì€ CPU ì‚¬ìš©ë¥  ê°ì§€, ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì‹¤í–‰")
        import gc
        gc.collect()
        
    def _handle_high_memory(self):
        """ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì²˜ë¦¬"""
        self.logger.warning("ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ê°ì§€, ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œë„")
        import gc
        gc.collect()
        
        # í° ê°ì²´ ì •ë¦¬
        gc.collect(2)
        
    def _handle_low_disk(self):
        """ë””ìŠ¤í¬ ê³µê°„ ë¶€ì¡± ì²˜ë¦¬"""
        self.logger.warning("ë””ìŠ¤í¬ ê³µê°„ ë¶€ì¡±, ì„ì‹œ íŒŒì¼ ì •ë¦¬")
        self._clean_temp_files()
        self._clean_old_logs()
        
    def _handle_thread_leak(self):
        """ìŠ¤ë ˆë“œ ëˆ„ìˆ˜ ì²˜ë¦¬"""
        self.logger.warning(f"ê³¼ë„í•œ ìŠ¤ë ˆë“œ ê°ì§€: {threading.active_count()}ê°œ")
        # ìŠ¤ë ˆë“œ ëª©ë¡ ë¡œê¹…
        for thread in threading.enumerate():
            self.logger.debug(f"  - {thread.name}: {thread.is_alive()}")
            
    def _handle_large_logs(self):
        """í° ë¡œê·¸ íŒŒì¼ ì²˜ë¦¬"""
        self.logger.info("ë¡œê·¸ íŒŒì¼ ì •ë¦¬ ì‹œì‘")
        self._clean_old_logs()
        
    def _clean_temp_files(self):
        """ì„ì‹œ íŒŒì¼ ì •ë¦¬"""
        temp_dir = Path(os.environ.get('TEMP', '/tmp'))
        cleaned = 0
        
        try:
            for f in temp_dir.glob('tmp*'):
                if f.is_file():
                    try:
                        # 1ì¼ ì´ìƒ ëœ íŒŒì¼ë§Œ ì‚­ì œ
                        age = datetime.now() - datetime.fromtimestamp(f.stat().st_mtime)
                        if age > timedelta(days=1):
                            f.unlink()
                            cleaned += 1
                    except:
                        pass
                        
            self.logger.info(f"ì„ì‹œ íŒŒì¼ {cleaned}ê°œ ì •ë¦¬ë¨")
        except Exception as e:
            self.logger.error(f"ì„ì‹œ íŒŒì¼ ì •ë¦¬ ì‹¤íŒ¨: {e}")
            
    def _clean_old_logs(self):
        """ì˜¤ë˜ëœ ë¡œê·¸ íŒŒì¼ ì •ë¦¬"""
        log_dir = Path.home() / '.excel_macro_automation' / 'logs'
        if not log_dir.exists():
            return
            
        cleaned = 0
        try:
            for log_file in log_dir.glob('*.log.*'):
                try:
                    # 7ì¼ ì´ìƒ ëœ ë¡œê·¸ íŒŒì¼ ì‚­ì œ
                    age = datetime.now() - datetime.fromtimestamp(log_file.stat().st_mtime)
                    if age > timedelta(days=7):
                        log_file.unlink()
                        cleaned += 1
                except:
                    pass
                    
            self.logger.info(f"ì˜¤ë˜ëœ ë¡œê·¸ íŒŒì¼ {cleaned}ê°œ ì •ë¦¬ë¨")
        except Exception as e:
            self.logger.error(f"ë¡œê·¸ ì •ë¦¬ ì‹¤íŒ¨: {e}")
            
    def get_status_report(self) -> dict:
        """í˜„ì¬ ìƒíƒœ ë¦¬í¬íŠ¸"""
        report = {
            'health_status': self.health_status,
            'timestamp': datetime.now().isoformat(),
            'metrics': {
                'cpu_avg': self.metrics.get_average('cpu', 10),
                'memory_avg': self.metrics.get_average('memory', 10),
                'disk_usage': psutil.disk_usage('/').percent,
                'thread_count': threading.active_count()
            },
            'rules': [
                {
                    'name': rule.name,
                    'last_value': rule.last_value,
                    'threshold': rule.threshold,
                    'violations': rule.violation_count
                }
                for rule in self.rules
            ],
            'recent_alerts': list(self.alert_history)[-10:]
        }
        
        return report
        
    def _save_report(self):
        """ë¦¬í¬íŠ¸ ì €ì¥"""
        try:
            report_file = Path.home() / '.excel_macro_automation' / 'monitor_report.json'
            report_file.parent.mkdir(exist_ok=True)
            
            report = self.get_status_report()
            
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(report, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            self.logger.error(f"ë¦¬í¬íŠ¸ ì €ì¥ ì‹¤íŒ¨: {e}")

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
_monitor = None

def get_monitor() -> BackgroundMonitor:
    """ëª¨ë‹ˆí„° ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global _monitor
    if _monitor is None:
        _monitor = BackgroundMonitor()
    return _monitor
</file>

<file path="src/utils/clipboard_utils.py">
"""
Clipboard utilities for cross-platform image handling
"""

import os
import sys
import time
import subprocess
from typing import Optional
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtWidgets import QApplication
from utils.path_utils import get_captures_dir, is_wsl


def save_clipboard_image() -> Optional[str]:
    """
    Try multiple methods to save clipboard image to file
    Returns the saved file path or None if no image found
    """
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    filename = f"clipboard_{timestamp}.png"
    
    # Create captures directory using path utility
    captures_dir = get_captures_dir()
    file_path = os.path.join(captures_dir, filename)
    
    # Method 1: Try Windows PowerShell if in WSL
    if is_wsl():
        if save_from_windows_clipboard(file_path):
            return file_path
    
    # Method 2: Try Qt clipboard
    if save_from_qt_clipboard(file_path):
        return file_path
    
    # Method 3: Try PIL
    if save_from_pil_clipboard(file_path):
        return file_path
    
    return None


def save_from_windows_clipboard(file_path: str) -> bool:
    """
    Use PowerShell to save clipboard image (WSL specific)
    """
    try:
        # Convert WSL path to Windows path
        win_path = subprocess.check_output(['wslpath', '-w', file_path]).decode().strip()
        
        # PowerShell script to save clipboard image
        ps_script = f'''
        Add-Type -Assembly System.Windows.Forms
        $clipboard = [System.Windows.Forms.Clipboard]::GetImage()
        if ($clipboard -ne $null) {{
            $clipboard.Save("{win_path}", [System.Drawing.Imaging.ImageFormat]::Png)
            Write-Host "SUCCESS"
        }} else {{
            Write-Host "NO_IMAGE"
        }}
        '''
        
        # Run PowerShell command
        result = subprocess.run(
            ['powershell.exe', '-Command', ps_script],
            capture_output=True,
            text=True
        )
        
        if "SUCCESS" in result.stdout:
            print("Successfully saved image from Windows clipboard")
            return True
        elif "NO_IMAGE" in result.stdout:
            print("No image in Windows clipboard")
        else:
            print(f"PowerShell error: {result.stderr}")
            
    except Exception as e:
        print(f"Windows clipboard error: {e}")
    
    return False


def save_from_qt_clipboard(file_path: str) -> bool:
    """
    Save image from Qt clipboard
    """
    try:
        clipboard = QApplication.clipboard()
        
        # Try image first
        if clipboard.mimeData().hasImage():
            image = clipboard.image()
            if not image.isNull():
                if image.save(file_path, "PNG"):
                    print("Successfully saved image from Qt clipboard")
                    return True
        
        # Try pixmap
        pixmap = clipboard.pixmap()
        if not pixmap.isNull():
            if pixmap.save(file_path, "PNG"):
                print("Successfully saved pixmap from Qt clipboard")
                return True
                
    except Exception as e:
        print(f"Qt clipboard error: {e}")
    
    return False


def save_from_pil_clipboard(file_path: str) -> bool:
    """
    Save image from PIL clipboard
    """
    try:
        from PIL import ImageGrab
        
        # Try multiple times with delay
        for attempt in range(3):
            if attempt > 0:
                time.sleep(0.1)
                
            img = ImageGrab.grabclipboard()
            if img:
                img.save(file_path)
                print("Successfully saved image from PIL clipboard")
                return True
                
    except Exception as e:
        print(f"PIL clipboard error: {e}")
    
    return False
</file>

<file path="src/utils/encryption.py">
"""
AES-256 encryption utilities for secure storage
"""

import os
from pathlib import Path
from typing import Optional
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
import base64

class EncryptionManager:
    """Handles AES-256 encryption/decryption for configuration and macro files"""
    
    def __init__(self, key_file: Optional[Path] = None):
        """Initialize encryption manager with key"""
        self.key_file = key_file or Path.home() / ".excel_macro_automation" / ".key"
        self.key = self._load_or_generate_key()
    
    def _load_or_generate_key(self) -> bytes:
        """Load existing key or generate new one"""
        if self.key_file.exists():
            return base64.b64decode(self.key_file.read_bytes())
        else:
            # Generate new key
            key = os.urandom(32)  # 256 bits
            self.key_file.parent.mkdir(parents=True, exist_ok=True)
            self.key_file.write_bytes(base64.b64encode(key))
            # Set restrictive permissions (Unix-like systems)
            if hasattr(os, 'chmod'):
                os.chmod(self.key_file, 0o600)
            return key
    
    def derive_key(self, password: str, salt: bytes) -> bytes:
        """Derive key from password using PBKDF2"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        return kdf.derive(password.encode())
    
    def encrypt(self, data: bytes, password: Optional[str] = None) -> bytes:
        """Encrypt data using AES-256-CBC"""
        # Use password-derived key if provided, otherwise use stored key
        if password:
            salt = os.urandom(16)
            key = self.derive_key(password, salt)
        else:
            salt = b''
            key = self.key
        
        # Generate IV
        iv = os.urandom(16)
        
        # Pad data to block size
        padder = padding.PKCS7(128).padder()
        padded_data = padder.update(data) + padder.finalize()
        
        # Encrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        
        # Return salt + iv + encrypted data
        return salt + iv + encrypted_data
    
    def decrypt(self, encrypted_data: bytes, password: Optional[str] = None) -> bytes:
        """Decrypt data using AES-256-CBC"""
        # Extract components
        if password:
            salt = encrypted_data[:16]
            iv = encrypted_data[16:32]
            ciphertext = encrypted_data[32:]
            key = self.derive_key(password, salt)
        else:
            iv = encrypted_data[:16]
            ciphertext = encrypted_data[16:]
            key = self.key
        
        # Decrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(ciphertext) + decryptor.finalize()
        
        # Remove padding
        unpadder = padding.PKCS7(128).unpadder()
        data = unpadder.update(padded_data) + unpadder.finalize()
        
        return data
    
    def encrypt_file(self, input_path: Path, output_path: Path, password: Optional[str] = None) -> None:
        """Encrypt a file"""
        data = input_path.read_bytes()
        encrypted_data = self.encrypt(data, password)
        output_path.write_bytes(encrypted_data)
    
    def decrypt_file(self, input_path: Path, output_path: Path, password: Optional[str] = None) -> None:
        """Decrypt a file"""
        encrypted_data = input_path.read_bytes()
        data = self.decrypt(encrypted_data, password)
        output_path.write_bytes(data)


# Global encryption manager instance
_encryption_manager = None


def get_encryption_manager() -> EncryptionManager:
    """Get global encryption manager instance"""
    global _encryption_manager
    if _encryption_manager is None:
        _encryption_manager = EncryptionManager()
    return _encryption_manager


def encrypt_data(data: str, password: str) -> bytes:
    """Encrypt string data with password"""
    manager = get_encryption_manager()
    return manager.encrypt(data.encode('utf-8'), password)


def decrypt_data(encrypted_data: bytes, password: str) -> str:
    """Decrypt data with password and return as string"""
    manager = get_encryption_manager()
    decrypted_bytes = manager.decrypt(encrypted_data, password)
    return decrypted_bytes.decode('utf-8')
</file>

<file path="src/utils/error_decorator.py">
"""
ì˜¤ë¥˜ ìë™ ë³µêµ¬ ë°ì½”ë ˆì´í„°
"""

import functools
import traceback
from typing import Any, Callable, Optional
from logger.app_logger import get_logger
from utils.error_recovery import get_recovery_manager

logger = get_logger(__name__)

def auto_recover(retry_count: int = 1, context_func: Optional[Callable] = None):
    """
    ì˜¤ë¥˜ ìë™ ë³µêµ¬ ë°ì½”ë ˆì´í„°
    
    Args:
        retry_count: ì¬ì‹œë„ íšŸìˆ˜
        context_func: ì»¨í…ìŠ¤íŠ¸ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” í•¨ìˆ˜
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            last_error = None
            recovery_manager = get_recovery_manager()
            
            for attempt in range(retry_count + 1):
                try:
                    return func(*args, **kwargs)
                    
                except Exception as e:
                    last_error = e
                    logger.error(f"{func.__name__} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ (ì‹œë„ {attempt + 1}/{retry_count + 1}): {e}")
                    
                    if attempt < retry_count:
                        # ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
                        context = {}
                        if context_func:
                            try:
                                context = context_func(*args, **kwargs)
                            except:
                                pass
                                
                        # ìë™ ë³µêµ¬ ì‹œë„
                        if recovery_manager.try_recover(e, context):
                            logger.info(f"ì˜¤ë¥˜ ë³µêµ¬ ì„±ê³µ, ì¬ì‹œë„í•©ë‹ˆë‹¤...")
                            continue
                            
                    # ë³µêµ¬ ì‹¤íŒ¨ ë˜ëŠ” ë§ˆì§€ë§‰ ì‹œë„
                    if attempt == retry_count:
                        logger.error(f"{func.__name__} ìµœì¢… ì‹¤íŒ¨: {e}")
                        logger.error(traceback.format_exc())
                        
            raise last_error
            
        return wrapper
    return decorator

def safe_execute(func: Callable, *args, **kwargs) -> tuple[bool, Any]:
    """
    ì•ˆì „í•œ í•¨ìˆ˜ ì‹¤í–‰
    
    Returns:
        (ì„±ê³µì—¬ë¶€, ê²°ê³¼ê°’ ë˜ëŠ” ì˜¤ë¥˜)
    """
    recovery_manager = get_recovery_manager()
    
    try:
        result = func(*args, **kwargs)
        return True, result
        
    except Exception as e:
        logger.error(f"ì•ˆì „ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
        
        # ë³µêµ¬ ì‹œë„
        if recovery_manager.try_recover(e):
            try:
                # ë³µêµ¬ í›„ ì¬ì‹œë„
                result = func(*args, **kwargs)
                return True, result
            except Exception as retry_error:
                logger.error(f"ì¬ì‹œë„ ì‹¤íŒ¨: {retry_error}")
                return False, retry_error
                
        return False, e

class ErrorContext:
    """ì˜¤ë¥˜ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì"""
    
    def __init__(self, operation_name: str, **context):
        self.operation_name = operation_name
        self.context = context
        self.recovery_manager = get_recovery_manager()
        
    def __enter__(self):
        logger.debug(f"{self.operation_name} ì‹œì‘")
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            logger.error(f"{self.operation_name} ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {exc_val}")
            
            # ë³µêµ¬ ì‹œë„
            if self.recovery_manager.try_recover(exc_val, self.context):
                logger.info(f"{self.operation_name} ì˜¤ë¥˜ ë³µêµ¬ ì„±ê³µ")
                return True  # ì˜ˆì™¸ ì „íŒŒ ë°©ì§€
                
        return False  # ì˜ˆì™¸ ì „íŒŒ

# ìì£¼ ì‚¬ìš©ë˜ëŠ” ì»¨í…ìŠ¤íŠ¸ í•¨ìˆ˜ë“¤
def file_context(*args, **kwargs) -> dict:
    """íŒŒì¼ ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸"""
    context = {}
    
    # ì²« ë²ˆì§¸ ì¸ìê°€ íŒŒì¼ ê²½ë¡œì¸ ê²½ìš°ê°€ ë§ìŒ
    if args and isinstance(args[0], str):
        context['file_path'] = args[0]
        
    # kwargsì—ì„œ íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
    for key in ['file_path', 'path', 'filename']:
        if key in kwargs:
            context['file_path'] = kwargs[key]
            break
            
    return context

def excel_context(*args, **kwargs) -> dict:
    """ì—‘ì…€ ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸"""
    context = file_context(*args, **kwargs)
    
    # ExcelManager ì¸ìŠ¤í„´ìŠ¤ ì°¾ê¸°
    if args and hasattr(args[0], 'file_path'):
        context['excel_file'] = getattr(args[0], 'file_path', None)
        
    return context

def ui_context(*args, **kwargs) -> dict:
    """UI ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸"""
    context = {}
    
    # QWidget ì¸ìŠ¤í„´ìŠ¤ ì°¾ê¸°
    if args:
        for arg in args:
            if hasattr(arg, 'windowTitle'):
                context['window'] = arg
                context['window_title'] = arg.windowTitle()
                break
                
    return context
</file>

<file path="src/utils/error_recovery.py">
"""
Windows í™˜ê²½ ìë™ ì˜¤ë¥˜ ë³µêµ¬ ì‹œìŠ¤í…œ
"""

import sys
import os
import traceback
import json
from typing import Dict, Any, Optional, Callable, List
from pathlib import Path
import subprocess
import chardet
import locale
from datetime import datetime
from logger.app_logger import get_logger

class ErrorPattern:
    """ì˜¤ë¥˜ íŒ¨í„´ ì •ì˜"""
    def __init__(self, name: str, patterns: List[str], 
                 recovery_func: Callable, priority: int = 0):
        self.name = name
        self.patterns = patterns
        self.recovery_func = recovery_func
        self.priority = priority
        self.success_count = 0
        self.fail_count = 0

class AutoErrorRecovery:
    """ìë™ ì˜¤ë¥˜ ë³µêµ¬ ë§¤ë‹ˆì €"""
    
    def __init__(self):
        self.logger = get_logger(__name__)
        self.error_patterns: List[ErrorPattern] = []
        self.recovery_history = []
        self.max_history = 100
        self._init_error_patterns()
        
    def _init_error_patterns(self):
        """ì˜¤ë¥˜ íŒ¨í„´ ì´ˆê¸°í™”"""
        # ì¸ì½”ë”© ì˜¤ë¥˜
        self.register_pattern(
            "encoding_error",
            ["UnicodeDecodeError", "UnicodeEncodeError", "codec can't decode"],
            self._fix_encoding_error,
            priority=10
        )
        
        # ì„í¬íŠ¸ ì˜¤ë¥˜
        self.register_pattern(
            "import_error",
            ["ImportError", "ModuleNotFoundError", "No module named"],
            self._fix_import_error,
            priority=9
        )
        
        # íŒŒì¼ ê²½ë¡œ ì˜¤ë¥˜
        self.register_pattern(
            "path_error",
            ["FileNotFoundError", "WindowsError", "cannot find the path"],
            self._fix_path_error,
            priority=8
        )
        
        # ê¶Œí•œ ì˜¤ë¥˜
        self.register_pattern(
            "permission_error",
            ["PermissionError", "Access is denied", "Permission denied"],
            self._fix_permission_error,
            priority=7
        )
        
        # Qt ê´€ë ¨ ì˜¤ë¥˜
        self.register_pattern(
            "qt_error",
            ["QPixmap", "QTimer", "AttributeError.*Qt", "Qt platform"],
            self._fix_qt_error,
            priority=6
        )
        
        # ë©”ëª¨ë¦¬/ë¦¬ì†ŒìŠ¤ ì˜¤ë¥˜
        self.register_pattern(
            "resource_error",
            ["MemoryError", "OSError.*resources", "Too many open files"],
            self._fix_resource_error,
            priority=5
        )
        
        # Excel ì €ì¥ ê´€ë ¨ ì˜¤ë¥˜
        self.register_pattern(
            "excel_save_error",
            ["No data to save", "ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤", "ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤"],
            self._fix_excel_save_error,
            priority=4
        )
        
    def register_pattern(self, name: str, patterns: List[str], 
                        recovery_func: Callable, priority: int = 0):
        """ì˜¤ë¥˜ íŒ¨í„´ ë“±ë¡"""
        pattern = ErrorPattern(name, patterns, recovery_func, priority)
        self.error_patterns.append(pattern)
        self.error_patterns.sort(key=lambda x: x.priority, reverse=True)
        
    def analyze_error(self, error: Exception, tb_str: str = None) -> Optional[ErrorPattern]:
        """ì˜¤ë¥˜ ë¶„ì„ ë° íŒ¨í„´ ë§¤ì¹­"""
        error_str = str(error)
        error_type = type(error).__name__
        
        if tb_str is None:
            tb_str = traceback.format_exc()
            
        full_error = f"{error_type}: {error_str}\n{tb_str}"
        
        # íŒ¨í„´ ë§¤ì¹­
        for pattern in self.error_patterns:
            for p in pattern.patterns:
                if p in full_error or p in error_type:
                    self.logger.info(f"ì˜¤ë¥˜ íŒ¨í„´ ê°ì§€: {pattern.name}")
                    return pattern
                    
        return None
        
    def try_recover(self, error: Exception, context: Dict[str, Any] = None) -> bool:
        """ì˜¤ë¥˜ ë³µêµ¬ ì‹œë„"""
        try:
            tb_str = traceback.format_exc()
            pattern = self.analyze_error(error, tb_str)
            
            if not pattern:
                self.logger.warning(f"ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜: {error}")
                return False
                
            self.logger.info(f"ë³µêµ¬ ì‹œë„: {pattern.name}")
            
            # ë³µêµ¬ í•¨ìˆ˜ ì‹¤í–‰
            success = pattern.recovery_func(error, context or {})
            
            # ê¸°ë¡ ì €ì¥
            self._save_recovery_history(pattern.name, error, success)
            
            if success:
                pattern.success_count += 1
                self.logger.info(f"ë³µêµ¬ ì„±ê³µ: {pattern.name}")
            else:
                pattern.fail_count += 1
                self.logger.error(f"ë³µêµ¬ ì‹¤íŒ¨: {pattern.name}")
                
            return success
            
        except Exception as e:
            self.logger.error(f"ë³µêµ¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return False
            
    def _fix_encoding_error(self, error: Exception, context: Dict) -> bool:
        """ì¸ì½”ë”© ì˜¤ë¥˜ ìˆ˜ì •"""
        try:
            # Windows ê¸°ë³¸ ì¸ì½”ë”© ì„¤ì •
            if sys.platform == 'win32':
                # UTF-8 ëª¨ë“œ í™œì„±í™”
                os.environ['PYTHONUTF8'] = '1'
                
                # ë¡œì¼€ì¼ ì„¤ì •
                try:
                    locale.setlocale(locale.LC_ALL, 'Korean_Korea.utf8')
                except:
                    locale.setlocale(locale.LC_ALL, 'Korean_Korea.949')
                    
            # íŒŒì¼ ì¸ì½”ë”© ê°ì§€ ë° ë³€í™˜
            if 'file_path' in context:
                file_path = context['file_path']
                if os.path.exists(file_path):
                    # ì¸ì½”ë”© ê°ì§€
                    with open(file_path, 'rb') as f:
                        raw_data = f.read()
                        result = chardet.detect(raw_data)
                        encoding = result['encoding']
                        
                    self.logger.info(f"ê°ì§€ëœ ì¸ì½”ë”©: {encoding}")
                    
                    # UTF-8ë¡œ ë³€í™˜
                    if encoding and encoding.lower() != 'utf-8':
                        text = raw_data.decode(encoding, errors='replace')
                        with open(file_path, 'w', encoding='utf-8') as f:
                            f.write(text)
                        self.logger.info(f"íŒŒì¼ì„ UTF-8ë¡œ ë³€í™˜: {file_path}")
                        
            return True
            
        except Exception as e:
            self.logger.error(f"ì¸ì½”ë”© ìˆ˜ì • ì‹¤íŒ¨: {e}")
            return False
            
    def _fix_import_error(self, error: Exception, context: Dict) -> bool:
        """ì„í¬íŠ¸ ì˜¤ë¥˜ ìˆ˜ì •"""
        try:
            error_msg = str(error)
            
            # ëª¨ë“ˆëª… ì¶”ì¶œ
            if "No module named" in error_msg:
                module_name = error_msg.split("'")[1].split('.')[0]
                
                # ì•Œë ¤ì§„ ëª¨ë“ˆ ë§¤í•‘
                module_map = {
                    'cv2': 'opencv-python',
                    'PIL': 'Pillow',
                    'sklearn': 'scikit-learn',
                    'easyocr': 'easyocr',
                    'pynput': 'pynput',
                    'mss': 'mss',
                    'chardet': 'chardet'
                }
                
                install_name = module_map.get(module_name, module_name)
                
                # pip ì„¤ì¹˜ ì‹œë„
                self.logger.info(f"ëª¨ë“ˆ ì„¤ì¹˜ ì‹œë„: {install_name}")
                result = subprocess.run(
                    [sys.executable, '-m', 'pip', 'install', install_name],
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    self.logger.info(f"ëª¨ë“ˆ ì„¤ì¹˜ ì„±ê³µ: {install_name}")
                    return True
                else:
                    self.logger.error(f"ëª¨ë“ˆ ì„¤ì¹˜ ì‹¤íŒ¨: {result.stderr}")
                    
            return False
            
        except Exception as e:
            self.logger.error(f"ì„í¬íŠ¸ ìˆ˜ì • ì‹¤íŒ¨: {e}")
            return False
            
    def _fix_path_error(self, error: Exception, context: Dict) -> bool:
        """ê²½ë¡œ ì˜¤ë¥˜ ìˆ˜ì •"""
        try:
            # Windows ê²½ë¡œ ì •ê·œí™”
            if 'file_path' in context:
                file_path = context['file_path']
                
                # ê²½ë¡œ ì •ê·œí™”
                normalized = os.path.normpath(file_path)
                normalized = normalized.replace('/', '\\') if sys.platform == 'win32' else normalized
                
                # ë””ë ‰í† ë¦¬ ìƒì„±
                dir_path = os.path.dirname(normalized)
                if dir_path and not os.path.exists(dir_path):
                    os.makedirs(dir_path, exist_ok=True)
                    self.logger.info(f"ë””ë ‰í† ë¦¬ ìƒì„±: {dir_path}")
                    
                context['file_path'] = normalized
                return True
                
            return False
            
        except Exception as e:
            self.logger.error(f"ê²½ë¡œ ìˆ˜ì • ì‹¤íŒ¨: {e}")
            return False
            
    def _fix_permission_error(self, error: Exception, context: Dict) -> bool:
        """ê¶Œí•œ ì˜¤ë¥˜ ìˆ˜ì •"""
        try:
            if sys.platform == 'win32':
                # ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
                import ctypes
                is_admin = ctypes.windll.shell32.IsUserAnAdmin()
                
                if not is_admin:
                    self.logger.warning("ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤")
                    # ê¶Œí•œ ìƒìŠ¹ ìš”ì²­ì€ ì‚¬ìš©ì ìƒí˜¸ì‘ìš©ì´ í•„ìš”í•˜ë¯€ë¡œ False ë°˜í™˜
                    return False
                    
            return False
            
        except Exception as e:
            self.logger.error(f"ê¶Œí•œ ìˆ˜ì • ì‹¤íŒ¨: {e}")
            return False
            
    def _fix_qt_error(self, error: Exception, context: Dict) -> bool:
        """Qt ê´€ë ¨ ì˜¤ë¥˜ ìˆ˜ì •"""
        try:
            error_str = str(error)
            
            # QTimer ì˜¤ë¥˜
            if "QTimer" in error_str and "currentTime" in error_str:
                self.logger.info("QTimer.currentTime() -> QTime.currentTime() ì˜¤ë¥˜ ê°ì§€")
                # ì´ë¯¸ ì½”ë“œì—ì„œ ìˆ˜ì •í–ˆìœ¼ë¯€ë¡œ ì¬ì‹œì‘ ê¶Œì¥
                return False
                
            # QPixmap null ì˜¤ë¥˜
            if "QPixmap" in error_str and "null pixmap" in error_str:
                self.logger.info("Null pixmap ì˜¤ë¥˜ ê°ì§€")
                # ì´ë¯¸ì§€ íŒŒì¼ í™•ì¸ í•„ìš”
                return False
                
            # Qt í”Œë«í¼ ì˜¤ë¥˜
            if "qt.qpa.plugin" in error_str:
                os.environ['QT_QPA_PLATFORM'] = 'windows' if sys.platform == 'win32' else 'xcb'
                self.logger.info("Qt í”Œë«í¼ ì„¤ì • ì™„ë£Œ")
                return True
                
            return False
            
        except Exception as e:
            self.logger.error(f"Qt ì˜¤ë¥˜ ìˆ˜ì • ì‹¤íŒ¨: {e}")
            return False
            
    def _fix_resource_error(self, error: Exception, context: Dict) -> bool:
        """ë¦¬ì†ŒìŠ¤ ì˜¤ë¥˜ ìˆ˜ì •"""
        try:
            # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
            import gc
            gc.collect()
            
            # Windows ë¦¬ì†ŒìŠ¤ ì •ë¦¬
            if sys.platform == 'win32':
                # ì„ì‹œ íŒŒì¼ ì •ë¦¬
                temp_dir = Path(os.environ.get('TEMP', '/tmp'))
                for f in temp_dir.glob('tmp*'):
                    try:
                        if f.is_file() and (datetime.now() - datetime.fromtimestamp(f.stat().st_mtime)).days > 1:
                            f.unlink()
                    except:
                        pass
                        
            self.logger.info("ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ")
            return True
            
        except Exception as e:
            self.logger.error(f"ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹¤íŒ¨: {e}")
            return False
    
    def _fix_excel_save_error(self, error: Exception, context: Dict) -> bool:
        """Excel ì €ì¥ ì˜¤ë¥˜ ìˆ˜ì •"""
        try:
            self.logger.info("Excel ì €ì¥ ì˜¤ë¥˜ ê°ì§€ - Excel ë°ì´í„° ì—†ì´ ì‹¤í–‰ ì¤‘")
            
            # ì´ ì˜¤ë¥˜ëŠ” ì •ìƒì ì¸ ìƒí™© (Excel ì—†ì´ ì‹¤í–‰)ì´ë¯€ë¡œ ë¬´ì‹œ
            # í–¥í›„ engine.pyì—ì„œ ì´ë¯¸ ìˆ˜ì •í–ˆìœ¼ë¯€ë¡œ ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨
            
            # ì»¨í…ìŠ¤íŠ¸ì— excel_managerê°€ ìˆìœ¼ë©´ ìƒíƒœ í™•ì¸
            if 'excel_manager' in context:
                excel_mgr = context['excel_manager']
                if hasattr(excel_mgr, '_current_data') and excel_mgr._current_data is None:
                    self.logger.info("Excel ë°ì´í„° ì—†ìŒ í™•ì¸ - ì •ìƒ ë™ì‘")
                    return True
                    
            # ì˜¤ë¥˜ ë©”ì‹œì§€ í™•ì¸
            if "No data to save" in str(error):
                self.logger.info("Excel ì—†ì´ ë§¤í¬ë¡œ ì‹¤í–‰ ì¤‘ - ì €ì¥ ê±´ë„ˆëœ€")
                return True
                
            return False
            
        except Exception as e:
            self.logger.error(f"Excel ì €ì¥ ì˜¤ë¥˜ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
            return False
            
    def _save_recovery_history(self, pattern_name: str, error: Exception, success: bool):
        """ë³µêµ¬ ê¸°ë¡ ì €ì¥"""
        record = {
            'timestamp': datetime.now().isoformat(),
            'pattern': pattern_name,
            'error_type': type(error).__name__,
            'error_msg': str(error),
            'success': success
        }
        
        self.recovery_history.append(record)
        
        # ìµœëŒ€ ê¸°ë¡ ìˆ˜ ìœ ì§€
        if len(self.recovery_history) > self.max_history:
            self.recovery_history = self.recovery_history[-self.max_history:]
            
        # íŒŒì¼ë¡œ ì €ì¥
        try:
            history_file = Path.home() / '.excel_macro_automation' / 'error_recovery_history.json'
            history_file.parent.mkdir(exist_ok=True)
            
            with open(history_file, 'w', encoding='utf-8') as f:
                json.dump(self.recovery_history, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            self.logger.error(f"ë³µêµ¬ ê¸°ë¡ ì €ì¥ ì‹¤íŒ¨: {e}")
            
    def get_statistics(self) -> Dict[str, Any]:
        """ë³µêµ¬ í†µê³„ ë°˜í™˜"""
        stats = {
            'patterns': [],
            'total_recoveries': len(self.recovery_history),
            'success_rate': 0
        }
        
        success_count = sum(1 for r in self.recovery_history if r['success'])
        if self.recovery_history:
            stats['success_rate'] = success_count / len(self.recovery_history) * 100
            
        for pattern in self.error_patterns:
            stats['patterns'].append({
                'name': pattern.name,
                'success': pattern.success_count,
                'fail': pattern.fail_count,
                'rate': pattern.success_count / (pattern.success_count + pattern.fail_count) * 100 
                        if (pattern.success_count + pattern.fail_count) > 0 else 0
            })
            
        return stats

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
_recovery_manager = None

def get_recovery_manager() -> AutoErrorRecovery:
    """ë³µêµ¬ ë§¤ë‹ˆì € ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global _recovery_manager
    if _recovery_manager is None:
        _recovery_manager = AutoErrorRecovery()
    return _recovery_manager
</file>

<file path="src/utils/error_report_generator.py">
"""
ì˜¤ë¥˜ ìˆ˜ì§‘ ë° ê¸°ë¡ ì‹œìŠ¤í…œ
"""

import json
import os
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import traceback
import sys
from collections import Counter

from logger.app_logger import get_logger

class ErrorCollector:
    """ì˜¤ë¥˜ ìˆ˜ì§‘ ë° ê¸°ë¡"""
    
    def __init__(self):
        self.logger = get_logger(__name__)
        self.error_dir = Path.home() / '.excel_macro_automation' / 'collected_errors'
        self.error_dir.mkdir(parents=True, exist_ok=True)
    
    def collect_errors(self, days: int = 7) -> List[Dict[str, Any]]:
        """ì˜¤ë¥˜ ìˆ˜ì§‘ ë©”ì¸ ë©”ì„œë“œ"""
        errors = self._collect_recent_errors(days)
        self._save_collected_errors(errors, days)
        return errors
    
    def _collect_recent_errors(self, days: int) -> List[Dict[str, Any]]:
        """ìµœê·¼ ì˜¤ë¥˜ ìˆ˜ì§‘"""
        errors = []
        cutoff_date = datetime.now() - timedelta(days=days)
        
        # 1. ì˜¤ë¥˜ ë³µêµ¬ íˆìŠ¤í† ë¦¬ì—ì„œ ìˆ˜ì§‘
        recovery_history = self._load_recovery_history()
        for record in recovery_history:
            try:
                timestamp = datetime.fromisoformat(record['timestamp'])
                if timestamp > cutoff_date and not record.get('success', True):
                    errors.append({
                        'timestamp': timestamp,
                        'type': record.get('error_type', 'Unknown'),
                        'message': record.get('error_msg', ''),
                        'source': 'recovery_system',
                        'pattern': record.get('pattern', ''),
                        'context': {}
                    })
            except:
                pass
        
        # 2. ì‹¤í–‰ ë¡œê·¸ì—ì„œ ìˆ˜ì§‘
        execution_errors = self._collect_from_execution_logs(cutoff_date)
        errors.extend(execution_errors)
        
        # 3. ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸ì—ì„œ ìˆ˜ì§‘
        app_errors = self._collect_from_app_logs(cutoff_date)
        errors.extend(app_errors)
        
        # ì‹œê°„ìˆœ ì •ë ¬
        errors.sort(key=lambda x: x['timestamp'], reverse=True)
        
        return errors
    
    def _load_recovery_history(self) -> List[Dict]:
        """ë³µêµ¬ íˆìŠ¤í† ë¦¬ ë¡œë“œ"""
        history_file = Path.home() / '.excel_macro_automation' / 'error_recovery_history.json'
        if history_file.exists():
            try:
                with open(history_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                pass
        return []
    
    def _collect_from_execution_logs(self, cutoff_date: datetime) -> List[Dict]:
        """ì‹¤í–‰ ë¡œê·¸ì—ì„œ ì˜¤ë¥˜ ìˆ˜ì§‘"""
        errors = []
        log_dir = Path.home() / '.excel_macro_automation' / 'execution_logs'
        
        if log_dir.exists():
            for log_file in log_dir.glob('*.csv'):
                try:
                    # CSV íŒŒì¼ì—ì„œ ì˜¤ë¥˜ ì°¾ê¸°
                    import csv
                    with open(log_file, 'r', encoding='utf-8') as f:
                        reader = csv.DictReader(f)
                        for row in reader:
                            if row.get('status') == 'FAILED':
                                timestamp = datetime.fromisoformat(row.get('timestamp', ''))
                                if timestamp > cutoff_date:
                                    errors.append({
                                        'timestamp': timestamp,
                                        'type': 'ExecutionError',
                                        'message': row.get('error', ''),
                                        'source': 'execution_log',
                                        'context': {
                                            'step': row.get('step_name', ''),
                                            'row': row.get('row_index', '')
                                        }
                                    })
                except:
                    pass
                    
        return errors
    
    def _collect_from_app_logs(self, cutoff_date: datetime) -> List[Dict]:
        """ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸ì—ì„œ ì˜¤ë¥˜ ìˆ˜ì§‘"""
        errors = []
        log_dir = Path.home() / '.excel_macro_automation' / 'logs'
        
        if log_dir.exists():
            for log_file in log_dir.glob('*.log'):
                try:
                    with open(log_file, 'r', encoding='utf-8') as f:
                        for line in f:
                            if 'ERROR' in line:
                                # ë¡œê·¸ ë¼ì¸ íŒŒì‹±
                                parts = line.split(' - ', 2)
                                if len(parts) >= 3:
                                    try:
                                        timestamp = datetime.strptime(parts[0], '%Y-%m-%d %H:%M:%S,%f')
                                        if timestamp > cutoff_date:
                                            errors.append({
                                                'timestamp': timestamp,
                                                'type': 'ApplicationError',
                                                'message': parts[2].strip(),
                                                'source': 'app_log',
                                                'context': {}
                                            })
                                    except:
                                        pass
                except:
                    pass
                    
        return errors
    
    def _save_collected_errors(self, errors: List[Dict[str, Any]], days: int = 7):
        """ìˆ˜ì§‘ëœ ì˜¤ë¥˜ë¥¼ íŒŒì¼ë¡œ ì €ì¥"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        error_file = self.error_dir / f'errors_{timestamp}.json'
        
        # ë‚ ì§œ ê°ì²´ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
        serializable_errors = []
        for error in errors:
            error_copy = error.copy()
            if isinstance(error_copy.get('timestamp'), datetime):
                error_copy['timestamp'] = error_copy['timestamp'].isoformat()
            serializable_errors.append(error_copy)
        
        with open(error_file, 'w', encoding='utf-8') as f:
            json.dump(serializable_errors, f, ensure_ascii=False, indent=2)
            
        self.logger.info(f"ì˜¤ë¥˜ {len(errors)}ê°œë¥¼ {error_file}ì— ì €ì¥")
        
        # ìµœì‹  ì˜¤ë¥˜ íŒŒì¼ ë§í¬ ìƒì„±
        latest_link = self.error_dir / 'latest_errors.json'
        if latest_link.exists():
            latest_link.unlink()
        
        with open(latest_link, 'w', encoding='utf-8') as f:
            json.dump({
                'file': error_file.name,
                'timestamp': timestamp,
                'count': len(errors),
                'days_collected': days
            }, f, ensure_ascii=False, indent=2)
    
    def get_error_summary(self) -> Dict[str, Any]:
        """ì˜¤ë¥˜ ìš”ì•½ í†µê³„ ë°˜í™˜"""
        errors = self.collect_errors(7)  # ìµœê·¼ 7ì¼
        
        summary = {
            'total_errors': len(errors),
            'error_types': {},
            'sources': {},
            'recent_errors': []
        }
        
        # ìœ í˜•ë³„ ì§‘ê³„
        for error in errors:
            error_type = error.get('type', 'Unknown')
            summary['error_types'][error_type] = summary['error_types'].get(error_type, 0) + 1
            
            source = error.get('source', 'unknown')
            summary['sources'][source] = summary['sources'].get(source, 0) + 1
        
        # ìµœê·¼ 5ê°œ ì˜¤ë¥˜
        summary['recent_errors'] = errors[:5]
        
        return summary
    
    def get_latest_errors(self, count: int = 10) -> List[Dict[str, Any]]:
        """ìµœì‹  ì˜¤ë¥˜ íŒŒì¼ì—ì„œ ì§€ì •ëœ ê°œìˆ˜ë§Œí¼ ì˜¤ë¥˜ ë°˜í™˜"""
        latest_link = self.error_dir / 'latest_errors.json'
        
        if latest_link.exists():
            try:
                with open(latest_link, 'r', encoding='utf-8') as f:
                    link_info = json.load(f)
                    
                error_file = self.error_dir / link_info['file']
                if error_file.exists():
                    with open(error_file, 'r', encoding='utf-8') as f:
                        errors = json.load(f)
                        return errors[:count]
            except:
                pass
                
        return []
    
    def clear_old_errors(self, days: int = 30):
        """ì˜¤ë˜ëœ ì˜¤ë¥˜ íŒŒì¼ ì •ë¦¬"""
        cutoff_date = datetime.now() - timedelta(days=days)
        cleaned = 0
        
        for error_file in self.error_dir.glob('errors_*.json'):
            try:
                # íŒŒì¼ëª…ì—ì„œ ë‚ ì§œ ì¶”ì¶œ
                date_str = error_file.stem.split('_')[1]
                file_date = datetime.strptime(date_str[:8], '%Y%m%d')
                
                if file_date < cutoff_date:
                    error_file.unlink()
                    cleaned += 1
            except:
                pass
                
        if cleaned > 0:
            self.logger.info(f"{cleaned}ê°œì˜ ì˜¤ë˜ëœ ì˜¤ë¥˜ íŒŒì¼ ì •ë¦¬")

# ì‚¬ìš© ì˜ˆì‹œ í•¨ìˆ˜
def collect_and_save_errors(days: int = 7) -> int:
    """ì˜¤ë¥˜ ìˆ˜ì§‘ ë° ì €ì¥ í—¬í¼ í•¨ìˆ˜"""
    collector = ErrorCollector()
    errors = collector.collect_errors(days)
    return len(errors)

def get_recent_error_summary() -> Dict[str, Any]:
    """ìµœê·¼ ì˜¤ë¥˜ ìš”ì•½ ë°˜í™˜"""
    collector = ErrorCollector()
    return collector.get_error_summary()
</file>

<file path="src/utils/macro_loader.py">
"""
Safe macro loading utilities for Windows environment
"""

import json
import os
from pathlib import Path
from typing import Optional, Dict, Any
import chardet
from core.macro_types import Macro, StepFactory, StepType
from logger.app_logger import get_logger

logger = get_logger(__name__)

def detect_file_encoding(file_path: str) -> str:
    """Detect file encoding"""
    try:
        with open(file_path, 'rb') as f:
            raw_data = f.read()
            result = chardet.detect(raw_data)
            encoding = result['encoding']
            confidence = result['confidence']
            
            # Use UTF-8 if confidence is low
            if confidence < 0.7:
                encoding = 'utf-8'
                
            return encoding or 'utf-8'
    except Exception as e:
        logger.warning(f"Failed to detect encoding: {e}")
        return 'utf-8'

def sanitize_string(text: str) -> str:
    """Remove invalid characters from string"""
    if not text:
        return ""
    
    # Remove non-printable characters except newlines and tabs
    cleaned = ''.join(c for c in text if ord(c) >= 32 or c in '\n\r\t')
    return cleaned

def fix_step_data(step_data: Dict[str, Any], index: int) -> Dict[str, Any]:
    """Fix common step data issues"""
    step_type = step_data.get('step_type', 'unknown')
    
    # Fix step name
    step_name = step_data.get('name', '')
    if not step_name or step_name != sanitize_string(step_name):
        default_names = {
            'mouse_click': 'ë§ˆìš°ìŠ¤ í´ë¦­',
            'mouse_move': 'ë§ˆìš°ìŠ¤ ì´ë™',
            'keyboard_type': 'í…ìŠ¤íŠ¸ ì…ë ¥',
            'wait_time': 'ëŒ€ê¸°',
            'image_search': 'ì´ë¯¸ì§€ ê²€ìƒ‰',
            'ocr_text': 'í…ìŠ¤íŠ¸ ê²€ìƒ‰',
            'if_condition': 'ì¡°ê±´ë¬¸',
            'loop': 'ë°˜ë³µë¬¸'
        }
        step_data['name'] = default_names.get(step_type, f'ë‹¨ê³„ {index + 1}')
        logger.info(f"Fixed step name: '{step_name}' -> '{step_data['name']}'")
    
    # Fix description
    if 'description' in step_data:
        desc = step_data['description']
        if isinstance(desc, str):
            step_data['description'] = sanitize_string(desc)
    
    # Fix keyboard_type empty text
    if step_type == 'keyboard_type':
        text = step_data.get('text', '')
        if not text or not text.strip():
            step_data['text'] = ' '  # Single space as placeholder
            logger.info(f"Fixed empty text in keyboard_type step")
        else:
            step_data['text'] = sanitize_string(text)
    
    # Fix wait_time
    if step_type == 'wait_time':
        wait_time = step_data.get('wait_time', 0)
        if not isinstance(wait_time, (int, float)) or wait_time <= 0:
            step_data['wait_time'] = 1.0
            logger.info(f"Fixed invalid wait_time: {wait_time} -> 1.0")
    
    # Ensure enabled field exists
    if 'enabled' not in step_data:
        step_data['enabled'] = True
    
    return step_data

def load_macro_safe(file_path: str) -> Optional[Macro]:
    """Safely load macro from file with error handling"""
    try:
        file_path = Path(file_path)
        
        if not file_path.exists():
            logger.error(f"Macro file not found: {file_path}")
            return None
        
        # Detect encoding
        encoding = detect_file_encoding(str(file_path))
        logger.info(f"Loading macro with {encoding} encoding")
        
        # Load JSON with error handling
        with open(file_path, 'r', encoding=encoding, errors='replace') as f:
            macro_data = json.load(f)
        
        # Fix macro name
        macro_name = macro_data.get('name', '')
        if not macro_name or macro_name != sanitize_string(macro_name):
            macro_data['name'] = file_path.stem  # Use filename without extension
            logger.info(f"Fixed macro name: '{macro_name}' -> '{macro_data['name']}'")
        
        # Fix macro description
        if 'description' in macro_data:
            macro_data['description'] = sanitize_string(macro_data.get('description', ''))
        
        # Fix each step
        steps = macro_data.get('steps', [])
        for i, step_data in enumerate(steps):
            macro_data['steps'][i] = fix_step_data(step_data, i)
        
        # Create macro object
        try:
            macro = Macro.from_dict(macro_data)
            
            # Validate macro
            errors = macro.validate()
            if errors:
                logger.warning(f"Macro validation warnings: {errors}")
                # Don't fail on warnings, just log them
            
            return macro
            
        except Exception as e:
            logger.error(f"Failed to create macro object: {e}")
            
            # Try to create a minimal working macro
            macro = Macro(name=macro_data.get('name', 'Recovery Macro'))
            
            # Add only valid steps
            for i, step_data in enumerate(macro_data.get('steps', [])):
                try:
                    step = StepFactory.from_dict(step_data)
                    if not step.validate():  # Only add if no validation errors
                        macro.add_step(step)
                except Exception as step_error:
                    logger.warning(f"Skipping invalid step {i+1}: {step_error}")
            
            if len(macro.steps) > 0:
                return macro
            else:
                logger.error("No valid steps could be recovered")
                return None
            
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in macro file: {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error loading macro: {e}")
        import traceback
        traceback.print_exc()
        return None

def save_macro_safe(macro: Macro, file_path: str) -> bool:
    """Safely save macro to file"""
    try:
        file_path = Path(file_path)
        
        # Ensure directory exists
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Convert to dict
        macro_data = macro.to_dict()
        
        # Save with UTF-8 encoding
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(macro_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"Macro saved successfully: {file_path}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to save macro: {e}")
        return False
</file>

<file path="src/utils/monitor_utils.py">
"""
Monitor detection and coordinate utilities
"""

from typing import Dict, List, Tuple, Optional
import logging

logger = logging.getLogger(__name__)


def get_monitor_info() -> List[Dict]:
    """
    Get information about all connected monitors
    Returns list of monitor dictionaries with x, y, width, height, is_primary
    """
    monitors = []
    
    try:
        # Try using screeninfo library if available
        from screeninfo import get_monitors
        
        for m in get_monitors():
            monitors.append({
                'name': m.name,
                'x': m.x,
                'y': m.y,
                'width': m.width,
                'height': m.height,
                'is_primary': m.is_primary if hasattr(m, 'is_primary') else (m.x == 0 and m.y == 0)
            })
            
    except ImportError:
        logger.warning("screeninfo not installed, using fallback method")
        # Fallback to tkinter method
        try:
            import tkinter as tk
            root = tk.Tk()
            root.withdraw()  # Hide the window
            
            # Get primary monitor info
            primary_width = root.winfo_screenwidth()
            primary_height = root.winfo_screenheight()
            
            # Get virtual screen size (all monitors)
            virtual_width = root.winfo_vrootwidth()
            virtual_height = root.winfo_vrootheight()
            
            monitors.append({
                'name': 'Primary',
                'x': 0,
                'y': 0,
                'width': primary_width,
                'height': primary_height,
                'is_primary': True
            })
            
            # If virtual size is larger, we have multiple monitors
            if virtual_width > primary_width:
                # Assume second monitor is to the right
                monitors.append({
                    'name': 'Secondary',
                    'x': primary_width,
                    'y': 0,
                    'width': virtual_width - primary_width,
                    'height': primary_height,
                    'is_primary': False
                })
            elif virtual_width < 0:
                # Monitor might be to the left
                monitors.insert(0, {
                    'name': 'Secondary',
                    'x': virtual_width,
                    'y': 0,
                    'width': -virtual_width,
                    'height': primary_height,
                    'is_primary': False
                })
                
            root.destroy()
            
        except Exception as e:
            logger.error(f"Failed to get monitor info: {e}")
            # Return at least one monitor
            monitors.append({
                'name': 'Default',
                'x': 0,
                'y': 0,
                'width': 1920,
                'height': 1080,
                'is_primary': True
            })
    
    return monitors


def get_monitor_at_position(x: int, y: int) -> Optional[Dict]:
    """
    Get monitor information for the monitor containing the given position
    """
    monitors = get_monitor_info()
    
    for monitor in monitors:
        if (monitor['x'] <= x < monitor['x'] + monitor['width'] and
            monitor['y'] <= y < monitor['y'] + monitor['height']):
            return monitor
            
    # If no monitor found, return the primary monitor
    for monitor in monitors:
        if monitor['is_primary']:
            return monitor
            
    return monitors[0] if monitors else None


def get_monitor_name_for_position(x: int, y: int) -> str:
    """
    Get a friendly name for the monitor at the given position
    """
    monitor = get_monitor_at_position(x, y)
    
    if not monitor:
        return "ì•Œ ìˆ˜ ì—†ëŠ” ëª¨ë‹ˆí„°"
        
    # Create a friendly name based on position
    if monitor['is_primary']:
        return "ì£¼ ëª¨ë‹ˆí„°"
    elif monitor['x'] < 0:
        return "ì™¼ìª½ ëª¨ë‹ˆí„°"
    elif monitor['x'] > 0:
        return "ì˜¤ë¥¸ìª½ ëª¨ë‹ˆí„°"
    elif monitor['y'] < 0:
        return "ìœ„ìª½ ëª¨ë‹ˆí„°"
    elif monitor['y'] > 0:
        return "ì•„ë˜ìª½ ëª¨ë‹ˆí„°"
    else:
        return monitor.get('name', 'ë³´ì¡° ëª¨ë‹ˆí„°')


def get_total_screen_bounds() -> Tuple[int, int, int, int]:
    """
    Get the total bounds of all monitors combined
    Returns: (min_x, min_y, max_x, max_y)
    """
    monitors = get_monitor_info()
    
    if not monitors:
        return (0, 0, 1920, 1080)
        
    min_x = min(m['x'] for m in monitors)
    min_y = min(m['y'] for m in monitors)
    max_x = max(m['x'] + m['width'] for m in monitors)
    max_y = max(m['y'] + m['height'] for m in monitors)
    
    return (min_x, min_y, max_x, max_y)


def is_position_valid(x: int, y: int) -> bool:
    """
    Check if a position is within any monitor bounds
    """
    return get_monitor_at_position(x, y) is not None
</file>

<file path="src/utils/path_utils.py">
"""
Cross-platform path utilities for Windows/WSL compatibility
"""

import os
import sys
import platform


def normalize_path(path: str) -> str:
    """
    Normalize path for the current platform
    Handles both Windows and WSL/Linux paths
    """
    if not path:
        return path
    
    # Convert to absolute path if relative
    if not os.path.isabs(path):
        path = os.path.abspath(path)
    
    # Normalize separators
    path = os.path.normpath(path)
    
    return path


def get_project_root() -> str:
    """
    Get the project root directory in a platform-independent way
    """
    # Get the directory of this file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Go up two levels (utils -> src -> project_root)
    project_root = os.path.dirname(os.path.dirname(current_dir))
    
    return normalize_path(project_root)


def get_captures_dir() -> str:
    """
    Get the captures directory, creating it if necessary
    """
    captures_dir = os.path.join(get_project_root(), "captures")
    os.makedirs(captures_dir, exist_ok=True)
    return captures_dir


def get_logs_dir() -> str:
    """
    Get the logs directory, creating it if necessary
    """
    logs_dir = os.path.join(get_project_root(), "logs")
    os.makedirs(logs_dir, exist_ok=True)
    return logs_dir


def is_wsl() -> bool:
    """
    Check if running in WSL environment
    """
    return 'microsoft' in platform.uname().release.lower()


def is_windows_native() -> bool:
    """
    Check if running in native Windows (not WSL)
    """
    return sys.platform == 'win32' and not is_wsl()


def convert_wsl_to_windows_path(wsl_path: str) -> str:
    """
    Convert WSL path to Windows path
    Example: /home/user/file -> \\\\wsl$\\Ubuntu\\home\\user\\file
    """
    if not wsl_path.startswith('/'):
        return wsl_path
    
    # Get WSL distribution name (default to Ubuntu)
    import subprocess
    try:
        result = subprocess.run(['wslpath', '-w', wsl_path], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass
    
    # Fallback conversion
    windows_path = wsl_path.replace('/', '\\')
    return f"\\\\wsl$\\Ubuntu{windows_path}"


def convert_windows_to_wsl_path(windows_path: str) -> str:
    """
    Convert Windows path to WSL path
    Example: C:\\Users\\file -> /mnt/c/Users/file
    """
    if ':' not in windows_path:
        return windows_path
    
    # Use wslpath if available
    import subprocess
    try:
        result = subprocess.run(['wslpath', '-u', windows_path], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass
    
    # Fallback conversion
    drive = windows_path[0].lower()
    path = windows_path[2:].replace('\\', '/')
    return f"/mnt/{drive}{path}"
</file>

<file path="src/utils/self_diagnosis.py">
"""
Windows í™˜ê²½ ìê°€ ì§„ë‹¨ ë° ë³µêµ¬ ë„êµ¬
"""

import sys
import os
import platform
import subprocess
import json
from pathlib import Path
from typing import Dict, List, Tuple, Any
import importlib
import locale
import ctypes
from datetime import datetime

from logger.app_logger import get_logger

class DiagnosticResult:
    """ì§„ë‹¨ ê²°ê³¼"""
    def __init__(self, category: str, name: str, passed: bool, 
                 message: str, fix_command: str = None):
        self.category = category
        self.name = name
        self.passed = passed
        self.message = message
        self.fix_command = fix_command
        self.timestamp = datetime.now()

class SelfDiagnosis:
    """ìê°€ ì§„ë‹¨ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.logger = get_logger(__name__)
        self.results: List[DiagnosticResult] = []
        self.fixes_applied = 0
        
    def run_full_diagnosis(self) -> Dict[str, Any]:
        """ì „ì²´ ì§„ë‹¨ ì‹¤í–‰"""
        self.logger.info("=" * 50)
        self.logger.info("ìê°€ ì§„ë‹¨ ì‹œì‘")
        self.logger.info("=" * 50)
        
        self.results.clear()
        self.fixes_applied = 0
        
        # ì§„ë‹¨ í•­ëª©ë“¤
        self._check_python_environment()
        self._check_platform_settings()
        self._check_required_packages()
        self._check_file_system()
        self._check_encoding_settings()
        self._check_permissions()
        self._check_qt_environment()
        self._check_resources()
        
        # ê²°ê³¼ ìš”ì•½
        summary = self._generate_summary()
        
        # ê²°ê³¼ ì €ì¥
        self._save_results()
        
        return summary
        
    def _check_python_environment(self):
        """Python í™˜ê²½ ê²€ì‚¬"""
        # Python ë²„ì „
        py_version = sys.version_info
        passed = py_version >= (3, 7)
        self.results.append(DiagnosticResult(
            "Python", 
            "ë²„ì „ ì²´í¬",
            passed,
            f"Python {py_version.major}.{py_version.minor}.{py_version.micro}",
            "Python 3.7 ì´ìƒ ì„¤ì¹˜ í•„ìš”" if not passed else None
        ))
        
        # ê°€ìƒí™˜ê²½ í™•ì¸
        in_venv = hasattr(sys, 'real_prefix') or (
            hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix
        )
        self.results.append(DiagnosticResult(
            "Python",
            "ê°€ìƒí™˜ê²½",
            True,  # ê°€ìƒí™˜ê²½ì€ ì„ íƒì‚¬í•­
            "ê°€ìƒí™˜ê²½ ì‚¬ìš© ì¤‘" if in_venv else "ì‹œìŠ¤í…œ Python ì‚¬ìš© ì¤‘",
            None
        ))
        
    def _check_platform_settings(self):
        """í”Œë«í¼ ì„¤ì • ê²€ì‚¬"""
        # Windows í™•ì¸
        is_windows = sys.platform == 'win32'
        self.results.append(DiagnosticResult(
            "Platform",
            "ìš´ì˜ì²´ì œ",
            is_windows,
            f"{platform.system()} {platform.release()}",
            None
        ))
        
        # Qt í”Œë«í¼ ì„¤ì •
        qt_platform = os.environ.get('QT_QPA_PLATFORM', '')
        correct_platform = 'windows' if is_windows else 'xcb'
        passed = qt_platform == correct_platform or qt_platform == ''
        
        if not passed and is_windows:
            os.environ['QT_QPA_PLATFORM'] = 'windows'
            self.fixes_applied += 1
            
        self.results.append(DiagnosticResult(
            "Platform",
            "Qt í”Œë«í¼",
            passed,
            f"QT_QPA_PLATFORM={qt_platform}",
            f"QT_QPA_PLATFORMì„ '{correct_platform}'ë¡œ ì„¤ì •" if not passed else None
        ))
        
    def _check_required_packages(self):
        """í•„ìˆ˜ íŒ¨í‚¤ì§€ ê²€ì‚¬"""
        required_packages = {
            'PyQt5': 'PyQt5',
            'pandas': 'pandas',
            'openpyxl': 'openpyxl',
            'numpy': 'numpy',
            'Pillow': 'PIL',
            'opencv-python': 'cv2',
            'pyautogui': 'pyautogui',
            'mss': 'mss',
            'chardet': 'chardet'
        }
        
        optional_packages = {
            'easyocr': 'easyocr',
            'pynput': 'pynput',
            'scipy': 'scipy',
            'scikit-learn': 'sklearn'
        }
        
        # í•„ìˆ˜ íŒ¨í‚¤ì§€ ê²€ì‚¬
        for package_name, import_name in required_packages.items():
            try:
                importlib.import_module(import_name)
                passed = True
                message = f"{package_name} ì„¤ì¹˜ë¨"
            except ImportError:
                passed = False
                message = f"{package_name} ë¯¸ì„¤ì¹˜"
                
            self.results.append(DiagnosticResult(
                "Packages",
                package_name,
                passed,
                message,
                f"pip install {package_name}" if not passed else None
            ))
            
        # ì„ íƒ íŒ¨í‚¤ì§€ ê²€ì‚¬
        for package_name, import_name in optional_packages.items():
            try:
                importlib.import_module(import_name)
                message = f"{package_name} ì„¤ì¹˜ë¨ (ì„ íƒì‚¬í•­)"
            except ImportError:
                message = f"{package_name} ë¯¸ì„¤ì¹˜ (ì„ íƒì‚¬í•­)"
                
            self.results.append(DiagnosticResult(
                "Packages",
                package_name,
                True,  # ì„ íƒì‚¬í•­ì€ í•­ìƒ í†µê³¼
                message,
                None
            ))
            
    def _check_file_system(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ê²€ì‚¬"""
        # í”„ë¡œì íŠ¸ êµ¬ì¡° í™•ì¸
        project_root = Path(__file__).parent.parent.parent
        required_dirs = [
            'src/core',
            'src/ui',
            'src/automation',
            'src/excel',
            'src/vision',
            'src/utils',
            'resources'
        ]
        
        for dir_path in required_dirs:
            full_path = project_root / dir_path
            exists = full_path.exists()
            
            if not exists:
                # ë””ë ‰í† ë¦¬ ìƒì„± ì‹œë„
                try:
                    full_path.mkdir(parents=True, exist_ok=True)
                    self.fixes_applied += 1
                    exists = True
                except:
                    pass
                    
            self.results.append(DiagnosticResult(
                "FileSystem",
                f"ë””ë ‰í† ë¦¬: {dir_path}",
                exists,
                "ì¡´ì¬í•¨" if exists else "ì—†ìŒ",
                f"mkdir {dir_path}" if not exists else None
            ))
            
        # ë¡œê·¸ ë””ë ‰í† ë¦¬
        log_dir = Path.home() / '.excel_macro_automation'
        if not log_dir.exists():
            try:
                log_dir.mkdir(parents=True, exist_ok=True)
                self.fixes_applied += 1
            except:
                pass
                
    def _check_encoding_settings(self):
        """ì¸ì½”ë”© ì„¤ì • ê²€ì‚¬"""
        # ì‹œìŠ¤í…œ ì¸ì½”ë”©
        sys_encoding = sys.getdefaultencoding()
        self.results.append(DiagnosticResult(
            "Encoding",
            "ì‹œìŠ¤í…œ ì¸ì½”ë”©",
            sys_encoding == 'utf-8',
            f"ê¸°ë³¸ ì¸ì½”ë”©: {sys_encoding}",
            None
        ))
        
        # UTF-8 ëª¨ë“œ
        utf8_mode = os.environ.get('PYTHONUTF8', '0')
        if utf8_mode != '1' and sys.platform == 'win32':
            os.environ['PYTHONUTF8'] = '1'
            self.fixes_applied += 1
            
        self.results.append(DiagnosticResult(
            "Encoding",
            "UTF-8 ëª¨ë“œ",
            utf8_mode == '1',
            f"PYTHONUTF8={utf8_mode}",
            "PYTHONUTF8=1 ì„¤ì •" if utf8_mode != '1' else None
        ))
        
        # ë¡œì¼€ì¼ ì„¤ì •
        try:
            current_locale = locale.getlocale()
            self.results.append(DiagnosticResult(
                "Encoding",
                "ë¡œì¼€ì¼",
                True,
                f"ë¡œì¼€ì¼: {current_locale}",
                None
            ))
        except:
            self.results.append(DiagnosticResult(
                "Encoding",
                "ë¡œì¼€ì¼",
                False,
                "ë¡œì¼€ì¼ í™•ì¸ ì‹¤íŒ¨",
                None
            ))
            
    def _check_permissions(self):
        """ê¶Œí•œ ê²€ì‚¬"""
        if sys.platform == 'win32':
            # ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
            try:
                is_admin = ctypes.windll.shell32.IsUserAnAdmin()
                self.results.append(DiagnosticResult(
                    "Permissions",
                    "ê´€ë¦¬ì ê¶Œí•œ",
                    True,  # ê´€ë¦¬ì ê¶Œí•œì€ ì„ íƒì‚¬í•­
                    "ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰ ì¤‘" if is_admin else "ì¼ë°˜ ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰ ì¤‘",
                    None
                ))
            except:
                self.results.append(DiagnosticResult(
                    "Permissions",
                    "ê´€ë¦¬ì ê¶Œí•œ",
                    True,
                    "ê¶Œí•œ í™•ì¸ ë¶ˆê°€",
                    None
                ))
                
    def _check_qt_environment(self):
        """Qt í™˜ê²½ ê²€ì‚¬"""
        try:
            from PyQt5.QtCore import QT_VERSION_STR
            from PyQt5.Qt import PYQT_VERSION_STR
            
            self.results.append(DiagnosticResult(
                "Qt",
                "Qt ë²„ì „",
                True,
                f"Qt {QT_VERSION_STR}, PyQt {PYQT_VERSION_STR}",
                None
            ))
        except ImportError:
            self.results.append(DiagnosticResult(
                "Qt",
                "Qt ì„¤ì¹˜",
                False,
                "PyQt5 ë¯¸ì„¤ì¹˜",
                "pip install PyQt5"
            ))
            
    def _check_resources(self):
        """ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ê²€ì‚¬"""
        try:
            import psutil
            
            # CPU ì‚¬ìš©ë¥ 
            cpu_percent = psutil.cpu_percent(interval=1)
            self.results.append(DiagnosticResult(
                "Resources",
                "CPU ì‚¬ìš©ë¥ ",
                cpu_percent < 80,
                f"CPU: {cpu_percent}%",
                "ë†’ì€ CPU ì‚¬ìš©ë¥ " if cpu_percent >= 80 else None
            ))
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
            memory = psutil.virtual_memory()
            self.results.append(DiagnosticResult(
                "Resources",
                "ë©”ëª¨ë¦¬",
                memory.percent < 80,
                f"ë©”ëª¨ë¦¬: {memory.percent}% ì‚¬ìš© ì¤‘",
                "ë©”ëª¨ë¦¬ ë¶€ì¡±" if memory.percent >= 80 else None
            ))
            
            # ë””ìŠ¤í¬ ê³µê°„
            disk = psutil.disk_usage('/')
            self.results.append(DiagnosticResult(
                "Resources",
                "ë””ìŠ¤í¬",
                disk.percent < 90,
                f"ë””ìŠ¤í¬: {disk.percent}% ì‚¬ìš© ì¤‘",
                "ë””ìŠ¤í¬ ê³µê°„ ë¶€ì¡±" if disk.percent >= 90 else None
            ))
            
        except ImportError:
            self.results.append(DiagnosticResult(
                "Resources",
                "ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§",
                True,
                "psutil ë¯¸ì„¤ì¹˜ (ì„ íƒì‚¬í•­)",
                None
            ))
            
    def _generate_summary(self) -> Dict[str, Any]:
        """ì§„ë‹¨ ê²°ê³¼ ìš”ì•½"""
        total = len(self.results)
        passed = sum(1 for r in self.results if r.passed)
        failed = total - passed
        
        categories = {}
        for result in self.results:
            if result.category not in categories:
                categories[result.category] = {'passed': 0, 'failed': 0}
                
            if result.passed:
                categories[result.category]['passed'] += 1
            else:
                categories[result.category]['failed'] += 1
                
        summary = {
            'total_checks': total,
            'passed': passed,
            'failed': failed,
            'fixes_applied': self.fixes_applied,
            'categories': categories,
            'timestamp': datetime.now().isoformat()
        }
        
        # ì½˜ì†” ì¶œë ¥
        self.logger.info("\n" + "=" * 50)
        self.logger.info("ì§„ë‹¨ ê²°ê³¼ ìš”ì•½")
        self.logger.info("=" * 50)
        self.logger.info(f"ì´ ê²€ì‚¬ í•­ëª©: {total}")
        self.logger.info(f"í†µê³¼: {passed}")
        self.logger.info(f"ì‹¤íŒ¨: {failed}")
        self.logger.info(f"ìë™ ìˆ˜ì • ì ìš©: {self.fixes_applied}")
        
        if failed > 0:
            self.logger.warning("\nì‹¤íŒ¨í•œ í•­ëª©:")
            for result in self.results:
                if not result.passed:
                    self.logger.warning(f"- [{result.category}] {result.name}: {result.message}")
                    if result.fix_command:
                        self.logger.info(f"  ìˆ˜ì • ë°©ë²•: {result.fix_command}")
                        
        return summary
        
    def _save_results(self):
        """ì§„ë‹¨ ê²°ê³¼ ì €ì¥"""
        try:
            results_file = Path.home() / '.excel_macro_automation' / 'diagnosis_results.json'
            results_file.parent.mkdir(exist_ok=True)
            
            data = {
                'timestamp': datetime.now().isoformat(),
                'results': [
                    {
                        'category': r.category,
                        'name': r.name,
                        'passed': r.passed,
                        'message': r.message,
                        'fix_command': r.fix_command
                    }
                    for r in self.results
                ],
                'summary': self._generate_summary()
            }
            
            with open(results_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            self.logger.error(f"ì§„ë‹¨ ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨: {e}")
            
    def auto_fix(self) -> int:
        """ìë™ ìˆ˜ì • ê°€ëŠ¥í•œ ë¬¸ì œ í•´ê²°"""
        fixed_count = 0
        
        for result in self.results:
            if not result.passed and result.fix_command:
                if result.fix_command.startswith("pip install"):
                    # pip ì„¤ì¹˜
                    package = result.fix_command.split()[-1]
                    try:
                        subprocess.run(
                            [sys.executable, '-m', 'pip', 'install', package],
                            check=True,
                            capture_output=True
                        )
                        fixed_count += 1
                        self.logger.info(f"íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì„±ê³µ: {package}")
                    except:
                        self.logger.error(f"íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì‹¤íŒ¨: {package}")
                        
        return fixed_count

def run_diagnosis():
    """ì§„ë‹¨ ì‹¤í–‰ í—¬í¼ í•¨ìˆ˜ (ë°°ì¹˜ íŒŒì¼ í˜¸í™˜ì„±)"""
    diagnosis = SelfDiagnosis()
    result = diagnosis.run_full_diagnosis()
    
    # ë°°ì¹˜ íŒŒì¼ì—ì„œ í˜¸ì¶œ ì‹œ ìë™ìœ¼ë¡œ ìˆ˜ì • ì‹œë„
    if result['summary']['failed'] > 0:
        print("\nìˆ˜ì •ì´ í•„ìš”í•œ í•­ëª©ì´ ìˆìŠµë‹ˆë‹¤.")
        # ë°°ì¹˜ íŒŒì¼ì—ì„œëŠ” ì…ë ¥ì„ ë°›ì§€ ì•Šê³  ìë™ ìˆ˜ì •
        if 'BATCH_MODE' in os.environ or not sys.stdin.isatty():
            print("ìë™ ìˆ˜ì •ì„ ì‹œë„í•©ë‹ˆë‹¤...")
            fixed = diagnosis.auto_fix()
            print(f"\n{fixed}ê°œ í•­ëª©ì„ ìë™ìœ¼ë¡œ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.")
        else:
            response = input("ìë™ ìˆ˜ì •ì„ ì‹œë„í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ")
            if response.lower() == 'y':
                fixed = diagnosis.auto_fix()
                print(f"\n{fixed}ê°œ í•­ëª©ì„ ìë™ìœ¼ë¡œ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.")
            
    return result

if __name__ == "__main__":
    run_diagnosis()
</file>

<file path="src/vision/image_matcher.py">
"""
OpenCV-based image matching engine with DPI scaling and multi-monitor support
"""

import time
from typing import Optional, Tuple, List, Dict, Any
from dataclasses import dataclass
import numpy as np
import cv2
import pyautogui
from PIL import Image
import mss
from config.settings import Settings
from logger.app_logger import get_logger

@dataclass
class MatchResult:
    """Result of image matching operation"""
    found: bool
    confidence: float
    location: Optional[Tuple[int, int, int, int]] = None  # x, y, width, height
    center: Optional[Tuple[int, int]] = None  # center x, y
    
@dataclass 
class MonitorInfo:
    """Monitor information"""
    index: int
    left: int
    top: int
    width: int
    height: int
    scale: float = 1.0

class ImageMatcher:
    """Advanced image matching with OpenCV"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        self._template_cache: Dict[str, np.ndarray] = {}
        self._sct = mss.mss()
        self._monitors = self._detect_monitors()
        
    def _detect_monitors(self) -> List[MonitorInfo]:
        """Detect all monitors and their properties"""
        monitors = []
        
        for i, monitor in enumerate(self._sct.monitors[1:], 1):  # Skip combined monitor
            info = MonitorInfo(
                index=i,
                left=monitor["left"],
                top=monitor["top"],
                width=monitor["width"],
                height=monitor["height"]
            )
            
            # Detect DPI scaling (simplified - may need platform-specific code)
            try:
                # Get actual screen size vs reported size
                actual_size = pyautogui.size()
                if i == 1:  # Primary monitor
                    scale_x = actual_size.width / monitor["width"]
                    scale_y = actual_size.height / monitor["height"]
                    info.scale = max(scale_x, scale_y)
            except:
                info.scale = 1.0
                
            monitors.append(info)
            self.logger.debug(f"Detected monitor {i}: {info}")
            
        return monitors
        
    def _load_template(self, image_path: str, scale: float = 1.0) -> np.ndarray:
        """Load and cache template image with scaling"""
        cache_key = f"{image_path}_{scale}"
        
        if cache_key in self._template_cache:
            return self._template_cache[cache_key]
            
        try:
            # Load template
            template = cv2.imread(image_path)
            if template is None:
                raise ValueError(f"Failed to load image: {image_path}")
                
            # Apply DPI scaling if needed
            if scale != 1.0:
                width = int(template.shape[1] * scale)
                height = int(template.shape[0] * scale)
                template = cv2.resize(template, (width, height), interpolation=cv2.INTER_LINEAR)
                
            # Convert to grayscale for faster matching
            template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
            
            # Cache the processed template
            self._template_cache[cache_key] = template_gray
            
            return template_gray
            
        except Exception as e:
            self.logger.error(f"Error loading template {image_path}: {e}")
            raise
            
    def _capture_screen(self, region: Optional[Tuple[int, int, int, int]] = None,
                       monitor_index: Optional[int] = None) -> np.ndarray:
        """Capture screen or region"""
        try:
            if region:
                # Capture specific region
                monitor = {
                    "left": region[0],
                    "top": region[1], 
                    "width": region[2],
                    "height": region[3]
                }
            elif monitor_index is not None and 0 <= monitor_index < len(self._monitors):
                # Capture specific monitor
                mon_info = self._monitors[monitor_index]
                monitor = {
                    "left": mon_info.left,
                    "top": mon_info.top,
                    "width": mon_info.width,
                    "height": mon_info.height
                }
            else:
                # Capture all monitors
                monitor = self._sct.monitors[0]
                
            # Capture screenshot
            screenshot = self._sct.grab(monitor)
            
            # Convert to numpy array
            img = np.array(screenshot)
            
            # Convert BGRA to BGR
            img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
            
            return img
            
        except Exception as e:
            self.logger.error(f"Error capturing screen: {e}")
            raise
            
    def find_image(self, template_path: str, 
                   confidence: float = 0.9,
                   region: Optional[Tuple[int, int, int, int]] = None,
                   monitor_index: Optional[int] = None,
                   grayscale: bool = True) -> MatchResult:
        """Find image on screen using template matching"""
        
        try:
            # Determine scale factor
            scale = 1.0
            if monitor_index is not None and 0 <= monitor_index < len(self._monitors):
                scale = self._monitors[monitor_index].scale
                
            # Load template
            template = self._load_template(template_path, scale)
            
            # Capture screen
            screenshot = self._capture_screen(region, monitor_index)
            
            # Convert to grayscale if needed
            if grayscale:
                screenshot_gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
            else:
                screenshot_gray = screenshot
                
            # Perform template matching
            result = cv2.matchTemplate(screenshot_gray, template, cv2.TM_CCOEFF_NORMED)
            
            # Find best match
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
            
            if max_val >= confidence:
                # Calculate absolute coordinates
                h, w = template.shape[:2]
                x, y = max_loc
                
                # Adjust for region offset if applicable
                if region:
                    x += region[0]
                    y += region[1]
                elif monitor_index is not None:
                    mon_info = self._monitors[monitor_index]
                    x += mon_info.left
                    y += mon_info.top
                    
                location = (x, y, w, h)
                center = (x + w // 2, y + h // 2)
                
                return MatchResult(
                    found=True,
                    confidence=max_val,
                    location=location,
                    center=center
                )
            else:
                return MatchResult(found=False, confidence=max_val)
                
        except Exception as e:
            self.logger.error(f"Error in find_image: {e}")
            return MatchResult(found=False, confidence=0.0)
            
    def find_all_images(self, template_path: str,
                       confidence: float = 0.9,
                       region: Optional[Tuple[int, int, int, int]] = None,
                       limit: int = 10) -> List[MatchResult]:
        """Find all occurrences of image on screen"""
        
        results = []
        
        try:
            # Load template
            template = self._load_template(template_path)
            
            # Capture screen  
            screenshot = self._capture_screen(region)
            screenshot_gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
            
            # Perform template matching
            match_result = cv2.matchTemplate(screenshot_gray, template, cv2.TM_CCOEFF_NORMED)
            
            # Find all matches above threshold
            locations = np.where(match_result >= confidence)
            
            h, w = template.shape[:2]
            
            # Process matches
            for pt in zip(*locations[::-1]):
                if len(results) >= limit:
                    break
                    
                x, y = pt
                
                # Adjust for region offset
                if region:
                    x += region[0]
                    y += region[1]
                    
                location = (x, y, w, h)
                center = (x + w // 2, y + h // 2)
                
                # Get confidence for this match
                conf = match_result[y, x]
                
                results.append(MatchResult(
                    found=True,
                    confidence=float(conf),
                    location=location,
                    center=center
                ))
                
        except Exception as e:
            self.logger.error(f"Error in find_all_images: {e}")
            
        return results
        
    def wait_for_image(self, template_path: str,
                      timeout: float = 30.0,
                      confidence: float = 0.9,
                      region: Optional[Tuple[int, int, int, int]] = None,
                      check_interval: float = 0.5) -> MatchResult:
        """Wait for image to appear on screen"""
        
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            result = self.find_image(template_path, confidence, region)
            
            if result.found:
                return result
                
            time.sleep(check_interval)
            
        # Timeout reached
        return MatchResult(found=False, confidence=0.0)
        
    def capture_region(self, region: Tuple[int, int, int, int], 
                      save_path: Optional[str] = None) -> np.ndarray:
        """Capture a specific region of the screen"""
        
        screenshot = self._capture_screen(region)
        
        if save_path:
            cv2.imwrite(save_path, screenshot)
            self.logger.info(f"Saved screenshot to {save_path}")
            
        return screenshot
        
    def clear_cache(self):
        """Clear template cache"""
        self._template_cache.clear()
        self.logger.debug("Template cache cleared")

class ImageMatcherLegacy:
    """Legacy image matcher using pyautogui for fallback"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        
    def find_image(self, template_path: str,
                   confidence: float = 0.9,
                   region: Optional[Tuple[int, int, int, int]] = None) -> MatchResult:
        """Find image using pyautogui"""
        
        try:
            location = pyautogui.locateOnScreen(
                template_path,
                confidence=confidence,
                region=region
            )
            
            if location:
                center = pyautogui.center(location)
                return MatchResult(
                    found=True,
                    confidence=confidence,
                    location=location,
                    center=center
                )
            else:
                return MatchResult(found=False, confidence=0.0)
                
        except Exception as e:
            self.logger.error(f"Error in legacy find_image: {e}")
            return MatchResult(found=False, confidence=0.0)
</file>

<file path="start_gui.sh">
#!/bin/bash
# Excel Macro Automation ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

echo "Excel Macro Automation GUI ì‹œì‘..."
echo "=================================="

# ê°€ìƒí™˜ê²½ í™œì„±í™”
source venv/bin/activate

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
export DISPLAY=${DISPLAY:-:0}
export QT_QPA_PLATFORM=xcb
export QT_DEBUG_PLUGINS=0

# Python ê²½ë¡œ ì¶œë ¥
echo "Python ê²½ë¡œ: $(which python)"
echo "Python ë²„ì „: $(python --version)"
echo ""

# GUI ì‹¤í–‰
echo "GUIë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤..."
python run_main.py

echo "=================================="
echo "í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250715_225040.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_111655.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-15T10:00:00.000Z",
      "endTime": "2025-07-15T15:00:00.000Z",
      "actualEndTime": "2025-07-15T14:41:16.998Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2152,
            "outputTokens": 89802,
            "cacheCreationTokens": 2254600,
            "cacheReadTokens": 54716499,
            "totalTokens": 91954
          },
          "costUSD": 131.115928,
          "entriesCount": 644
        }
      },
      "totalTokens": 459770,
      "totalTokensOld": 91954,
      "costUSD": 131.115928,
      "entries": 647,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-15T14:41:16.998Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-16T00:00:00.000Z",
      "endTime": "2025-07-16T05:00:00.000Z",
      "actualEndTime": "2025-07-16T02:16:52.142Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1517,
            "outputTokens": 51006,
            "cacheCreationTokens": 1964228,
            "cacheReadTokens": 31405887,
            "totalTokens": 52523
          },
          "costUSD": 87.78631,
          "entriesCount": 393
        }
      },
      "totalTokens": 262615,
      "totalTokensOld": 52523,
      "costUSD": 87.78631,
      "entries": 408,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:45:24.854Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:46:52.080Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:00:13.826Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:20:13.306Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_230208.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-15T10:00:00.000Z",
      "endTime": "2025-07-15T15:00:00.000Z",
      "actualEndTime": "2025-07-15T14:41:16.998Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2152,
            "outputTokens": 89802,
            "cacheCreationTokens": 2254600,
            "cacheReadTokens": 54716499,
            "totalTokens": 91954
          },
          "costUSD": 131.115928,
          "entriesCount": 644
        }
      },
      "totalTokens": 459770,
      "totalTokensOld": 91954,
      "costUSD": 131.115928,
      "entries": 647,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-15T14:41:16.998Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-16T00:00:00.000Z",
      "endTime": "2025-07-16T05:00:00.000Z",
      "actualEndTime": "2025-07-16T03:50:31.984Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1758,
            "outputTokens": 57412,
            "cacheCreationTokens": 2744546,
            "cacheReadTokens": 41214649,
            "totalTokens": 59170
          },
          "costUSD": 117.614481,
          "entriesCount": 486
        }
      },
      "totalTokens": 295850,
      "totalTokensOld": 59170,
      "costUSD": 117.614481,
      "entries": 503,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:45:24.854Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:46:52.080Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:00:13.826Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:20:13.306Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T03:50:31.984Z",
          "content": "Claude AI usage limit reached|1752642000",
          "resetTime": "2025-07-16T05:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path="usage_tracking2.json">
{
  "user_id": "f6904afa-4a7e-42ad-8e37-34f0262bc38a",
  "first_run": "2025-07-15T22:50:40.701999"
}
</file>

<file path="web_ui_enhanced.py">
#!/usr/bin/env python3
"""
í–¥ìƒëœ ì›¹ UI - ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜ ë° ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸° ê¸°ëŠ¥ í¬í•¨
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
import base64
import tempfile
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List
import io

# Flask ì„¤ì¹˜ í™•ì¸
try:
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS
except ImportError:
    print("í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask", "flask-cors"])
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS

# ì¶”ê°€ íŒ¨í‚¤ì§€ ì„¤ì¹˜ í™•ì¸
try:
    import pyautogui
    import pyperclip
    from PIL import Image, ImageGrab
    import keyboard
    import mouse
except ImportError:
    print("ì¶”ê°€ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "pyautogui", "pyperclip", "pillow", "keyboard", "mouse"])
    import pyautogui
    import pyperclip
    from PIL import Image, ImageGrab
    import keyboard
    import mouse

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# ê¸°ì¡´ ë§¤í¬ë¡œ ëª¨ë“ˆ import ì‹œë„
try:
    from core.macro_types import (
        MacroStep, StepType, MouseClickStep, KeyboardTypeStep,
        WaitTimeStep, ImageSearchStep, TextSearchStep, IfConditionStep,
        ConditionType, ComparisonOperator
    )
    from automation.executor import MacroExecutor
    from excel.excel_manager import ExcelManager
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    MODULES_LOADED = True
except Exception as e:
    print(f"ê²½ê³ : ì¼ë¶€ ëª¨ë“ˆì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
    MODULES_LOADED = False

app = Flask(__name__)
CORS(app)

# ì „ì—­ ìƒíƒœ ê´€ë¦¬
class AppState:
    def __init__(self):
        self.excel_manager = ExcelManager() if MODULES_LOADED else None
        self.macro_steps: List[Dict] = []
        self.executor = None
        self.execution_thread = None
        self.execution_log = []
        self.is_running = False
        self.settings = Settings() if MODULES_LOADED else None
        self.mouse_position = {'x': 0, 'y': 0}
        self.is_tracking_mouse = False
        self.captured_images = {}  # ì´ë¯¸ì§€ ì„ì‹œ ì €ì¥ì†Œ
        
    def add_log(self, message: str, level: str = "info"):
        self.execution_log.append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': level,
            'message': message
        })

app_state = AppState()

# ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  ìŠ¤ë ˆë“œ
def track_mouse_position():
    """ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ê³„ì† ì¶”ì """
    while True:
        if app_state.is_tracking_mouse:
            try:
                x, y = pyautogui.position()
                app_state.mouse_position = {'x': x, 'y': y}
            except:
                pass
        time.sleep(0.1)

# ë§ˆìš°ìŠ¤ ì¶”ì  ìŠ¤ë ˆë“œ ì‹œì‘
mouse_thread = threading.Thread(target=track_mouse_position, daemon=True)
mouse_thread.start()

# HTML í…œí”Œë¦¿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - Enhanced</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #667eea;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        .button.secondary {
            background: #757575;
        }
        .button.success {
            background: #4CAF50;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }
        .step-type-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .macro-step {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .step-config-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .form-group {
            margin: 20px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .mouse-position {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 20px;
            margin: 20px 0;
        }
        .capture-button {
            background: #FF9800;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            margin: 10px;
        }
        .image-preview {
            max-width: 100%;
            max-height: 300px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .paste-area {
            border: 2px dashed #667eea;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s;
        }
        .paste-area:hover {
            background: #f8f9ff;
            border-color: #764ba2;
        }
        .paste-area.dragover {
            background: #e8eaff;
            border-color: #4CAF50;
        }
        .coordinate-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }
        .coord-box {
            background: #f8f9ff;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .hint-text {
            color: #666;
            font-size: 14px;
            margin: 10px 0;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Excel Macro Automation - Enhanced</h1>
            <p>ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜ ë° ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸° ê¸°ëŠ¥ í¬í•¨</p>
            <div class="status-badge">
                ìƒíƒœ: <span id="status">ì¤€ë¹„ë¨</span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">ğŸ“Š Excel</button>
            <button class="tab" onclick="showTab('editor')">âœï¸ Editor</button>
            <button class="tab" onclick="showTab('run')">â–¶ï¸ Run</button>
            <button class="tab" onclick="showTab('tools')">ğŸ› ï¸ Tools</button>
        </div>
        
        <div class="content">
            <!-- Excel íƒ­ -->
            <div id="excel" class="panel active">
                <h2>Excel íŒŒì¼ ê´€ë¦¬</h2>
                <div>
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">ì—…ë¡œë“œ</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor íƒ­ -->
            <div id="editor" class="panel">
                <h2>ë§¤í¬ë¡œ í¸ì§‘ê¸°</h2>
                <div class="step-palette">
                    <div class="step-type-card" onclick="addStep('mouse_click')">
                        <div>ğŸ–±ï¸</div>
                        <div>ë§ˆìš°ìŠ¤ í´ë¦­</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('keyboard_type')">
                        <div>âŒ¨ï¸</div>
                        <div>í…ìŠ¤íŠ¸ ì…ë ¥</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('wait_time')">
                        <div>â±ï¸</div>
                        <div>ëŒ€ê¸°</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('image_search')">
                        <div>ğŸ”</div>
                        <div>ì´ë¯¸ì§€ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('ocr_text')">
                        <div>ğŸ”¤</div>
                        <div>í…ìŠ¤íŠ¸ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('if_condition')">
                        <div>â“</div>
                        <div>ì¡°ê±´ë¬¸</div>
                    </div>
                </div>
                
                <h3>í˜„ì¬ ë§¤í¬ë¡œ</h3>
                <div id="macroSteps"></div>
                
                <button class="button" onclick="saveMacro()">ğŸ’¾ ë§¤í¬ë¡œ ì €ì¥</button>
                <button class="button secondary" onclick="clearMacro()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            </div>
            
            <!-- Run íƒ­ -->
            <div id="run" class="panel">
                <h2>ë§¤í¬ë¡œ ì‹¤í–‰</h2>
                <button class="button" onclick="runMacro()">â–¶ï¸ ì‹¤í–‰</button>
                <button class="button secondary" onclick="stopMacro()">â¹ï¸ ì¤‘ì§€</button>
                
                <h3>ì‹¤í–‰ ë¡œê·¸</h3>
                <div id="executionLog" class="execution-log"></div>
            </div>
            
            <!-- Tools íƒ­ -->
            <div id="tools" class="panel">
                <h2>ìœ ìš©í•œ ë„êµ¬</h2>
                
                <h3>ğŸ¯ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜</h3>
                <div class="mouse-position">
                    <div class="coordinate-display">
                        <div class="coord-box">X: <span id="mouseX">0</span></div>
                        <div class="coord-box">Y: <span id="mouseY">0</span></div>
                    </div>
                    <p class="hint-text">ë§ˆìš°ìŠ¤ë¥¼ ì›€ì§ì—¬ì„œ ì¢Œí‘œë¥¼ í™•ì¸í•˜ì„¸ìš”</p>
                    <button class="capture-button" onclick="toggleMouseTracking()">
                        <span id="trackingText">ğŸ¯ ì¢Œí‘œ ì¶”ì  ì‹œì‘</span>
                    </button>
                    <p class="hint-text" id="captureHint" style="display: none;">
                        F9 í‚¤ë¥¼ ëˆŒëŸ¬ì„œ í˜„ì¬ ì¢Œí‘œë¥¼ ìº¡ì²˜í•˜ì„¸ìš”
                    </p>
                </div>
                
                <h3>ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜</h3>
                <button class="button success" onclick="captureScreen()">
                    ğŸ“· ì „ì²´ í™”ë©´ ìº¡ì²˜
                </button>
                <button class="button success" onclick="captureRegion()">
                    âœ‚ï¸ ì˜ì—­ ì„ íƒ ìº¡ì²˜
                </button>
                
                <h3>ğŸ–¼ï¸ ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸°</h3>
                <div class="paste-area" onclick="document.getElementById('imageUpload').click()" 
                     ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <p>ì´ë¯¸ì§€ë¥¼ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
                    <p>ë˜ëŠ” Ctrl+Vë¡œ í´ë¦½ë³´ë“œì—ì„œ ë¶™ì—¬ë„£ê¸°</p>
                    <input type="file" id="imageUpload" accept="image/*" style="display: none;" onchange="handleFileSelect(event)">
                </div>
                <div id="imagePreview"></div>
            </div>
        </div>
    </div>
    
    <!-- ìŠ¤í… ì„¤ì • ëª¨ë‹¬ -->
    <div id="stepConfigModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">ìŠ¤í… ì„¤ì •</h2>
            <div id="modalBody"></div>
            <button class="button" onclick="saveStepConfig()">ì €ì¥</button>
            <button class="button secondary" onclick="closeModal()">ì·¨ì†Œ</button>
        </div>
    </div>
    
    <script>
        let currentStepIndex = null;
        let isTracking = false;
        let capturedPosition = null;
        
        // íƒ­ ì „í™˜
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        // Excel ì—…ë¡œë“œ
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('excelInfo').innerHTML = 
                    '<p>íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ' + data.filename + '</p>';
            });
        }
        
        // ë§¤í¬ë¡œ ìŠ¤í… ì¶”ê°€
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
                // ì¦‰ì‹œ ì„¤ì • ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
                configureStep(data.index);
            });
        }
        
        // ë§¤í¬ë¡œ ìŠ¤í… ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => `
                    <div class="macro-step">
                        <div>
                            <strong>${i + 1}. ${step.name}</strong>
                            ${step.description ? '<br>' + step.description : ''}
                        </div>
                        <div>
                            <button class="step-config-button" onclick="configureStep(${i})">ì„¤ì •</button>
                            <button class="button secondary" onclick="removeStep(${i})">ì‚­ì œ</button>
                        </div>
                    </div>
                `).join('');
            });
        }
        
        // ìŠ¤í… ì„¤ì •
        function configureStep(index) {
            currentStepIndex = index;
            
            fetch('/get_step_config/' + index)
            .then(response => response.json())
            .then(data => {
                document.getElementById('modalTitle').textContent = data.title;
                document.getElementById('modalBody').innerHTML = data.html;
                document.getElementById('stepConfigModal').style.display = 'block';
                
                // ë§ˆìš°ìŠ¤ í´ë¦­ ìŠ¤í…ì¸ ê²½ìš° ì¢Œí‘œ ìº¡ì²˜ ë²„íŠ¼ ì¶”ê°€
                if (data.step_type === 'mouse_click') {
                    setupMouseCaptureForModal();
                }
            });
        }
        
        // ëª¨ë‹¬ì— ë§ˆìš°ìŠ¤ ìº¡ì²˜ ê¸°ëŠ¥ ì„¤ì •
        function setupMouseCaptureForModal() {
            // ìº¡ì²˜ëœ ì¢Œí‘œê°€ ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ ì…ë ¥
            if (capturedPosition) {
                document.querySelector('input[name="x"]').value = capturedPosition.x;
                document.querySelector('input[name="y"]').value = capturedPosition.y;
            }
        }
        
        // ìŠ¤í… ì„¤ì • ì €ì¥
        function saveStepConfig() {
            const formData = new FormData();
            const inputs = document.querySelectorAll('#modalBody input, #modalBody select, #modalBody textarea');
            
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    formData.append(input.name, input.checked);
                } else if (input.type === 'file' && input.files.length > 0) {
                    formData.append(input.name, input.files[0]);
                } else {
                    formData.append(input.name, input.value);
                }
            });
            
            fetch('/save_step_config/' + currentStepIndex, {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    refreshMacroSteps();
                } else {
                    alert('ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        // ëª¨ë‹¬ ë‹«ê¸°
        function closeModal() {
            document.getElementById('stepConfigModal').style.display = 'none';
        }
        
        // ìŠ¤í… ì œê±°
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        // ë§¤í¬ë¡œ ì €ì¥
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('ë§¤í¬ë¡œê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }
        
        // ë§¤í¬ë¡œ ì´ˆê¸°í™”
        function clearMacro() {
            if (confirm('ëª¨ë“  ë§¤í¬ë¡œ ìŠ¤í…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        // ë§¤í¬ë¡œ ì‹¤í–‰
        function runMacro() {
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('ì‹¤í–‰ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        // ë§¤í¬ë¡œ ì¤‘ì§€
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'});
        }
        
        // ì‹¤í–‰ ë¡œê·¸ ì—…ë°ì´íŠ¸
        function updateExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    '<div class="log-entry ' + entry.level + '">[' + entry.time + '] ' + entry.message + '</div>'
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        // ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì¶”ì 
        function toggleMouseTracking() {
            isTracking = !isTracking;
            
            fetch('/toggle_mouse_tracking', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({tracking: isTracking})
            });
            
            if (isTracking) {
                document.getElementById('trackingText').textContent = 'â¹ï¸ ì¢Œí‘œ ì¶”ì  ì¤‘ì§€';
                document.getElementById('captureHint').style.display = 'block';
                startMousePositionUpdate();
            } else {
                document.getElementById('trackingText').textContent = 'ğŸ¯ ì¢Œí‘œ ì¶”ì  ì‹œì‘';
                document.getElementById('captureHint').style.display = 'none';
            }
        }
        
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        function startMousePositionUpdate() {
            if (isTracking) {
                fetch('/get_mouse_position')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('mouseX').textContent = data.x;
                    document.getElementById('mouseY').textContent = data.y;
                    
                    if (isTracking) {
                        setTimeout(startMousePositionUpdate, 100);
                    }
                });
            }
        }
        
        // ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜
        function captureScreen() {
            fetch('/capture_screen', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('ìŠ¤í¬ë¦°ìƒ·ì´ ìº¡ì²˜ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // ì˜ì—­ ìº¡ì²˜
        function captureRegion() {
            alert('í™”ë©´ì—ì„œ ìº¡ì²˜í•  ì˜ì—­ì„ ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”.');
            fetch('/capture_region', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
        function showImagePreview(imageUrl) {
            const previewDiv = document.getElementById('imagePreview');
            previewDiv.innerHTML = `<img src="${imageUrl}" class="image-preview">`;
        }
        
        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ í•¸ë“¤ëŸ¬
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleImageFile(files[0]);
            }
        }
        
        // íŒŒì¼ ì„ íƒ í•¸ë“¤ëŸ¬
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        }
        
        // ì´ë¯¸ì§€ íŒŒì¼ ì²˜ë¦¬
        function handleImageFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            
            fetch('/upload_image', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // í´ë¦½ë³´ë“œ ë¶™ì—¬ë„£ê¸° í•¸ë“¤ëŸ¬
        document.addEventListener('paste', function(e) {
            const items = e.clipboardData.items;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    handleImageFile(blob);
                    e.preventDefault();
                    break;
                }
            }
        });
        
        // F9 í‚¤ë¡œ ì¢Œí‘œ ìº¡ì²˜
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F9' && isTracking) {
                fetch('/capture_mouse_position', {method: 'POST'})
                .then(response => response.json())
                .then(data => {
                    capturedPosition = {x: data.x, y: data.y};
                    alert(`ì¢Œí‘œê°€ ìº¡ì²˜ë˜ì—ˆìŠµë‹ˆë‹¤: X=${data.x}, Y=${data.y}`);
                });
            }
        });
        
        // ì´ˆê¸°í™”
        window.onload = function() {
            refreshMacroSteps();
            setInterval(updateExecutionLog, 1000);
        };
        
        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function(event) {
            if (event.target == document.getElementById('stepConfigModal')) {
                closeModal();
            }
        }
    </script>
</body>
</html>
'''

# API ì—”ë“œí¬ì¸íŠ¸ë“¤
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(tempfile.gettempdir(), file.filename)
        file.save(filepath)
        
        if MODULES_LOADED and app_state.excel_manager:
            app_state.excel_manager.load_file(filepath)
        
        return jsonify({'success': True, 'filename': file.filename})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    
    step_data = {
        'type': step_type,
        'name': get_step_name(step_type),
        'config': get_default_config(step_type)
    }
    
    app_state.macro_steps.append(step_data)
    
    return jsonify({
        'success': True,
        'index': len(app_state.macro_steps) - 1
    })

@app.route('/get_macro')
def get_macro():
    steps_info = []
    for step in app_state.macro_steps:
        step_info = {
            'type': step['type'],
            'name': step['name'],
            'description': get_step_description(step)
        }
        steps_info.append(step_info)
    
    return jsonify({'steps': steps_info})

@app.route('/get_step_config/<int:index>')
def get_step_config(index):
    if index >= len(app_state.macro_steps):
        return jsonify({'title': 'ì˜¤ë¥˜', 'html': '<p>ì˜ëª»ëœ ì¸ë±ìŠ¤</p>'})
    
    step = app_state.macro_steps[index]
    step_type = step['type']
    config = step.get('config', {})
    
    title = f"{step['name']} ì„¤ì •"
    html = generate_config_html(step_type, config)
    
    return jsonify({
        'title': title,
        'html': html,
        'step_type': step_type
    })

@app.route('/save_step_config/<int:index>', methods=['POST'])
def save_step_config(index):
    try:
        if index >= len(app_state.macro_steps):
            return jsonify({'success': False, 'error': 'ì˜ëª»ëœ ì¸ë±ìŠ¤'})
        
        step = app_state.macro_steps[index]
        
        # í¼ ë°ì´í„°ë¥¼ configì— ì €ì¥
        for key, value in request.form.items():
            if value == 'true':
                step['config'][key] = True
            elif value == 'false':
                step['config'][key] = False
            else:
                try:
                    step['config'][key] = float(value)
                except ValueError:
                    step['config'][key] = value
        
        # ì´ë¯¸ì§€ íŒŒì¼ ì²˜ë¦¬
        if 'image' in request.files:
            image_file = request.files['image']
            if image_file.filename:
                image_id = f"step_{index}_{int(time.time())}"
                image_path = save_uploaded_image(image_file, image_id)
                step['config']['image_path'] = image_path
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state.macro_steps):
        app_state.macro_steps.pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state.macro_steps = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state.macro_steps, f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    if not app_state.macro_steps:
        return jsonify({'success': False, 'error': 'ì‹¤í–‰í•  ë§¤í¬ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.'})
    
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œì‘", "info")
    
    # ì‹¤ì œ ì‹¤í–‰ ë¡œì§
    for i, step in enumerate(app_state.macro_steps):
        app_state.add_log(f"ë‹¨ê³„ {i+1}: {step['name']} ì‹¤í–‰", "info")
        
        if step['type'] == 'mouse_click':
            x = int(step['config'].get('x', 0))
            y = int(step['config'].get('y', 0))
            pyautogui.click(x, y)
            app_state.add_log(f"ë§ˆìš°ìŠ¤ í´ë¦­: ({x}, {y})", "success")
            
        elif step['type'] == 'keyboard_type':
            text = step['config'].get('text', '')
            pyautogui.typewrite(text)
            if step['config'].get('press_enter'):
                pyautogui.press('enter')
            app_state.add_log(f"í…ìŠ¤íŠ¸ ì…ë ¥: {text}", "success")
            
        elif step['type'] == 'wait_time':
            seconds = float(step['config'].get('seconds', 1))
            time.sleep(seconds)
            app_state.add_log(f"{seconds}ì´ˆ ëŒ€ê¸°", "success")
        
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ", "success")
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state.is_running = False
    app_state.add_log("ë§¤í¬ë¡œ ì¤‘ì§€ë¨", "warning")
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state.execution_log[-50:]})

# ë§ˆìš°ìŠ¤ ì¶”ì  ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
@app.route('/toggle_mouse_tracking', methods=['POST'])
def toggle_mouse_tracking():
    app_state.is_tracking_mouse = request.json.get('tracking', False)
    return jsonify({'success': True})

@app.route('/get_mouse_position')
def get_mouse_position():
    return jsonify(app_state.mouse_position)

@app.route('/capture_mouse_position', methods=['POST'])
def capture_mouse_position():
    return jsonify(app_state.mouse_position)

# ìŠ¤í¬ë¦°ìƒ· ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
@app.route('/capture_screen', methods=['POST'])
def capture_screen():
    try:
        # ì „ì²´ í™”ë©´ ìº¡ì²˜
        screenshot = ImageGrab.grab()
        
        # ì´ë¯¸ì§€ ì €ì¥
        image_id = f"screenshot_{int(time.time())}"
        image_path = save_screenshot(screenshot, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/capture_region', methods=['POST'])
def capture_region():
    try:
        # ê°„ë‹¨íˆ êµ¬í˜„ - ì‹¤ì œë¡œëŠ” ì˜ì—­ ì„ íƒ UIê°€ í•„ìš”
        app_state.add_log("ì˜ì—­ ìº¡ì²˜ ê¸°ëŠ¥ì€ ì¶”ê°€ êµ¬í˜„ì´ í•„ìš”í•©ë‹ˆë‹¤", "warning")
        
        # ì„ì‹œë¡œ ì „ì²´ í™”ë©´ ìº¡ì²˜
        screenshot = ImageGrab.grab()
        
        image_id = f"region_{int(time.time())}"
        image_path = save_screenshot(screenshot, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/upload_image', methods=['POST'])
def upload_image():
    try:
        image_file = request.files['image']
        image_id = f"upload_{int(time.time())}"
        image_path = save_uploaded_image(image_file, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/image/<image_id>')
def get_image(image_id):
    if image_id in app_state.captured_images:
        image_data = app_state.captured_images[image_id]
        return send_file(
            io.BytesIO(image_data),
            mimetype='image/png',
            as_attachment=False
        )
    return '', 404

# í—¬í¼ í•¨ìˆ˜ë“¤
def get_step_name(step_type):
    names = {
        'mouse_click': 'ë§ˆìš°ìŠ¤ í´ë¦­',
        'keyboard_type': 'í…ìŠ¤íŠ¸ ì…ë ¥',
        'wait_time': 'ëŒ€ê¸°',
        'image_search': 'ì´ë¯¸ì§€ ê²€ìƒ‰',
        'ocr_text': 'í…ìŠ¤íŠ¸ ê²€ìƒ‰',
        'if_condition': 'ì¡°ê±´ë¬¸'
    }
    return names.get(step_type, 'ì•Œ ìˆ˜ ì—†ìŒ')

def get_default_config(step_type):
    configs = {
        'mouse_click': {'x': 0, 'y': 0, 'button': 'left', 'click_type': 'single'},
        'keyboard_type': {'text': '', 'press_enter': False},
        'wait_time': {'seconds': 1.0},
        'image_search': {'image_path': '', 'confidence': 0.8},
        'ocr_text': {'search_text': '', 'exact_match': False},
        'if_condition': {'condition_type': 'image_found', 'value': ''}
    }
    return configs.get(step_type, {})

def get_step_description(step):
    config = step.get('config', {})
    step_type = step['type']
    
    if step_type == 'mouse_click':
        return f"({config.get('x', 0)}, {config.get('y', 0)}) í´ë¦­"
    elif step_type == 'keyboard_type':
        text = config.get('text', '')
        return f"'{text[:20]}...' ì…ë ¥" if len(text) > 20 else f"'{text}' ì…ë ¥"
    elif step_type == 'wait_time':
        return f"{config.get('seconds', 1)}ì´ˆ ëŒ€ê¸°"
    elif step_type == 'image_search':
        return "ì´ë¯¸ì§€ ê²€ìƒ‰ í›„ í´ë¦­"
    elif step_type == 'ocr_text':
        return f"'{config.get('search_text', '')}' í…ìŠ¤íŠ¸ ê²€ìƒ‰"
    elif step_type == 'if_condition':
        return f"{config.get('condition_type', '')} ì¡°ê±´"
    
    return ""

def generate_config_html(step_type, config):
    if step_type == 'mouse_click':
        return f'''
        <div class="form-group">
            <label>X ì¢Œí‘œ</label>
            <input type="number" name="x" value="{config.get('x', 0)}" required>
        </div>
        <div class="form-group">
            <label>Y ì¢Œí‘œ</label>
            <input type="number" name="y" value="{config.get('y', 0)}" required>
        </div>
        <div class="form-group" style="background: #f8f9ff; padding: 15px; border-radius: 5px;">
            <p style="text-align: center; color: #667eea; font-weight: bold;">
                ğŸ’¡ íŒ: Tools íƒ­ì—ì„œ ë§ˆìš°ìŠ¤ ì¢Œí‘œë¥¼ ì‰½ê²Œ ìº¡ì²˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!
            </p>
            <p style="text-align: center; margin-top: 10px;">
                1. Tools íƒ­ìœ¼ë¡œ ì´ë™<br>
                2. "ì¢Œí‘œ ì¶”ì  ì‹œì‘" í´ë¦­<br>
                3. ì›í•˜ëŠ” ìœ„ì¹˜ì—ì„œ F9 í‚¤ ëˆ„ë¥´ê¸°
            </p>
        </div>
        <div class="form-group">
            <label>ë§ˆìš°ìŠ¤ ë²„íŠ¼</label>
            <select name="button">
                <option value="left" {'selected' if config.get('button') == 'left' else ''}>ì™¼ìª½</option>
                <option value="right" {'selected' if config.get('button') == 'right' else ''}>ì˜¤ë¥¸ìª½</option>
            </select>
        </div>
        <div class="form-group">
            <label>í´ë¦­ íƒ€ì…</label>
            <select name="click_type">
                <option value="single" {'selected' if config.get('click_type') == 'single' else ''}>ì‹±ê¸€ í´ë¦­</option>
                <option value="double" {'selected' if config.get('click_type') == 'double' else ''}>ë”ë¸” í´ë¦­</option>
            </select>
        </div>
        '''
        
    elif step_type == 'keyboard_type':
        return f'''
        <div class="form-group">
            <label>ì…ë ¥í•  í…ìŠ¤íŠ¸</label>
            <textarea name="text" rows="3">{config.get('text', '')}</textarea>
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="press_enter" value="true" {'checked' if config.get('press_enter') else ''}>
                ì…ë ¥ í›„ Enter í‚¤ ëˆ„ë¥´ê¸°
            </label>
        </div>
        '''
        
    elif step_type == 'wait_time':
        return f'''
        <div class="form-group">
            <label>ëŒ€ê¸° ì‹œê°„ (ì´ˆ)</label>
            <input type="number" name="seconds" value="{config.get('seconds', 1.0)}" step="0.1" min="0.1" required>
        </div>
        '''
        
    elif step_type == 'image_search':
        return f'''
        <div class="form-group">
            <label>ê²€ìƒ‰í•  ì´ë¯¸ì§€</label>
            <input type="file" name="image" accept="image/*">
            <p style="margin-top: 10px; color: #666;">
                ğŸ’¡ íŒ: Tools íƒ­ì—ì„œ ìŠ¤í¬ë¦°ìƒ·ì„ ìº¡ì²˜í•˜ê±°ë‚˜ í´ë¦½ë³´ë“œì—ì„œ ì´ë¯¸ì§€ë¥¼ ë¶™ì—¬ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!
            </p>
        </div>
        <div class="form-group">
            <label>ìœ ì‚¬ë„ (0.0 ~ 1.0)</label>
            <input type="number" name="confidence" value="{config.get('confidence', 0.8)}" step="0.1" min="0" max="1" required>
        </div>
        '''
        
    elif step_type == 'ocr_text':
        return f'''
        <div class="form-group">
            <label>ê²€ìƒ‰í•  í…ìŠ¤íŠ¸</label>
            <input type="text" name="search_text" value="{config.get('search_text', '')}">
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="exact_match" value="true" {'checked' if config.get('exact_match') else ''}>
                ì •í™•íˆ ì¼ì¹˜
            </label>
        </div>
        '''
        
    elif step_type == 'if_condition':
        return f'''
        <div class="form-group">
            <label>ì¡°ê±´ íƒ€ì…</label>
            <select name="condition_type">
                <option value="image_found" {'selected' if config.get('condition_type') == 'image_found' else ''}>ì´ë¯¸ì§€ ë°œê²¬</option>
                <option value="text_found" {'selected' if config.get('condition_type') == 'text_found' else ''}>í…ìŠ¤íŠ¸ ë°œê²¬</option>
                <option value="excel_value" {'selected' if config.get('condition_type') == 'excel_value' else ''}>Excel ê°’</option>
            </select>
        </div>
        <div class="form-group">
            <label>ë¹„êµ ê°’</label>
            <input type="text" name="value" value="{config.get('value', '')}">
        </div>
        '''
    
    return '<p>ì„¤ì •ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>'

def save_screenshot(image, image_id):
    # ë©”ëª¨ë¦¬ì— ì €ì¥
    buffer = io.BytesIO()
    image.save(buffer, format='PNG')
    app_state.captured_images[image_id] = buffer.getvalue()
    return image_id

def save_uploaded_image(image_file, image_id):
    # ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë¥¼ ë©”ëª¨ë¦¬ì— ì €ì¥
    image_data = image_file.read()
    app_state.captured_images[image_id] = image_data
    return image_id

# ë©”ì¸ ì‹¤í–‰
if __name__ == '__main__':
    # pyautogui ì•ˆì „ ì„¤ì •
    pyautogui.FAILSAFE = True
    pyautogui.PAUSE = 0.1
    
    print("=" * 60)
    print("Excel Macro Automation - Enhanced Version")
    print("=" * 60)
    print("\nâœ¨ ìƒˆë¡œìš´ ê¸°ëŠ¥:")
    print("- ğŸ¯ ì‹¤ì‹œê°„ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì¶”ì ")
    print("- ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜ ë° ì €ì¥")
    print("- ğŸ–¼ï¸ ì´ë¯¸ì§€ ë“œë˜ê·¸ ì•¤ ë“œë¡­ / í´ë¦½ë³´ë“œ ë¶™ì—¬ë„£ê¸°")
    print("- âŒ¨ï¸ F9 í‚¤ë¡œ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜")
    print("- ğŸ–¥ï¸ ë©€í‹° ëª¨ë‹ˆí„° ì§€ì›")
    print("\në¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤...")
    print("ìˆ˜ë™ìœ¼ë¡œ ì—´ë ¤ë©´: http://localhost:5558")
    print("\nì¢…ë£Œí•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.")
    print("=" * 60)
    
    # ë¸Œë¼ìš°ì € ìë™ ì—´ê¸°
    def open_browser():
        time.sleep(1.5)
        webbrowser.open('http://localhost:5558')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask ì•± ì‹¤í–‰
    app.run(host='0.0.0.0', port=5558, debug=False)
</file>

<file path="web_ui_integrated_working.py">
#!/usr/bin/env python3
"""
ì›¹ UIì™€ ê¸°ì¡´ ë§¤í¬ë¡œ ê¸°ëŠ¥ì„ í†µí•©í•œ ì‹¤í–‰ ê°€ëŠ¥í•œ ë²„ì „
ë§¤í¬ë¡œ ìŠ¤í… ì„¤ì • ê¸°ëŠ¥ì´ í¬í•¨ëœ ì™„ì „í•œ ì›¹ ì¸í„°í˜ì´ìŠ¤
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
import base64
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

# Flask ì„¤ì¹˜ í™•ì¸
try:
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS
except ImportError:
    print("í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask", "flask-cors"])
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# ê¸°ì¡´ ë§¤í¬ë¡œ ëª¨ë“ˆ import
try:
    from core.macro_types import (
        MacroStep, StepType, MouseClickStep, KeyboardTypeStep,
        WaitTimeStep, ImageSearchStep, TextSearchStep, IfConditionStep,
        ConditionType, ComparisonOperator
    )
    from automation.executor import MacroExecutor
    from excel.excel_manager import ExcelManager
    from config.settings import Settings
    from logger.app_logger import setup_logger
    from vision.image_matcher import ImageMatcher
    from vision.text_extractor import TextExtractor
    
    MODULES_LOADED = True
except Exception as e:
    print(f"ê²½ê³ : ì¼ë¶€ ëª¨ë“ˆì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
    MODULES_LOADED = False

app = Flask(__name__)
CORS(app)

# ë¡œê±° ì„¤ì •
logger = setup_logger() if MODULES_LOADED else None

# ì „ì—­ ìƒíƒœ ê´€ë¦¬
class AppState:
    def __init__(self):
        self.excel_manager = ExcelManager() if MODULES_LOADED else None
        self.macro_steps: List[Dict] = []  # ë‹¨ìˆœí™”ëœ ìŠ¤í… ì €ì¥
        self.executor = None
        self.execution_thread = None
        self.execution_log = []
        self.is_running = False
        self.settings = Settings() if MODULES_LOADED else None
        
    def add_log(self, message: str, level: str = "info"):
        self.execution_log.append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': level,
            'message': message
        })
        if logger:
            getattr(logger, level)(message)

app_state = AppState()

# HTML í…œí”Œë¦¿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - í†µí•© ì›¹ UI</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #667eea;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        .button.secondary {
            background: #757575;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }
        .step-type-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .macro-step {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .step-config-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
        }
        .form-group {
            margin: 20px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .execution-log {
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .log-entry {
            padding: 5px 0;
        }
        .log-entry.error {
            color: #ff5252;
        }
        .log-entry.success {
            color: #69f0ae;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Excel Macro Automation</h1>
            <p>ì™„ì „í•œ ë§¤í¬ë¡œ ìë™í™” ì‹œìŠ¤í…œ (ìŠ¤í… ì„¤ì • ê¸°ëŠ¥ í¬í•¨)</p>
            <div class="status-badge">
                ìƒíƒœ: <span id="status">ì¤€ë¹„ë¨</span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">ğŸ“Š Excel</button>
            <button class="tab" onclick="showTab('editor')">âœï¸ Editor</button>
            <button class="tab" onclick="showTab('run')">â–¶ï¸ Run</button>
        </div>
        
        <div class="content">
            <!-- Excel íƒ­ -->
            <div id="excel" class="panel active">
                <h2>Excel íŒŒì¼ ê´€ë¦¬</h2>
                <div>
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">ì—…ë¡œë“œ</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor íƒ­ -->
            <div id="editor" class="panel">
                <h2>ë§¤í¬ë¡œ í¸ì§‘ê¸°</h2>
                <div class="step-palette">
                    <div class="step-type-card" onclick="addStep('mouse_click')">
                        <div>ğŸ–±ï¸</div>
                        <div>ë§ˆìš°ìŠ¤ í´ë¦­</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('keyboard_type')">
                        <div>âŒ¨ï¸</div>
                        <div>í…ìŠ¤íŠ¸ ì…ë ¥</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('wait_time')">
                        <div>â±ï¸</div>
                        <div>ëŒ€ê¸°</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('image_search')">
                        <div>ğŸ”</div>
                        <div>ì´ë¯¸ì§€ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('ocr_text')">
                        <div>ğŸ”¤</div>
                        <div>í…ìŠ¤íŠ¸ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('if_condition')">
                        <div>â“</div>
                        <div>ì¡°ê±´ë¬¸</div>
                    </div>
                </div>
                
                <h3>í˜„ì¬ ë§¤í¬ë¡œ</h3>
                <div id="macroSteps"></div>
                
                <button class="button" onclick="saveMacro()">ğŸ’¾ ë§¤í¬ë¡œ ì €ì¥</button>
                <button class="button secondary" onclick="clearMacro()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            </div>
            
            <!-- Run íƒ­ -->
            <div id="run" class="panel">
                <h2>ë§¤í¬ë¡œ ì‹¤í–‰</h2>
                <button class="button" onclick="runMacro()">â–¶ï¸ ì‹¤í–‰</button>
                <button class="button secondary" onclick="stopMacro()">â¹ï¸ ì¤‘ì§€</button>
                
                <h3>ì‹¤í–‰ ë¡œê·¸</h3>
                <div id="executionLog" class="execution-log"></div>
            </div>
        </div>
    </div>
    
    <!-- ìŠ¤í… ì„¤ì • ëª¨ë‹¬ -->
    <div id="stepConfigModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">ìŠ¤í… ì„¤ì •</h2>
            <div id="modalBody"></div>
            <button class="button" onclick="saveStepConfig()">ì €ì¥</button>
            <button class="button secondary" onclick="closeModal()">ì·¨ì†Œ</button>
        </div>
    </div>
    
    <script>
        let currentStepIndex = null;
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('excelInfo').innerHTML = 
                    '<p>íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ' + data.filename + '</p>';
            });
        }
        
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
                // ì¦‰ì‹œ ì„¤ì • ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
                configureStep(data.index);
            });
        }
        
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => `
                    <div class="macro-step">
                        <div>
                            <strong>${i + 1}. ${step.name}</strong>
                            ${step.description ? '<br>' + step.description : ''}
                        </div>
                        <div>
                            <button class="step-config-button" onclick="configureStep(${i})">ì„¤ì •</button>
                            <button class="button secondary" onclick="removeStep(${i})">ì‚­ì œ</button>
                        </div>
                    </div>
                `).join('');
            });
        }
        
        function configureStep(index) {
            currentStepIndex = index;
            
            fetch('/get_step_config/' + index)
            .then(response => response.json())
            .then(data => {
                document.getElementById('modalTitle').textContent = data.title;
                document.getElementById('modalBody').innerHTML = data.html;
                document.getElementById('stepConfigModal').style.display = 'block';
            });
        }
        
        function saveStepConfig() {
            const formData = new FormData();
            const inputs = document.querySelectorAll('#modalBody input, #modalBody select, #modalBody textarea');
            
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    formData.append(input.name, input.checked);
                } else {
                    formData.append(input.name, input.value);
                }
            });
            
            fetch('/save_step_config/' + currentStepIndex, {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    refreshMacroSteps();
                } else {
                    alert('ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        function closeModal() {
            document.getElementById('stepConfigModal').style.display = 'none';
        }
        
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('ë§¤í¬ë¡œê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }
        
        function clearMacro() {
            if (confirm('ëª¨ë“  ë§¤í¬ë¡œ ìŠ¤í…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        function runMacro() {
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('ì‹¤í–‰ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'});
        }
        
        function updateExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    '<div class="log-entry ' + entry.level + '">[' + entry.time + '] ' + entry.message + '</div>'
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        // ì´ˆê¸°í™”
        window.onload = function() {
            refreshMacroSteps();
            setInterval(updateExecutionLog, 1000);
        };
        
        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function(event) {
            if (event.target == document.getElementById('stepConfigModal')) {
                closeModal();
            }
        }
    </script>
</body>
</html>
'''

# API ì—”ë“œí¬ì¸íŠ¸ë“¤
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(tempfile.gettempdir(), file.filename)
        file.save(filepath)
        
        if MODULES_LOADED and app_state.excel_manager:
            app_state.excel_manager.load_file(filepath)
        
        return jsonify({'success': True, 'filename': file.filename})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    
    # ê¸°ë³¸ê°’ìœ¼ë¡œ ìŠ¤í… ì¶”ê°€
    step_data = {
        'type': step_type,
        'name': get_step_name(step_type),
        'config': get_default_config(step_type)
    }
    
    app_state.macro_steps.append(step_data)
    
    return jsonify({
        'success': True,
        'index': len(app_state.macro_steps) - 1
    })

@app.route('/get_macro')
def get_macro():
    steps_info = []
    for step in app_state.macro_steps:
        step_info = {
            'type': step['type'],
            'name': step['name'],
            'description': get_step_description(step)
        }
        steps_info.append(step_info)
    
    return jsonify({'steps': steps_info})

@app.route('/get_step_config/<int:index>')
def get_step_config(index):
    if index >= len(app_state.macro_steps):
        return jsonify({'title': 'ì˜¤ë¥˜', 'html': '<p>ì˜ëª»ëœ ì¸ë±ìŠ¤</p>'})
    
    step = app_state.macro_steps[index]
    step_type = step['type']
    config = step.get('config', {})
    
    title = f"{step['name']} ì„¤ì •"
    html = generate_config_html(step_type, config)
    
    return jsonify({'title': title, 'html': html})

@app.route('/save_step_config/<int:index>', methods=['POST'])
def save_step_config(index):
    try:
        if index >= len(app_state.macro_steps):
            return jsonify({'success': False, 'error': 'ì˜ëª»ëœ ì¸ë±ìŠ¤'})
        
        step = app_state.macro_steps[index]
        
        # í¼ ë°ì´í„°ë¥¼ configì— ì €ì¥
        for key, value in request.form.items():
            if value == 'true':
                step['config'][key] = True
            elif value == 'false':
                step['config'][key] = False
            else:
                try:
                    step['config'][key] = float(value)
                except ValueError:
                    step['config'][key] = value
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state.macro_steps):
        app_state.macro_steps.pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state.macro_steps = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state.macro_steps, f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    if not app_state.macro_steps:
        return jsonify({'success': False, 'error': 'ì‹¤í–‰í•  ë§¤í¬ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.'})
    
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œì‘", "info")
    
    # ì‹¤ì œ ì‹¤í–‰ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
    for i, step in enumerate(app_state.macro_steps):
        app_state.add_log(f"ë‹¨ê³„ {i+1}: {step['name']} ì‹¤í–‰", "info")
        # ì‹¤ì œ ì‹¤í–‰ ì½”ë“œ...
        
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ", "success")
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state.is_running = False
    app_state.add_log("ë§¤í¬ë¡œ ì¤‘ì§€ë¨", "warning")
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state.execution_log[-50:]})

# í—¬í¼ í•¨ìˆ˜ë“¤
def get_step_name(step_type):
    names = {
        'mouse_click': 'ë§ˆìš°ìŠ¤ í´ë¦­',
        'keyboard_type': 'í…ìŠ¤íŠ¸ ì…ë ¥',
        'wait_time': 'ëŒ€ê¸°',
        'image_search': 'ì´ë¯¸ì§€ ê²€ìƒ‰',
        'ocr_text': 'í…ìŠ¤íŠ¸ ê²€ìƒ‰',
        'if_condition': 'ì¡°ê±´ë¬¸'
    }
    return names.get(step_type, 'ì•Œ ìˆ˜ ì—†ìŒ')

def get_default_config(step_type):
    configs = {
        'mouse_click': {'x': 0, 'y': 0, 'button': 'left', 'click_type': 'single'},
        'keyboard_type': {'text': '', 'press_enter': False},
        'wait_time': {'seconds': 1.0},
        'image_search': {'image_path': '', 'confidence': 0.8},
        'ocr_text': {'search_text': '', 'exact_match': False},
        'if_condition': {'condition_type': 'image_found', 'value': ''}
    }
    return configs.get(step_type, {})

def get_step_description(step):
    config = step.get('config', {})
    step_type = step['type']
    
    if step_type == 'mouse_click':
        return f"({config.get('x', 0)}, {config.get('y', 0)}) í´ë¦­"
    elif step_type == 'keyboard_type':
        text = config.get('text', '')
        return f"'{text[:20]}...' ì…ë ¥" if len(text) > 20 else f"'{text}' ì…ë ¥"
    elif step_type == 'wait_time':
        return f"{config.get('seconds', 1)}ì´ˆ ëŒ€ê¸°"
    elif step_type == 'image_search':
        return "ì´ë¯¸ì§€ ê²€ìƒ‰ í›„ í´ë¦­"
    elif step_type == 'ocr_text':
        return f"'{config.get('search_text', '')}' í…ìŠ¤íŠ¸ ê²€ìƒ‰"
    elif step_type == 'if_condition':
        return f"{config.get('condition_type', '')} ì¡°ê±´"
    
    return ""

def generate_config_html(step_type, config):
    if step_type == 'mouse_click':
        return f'''
        <div class="form-group">
            <label>X ì¢Œí‘œ</label>
            <input type="number" name="x" value="{config.get('x', 0)}" required>
        </div>
        <div class="form-group">
            <label>Y ì¢Œí‘œ</label>
            <input type="number" name="y" value="{config.get('y', 0)}" required>
        </div>
        <div class="form-group">
            <label>ë§ˆìš°ìŠ¤ ë²„íŠ¼</label>
            <select name="button">
                <option value="left" {'selected' if config.get('button') == 'left' else ''}>ì™¼ìª½</option>
                <option value="right" {'selected' if config.get('button') == 'right' else ''}>ì˜¤ë¥¸ìª½</option>
            </select>
        </div>
        <div class="form-group">
            <label>í´ë¦­ íƒ€ì…</label>
            <select name="click_type">
                <option value="single" {'selected' if config.get('click_type') == 'single' else ''}>ì‹±ê¸€ í´ë¦­</option>
                <option value="double" {'selected' if config.get('click_type') == 'double' else ''}>ë”ë¸” í´ë¦­</option>
            </select>
        </div>
        '''
        
    elif step_type == 'keyboard_type':
        return f'''
        <div class="form-group">
            <label>ì…ë ¥í•  í…ìŠ¤íŠ¸</label>
            <textarea name="text" rows="3">{config.get('text', '')}</textarea>
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="press_enter" value="true" {'checked' if config.get('press_enter') else ''}>
                ì…ë ¥ í›„ Enter í‚¤ ëˆ„ë¥´ê¸°
            </label>
        </div>
        '''
        
    elif step_type == 'wait_time':
        return f'''
        <div class="form-group">
            <label>ëŒ€ê¸° ì‹œê°„ (ì´ˆ)</label>
            <input type="number" name="seconds" value="{config.get('seconds', 1.0)}" step="0.1" min="0.1" required>
        </div>
        '''
        
    elif step_type == 'image_search':
        return f'''
        <div class="form-group">
            <label>ì´ë¯¸ì§€ ê²½ë¡œ</label>
            <input type="text" name="image_path" value="{config.get('image_path', '')}" placeholder="ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ">
        </div>
        <div class="form-group">
            <label>ìœ ì‚¬ë„ (0.0 ~ 1.0)</label>
            <input type="number" name="confidence" value="{config.get('confidence', 0.8)}" step="0.1" min="0" max="1" required>
        </div>
        '''
        
    elif step_type == 'ocr_text':
        return f'''
        <div class="form-group">
            <label>ê²€ìƒ‰í•  í…ìŠ¤íŠ¸</label>
            <input type="text" name="search_text" value="{config.get('search_text', '')}">
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="exact_match" value="true" {'checked' if config.get('exact_match') else ''}>
                ì •í™•íˆ ì¼ì¹˜
            </label>
        </div>
        '''
        
    elif step_type == 'if_condition':
        return f'''
        <div class="form-group">
            <label>ì¡°ê±´ íƒ€ì…</label>
            <select name="condition_type">
                <option value="image_found" {'selected' if config.get('condition_type') == 'image_found' else ''}>ì´ë¯¸ì§€ ë°œê²¬</option>
                <option value="text_found" {'selected' if config.get('condition_type') == 'text_found' else ''}>í…ìŠ¤íŠ¸ ë°œê²¬</option>
                <option value="excel_value" {'selected' if config.get('condition_type') == 'excel_value' else ''}>Excel ê°’</option>
            </select>
        </div>
        <div class="form-group">
            <label>ë¹„êµ ê°’</label>
            <input type="text" name="value" value="{config.get('value', '')}">
        </div>
        '''
    
    return '<p>ì„¤ì •ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>'

# ë©”ì¸ ì‹¤í–‰
if __name__ == '__main__':
    print("=" * 60)
    print("Excel Macro Automation - í†µí•© ì›¹ UI (ë™ì‘ ë²„ì „)")
    print("=" * 60)
    print("\nâœ… ë§¤í¬ë¡œ ìŠ¤í… ì„¤ì • ê¸°ëŠ¥ì´ ì™„ì „íˆ êµ¬í˜„ëœ ë²„ì „ì…ë‹ˆë‹¤.")
    print("\nê¸°ëŠ¥:")
    print("- ê° ìŠ¤í…ë³„ ìƒì„¸ ì„¤ì • ê°€ëŠ¥")
    print("- ë§ˆìš°ìŠ¤ í´ë¦­: ì¢Œí‘œ, ë²„íŠ¼, í´ë¦­ íƒ€ì…")
    print("- í…ìŠ¤íŠ¸ ì…ë ¥: í…ìŠ¤íŠ¸ ë‚´ìš©, Enter í‚¤")
    print("- ëŒ€ê¸°: ëŒ€ê¸° ì‹œê°„")
    print("- ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ê²€ìƒ‰: ê²€ìƒ‰ ì¡°ê±´")
    print("- ì¡°ê±´ë¬¸: ì¡°ê±´ íƒ€ì…, ë¹„êµê°’")
    print("\në¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤...")
    print("ìˆ˜ë™ìœ¼ë¡œ ì—´ë ¤ë©´: http://localhost:5557")
    print("\nì¢…ë£Œí•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.")
    print("=" * 60)
    
    # ë¸Œë¼ìš°ì € ìë™ ì—´ê¸°
    def open_browser():
        import time
        time.sleep(1.5)
        webbrowser.open('http://localhost:5557')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask ì•± ì‹¤í–‰
    app.run(host='0.0.0.0', port=5557, debug=False)
</file>

<file path="web_ui_launcher.py">
#!/usr/bin/env python3
"""
WSL GUI ë¬¸ì œë¥¼ ìš°íšŒí•˜ëŠ” ì›¹ ê¸°ë°˜ UI ëŸ°ì²˜
ë¸Œë¼ìš°ì €ë¥¼ í†µí•´ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì œì–´í•©ë‹ˆë‹¤.
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
from pathlib import Path
from datetime import datetime

# Flask ì„¤ì¹˜ í™•ì¸
try:
    from flask import Flask, render_template_string, jsonify, request
except ImportError:
    print("Flask ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask"])
    from flask import Flask, render_template_string, jsonify, request

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

app = Flask(__name__)

# ì „ì—­ ìƒíƒœ ê´€ë¦¬
app_state = {
    "status": "ready",
    "excel_file": None,
    "macro_steps": [],
    "execution_log": []
}

# HTML í…œí”Œë¦¿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - Web UI</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .header h1 {
            color: #2196F3;
            margin-bottom: 10px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #2196F3;
            color: white;
        }
        .tab:hover {
            background: #1976D2;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 400px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #45a049;
        }
        .button.secondary {
            background: #757575;
        }
        .button.secondary:hover {
            background: #616161;
        }
        .file-input {
            margin: 20px 0;
        }
        .status-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .macro-step {
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .log-entry {
            padding: 5px 10px;
            margin: 2px 0;
            background: #f9f9f9;
            border-radius: 3px;
            font-family: monospace;
            font-size: 14px;
        }
        .log-entry.error {
            background: #ffebee;
            color: #c62828;
        }
        .log-entry.success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .step-type {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type:hover {
            background: #2196F3;
            color: white;
            transform: translateY(-2px);
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Excel Macro Automation</h1>
            <p>WSL GUI ë¬¸ì œë¥¼ ìš°íšŒí•˜ëŠ” ì›¹ ê¸°ë°˜ ì»¨íŠ¸ë¡¤ íŒ¨ë„</p>
            <div class="status-box">
                ìƒíƒœ: <span id="status">ì¤€ë¹„ë¨</span>
                <span id="loading" class="loading" style="display: none;"></span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">ğŸ“Š Excel</button>
            <button class="tab" onclick="showTab('editor')">âœï¸ Editor</button>
            <button class="tab" onclick="showTab('run')">â–¶ï¸ Run</button>
            <button class="tab" onclick="showTab('native')">ğŸ–¥ï¸ Native GUI</button>
        </div>
        
        <div class="content">
            <!-- Excel íƒ­ -->
            <div id="excel" class="panel active">
                <h2>Excel íŒŒì¼ ê´€ë¦¬</h2>
                <div class="file-input">
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">ì—…ë¡œë“œ</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor íƒ­ -->
            <div id="editor" class="panel">
                <h2>ë§¤í¬ë¡œ í¸ì§‘ê¸°</h2>
                <div class="step-palette">
                    <div class="step-type" onclick="addStep('mouse_click')">ğŸ–±ï¸ ë§ˆìš°ìŠ¤ í´ë¦­</div>
                    <div class="step-type" onclick="addStep('keyboard_type')">âŒ¨ï¸ í…ìŠ¤íŠ¸ ì…ë ¥</div>
                    <div class="step-type" onclick="addStep('wait_time')">â±ï¸ ëŒ€ê¸°</div>
                    <div class="step-type" onclick="addStep('image_search')">ğŸ” ì´ë¯¸ì§€ ê²€ìƒ‰</div>
                    <div class="step-type" onclick="addStep('ocr_text')">ğŸ”¤ í…ìŠ¤íŠ¸ ê²€ìƒ‰</div>
                    <div class="step-type" onclick="addStep('if_condition')">â“ ì¡°ê±´ë¬¸</div>
                </div>
                <h3>í˜„ì¬ ë§¤í¬ë¡œ</h3>
                <div id="macroSteps"></div>
                <button class="button" onclick="saveMacro()">ë§¤í¬ë¡œ ì €ì¥</button>
                <button class="button secondary" onclick="clearMacro()">ì´ˆê¸°í™”</button>
            </div>
            
            <!-- Run íƒ­ -->
            <div id="run" class="panel">
                <h2>ë§¤í¬ë¡œ ì‹¤í–‰</h2>
                <button class="button" onclick="runMacro()">â–¶ï¸ ì‹¤í–‰</button>
                <button class="button secondary" onclick="stopMacro()">â¹ï¸ ì¤‘ì§€</button>
                <h3>ì‹¤í–‰ ë¡œê·¸</h3>
                <div id="executionLog"></div>
            </div>
            
            <!-- Native GUI íƒ­ -->
            <div id="native" class="panel">
                <h2>ë„¤ì´í‹°ë¸Œ GUI ì‹¤í–‰ ì˜µì…˜</h2>
                <p>ì›¹ UI ëŒ€ì‹  ì›ë˜ GUIë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ ì•„ë˜ ì˜µì…˜ì„ ì‹œë„í•˜ì„¸ìš”:</p>
                
                <div style="margin: 20px 0;">
                    <h3>ì˜µì…˜ 1: X Server í™•ì¸ í›„ ì‹¤í–‰</h3>
                    <button class="button" onclick="runNative('check')">X Server ì²´í¬ & ì‹¤í–‰</button>
                    
                    <h3>ì˜µì…˜ 2: ê°€ìƒ ë””ìŠ¤í”Œë ˆì´ (Xvfb)</h3>
                    <button class="button" onclick="runNative('xvfb')">Xvfbë¡œ ì‹¤í–‰</button>
                    
                    <h3>ì˜µì…˜ 3: Windowsì—ì„œ ì§ì ‘ ì‹¤í–‰</h3>
                    <button class="button" onclick="runNative('windows')">Windows ìŠ¤í¬ë¦½íŠ¸ ìƒì„±</button>
                    
                    <h3>ì˜µì…˜ 4: ë””ë²„ê·¸ ëª¨ë“œ</h3>
                    <button class="button" onclick="runNative('debug')">ë””ë²„ê·¸ ì •ë³´ ë³´ê¸°</button>
                </div>
                
                <div id="nativeOutput" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>
    
    <script>
        let currentTab = 'excel';
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            currentTab = tabName;
        }
        
        function updateStatus(status, loading = false) {
            document.getElementById('status').textContent = status;
            document.getElementById('loading').style.display = loading ? 'inline-block' : 'none';
        }
        
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            updateStatus('Excel íŒŒì¼ ì—…ë¡œë“œ ì¤‘...', true);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                updateStatus('Excel íŒŒì¼ ë¡œë“œ ì™„ë£Œ');
                document.getElementById('excelInfo').innerHTML = 
                    `<p>íŒŒì¼ëª…: ${data.filename}</p>
                     <p>ì‹œíŠ¸: ${data.sheets.join(', ')}</p>
                     <p>í–‰ ìˆ˜: ${data.rows}</p>`;
            })
            .catch(error => {
                updateStatus('ì˜¤ë¥˜ ë°œìƒ');
                alert('ì˜¤ë¥˜: ' + error);
            });
        }
        
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
            });
        }
        
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => 
                    `<div class="macro-step">
                        ${i + 1}. ${step.name} (${step.type})
                        <button onclick="removeStep(${i})" style="float: right;">ì‚­ì œ</button>
                    </div>`
                ).join('');
            });
        }
        
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('ë§¤í¬ë¡œ ì €ì¥ ì™„ë£Œ!');
            });
        }
        
        function clearMacro() {
            if (confirm('ë§¤í¬ë¡œë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        function runMacro() {
            updateStatus('ë§¤í¬ë¡œ ì‹¤í–‰ ì¤‘...', true);
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                updateStatus('ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ');
                refreshExecutionLog();
            });
        }
        
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'})
            .then(() => {
                updateStatus('ë§¤í¬ë¡œ ì¤‘ì§€ë¨');
            });
        }
        
        function refreshExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    `<div class="log-entry ${entry.level}">[${entry.time}] ${entry.message}</div>`
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        function runNative(mode) {
            updateStatus('ë„¤ì´í‹°ë¸Œ GUI ì‹¤í–‰ ì‹œë„ ì¤‘...', true);
            fetch('/run_native/' + mode)
            .then(response => response.json())
            .then(data => {
                updateStatus(data.status);
                document.getElementById('nativeOutput').innerHTML = 
                    `<pre>${data.output}</pre>`;
            });
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        window.onload = function() {
            refreshMacroSteps();
            refreshExecutionLog();
        };
        
        // ì£¼ê¸°ì ìœ¼ë¡œ ë¡œê·¸ ì—…ë°ì´íŠ¸
        setInterval(refreshExecutionLog, 2000);
    </script>
</body>
</html>
'''

# API ì—”ë“œí¬ì¸íŠ¸ë“¤
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(project_root, 'temp_excel.xlsx')
        file.save(filepath)
        
        import pandas as pd
        xls = pd.ExcelFile(filepath)
        
        app_state['excel_file'] = filepath
        
        return jsonify({
            'success': True,
            'filename': file.filename,
            'sheets': xls.sheet_names,
            'rows': len(pd.read_excel(xls, xls.sheet_names[0]))
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    step_names = {
        'mouse_click': 'ë§ˆìš°ìŠ¤ í´ë¦­',
        'keyboard_type': 'í…ìŠ¤íŠ¸ ì…ë ¥',
        'wait_time': 'ëŒ€ê¸°',
        'image_search': 'ì´ë¯¸ì§€ ê²€ìƒ‰',
        'ocr_text': 'í…ìŠ¤íŠ¸ ê²€ìƒ‰',
        'if_condition': 'ì¡°ê±´ë¬¸'
    }
    
    app_state['macro_steps'].append({
        'type': step_type,
        'name': step_names.get(step_type, step_type)
    })
    
    return jsonify({'success': True})

@app.route('/get_macro')
def get_macro():
    return jsonify({'steps': app_state['macro_steps']})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state['macro_steps']):
        app_state['macro_steps'].pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state['macro_steps'] = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state['macro_steps'], f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    app_state['execution_log'].append({
        'time': datetime.now().strftime('%H:%M:%S'),
        'level': 'info',
        'message': 'ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œì‘'
    })
    
    # ì‹¤ì œ ë§¤í¬ë¡œ ì‹¤í–‰ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
    for i, step in enumerate(app_state['macro_steps']):
        app_state['execution_log'].append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': 'success',
            'message': f'ë‹¨ê³„ {i+1}: {step["name"]} ì‹¤í–‰ ì™„ë£Œ'
        })
    
    app_state['execution_log'].append({
        'time': datetime.now().strftime('%H:%M:%S'),
        'level': 'success',
        'message': 'ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ'
    })
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state['status'] = 'stopped'
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state['execution_log'][-50:]})  # ìµœê·¼ 50ê°œë§Œ

@app.route('/run_native/<mode>')
def run_native(mode):
    try:
        output = ""
        
        if mode == 'check':
            # X Server ì²´í¬ í›„ ì‹¤í–‰
            result = subprocess.run(['python3', 'run_main.py'], 
                                  capture_output=True, text=True, timeout=5)
            output = result.stdout + result.stderr
            status = "ì‹¤í–‰ ì‹œë„ ì™„ë£Œ"
            
        elif mode == 'xvfb':
            # Xvfbë¡œ ì‹¤í–‰
            subprocess.Popen(['xvfb-run', '-a', 'python3', 'run_main.py'])
            output = "Xvfb ê°€ìƒ ë””ìŠ¤í”Œë ˆì´ë¡œ ì‹¤í–‰ ì¤‘..."
            status = "Xvfb ì‹¤í–‰"
            
        elif mode == 'windows':
            # Windows ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
            output = "Windowsì—ì„œ ì‹¤í–‰:\n"
            output += "1. PowerShellì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰\n"
            output += "2. cd \\\\wsl.localhost\\Ubuntu\\home\\nosky\\macro\n"
            output += "3. .\\run_from_windows.ps1"
            status = "Windows ìŠ¤í¬ë¦½íŠ¸ ì•ˆë‚´"
            
        elif mode == 'debug':
            # ë””ë²„ê·¸ ì •ë³´
            output = f"DISPLAY: {os.environ.get('DISPLAY', 'Not set')}\n"
            output += f"Project Root: {project_root}\n"
            output += "Python Path: " + str(sys.path[:3])
            status = "ë””ë²„ê·¸ ì •ë³´"
            
    except Exception as e:
        output = str(e)
        status = "ì˜¤ë¥˜ ë°œìƒ"
    
    return jsonify({'status': status, 'output': output})

# ë©”ì¸ ì‹¤í–‰
if __name__ == '__main__':
    print("=" * 50)
    print("Excel Macro Automation - Web UI")
    print("=" * 50)
    print("\nWSL GUI ë¬¸ì œë¥¼ ìš°íšŒí•˜ëŠ” ì›¹ ê¸°ë°˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
    print("\në¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤...")
    print("ìˆ˜ë™ìœ¼ë¡œ ì—´ë ¤ë©´: http://localhost:5555")
    print("\nì¢…ë£Œí•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.")
    print("=" * 50)
    
    # ë¸Œë¼ìš°ì € ìë™ ì—´ê¸°
    def open_browser():
        import time
        time.sleep(1.5)
        webbrowser.open('http://localhost:5555')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask ì•± ì‹¤í–‰
    app.run(host='0.0.0.0', port=5555, debug=False)
</file>

<file path="WINDOWS_GUIDE.md">
# Windows ì‹¤í–‰ ê°€ì´ë“œ

ì´ ë¬¸ì„œëŠ” Excel ë§¤í¬ë¡œ ìë™í™” ë„êµ¬ë¥¼ Windows í™˜ê²½ì—ì„œ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## Windows ë„¤ì´í‹°ë¸Œ ì‹¤í–‰ì˜ ì¥ì 

Windowsì—ì„œ ì§ì ‘ ì‹¤í–‰í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ëª¨ë“  ê¸°ëŠ¥ì´ ì™„ì „í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤:
- í™”ë©´ ìº¡ì²˜ ë° ì´ë¯¸ì§€ ì¸ì‹
- ë§ˆìš°ìŠ¤/í‚¤ë³´ë“œ ìë™í™”
- íˆ¬ëª… ì˜¤ë²„ë ˆì´ ë Œë”ë§  
- í´ë¦½ë³´ë“œ ì ‘ê·¼
- ë©€í‹°ëª¨ë‹ˆí„° ì§€ì›

## ì‚¬ì „ ì¤€ë¹„ì‚¬í•­

1. **Python ì„¤ì¹˜**
   - [python.org](https://www.python.org/downloads/)ì—ì„œ Python 3.8 ì´ìƒ ë²„ì „ ë‹¤ìš´ë¡œë“œ
   - ì„¤ì¹˜ ì‹œ "Add Python to PATH" ì˜µì…˜ ì²´í¬ í•„ìˆ˜

2. **í”„ë¡œì íŠ¸ ìœ„ì¹˜**
   - í”„ë¡œì íŠ¸ëŠ” C:\mag\macroì— ìœ„ì¹˜
   - Cë“œë¼ì´ë¸Œì—ì„œ ì§ì ‘ ì‹¤í–‰ìœ¼ë¡œ ìµœì í™”ë¨

## ì‹¤í–‰ ë°©ë²•

### ë°©ë²• 1: ê°„ë‹¨ ì‹¤í–‰ (ê¶Œì¥)

1. Windows íƒìƒ‰ê¸°ì—ì„œ í”„ë¡œì íŠ¸ í´ë” ì—´ê¸°:
   ```
   C:\mag\macro
   ```

2. `RUN_SIMPLE.bat` ë”ë¸”í´ë¦­
   - ì¦‰ì‹œ ì‹¤í–‰
   - ì˜ì¡´ì„±ì´ ì„¤ì¹˜ë˜ì–´ ìˆì–´ì•¼ í•¨

### ë°©ë²• 2: ì™„ì „ ì„¤ì¹˜ ì‹¤í–‰

1. `WINDOWS_RUN.bat` ë”ë¸”í´ë¦­
   - ì˜ì¡´ì„± ìë™ ì„¤ì¹˜ í¬í•¨
   - ìµœì´ˆ ì‹¤í–‰ ì‹œ ê¶Œì¥

### ë°©ë²• 3: ì˜ì¡´ì„± ë³„ë„ ì„¤ì¹˜

1. `INSTALL_DEPENDENCIES.bat` ë”ë¸”í´ë¦­
   - íŒ¨í‚¤ì§€ë§Œ ì„¤ì¹˜

2. ì´í›„ `RUN_SIMPLE.bat`ë¡œ ì‹¤í–‰

### ë°©ë²• 4: Python ì§ì ‘ ì‹¤í–‰

1. ëª…ë ¹ í”„ë¡¬í”„íŠ¸ì—ì„œ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™:
   ```cmd
   cd C:\mag\macro
   ```

2. Pythonìœ¼ë¡œ ì§ì ‘ ì‹¤í–‰:
   ```cmd
   python run_main.py
   ```

### ë°©ë²• 5: ìˆ˜ë™ ì„¤ì¹˜ ë° ì‹¤í–‰

1. ê°€ìƒí™˜ê²½ ìƒì„± (ì„ íƒì‚¬í•­):
   ```cmd
   python -m venv venv
   venv\Scripts\activate
   ```

2. íŒ¨í‚¤ì§€ ì„¤ì¹˜:
   ```cmd
   pip install -r requirements.txt
   ```

5. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰:
   ```cmd
   python run_main.py
   ```

## ë¬¸ì œ í•´ê²°

### ê²½ë¡œ ê´€ë ¨ ì˜¤ë¥˜
í”„ë¡œì íŠ¸ ê²½ë¡œê°€ ì˜ëª»ëœ ê²½ìš°:

**í•´ê²°ë°©ë²•**:
- í”„ë¡œì íŠ¸ê°€ C:\mag\macroì— ìˆëŠ”ì§€ í™•ì¸
- ë°°ì¹˜ íŒŒì¼ì„ í”„ë¡œì íŠ¸ í´ë”ì—ì„œ ì‹¤í–‰

### Pythonì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
- Pythonì´ PATHì— ì¶”ê°€ë˜ì—ˆëŠ”ì§€ í™•ì¸
- `python --version` ëª…ë ¹ìœ¼ë¡œ ì„¤ì¹˜ í™•ì¸

### íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì˜¤ë¥˜
- pip ì—…ê·¸ë ˆì´ë“œ: `python -m pip install --upgrade pip`
- íŠ¹ì • íŒ¨í‚¤ì§€ ìˆ˜ë™ ì„¤ì¹˜: `pip install PyQt5`

### GUI ê´€ë ¨ ë¬¸ì œ
- Windows ë””ìŠ¤í”Œë ˆì´ ìŠ¤ì¼€ì¼ë§ ì„¤ì • í™•ì¸
- ê·¸ë˜í”½ ë“œë¼ì´ë²„ ì—…ë°ì´íŠ¸

### íŒŒì¼ ê²½ë¡œ ë¬¸ì œ
- ê²½ë¡œì— ê³µë°±ì´ ìˆìœ¼ë©´ ë”°ì˜´í‘œë¡œ ê°ì‹¸ê¸°
- ì ˆëŒ€ ê²½ë¡œ ì‚¬ìš© ê¶Œì¥

## Windows ë„¤ì´í‹°ë¸Œ ì‹¤í–‰ì˜ ì¥ì 

| ê¸°ëŠ¥ | ì¥ì  |
|------|------|
| í™”ë©´ ìº¡ì²˜ | ì™„ì „ ì§€ì› |
| ROI ì„ íƒ | ì •ìƒ ì‘ë™ |
| í´ë¦½ë³´ë“œ | ì™„ì „ ì§€ì› |
| ì„±ëŠ¥ | ë¹ ë¥¸ ì‹¤í–‰ |
| ë©€í‹°ëª¨ë‹ˆí„° | ì™„ì „ ì§€ì› |

## ê¶Œì¥ì‚¬í•­

1. **ì‹¤í–‰**: Cë“œë¼ì´ë¸Œì—ì„œ ì§ì ‘ ì‹¤í–‰
2. **í…ŒìŠ¤íŠ¸**: ë°°ì¹˜ íŒŒì¼ ì‚¬ìš©ìœ¼ë¡œ ê°„í¸í™”
3. **ë°°í¬**: Windows ì‹¤í–‰ íŒŒì¼ë¡œ íŒ¨í‚¤ì§•

## ì¶”ê°€ ë„êµ¬

Windowsì—ì„œ ë” ë‚˜ì€ ê²½í—˜ì„ ìœ„í•´:
- **Windows Terminal**: í–¥ìƒëœ í„°ë¯¸ë„ í™˜ê²½
- **PyInstaller**: ì‹¤í–‰ íŒŒì¼ ìƒì„± ë„êµ¬

---

ë¬¸ì œê°€ ë°œìƒí•˜ë©´ í”„ë¡œì íŠ¸ì˜ Issue í˜ì´ì§€ì— ë³´ê³ í•´ì£¼ì„¸ìš”.
</file>

<file path=".mcp.json">
{
  "mcpServers": {
    "vooster-ai": {
      "command": "npx",
      "args": [
        "-y",
        "--package=@vooster/mcp@latest",
        "vooster-ai",
        "--api-key=ak_arb850vwbd36cacmyp86xiah"
      ]
    },
    "playwright": {
      "command": "npx",
      "args": [
        "@playwright/mcp@latest"
      ]
    }
  }
}
</file>

<file path="prd.md">
# ì œí’ˆ ìš”êµ¬ì‚¬í•­ ë¬¸ì„œ(PRD)  
ì—‘ì…€ ê¸°ë°˜ ì‘ì—… ìë™í™” ë§¤í¬ë¡œ ë°ìŠ¤í¬íƒ‘ ì•±  

## 1. ê°œìš”  
ë³¸ ë°ìŠ¤í¬íƒ‘ ì•±ì€ ì—‘ì…€(Excel) íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ ì‚¬ìš©ìê°€ ì •ì˜í•œ ìˆœì„œëŒ€ë¡œ ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œÂ·í™”ë©´ ì¸ì‹ ë™ì‘ì„ ìë™ ìˆ˜í–‰í•˜ê³  ì™„ë£Œ ì—¬ë¶€ë¥¼ í‘œì‹œí•œë‹¤. ë¹„ê°œë°œì ì˜ë£Œì¸ì´ ë°˜ë³µì ì¸ ì»´í“¨í„° ì‘ì—…ì„ ì½”ë“œ ì‘ì„± ì—†ì´ ìë™í™”í•˜ì—¬ ì—…ë¬´ íš¨ìœ¨ì„ ê·¹ëŒ€í™”í•  ìˆ˜ ìˆë„ë¡ ì§ê´€ì  GUIë¥¼ ì œê³µí•œë‹¤.

## 2. ë¬¸ì œ ì •ì˜  
- ì˜ë£Œ í˜„ì¥Â·ì‚¬ë¬´ì‹¤ì˜ ë°˜ë³µì  ì „ì‚° ì—…ë¬´(í™˜ì ì •ë³´ ì…ë ¥, ë³´ê³ ì„œ ì—…ë¡œë“œ ë“±)ëŠ” ìˆ˜ì‘ì—… ì‹œê°„ì´ ê¸¸ê³  ì˜¤ë¥˜ ë°œìƒë¥ ì´ ë†’ìŒ.  
- ë³‘ì› ì „ì‚°íŒ€ ì§€ì›ì„ ë°›ì§€ ëª»í•˜ëŠ” ê°œì¸Â·ì†Œê·œëª¨ ê¸°ê´€ì€ ë³„ë„ ìë™í™” ì†”ë£¨ì…˜ ë„ì…ì´ ì–´ë ¤ì›€.  
- ì—‘ì…€ì— ì •ë¦¬ëœ ì‘ì—… ëª©ë¡ì„ ë°”íƒ•ìœ¼ë¡œ ìë™í™”í•˜ë ¤ í•´ë„ RPAÂ·ë§¤í¬ë¡œ íˆ´ì€ ë³µì¡í•œ ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±ì´ í•„ìš”.  

## 3. ëª©í‘œ ë° ì§€í‘œ  
- 1ì°¨ ëª©í‘œ: ì—‘ì…€â†’GUI êµ¬ì„±â†’ë§¤í¬ë¡œ ì‹¤í–‰ê¹Œì§€ 30ë¶„ ì´ë‚´ ë‹¬ì„±(ë¹„ê°œë°œì ê¸°ì¤€).  
- 2ì°¨ ëª©í‘œ: ìˆ˜ì‘ì—… ëŒ€ë¹„ ì—…ë¬´ ì‹œê°„ 50% ì´ìƒ ë‹¨ì¶•, ì˜¤ë¥˜ 90% ì´ìƒ ê°ì†Œ.  
- ì„±ê³µ ì§€í‘œ  
  - Onboarding ì™„ë£Œ ì‹œê°„ â‰¤30ë¶„ ì‚¬ìš©ì ë¹„ìœ¨ 80%  
  - ì›”ê°„ í™œì„± ì‚¬ìš©ì(MAU) â‰¥500 ì˜ë£Œì¸  
  - ì‘ì—…ë‹¹ í‰ê·  ì†Œìš” ì‹œê°„ 50%â†“  
  - ìë™í™” ì‹¤íŒ¨ìœ¨ â‰¤5%  

## 4. ëŒ€ìƒ ì‚¬ìš©ì  
### ì£¼ìš” ì‚¬ìš©ì  
- ì§êµ°: ê°„í˜¸ì‚¬Â·ì˜ë¬´ê¸°ë¡ì‚¬Â·ì˜ì‚¬Â·í–‰ì •ì›  
- íŠ¹ì„±: ì½”ë”© ì§€ì‹ ì—†ìŒ, ì—‘ì…€ ì‚¬ìš© ëŠ¥ìˆ™, ë°˜ë³µì…ë ¥Â·ì—…ë¡œë“œ ì—…ë¬´ ë¹ˆë²ˆ  
- ë‹ˆì¦ˆ: í´ë¦­Â·í‚¤ ì…ë ¥ ìë™í™”, ìƒíƒœ í™•ì¸, ì˜¤ë¥˜ ìµœì†Œí™”  

### ë¶€ìˆ˜ ì‚¬ìš©ì  
- ë³‘ì› IT ë‹´ë‹¹ì(ë°°í¬Â·íŒ¨í‚¤ì§•)  
- ì»¨ì„¤í„´íŠ¸(RPA PoC)  

## 5. ì‚¬ìš©ì ìŠ¤í† ë¦¬  
- â€œê°„í˜¸ì‚¬ë¡œì„œ í™˜ì 100ëª…ì˜ ê²€ì‚¬ ê²°ê³¼ë¥¼ ë³‘ì› í¬í„¸ì— ë“±ë¡í•˜ë ¤ê³  ì—‘ì…€ ëª©ë¡ì„ ë¶ˆëŸ¬ì™€ í´ë¦­Â·ì…ë ¥ì„ ìë™í™”í•˜ì—¬ ì‹œê°„ì„ ì ˆì•½í•˜ê³  ì‹¶ë‹¤.â€  
- â€œì˜ë¬´ê¸°ë¡ì‚¬ë¡œì„œ ì™„ë£Œë˜ì§€ ì•Šì€ í–‰ë§Œ ì¬ì‹¤í–‰í•´ ëˆ„ë½ ì—†ì´ ê¸°ë¡ì„ ë§ˆê°í•˜ê³  ì‹¶ë‹¤.â€  
- â€œí–‰ì •ì›ìœ¼ë¡œì„œ íŠ¹ì • ë²„íŠ¼ ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚˜ì•¼ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ë„ë¡ ì¡°ê±´ë¶€ ë¡œì§ì„ ì„¤ì •í•˜ê³  ì‹¶ë‹¤.â€  

## 6. ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­  
### 6.1 í•µì‹¬ ê¸°ëŠ¥  
1. ì—‘ì…€ ì—°ë™  
   - íŒŒì¼ ì„ íƒ í›„ ì‹œíŠ¸Â·ì—´ ë§¤í•‘ UI ì œê³µ  
   - ì§€ì • ì—´ì˜ ë°ì´í„° ë¯¸ë¦¬ë³´ê¸° ë° íƒ€ì… ê²€ì¦  
   - ì‹¤í–‰ í›„ ìƒíƒœ ì—´ ìë™ ì—…ë°ì´íŠ¸(ì™„ë£Œ/ì‹¤íŒ¨/ì‚¬ìš©ì ì •ì˜ í…ìŠ¤íŠ¸)  
   - ìˆ˜ë½ ê¸°ì¤€: ì˜ëª»ëœ ê²½ë¡œÂ·ì‹œíŠ¸ ì§€ì • ì‹œ ì˜¤ë¥˜ ì•Œë¦¼, ìƒíƒœ ì—´ì´ ì—†ëŠ” ê²½ìš° ìë™ ìƒì„±  

2. GUI ê¸°ë°˜ ì‘ì—… í¸ì§‘ê¸°  
   - Drag & Drop ë°©ì‹ ë‹¨ê³„ í¸ì§‘ íŒ¨ë„  
   - ì§€ì› ë™ì‘  
     â‘  ë§ˆìš°ìŠ¤: ì´ë™Â·í´ë¦­Â·ë”ë¸”í´ë¦­Â·ë“œë˜ê·¸  
     â‘¡ í‚¤ë³´ë“œ: í…ìŠ¤íŠ¸Â·íŠ¹ìˆ˜í‚¤Â·ë‹¨ì¶•í‚¤(ì¡°í•©)  
â‘¢ í™”ë©´ ì¸ì‹: ì´ë¯¸ì§€ ì„œì¹˜(OpenCV), OCR(EasyOCR)
â‘£ ë™ì  í…ìŠ¤íŠ¸ ê²€ìƒ‰ ë° í´ë¦­(Dynamic Text Search & Click)
   - ê°„í¸í•œ í™”ë©´ ì˜ì—­ ì„¤ì •: ì‚¬ìš©ìê°€ 'ì˜ì—­ ì§€ì •' ë²„íŠ¼ì„ ëˆ„ë¥´ë©´, í™”ë©´ì´ ë°˜íˆ¬ëª…í•˜ê²Œ ë³€í•˜ë©° ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸í•˜ì—¬ ê²€ìƒ‰í•  ì‚¬ê°í˜• ì˜ì—­ì„ ì†ì‰½ê²Œ ì§€ì •í•  ìˆ˜ ìˆìŒ(í™”ë©´ ìº¡ì²˜ ë„êµ¬ì²˜ëŸ¼)
   - ì§€ì •ëœ ì˜ì—­ì˜ ì¢Œí‘œëŠ” ì‘ì—… ë‹¨ê³„ì— ìë™ìœ¼ë¡œ ì €ì¥
   - ì—‘ì…€ ë°ì´í„° ê¸°ë°˜ í…ìŠ¤íŠ¸ ê²€ìƒ‰ ë° í´ë¦­: ì‚¬ìš©ìëŠ” ì‘ì—… íë¦„ì— "ë™ì  í…ìŠ¤íŠ¸ ì°¾ê¸°" ë‹¨ê³„ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŒ
   - ì´ ë‹¨ê³„ì—ì„œ ì—‘ì…€ì˜ íŠ¹ì • ì—´(e.g., 'ì´ë¦„' ë˜ëŠ” 'ë³‘ë ¥ë²ˆí˜¸' ì—´)ì„ ì§€ì •
   - ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œ, í”„ë¡œê·¸ë¨ì€ ë¯¸ë¦¬ ì§€ì •ëœ í™”ë©´ ì˜ì—­ ì•ˆì—ì„œ í˜„ì¬ ì‘ì—… ìˆœì„œì— í•´ë‹¹í•˜ëŠ” ì—‘ì…€ì˜ í…ìŠ¤íŠ¸(e.g., "í™ê¸¸ë™")ë¥¼ OCR(EasyOCR)ë¡œ ì°¾ì•„ëƒ„
   - í•´ë‹¹ í…ìŠ¤íŠ¸ë¥¼ ì°¾ìœ¼ë©´ ê·¸ ì¢Œí‘œë¥¼ ìë™ìœ¼ë¡œ í´ë¦­í•˜ê±°ë‚˜, ë‹¤ìŒ ë™ì‘ì˜ ê¸°ì¤€ì ìœ¼ë¡œ ì‚¬ìš©
â‘¤ íë¦„ ì œì–´: DelayÂ·LoopÂ·If(ì¡°ê±´)
   - ì—‘ì…€ ë³€ìˆ˜ ë°”ì¸ë”©(ì˜ˆ: {{ì´ë¦„}}) í…œí”Œë¦¿ ì§€ì›  
   - ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°Â·í…ŒìŠ¤íŠ¸ ì‹¤í–‰  
   - ìˆ˜ë½ ê¸°ì¤€: ë‹¨ê³„ ì¶”ê°€Â·ì‚­ì œÂ·ìˆœì„œë³€ê²½ì´ 3í´ë¦­ ì´ë‚´, ë¯¸ë¦¬ë³´ê¸° ì˜¤ë¥˜ìœ¨ â‰¤5%  

3. ë§¤í¬ë¡œ ì‹¤í–‰/ì œì–´  
   - í–‰ ë‹¨ìœ„ ìˆœì°¨ ì‹¤í–‰, â€œë¯¸ì™„ë£Œë§Œ ì‹¤í–‰â€ ì˜µì…˜  
   - ì¼ì‹œì •ì§€Â·ê°•ì œì¢…ë£Œ í•«í‚¤(ê¸°ë³¸ F9, Esc)  
   - ì‹¤í–‰ ë¡œê·¸: í–‰ ë²ˆí˜¸, ë‹¨ê³„, ì„±ê³µ/ì‹¤íŒ¨, ì†Œìš”ì‹œê°„(ms) CSV ì €ì¥  
   - ìˆ˜ë½ ê¸°ì¤€: 10,000í–‰ ì²˜ë¦¬ ì‹œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì—†ì´ ì™„ë£Œ  

### 6.2 ë³´ì¡° ê¸°ëŠ¥  
- ì‘ì—… í…œí”Œë¦¿ ê°¤ëŸ¬ë¦¬(ë¡œê·¸ì¸ ë¶ˆí•„ìš”, ë¡œì»¬ ì €ì¥)  
- ë‹¤êµ­ì–´ UI(í•œêµ­ì–´ ê¸°ë³¸, ì˜ì–´ ì„ íƒ)  
- ìë™ ì—…ë°ì´íŠ¸ ì²´í¬  
- ë‹¤í¬ëª¨ë“œ  

### 6.3 Nice-to-Have ì œì•ˆ  
- ìŒì„± ëª…ë ¹ìœ¼ë¡œ ë§¤í¬ë¡œ ì‹œì‘/ì •ì§€  
- ì‘ì—… ìŠ¤ì¼€ì¤„ëŸ¬(íŠ¹ì • ì‹œê°„ì— ìë™ ì‹¤í–‰)  
- í´ë¼ìš°ë“œ ë™ê¸°í™”ë¡œ ì—¬ëŸ¬ PC ì„¤ì • ê³µìœ   
- ì˜¤ë¥˜ ë°œìƒ ì‹œ ìŠ¤í¬ë¦°ìƒ· ìë™ ì²¨ë¶€ ë¦¬í¬íŠ¸  

## 7. ë¹„ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­  
- ì„±ëŠ¥: 1ë‹¨ê³„ ì‹¤í–‰ ì‘ë‹µ â‰¤300ms, 500ë‹¨ê³„/í–‰ ì²˜ë¦¬ ì‹œ CPU ì‚¬ìš©ë¥  50%â†“  
- ë³´ì•ˆ: ë¡œì»¬ íŒŒì¼Â·ìŠ¤í¬ë¦½íŠ¸ ì•”í˜¸í™” ì €ì¥(AES-256), ë„¤íŠ¸ì›Œí¬ ì „ì†¡ ì—†ìŒ ê¸°ë³¸  
- ì‚¬ìš©ì„±: ì˜¨ë³´ë”© íŠœí† ë¦¬ì–¼ 5ë¶„, UI ì ‘ê·¼ì„± WCAG 2.1 AA  
- í™•ì¥ì„±: í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜ë¡œ ìƒˆ ë™ì‘ íƒ€ì… ì¶”ê°€ ê°€ëŠ¥  
- í˜¸í™˜ì„±: Windows 10/11 64bit, í•´ìƒë„ 1280Ã—720 ì´ìƒ  

## 8. ê¸°ìˆ  ê³ ë ¤ì‚¬í•­  
- ì–¸ì–´: Python 3.8+  
- GUI: PyQt5(ê¶Œì¥), Fallback Tkinter  
- ìë™í™”: PyAutoGUI  
- ì´ë¯¸ì§€: OpenCV 4.x  
- OCR: EasyOCR
- ì—‘ì…€: pandas, openpyxl  
- íŒ¨í‚¤ì§•: PyInstaller(onefile)  
- êµ¬ì¡°: MVC íŒ¨í„´, ì‘ì—… ë‹¨ê³„ëŠ” JSON ì •ì˜ ì €ì¥
- ë©€í‹°/ì‹±ê¸€ ëª¨ë‹ˆí„° í™˜ê²½ ìë™ ì¸ì‹ ë° ì£¼ ëª¨ë‹ˆí„° ê¸°ì¤€ ë™ì‘ ë³´ì¥
- í†µí•©: ë³‘ì› ì‚¬ë‚´ë§ ì œí•œ í™˜ê²½ ê³ ë ¤, ì¸í„°ë„· í•„ìš” ì—†ìŒ  

## 9. ì„±ê³µ ì§€í‘œ  
- ê¸°ëŠ¥ ì§€í‘œ: ë§¤í¬ë¡œ ì™„ë£Œìœ¨ â‰¥95%, ë¡œê·¸ ì˜¤ë¥˜ìœ¨ â‰¤2%  
- ì‚¬ìš©ì ì§€í‘œ: NPSâ‰¥50, ì¬ë°©ë¬¸ë¥  70%  
- ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œ: ë¼ì´ì„ ìŠ¤ ì—…ì…€ ë¹„ìœ¨ 20%  
- ê¸°ìˆ  ì§€í‘œ: í‰ê·  ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ â‰¤500MB, í¬ë˜ì‹œ 0.1/ì„¸ì…˜â†“  

## 10. ì¼ì • ë° ë§ˆì¼ìŠ¤í†¤  
- 1ë‹¨ê³„(MVP, 3ê°œì›”)  
  - ì—‘ì…€ ë¶ˆëŸ¬ì˜¤ê¸°, ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œ ë™ì‘, ìˆœì°¨ ì‹¤í–‰, ìƒíƒœ ì—…ë°ì´íŠ¸  
- 2ë‹¨ê³„(ê³ ë„í™”, +2ê°œì›”)  
  - ì´ë¯¸ì§€ ì„œì¹˜, OCR, ì¡°ê±´Â·ë°˜ë³µ, ë¡œê·¸ ë·°ì–´  
- 3ë‹¨ê³„(í™•ì¥, +2ê°œì›”)  
  - í…œí”Œë¦¿ ê°¤ëŸ¬ë¦¬, ë‹¤êµ­ì–´, ìë™ ì—…ë°ì´íŠ¸, ë‹¤í¬ëª¨ë“œ  
- 4ë‹¨ê³„(NTH, +3ê°œì›”)  
  - ìŒì„± ëª…ë ¹, ìŠ¤ì¼€ì¤„ëŸ¬, í´ë¼ìš°ë“œ ì‹±í¬  

## 11. ìœ„í—˜ ë° ì™„í™”  
- ê¸°ìˆ : í™”ë©´ í•´ìƒë„ ë° ë©€í‹°/ì‹±ê¸€ ëª¨ë‹ˆí„° í™˜ê²½ì—ì„œ ì´ë¯¸ì§€ ë§¤ì¹­Â·ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥ â†’ DPI ìŠ¤ì¼€ì¼ ë³´ì • ì•Œê³ ë¦¬ì¦˜ ë° ë©€í‹° ëª¨ë‹ˆí„° íƒì§€, ì¢Œí‘œ ì¼ì¹˜ ë¡œì§ ì ìš©
- ë¹„ì¦ˆë‹ˆìŠ¤: ì˜ë£Œê¸°ê´€ ë³´ì•ˆ ì •ì±…ìœ¼ë¡œ ì‹¤í–‰ íŒŒì¼ ì°¨ë‹¨ â†’ ì˜¤í”„ë¼ì¸ ì„¤ì¹˜ íŒ¨í‚¤ì§€Â·ì„œëª… ë°°í¬  
- ì‚¬ìš©ì: ë¹„ê°œë°œì í˜¼ë€ â†’ ì¸ì•± ê°€ì´ë“œÂ·íˆ´íŒÂ·ì˜ìƒ ì œê³µ  

## 12. í–¥í›„ ê³ ë ¤ì‚¬í•­  
- MacÂ·ë¦¬ëˆ…ìŠ¤ ë²„ì „  
- AI ê¸°ë°˜ ìë™ ë‹¨ê³„ ì¶”ì²œ(ì‚¬ìš© íŒ¨í„´ í•™ìŠµ)  
- HIPAAÂ·GDPR ë“± ì˜ë£Œ ë°ì´í„° ê·œì • ì¤€ìˆ˜ ëª¨ë“ˆ  
- SaaS RPA ì—°ê³„ API ê³µê°œ  

(ë¬¸ì„œ ê¸¸ì´: ì•½ 4,100ì)
</file>

<file path="requirements.txt">
# Core GUI Framework
PyQt5>=5.15.0

# Data Processing
pandas>=1.3.0
openpyxl>=3.0.0
numpy>=1.21.0

# Screen Automation
pyautogui>=0.9.53
pillow>=8.3.0
opencv-python>=4.5.0

# Screen Information
screeninfo>=0.8.0

# Image Processing
mss>=6.1.0

# OCR (Optical Character Recognition)
easyocr>=1.7.0

# Security
cryptography>=3.4.0

# Development tools (optional)
black>=21.0
flake8>=3.9.0
</file>

<file path="run_main.py">
#!/usr/bin/env python3
"""
ì‹¤ì œ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
ëª¨ë“  import ë¬¸ì œë¥¼ í•´ê²°í•˜ì—¬ ì‹¤í–‰
"""

import sys
import os
from pathlib import Path

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python ê²½ë¡œì— ì¶”ê°€
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
if sys.platform == 'win32':
    os.environ['QT_QPA_PLATFORM'] = 'windows'
else:
    os.environ['QT_QPA_PLATFORM'] = 'xcb'
os.environ['PYTHONPATH'] = f"{project_root}:{src_path}"
os.environ['PYTHONIOENCODING'] = 'utf-8'

# ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½í•˜ê¸° ìœ„í•œ monkey patching
def patch_imports():
    """ëª¨ë“  ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½"""
    
    # settings.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    settings_file = src_path / "config" / "settings.py"
    content = settings_file.read_text(encoding='utf-8')
    content = content.replace("from ..utils.encryption", "from utils.encryption")
    content = content.replace("from ..logger.app_logger", "from logger.app_logger")
    settings_file.write_text(content, encoding='utf-8')
    
    # main_window.pyì˜ ìƒëŒ€ import ìˆ˜ì •  
    main_window_file = src_path / "ui" / "main_window.py"
    if main_window_file.exists():
        content = main_window_file.read_text(encoding='utf-8')
        content = content.replace("from ..config.settings", "from config.settings")
        content = content.replace("from ..logger.app_logger", "from logger.app_logger")
        content = content.replace("from .widgets.excel_widget", "from ui.widgets.excel_widget")
        content = content.replace("from .widgets.macro_editor", "from ui.widgets.macro_editor")
        content = content.replace("from .widgets.execution_widget", "from ui.widgets.execution_widget")
        main_window_file.write_text(content, encoding='utf-8')
    
    # excel_widget.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    excel_widget_file = src_path / "ui" / "widgets" / "excel_widget.py"
    if excel_widget_file.exists():
        content = excel_widget_file.read_text(encoding='utf-8')
        content = content.replace("from ...excel.excel_manager", "from excel.excel_manager")
        content = content.replace("from ...config.settings", "from config.settings")
        content = content.replace("from ...logger.app_logger", "from logger.app_logger")
        excel_widget_file.write_text(content, encoding='utf-8')
    
    # macro_editor.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    macro_editor_file = src_path / "ui" / "widgets" / "macro_editor.py"
    if macro_editor_file.exists():
        content = macro_editor_file.read_text(encoding='utf-8')
        content = content.replace("from ...core", "from core")
        content = content.replace("from ..dialogs", "from ui.dialogs")
        macro_editor_file.write_text(content, encoding='utf-8')
    
    # execution_widget.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    execution_widget_file = src_path / "ui" / "widgets" / "execution_widget.py"
    if execution_widget_file.exists():
        content = execution_widget_file.read_text(encoding='utf-8')
        content = content.replace("from ...automation", "from automation")
        content = content.replace("from ...core", "from core")
        content = content.replace("from ...config", "from config")
        content = content.replace("from ...logger", "from logger")
        execution_widget_file.write_text(content, encoding='utf-8')
    
    # ë‹¤ë¥¸ íŒŒì¼ë“¤ë„ ìˆ˜ì •
    for py_file in src_path.rglob("*.py"):
        try:
            content = py_file.read_text(encoding='utf-8')
            if "from .." in content:
                # ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½
                content = content.replace("from ...", "from ")
                content = content.replace("from ..", "from ")
                py_file.write_text(content, encoding='utf-8')
        except:
            pass

# Import ìˆ˜ì • ì ìš©
print("Import ê²½ë¡œ ìˆ˜ì • ì¤‘...")
patch_imports()
print("Import ê²½ë¡œ ìˆ˜ì • ì™„ë£Œ!")

# ì´ì œ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    from PyQt5.QtGui import QFont
    
    # High DPI ì§€ì› - QApplication ìƒì„± ì „ì— ì„¤ì •
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # í•œê¸€ í°íŠ¸ ì„¤ì •
    font = QFont("Nanum Gothic", 10)
    app.setFont(font)
    
    # ë©”ì¸ ìœˆë„ìš° import ë° ì‹¤í–‰
    from ui.main_window import MainWindow
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    # ë¡œê±° ì„¤ì •
    logger = setup_logger()
    logger.info("Starting Excel Macro Automation Application")
    
    # ì„¤ì • ì´ˆê¸°í™”
    settings = Settings()
    
    # ë©”ì¸ ìœˆë„ìš° ìƒì„± ë° í‘œì‹œ
    window = MainWindow(settings)
    window.setWindowTitle("Excel ê¸°ë°˜ ì‘ì—… ìë™í™” ë§¤í¬ë¡œ")
    window.show()
    
    print("\nâœ“ Excel Macro Automation ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
    print("âœ“ ëª¨ë“  GUI ì»´í¬ë„ŒíŠ¸ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.")
    print("\nê¸°ëŠ¥:")
    print("- Excel íƒ­: íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°, ì‹œíŠ¸ ì„ íƒ, ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°")
    print("- Editor íƒ­: ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë§¤í¬ë¡œ í¸ì§‘")
    print("- Run íƒ­: ë§¤í¬ë¡œ ì‹¤í–‰ ë° ëª¨ë‹ˆí„°ë§")
    print("\nì°½ì„ ë‹«ìœ¼ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.")
    
    # ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"\nì˜¤ë¥˜ ë°œìƒ: {e}")
    print("\nìì„¸í•œ ì˜¤ë¥˜ ì •ë³´:")
    import traceback
    traceback.print_exc()
    
    print("\në””ë²„ê¹… ì •ë³´:")
    print(f"Project root: {project_root}")
    print(f"Src path: {src_path}")
    print(f"Python path: {sys.path[:3]}")
</file>

<file path="run_simple.py">
#!/usr/bin/env python3
"""
ê°„ë‹¨í•œ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸ - import ë¬¸ì œ í•´ê²°
"""

import sys
import os
from pathlib import Path

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python ê²½ë¡œì— ì¶”ê°€
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
if sys.platform == 'win32':
    os.environ['QT_QPA_PLATFORM'] = 'windows'
elif sys.platform.startswith('linux'):
    os.environ['QT_QPA_PLATFORM'] = 'xcb'
    if 'DISPLAY' not in os.environ:
        os.environ['DISPLAY'] = ':0'

print("Excel Macro Automation ì‹œì‘...")

try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    
    # High DPI ì„¤ì •
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒì„±
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # ì„¤ì • ë° ë¡œê±° ì´ˆê¸°í™”
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    settings = Settings()
    logger = setup_logger()
    
    # ë©”ì¸ ìœˆë„ìš° ìƒì„±
    from ui.main_window import MainWindow
    window = MainWindow(settings)
    
    # ìœˆë„ìš° í‘œì‹œ
    window.show()
    
    print("âœ“ GUIê°€ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
    print("ì¢…ë£Œí•˜ë ¤ë©´ ì°½ì„ ë‹«ìœ¼ì„¸ìš”.")
    
    # ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"\nì˜¤ë¥˜ ë°œìƒ: {e}")
    import traceback
    traceback.print_exc()
    input("\nEnterë¥¼ ëˆŒëŸ¬ ì¢…ë£Œ...")
</file>

<file path="src/core/__init__.py">
"""
Core business logic module
"""

from core.macro_types import (
    MacroStep, StepType, MouseButton, ConditionOperator,
    MouseClickStep, MouseMoveStep,
    KeyboardTypeStep, KeyboardHotkeyStep, 
    WaitTimeStep, WaitImageStep, TextSearchStep,
    IfConditionStep, LoopStep,
    Macro, StepFactory
)

from core.macro_storage import MacroStorage

__all__ = [
    # Types and Enums
    'MacroStep', 'StepType', 'MouseButton', 'ConditionOperator',
    
    # Step Classes
    'MouseClickStep', 'MouseMoveStep',
    'KeyboardTypeStep', 'KeyboardHotkeyStep',
    'WaitTimeStep', 'WaitImageStep', 'TextSearchStep',
    'IfConditionStep', 'LoopStep',
    
    # Main Classes
    'Macro', 'StepFactory', 'MacroStorage'
]
</file>

<file path="src/ui/widgets/simple_roi_selector.py">
"""
Simple ROI selector using screenshot approach
"""

import os
import time
from typing import Optional, Tuple
from PyQt5.QtWidgets import QWidget, QLabel, QRubberBand
from PyQt5.QtCore import Qt, QRect, QPoint, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor, QCursor
import pyautogui


class SimpleROISelector(QWidget):
    """Simple ROI selector that uses screenshot approach"""
    
    selectionComplete = pyqtSignal(tuple)  # (x, y, width, height)
    selectionCancelled = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Selection state
        self.origin = QPoint()
        self.rubber_band = None
        self.screenshot_pixmap = None
        
        # Setup window
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setWindowState(Qt.WindowFullScreen)
        self.setCursor(Qt.CrossCursor)
        
        # Instructions label
        self.label = QLabel(self)
        self.label.setText("ë“œë˜ê·¸í•˜ì—¬ ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”. ESC: ì·¨ì†Œ")
        self.label.setStyleSheet("""
            QLabel {
                background-color: rgba(0, 0, 0, 180);
                color: white;
                padding: 10px;
                font-size: 16px;
                font-weight: bold;
            }
        """)
        self.label.adjustSize()
        self.label.move(10, 10)
        
    def start_selection(self):
        """Start ROI selection"""
        # Take screenshot first
        try:
            # Hide any windows
            QTimer.singleShot(100, self._take_screenshot)
        except Exception as e:
            print(f"Screenshot error: {e}")
            self.selectionCancelled.emit()
            self.close()
            
    def _take_screenshot(self):
        """Take screenshot and show selector"""
        try:
            # Take screenshot using pyautogui
            screenshot = pyautogui.screenshot()
            
            # Convert to QPixmap
            import io
            from PIL import Image
            
            # Save to bytes
            buffer = io.BytesIO()
            screenshot.save(buffer, format='PNG')
            buffer.seek(0)
            
            # Load as QPixmap
            self.screenshot_pixmap = QPixmap()
            self.screenshot_pixmap.loadFromData(buffer.read())
            
            # Set window size to screen size
            self.resize(self.screenshot_pixmap.size())
            
            # Show window
            self.show()
            self.raise_()
            self.activateWindow()
            
        except Exception as e:
            print(f"Screenshot error: {e}")
            self.selectionCancelled.emit()
            self.close()
            
    def paintEvent(self, event):
        """Paint screenshot as background"""
        if self.screenshot_pixmap:
            painter = QPainter(self)
            painter.drawPixmap(0, 0, self.screenshot_pixmap)
            
            # Darken the screenshot slightly (reduced from 50 to 30 for better visibility)
            painter.fillRect(self.rect(), QColor(0, 0, 0, 30))
            
    def mousePressEvent(self, event):
        """Handle mouse press"""
        if event.button() == Qt.LeftButton:
            self.origin = event.pos()
            
            if not self.rubber_band:
                self.rubber_band = QRubberBand(QRubberBand.Rectangle, self)
                self.rubber_band.setStyleSheet("""
                    QRubberBand {
                        border: 2px solid rgb(50, 150, 250);
                        background-color: rgba(50, 150, 250, 30);
                    }
                """)
                
            self.rubber_band.setGeometry(QRect(self.origin, event.pos()))
            self.rubber_band.show()
            
    def mouseMoveEvent(self, event):
        """Handle mouse move"""
        if self.rubber_band and event.buttons() == Qt.LeftButton:
            self.rubber_band.setGeometry(QRect(self.origin, event.pos()).normalized())
            
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() == Qt.LeftButton and self.rubber_band:
            rect = self.rubber_band.geometry()
            
            if rect.width() > 5 and rect.height() > 5:
                # Emit the selection - ensure all values are integers
                region = (int(rect.x()), int(rect.y()), int(rect.width()), int(rect.height()))
                self.selectionComplete.emit(region)
            
            self.close()
            
    def keyPressEvent(self, event):
        """Handle key press"""
        if event.key() == Qt.Key_Escape:
            self.selectionCancelled.emit()
            self.close()
            
    def close(self):
        """Clean up and close"""
        if self.rubber_band:
            self.rubber_band.hide()
        super().close()
</file>

<file path="src/vision/__init__.py">
"""
Vision module for image recognition and text extraction
"""

from vision.image_matcher import ImageMatcher, MatchResult
from vision.text_extractor import TextExtractor, TextResult

__all__ = ['ImageMatcher', 'MatchResult', 'TextExtractor', 'TextResult']
</file>

<file path="trd.md">
# Technical Requirements Document (TRD)

## 1. Executive Technical Summary
- **í”„ë¡œì íŠ¸ ê°œìš”**  
  Python ê¸°ë°˜ ë°ìŠ¤í¬íƒ‘ ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ, ì—‘ì…€ íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ GUIë¡œ ë¡œë“œÂ·í¸ì§‘í•˜ê³  PyAutoGUI/OpenCV/Tesseractë¥¼ ì´ìš©í•´ ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œÂ·í™”ë©´ ì¸ì‹ ë§¤í¬ë¡œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤. MVC íŒ¨í„´ì„ ì ìš©í•´ ìœ ì§€ ë³´ìˆ˜ì„±ê³¼ í™•ì¥ì„±ì„ í™•ë³´í•˜ë©°, ì˜¤í”„ë¼ì¸ í™˜ê²½ì—ì„œ ë‹¨ì¼ íŒŒì¼ ë°°í¬ ë°©ì‹(PyInstaller)ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

- **í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ**  
Python 3.8+, PyQt5(Tkinter ëŒ€ì²´), PyAutoGUI, OpenCV 4.x, EasyOCR, pandas, openpyxl, PyInstaller

- **ì£¼ìš” ê¸°ìˆ  ëª©í‘œ**  
  â€¢ 1ë‹¨ê³„ ì‹¤í–‰ ì‘ë‹µ â‰¤300ms  
  â€¢ 10,000í–‰ ì²˜ë¦¬ ì‹œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì—†ì´ ì™„ë£Œ  
  â€¢ CPU ì‚¬ìš©ë¥  500ë‹¨ê³„/í–‰ ì²˜ë¦¬ ì‹œ 50% ì´í•˜ ìœ ì§€  
  â€¢ ìë™í™” ì‹¤íŒ¨ìœ¨ â‰¤5%  

- **ì¤‘ìš” ê°€ì • ì‚¬í•­**  
  â€¢ Windows 10/11 64bit ì „ìš©  
  â€¢ ì¸í„°ë„· ì—°ê²° ì—†ì´ ì˜¤í”„ë¼ì¸ ì‹¤í–‰  
  â€¢ ë‹¨ì¼ ì‚¬ìš©ì í™˜ê²½(ë¡œì»¬ íŒŒì¼ ì €ì¥)  
  â€¢ DPI ìŠ¤ì¼€ì¼ & ë©€í‹° ëª¨ë‹ˆí„° í™˜ê²½ ìë™ ì¸ì‹  

---

## 2. Tech Stack

| Category         | Technology / Library   | Reasoning (ì„ íƒ ì´ìœ )                                    |
| ---------------- | ---------------------- | ------------------------------------------------------- |
| ì–¸ì–´             | Python 3.8+            | í’ë¶€í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ ì»¤ë®¤ë‹ˆí‹°, ë¹ ë¥¸ ê°œë°œ ì†ë„              |
| GUI í”„ë ˆì„ì›Œí¬   | PyQt5                  | ì§ê´€ì  WYSIWYG ì—ë””í„°, í’ë¶€í•œ ìœ„ì ¯, ë°˜ì‘í˜• ë ˆì´ì•„ì›ƒ ì§€ì›  |
| GUI ëŒ€ì²´         | Tkinter                | PyQt5 ë¹„ì„¤ì¹˜ ì‹œ ê¸°ë³¸ ì œê³µ, ìµœì†Œ ê¸°ëŠ¥ ë³´ì¥                |
| ìë™í™” ì—”ì§„      | PyAutoGUI              | ë§ˆìš°ìŠ¤/í‚¤ë³´ë“œ ì œì–´, í¬ë¡œìŠ¤ í”Œë«í¼ ì§€ì›                   |
| ì´ë¯¸ì§€ ì²˜ë¦¬      | OpenCV 4.x             | ê³ ì„±ëŠ¥ ì´ë¯¸ì§€ ì„œì¹˜ ë° DPI ìŠ¤ì¼€ì¼ ë³´ì •                     |
| OCR ì—”ì§„         | EasyOCR                | í•œê¸€ ì¸ì‹ ì •í™•ë„ê°€ ë†’ê³ , Tesseract ëŒ€ë¹„ ì‹¤íŒ¨ìœ¨ì´ ë‚®ìŒ. íŒŒì´ì¬ ì—°ë™ë„ ë§¤ìš° ê°„í¸í•¨. |
| ì—‘ì…€ ì²˜ë¦¬        | pandas, openpyxl       | ëŒ€ìš©ëŸ‰ ì—‘ì…€ ë°ì´í„° ì²˜ë¦¬, ì‹œíŠ¸Â·ì…€ CRUD ì§€ì›               |
| íŒ¨í‚¤ì§•           | PyInstaller (onefile)  | ë‹¨ì¼ ì‹¤í–‰ íŒŒì¼ ë°°í¬, ì˜¤í”„ë¼ì¸ ì„¤ì¹˜ ì§€ì›                 |
| êµ¬ì¡° íŒ¨í„´        | MVC                    | ì—­í•  ë¶„ë¦¬ë¡œ ìœ ì§€ë³´ìˆ˜ì„±Â·í™•ì¥ì„± í™•ë³´                        |
| ì„¤ì •Â·ì •ì˜ ì €ì¥   | JSON                   | ê°€ë³ê³  ê°€ë…ì„± ë†’ì€ ë§¤í¬ë¡œ ë‹¨ê³„ ì •ì˜ íŒŒì¼                  |

---

## 3. System Architecture Design

### Top-Level Building Blocks
- UI Layer (PyQt5/Tkinter)  
  â€¢ ì‘ì—… í¸ì§‘ê¸°, ì‹œíŠ¸Â·ì—´ ë§¤í•‘, ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°  
- Core Controller  
  â€¢ ì‚¬ìš©ì ì¸í„°ë™ì…˜ ì²˜ë¦¬, ë§¤í¬ë¡œ ë‹¨ê³„ ì¡°í•©, ìƒíƒœ ê´€ë¦¬  
- Automation Engine  
  â€¢ PyAutoGUI ê¸°ë°˜ ë™ì‘ ì‹¤í–‰, OpenCV ì´ë¯¸ì§€ ì„œì¹˜, EasyOCR ì—”ì§„ OCR  
- Data Access Layer  
  â€¢ pandas/openpyxlë¡œ ì—‘ì…€ ì…ì¶œë ¥, ë¡œê·¸(CSV) ì €ì¥  
- Config & Plugin Manager  
  â€¢ JSON ê¸°ë°˜ í”ŒëŸ¬ê·¸ì¸/ë‹¨ê³„ ì •ì˜ ë¡œë”©, ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤  
- Packaging & Deployment  
  â€¢ PyInstaller ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸, AES-256 ì•”í˜¸í™” ì˜µì…˜  

### Top-Level Component Interaction Diagram
```mermaid
graph TD
    U[UI Layer] --> C[Core Controller]
    C --> A[Automation Engine]
    C --> D[Data Access Layer]
    A --> I[Image/OCR]
    D --> E[Excel Files]
    D --> L[Log CSV]
```

- UI Layerì—ì„œ Core Controllerë¡œ ì‚¬ìš©ì ì…ë ¥Â·ëª…ë ¹ ì „ë‹¬  
- Core Controllerê°€ Automation Engineê³¼ Data Access Layerë¥¼ ì¡°ì •  
- Automation Engineì€ OpenCVÂ·Tesseractë¡œ í™”ë©´ ì¸ì‹ í›„ PyAutoGUIë¡œ ë™ì‘ ì‹¤í–‰  
- Data Access LayerëŠ” ì—‘ì…€ íŒŒì¼ ì…ì¶œë ¥ ë° ì‹¤í–‰ ë¡œê·¸(CSV) ì €ì¥  

### Code Organization & Convention

**Domain-Driven Organization Strategy**  
- Domain Separation: `excel`, `ui`, `automation`, `core`, `plugin`  
- Layer-Based Architecture: `presentation(UI)`, `application(core)`, `domain(automation)`, `infrastructure(data)`  
- Feature-Based Modules: ë‹¨ê³„ë³„(`mouse_actions`, `keyboard_actions`, `image_search`, `flow_control`)  
- Shared Components: ê³µí†µ ìœ í‹¸(`utils`), ì•”í˜¸í™”Â·ì„¤ì •(`config`), ë¡œê¹…(`logger`)

**Universal File & Folder Structure**
```
/project-root
â”œâ”€â”€ build/                     # PyInstaller ë¹Œë“œ ì¶œë ¥
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ settings.json         # ì•± ì„¤ì •(ì•”í˜¸í™”)
â”‚   â””â”€â”€ locales/              # ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤
â”œâ”€â”€ plugin/                    # í™•ì¥ í”ŒëŸ¬ê·¸ì¸ ì •ì˜(JSON)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/                  # ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§
â”‚   â”œâ”€â”€ ui/                    # PyQt5/Tkinter ë·°
â”‚   â”œâ”€â”€ automation/            # PyAutoGUI, OpenCV, OCR ëª¨ë“ˆ
â”‚   â”œâ”€â”€ data/                  # ì—‘ì…€ ë° ë¡œê·¸ ì…ì¶œë ¥
â”‚   â”œâ”€â”€ utils/                 # ê³µí†µ ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ main.py                # ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸
â”œâ”€â”€ tests/                     # ë‹¨ìœ„/í†µí•© í…ŒìŠ¤íŠ¸
â””â”€â”€ requirements.txt           # íŒ¨í‚¤ì§€ ì˜ì¡´ì„±
```

### Data Flow & Communication Patterns
- **í´ë¼ì´ì–¸íŠ¸-ì»¨íŠ¸ë¡¤ëŸ¬ í†µì‹ **: UI ì´ë²¤íŠ¸ â†’ Core Controller ë©”ì„œë“œ í˜¸ì¶œ  
- **ë°ì´í„°ë² ì´ìŠ¤(ì—‘ì…€) ìƒí˜¸ì‘ìš©**: pandas/openpyxl ë™ê¸°ì‹ ì½ê¸°Â·ì“°ê¸°  
- **ì™¸ë¶€ ì„œë¹„ìŠ¤ ì—°ë™**: ì—†ìŒ(ì˜¤í”„ë¼ì¸ í™˜ê²½ ê¸°ë³¸)  
- **ì‹¤ì‹œê°„ í†µì‹ **: UI ìŠ¤ë ˆë“œì™€ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ìŠ¤ë ˆë“œ ê°„ í/ì‹œê·¸ë„  
- **ë°ì´í„° ë™ê¸°í™”**: ì‹¤í–‰ ë¡œê·¸(CSV)ì— ë‹¨ê³„ë³„ ê²°ê³¼ ì¦‰ì‹œ ê¸°ë¡  

---

## 4. Performance & Optimization Strategy
- ì´ë¯¸ì§€ ë§¤ì¹­ìš© ROI(Region of Interest) ë° í…œí”Œë¦¿ ìºì‹±ìœ¼ë¡œ ê²€ìƒ‰ ì†ë„ ê°œì„   
- ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ì‚¬ìš©ìœ¼ë¡œ UI ì‘ë‹µì„± í™•ë³´  
- OpenCV ë©€í‹°ìŠ¤ë ˆë“œ ë¹Œë“œ í™œìš© ë° Tesseract ROI ì„¤ì •ìœ¼ë¡œ OCR ì†ë„ ìµœì í™”  
- ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ ìœ„í•´ ì‹¤í–‰ í›„ ë¦¬ì†ŒìŠ¤(ì´ë¯¸ì§€Â·ê°ì²´) ëª…ì‹œì  í•´ì œ  

---

## 5. Implementation Roadmap & Milestones

### Phase 1: Foundation (MVP Implementation)
- **Core Infrastructure**: ê°œë°œ í™˜ê²½ ì„¤ì •, CI/CD(GitHub Actions), ê¸°ë³¸ í”„ë¡œì íŠ¸ êµ¬ì¡°  
- **Essential Features**: ì—‘ì…€ ë¶ˆëŸ¬ì˜¤ê¸°Â·ë§¤í•‘ UI, ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œ ìˆœì°¨ ì‹¤í–‰, ìƒíƒœ ì—´ ì—…ë°ì´íŠ¸  
- **Basic Security**: ì„¤ì • íŒŒì¼ AES-256 ì•”í˜¸í™” ì €ì¥  
- **Development Setup**: ê°€ìƒí™˜ê²½, lint(Flake8), ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬  
- **Timeline**: 3ê°œì›”

### Phase 2: Feature Enhancement
- **Advanced Features**: ì´ë¯¸ì§€ ì„œì¹˜(OpenCV), OCR(pytesseract), LoopÂ·If ì œì–´  
- **Performance Optimization**: ìŠ¤ë ˆë“œ ìµœì í™”, í…œí”Œë¦¿ ìºì‹± ê°œì„   
- **Enhanced Security**: ì½”ë“œ ì„œëª…, ì„¤ì¹˜ íŒ¨í‚¤ì§€ ë³´ì•ˆ ì˜µì…˜  
- **Monitoring Implementation**: ìƒì„¸ ì‹¤í–‰ ë¡œê·¸ CSV ë·°ì–´ ëª¨ë“ˆ  
- **Timeline**: 2ê°œì›”

### Phase 3: Scaling & Optimization
- **Scalability Implementation**: í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜ ì™„ì„±, ë©€í‹° ëª¨ë‹ˆí„° ì•ˆì •í™”  
- **Advanced Integrations**: ìë™ ì—…ë°ì´íŠ¸ ì²´í¬, ë‹¤êµ­ì–´ UI, ë‹¤í¬ëª¨ë“œ  
- **Enterprise Features**: ë¡œì»¬ í…œí”Œë¦¿ ê°¤ëŸ¬ë¦¬, êµ¬ì„± ë™ê¸°í™” ì˜µì…˜  
- **Compliance & Auditing**: ê°ì‚¬ ë¡œê·¸, ì‹¤í–‰ ì´ë ¥ ë¦¬í¬íŠ¸  
- **Timeline**: 2ê°œì›”

---

## 6. Risk Assessment & Mitigation Strategies

### Technical Risk Analysis
- **ê¸°ìˆ  ë¦¬ìŠ¤í¬**: ì´ë¯¸ì§€ ë§¤ì¹­ ì˜¤ë¥˜ â†’ DPI ë³´ì • ì•Œê³ ë¦¬ì¦˜ ë° ë©€í‹° ëª¨ë‹ˆí„° ì¢Œí‘œ ë™ê¸°í™”  
- **ì„±ëŠ¥ ë¦¬ìŠ¤í¬**: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œ ëŠë ¤ì§ â†’ ROI ìºì‹±Â·ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ í™œìš©  
- **ë³´ì•ˆ ë¦¬ìŠ¤í¬**: ì„¤ì • íŒŒì¼ ë¬´ë‹¨ ì—´ëŒ â†’ AES-256 ì•”í˜¸í™” ë° íŒŒì¼ ê¶Œí•œ ì œí•œ  
- **í†µí•© ë¦¬ìŠ¤í¬**: Tesseract ë²„ì „ í˜¸í™˜ì„± â†’ ì‚¬ì „ í…ŒìŠ¤íŠ¸ ë° ë¡œì»¬ ë²ˆë“¤ë§  
- **Mitigation**: ì‚¬ì „ í™˜ê²½ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸, ìë™í™” í…ŒìŠ¤íŠ¸, ì£¼ê¸°ì  ë³´ì•ˆ ê°ì‚¬

### Project Delivery Risks
- **ì¼ì • ë¦¬ìŠ¤í¬**: ê¸°ëŠ¥ ë³µì¡ë„ ê³¼ì†Œí‰ê°€ â†’ MVP ë²”ìœ„ ëª…í™•í™” ë° ì£¼ê¸°ì  ìŠ¤ì½”í”„ ë¦¬ë·°  
- **ë¦¬ì†ŒìŠ¤ ë¦¬ìŠ¤í¬**: Python GUI ì „ë¬¸ ê°œë°œì ë¶€ì¡± â†’ ë¬¸ì„œí™”Â·ë‚´ë¶€ ì›Œí¬ìˆ ì‹¤ì‹œ  
- **í’ˆì§ˆ ë¦¬ìŠ¤í¬**: í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ì €ì¡° â†’ CI ë³‘í•© ì „ 80% ì´ìƒ ì»¤ë²„ë¦¬ì§€ ê°•ì œ  
- **ë°°í¬ ë¦¬ìŠ¤í¬**: ë³‘ì› ë³´ì•ˆ ì •ì±… ì°¨ë‹¨ â†’ ì˜¤í”„ë¼ì¸ ì„¤ì¹˜ íŒ¨í‚¤ì§€, ë””ì§€í„¸ ì„œëª… ì œê³µ  
- **ë¹„ìƒ ê³„íš**: ì£¼ìš” ê¸°ëŠ¥ ì§€ì—° ì‹œ Nice-to-Have í›„ìˆœìœ„ ì¡°ì •, í˜ì¼ì˜¤ë²„ ì„¤ì¹˜ ì§€ì¹¨ ì‘ì„±
</file>

<file path="web_macro.json">
[
  {
    "type": "mouse_click",
    "name": "ë§ˆìš°ìŠ¤ í´ë¦­"
  },
  {
    "type": "keyboard_type",
    "name": "í…ìŠ¤íŠ¸ ì…ë ¥"
  },
  {
    "type": "wait_time",
    "name": "ëŒ€ê¸°"
  }
]
</file>

<file path="src/config/settings.py">
"""
Application settings management with encryption support
"""

import json
import os
from pathlib import Path
from typing import Any, Dict, Optional
from utils.encryption import EncryptionManager

class Settings:
    """Manages application settings with encryption support"""
    
    DEFAULT_SETTINGS = {
        "version": "1.0.0",
        "language": "ko",
        "theme": "light",
        "hotkeys": {
            "pause": "F9",
            "stop": "Escape"
        },
        "execution": {
            "default_delay_ms": 100,
            "screenshot_quality": 95,
            "ocr_confidence_threshold": 0.7
        },
        "ui": {
            "window_size": [1280, 720],
            "show_tooltips": True,
            "confirm_exit": True,
            "compact_mode": False
        }
    }
    
    def __init__(self, config_dir: Optional[Path] = None):
        """Initialize settings manager"""
        self.config_dir = config_dir or Path.home() / ".excel_macro_automation"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        self.settings_file = self.config_dir / "settings.json"
        self.encrypted_settings_file = self.config_dir / "settings.enc"
        
        self.encryption_manager = EncryptionManager()
        self.settings = self._load_settings()
    
    def _load_settings(self) -> Dict[str, Any]:
        """Load settings from file or create defaults"""
        # Try loading encrypted settings first
        if self.encrypted_settings_file.exists():
            try:
                encrypted_data = self.encrypted_settings_file.read_bytes()
                decrypted_data = self.encryption_manager.decrypt(encrypted_data)
                return json.loads(decrypted_data.decode('utf-8'))
            except Exception as e:
                print(f"Failed to load encrypted settings: {e}")
        
        # Try loading plain JSON settings
        if self.settings_file.exists():
            try:
                return json.loads(self.settings_file.read_text(encoding='utf-8'))
            except Exception as e:
                print(f"Failed to load settings: {e}")
        
        # Return default settings
        return self.DEFAULT_SETTINGS.copy()
    
    def save(self, encrypted: bool = True) -> None:
        """Save settings to file"""
        settings_json = json.dumps(self.settings, indent=2, ensure_ascii=False)
        
        if encrypted:
            encrypted_data = self.encryption_manager.encrypt(settings_json.encode('utf-8'))
            self.encrypted_settings_file.write_bytes(encrypted_data)
            # Remove plain text version if it exists
            if self.settings_file.exists():
                self.settings_file.unlink()
        else:
            self.settings_file.write_text(settings_json, encoding='utf-8')
            # Remove encrypted version if it exists
            if self.encrypted_settings_file.exists():
                self.encrypted_settings_file.unlink()
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get setting value by key (supports dot notation)"""
        keys = key.split('.')
        value = self.settings
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def set(self, key: str, value: Any) -> None:
        """Set setting value by key (supports dot notation)"""
        keys = key.split('.')
        target = self.settings
        
        for k in keys[:-1]:
            if k not in target:
                target[k] = {}
            target = target[k]
        
        target[keys[-1]] = value
    
    def reset_to_defaults(self) -> None:
        """Reset all settings to defaults"""
        self.settings = self.DEFAULT_SETTINGS.copy()
        self.save()
</file>

<file path="src/excel/excel_manager.py">
"""
Core Excel file management functionality
"""

import os
from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple
import pandas as pd
import openpyxl
from logger.app_logger import get_logger
from excel.models import (
    ExcelFileInfo, SheetInfo, ColumnInfo, ColumnType, 
    ExcelData, ColumnMapping
)

class ExcelManager:
    """Manages Excel file operations"""
    
    def __init__(self):
        self.logger = get_logger(__name__)
        self._current_file: Optional[str] = None
        self._current_data: Optional[ExcelData] = None
        self._column_mappings: Dict[str, ColumnMapping] = {}
    
    @property
    def file_path(self) -> Optional[str]:
        """Get current file path"""
        return self._current_file
        
    def load_file(self, file_path: str) -> ExcelFileInfo:
        """Load Excel file and return file information"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Excel file not found: {file_path}")
        
        if not file_path.suffix.lower() in ['.xlsx', '.xls', '.xlsm']:
            raise ValueError(f"Invalid Excel file format: {file_path.suffix}")
        
        self.logger.info(f"Loading Excel file: {file_path}")
        
        # Get file info
        file_size = file_path.stat().st_size
        
        # Load workbook to get sheet names
        workbook = openpyxl.load_workbook(file_path, read_only=True, data_only=True)
        sheet_names = workbook.sheetnames
        workbook.close()
        
        # Analyze each sheet
        sheets = []
        for sheet_name in sheet_names:
            sheet_info = self._analyze_sheet(file_path, sheet_name)
            sheets.append(sheet_info)
        
        self._current_file = str(file_path)
        
        return ExcelFileInfo(
            file_path=str(file_path),
            file_size=file_size,
            sheet_count=len(sheets),
            sheets=sheets
        )
    
    def _analyze_sheet(self, file_path: Path, sheet_name: str) -> SheetInfo:
        """Analyze a specific sheet"""
        # Read first 1000 rows for analysis
        df = pd.read_excel(file_path, sheet_name=sheet_name, nrows=1000)
        
        # Get full row count
        full_df = pd.read_excel(file_path, sheet_name=sheet_name, usecols=[0])
        row_count = len(full_df)
        
        # Analyze columns
        columns = []
        for idx, col in enumerate(df.columns):
            col_info = self._analyze_column(df[col], col, idx)
            columns.append(col_info)
        
        return SheetInfo(
            name=sheet_name,
            row_count=row_count,
            column_count=len(columns),
            columns=columns
        )
    
    def _analyze_column(self, series: pd.Series, name: str, index: int) -> ColumnInfo:
        """Analyze a single column"""
        # Get non-null values
        non_null = series.dropna()
        
        # Determine data type
        data_type = self._detect_column_type(non_null)
        
        # Get sample values
        sample_values = non_null.head(5).tolist()
        
        return ColumnInfo(
            name=str(name),
            index=index,
            data_type=data_type,
            sample_values=sample_values,
            null_count=series.isnull().sum(),
            unique_count=series.nunique()
        )
    
    def _detect_column_type(self, series: pd.Series) -> ColumnType:
        """Detect column data type"""
        if len(series) == 0:
            return ColumnType.EMPTY
        
        # Try to infer type
        try:
            pd.to_numeric(series)
            return ColumnType.NUMBER
        except (ValueError, TypeError):
            pass
        
        try:
            # Suppress warning for mixed date formats
            import warnings
            with warnings.catch_warnings():
                warnings.filterwarnings('ignore', message='Could not infer format')
                pd.to_datetime(series, errors='coerce')
            return ColumnType.DATE
        except (ValueError, TypeError, AttributeError):
            pass
        
        # Check for boolean
        unique_values = series.unique()
        if len(unique_values) <= 2:
            bool_values = {True, False, 'True', 'False', 'true', 'false', 
                          'TRUE', 'FALSE', 'ì˜ˆ', 'ì•„ë‹ˆì˜¤', 'Yes', 'No'}
            if all(val in bool_values for val in unique_values):
                return ColumnType.BOOLEAN
        
        return ColumnType.TEXT
    
    def read_sheet(self, sheet_name: str, max_rows: Optional[int] = None) -> ExcelData:
        """Read data from a specific sheet"""
        if not self._current_file:
            raise ValueError("No Excel file loaded")
        
        self.logger.info(f"Reading sheet: {sheet_name}")
        
        # Read data
        df = pd.read_excel(self._current_file, sheet_name=sheet_name, nrows=max_rows)
        
        # Create ExcelData instance
        excel_data = ExcelData(df, sheet_name, self._current_file)
        
        # Check for status column
        status_columns = ['ìƒíƒœ', 'Status', 'ì™„ë£Œì—¬ë¶€', 'ì²˜ë¦¬ìƒíƒœ', 'status', 'STATUS']
        for col in status_columns:
            if col in df.columns:
                excel_data.set_status_column(col)
                break
        
        # If no status column found, create one
        if not excel_data.get_status_column():
            excel_data.set_status_column('ì²˜ë¦¬ìƒíƒœ')
            self.logger.info("Created new status column: ì²˜ë¦¬ìƒíƒœ")
        
        self._current_data = excel_data
        return excel_data
    
    def save_file(self, file_path: Optional[str] = None) -> str:
        """Save current data back to Excel"""
        if not self._current_data:
            # Excel ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì €ì¥í•˜ì§€ ì•ŠìŒ (standalone ëª¨ë“œ)
            self.logger.info("No Excel data to save - skipping save operation")
            return ""
        
        save_path = file_path or self._current_file
        
        # Read all sheets to preserve
        with pd.ExcelFile(self._current_file) as xls:
            sheets = {}
            for sheet_name in xls.sheet_names:
                if sheet_name == self._current_data.sheet_name:
                    sheets[sheet_name] = self._current_data.dataframe
                else:
                    sheets[sheet_name] = pd.read_excel(xls, sheet_name)
        
        # Save all sheets
        with pd.ExcelWriter(save_path, engine='openpyxl') as writer:
            for sheet_name, df in sheets.items():
                df.to_excel(writer, sheet_name=sheet_name, index=False)
        
        self.logger.info(f"Saved Excel file: {save_path}")
        return save_path
    
    def set_column_mapping(self, excel_column: str, variable_name: str, 
                          data_type: ColumnType, is_required: bool = True):
        """Set mapping between Excel column and variable"""
        mapping = ColumnMapping(
            excel_column=excel_column,
            variable_name=variable_name,
            data_type=data_type,
            is_required=is_required
        )
        self._column_mappings[variable_name] = mapping
    
    def get_mapped_data(self, row_index: int) -> Dict[str, Any]:
        """Get row data with variable mappings applied"""
        if not self._current_data:
            raise ValueError("No data loaded")
        
        row_data = self._current_data.get_row_data(row_index)
        mapped_data = {}
        
        for var_name, mapping in self._column_mappings.items():
            if mapping.excel_column in row_data:
                mapped_data[var_name] = row_data[mapping.excel_column]
            elif mapping.default_value is not None:
                mapped_data[var_name] = mapping.default_value
            elif mapping.is_required:
                raise ValueError(f"Required column '{mapping.excel_column}' not found")
        
        return mapped_data
    
    def update_row_status(self, row_index: int, status: str, save_immediately: bool = False):
        """Update status for a specific row"""
        if not self._current_data:
            raise ValueError("No data loaded")
        
        self._current_data.update_row_status(row_index, status)
        
        if save_immediately:
            self.save_file()
    
    def get_pending_rows(self) -> List[int]:
        """Get list of row indices that need processing"""
        if not self._current_data:
            return []
        
        incomplete = self._current_data.get_incomplete_rows()
        return incomplete.index.tolist()
</file>

<file path="src/ui/dialogs/loop_step_dialog.py">
"""
Loop step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QComboBox, QSpinBox, QListWidget, QListWidgetItem,
    QAbstractItemView, QMessageBox, QTextEdit, QWidget
)
from PyQt5.QtCore import Qt
from core.macro_types import LoopStep, MacroStep
from typing import List, Optional


class LoopStepDialog(QDialog):
    """Dialog for configuring loop step"""
    
    def __init__(self, step: LoopStep, available_steps: List[MacroStep], parent=None):
        super().__init__(parent)
        self.step = step
        self.available_steps = available_steps  # All steps in the macro
        self.setWindowTitle("ë°˜ë³µë¬¸ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(600)
        self.setMinimumHeight(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Loop type group
        type_group = QGroupBox("ë°˜ë³µ íƒ€ì…")
        type_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #2196F3;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                color: #1976d2;
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        type_layout = QVBoxLayout()
        
        # Loop type selection
        type_form_layout = QFormLayout()
        self.type_combo = QComboBox()
        self.type_combo.addItems([
            "ì§€ì • íšŸìˆ˜ ë°˜ë³µ",
            "ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€",
            "ê° ì—‘ì…€ í–‰ì— ëŒ€í•´"
        ])
        self.type_combo.currentIndexChanged.connect(self.on_type_changed)
        type_form_layout.addRow("ë°˜ë³µ ë°©ì‹:", self.type_combo)
        type_layout.addLayout(type_form_layout)
        
        # Count settings (for count type)
        self.count_widget = QWidget()
        count_layout = QHBoxLayout()
        count_layout.addWidget(QLabel("ë°˜ë³µ íšŸìˆ˜:"))
        self.count_spin = QSpinBox()
        self.count_spin.setMinimum(1)
        self.count_spin.setMaximum(9999)
        self.count_spin.setValue(5)
        count_layout.addWidget(self.count_spin)
        count_layout.addWidget(QLabel("íšŒ"))
        count_layout.addStretch()
        self.count_widget.setLayout(count_layout)
        type_layout.addWidget(self.count_widget)
        
        # Image settings (for while_image type)
        self.image_widget = QWidget()
        image_layout = QVBoxLayout()
        image_info = QLabel(
            "ì´ë¯¸ì§€ê°€ í™”ë©´ì— ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ ë°˜ë³µí•©ë‹ˆë‹¤.\n"
            "ì´ë¯¸ì§€ ê²€ìƒ‰ ë‹¨ê³„ë¥¼ ë°˜ë³µ ëŒ€ìƒì— í¬í•¨ì‹œì¼œì•¼ í•©ë‹ˆë‹¤."
        )
        image_info.setWordWrap(True)
        image_info.setStyleSheet("color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        image_layout.addWidget(image_info)
        self.image_widget.setLayout(image_layout)
        self.image_widget.hide()
        type_layout.addWidget(self.image_widget)
        
        # Row settings (for for_each_row type)
        self.row_widget = QWidget()
        row_layout = QVBoxLayout()
        row_info = QLabel(
            "ì—‘ì…€ì˜ ê° í–‰ì— ëŒ€í•´ ë°˜ë³µí•©ë‹ˆë‹¤.\n"
            "ë³€ìˆ˜ ì¹˜í™˜ì„ ì‚¬ìš©í•˜ëŠ” ë‹¨ê³„ë¥¼ í¬í•¨ì‹œì¼œ ê° í–‰ì˜ ë°ì´í„°ë¥¼ í™œìš©í•˜ì„¸ìš”."
        )
        row_info.setWordWrap(True)
        row_info.setStyleSheet("color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        row_layout.addWidget(row_info)
        self.row_widget.setLayout(row_layout)
        self.row_widget.hide()
        type_layout.addWidget(self.row_widget)
        
        type_group.setLayout(type_layout)
        layout.addWidget(type_group)
        
        # Steps selection group
        steps_group = QGroupBox("ë°˜ë³µí•  ë‹¨ê³„ ì„ íƒ")
        steps_layout = QVBoxLayout()
        
        steps_info = QLabel("ë°˜ë³µí•  ë‹¨ê³„ë“¤ì„ ì„ íƒí•˜ì„¸ìš” (Ctrl+í´ë¦­ìœ¼ë¡œ ë‹¤ì¤‘ ì„ íƒ)")
        steps_info.setStyleSheet("color: #666; font-size: 12px;")
        steps_layout.addWidget(steps_info)
        
        # Available steps list
        self.steps_list = QListWidget()
        self.steps_list.setSelectionMode(QAbstractItemView.MultiSelection)
        self.steps_list.setStyleSheet("""
            QListWidget {
                background-color: white;
                border: 2px solid #2196F3;
                border-radius: 5px;
                padding: 5px;
            }
            QListWidget::item {
                padding: 8px;
                margin: 2px;
                border: 1px solid #e0e0e0;
                border-radius: 3px;
                background-color: #f5f5f5;
            }
            QListWidget::item:hover {
                background-color: #e3f2fd;
                border-color: #2196F3;
            }
            QListWidget::item:selected {
                background-color: #1976d2;
                color: white;
                border-color: #1565c0;
            }
        """)
        
        # Add available steps to list
        for step in self.available_steps:
            if step.step_id != self.step.step_id:  # Don't include self
                item = QListWidgetItem(f"{step.name} ({step.step_type.value})")
                item.setData(Qt.UserRole, step.step_id)
                self.steps_list.addItem(item)
                
        steps_layout.addWidget(self.steps_list)
        
        # Selected steps info
        self.selected_info = QLabel("ì„ íƒëœ ë‹¨ê³„: 0ê°œ")
        self.selected_info.setStyleSheet("font-weight: bold;")
        steps_layout.addWidget(self.selected_info)
        
        self.steps_list.itemSelectionChanged.connect(self.update_selected_info)
        
        steps_group.setLayout(steps_layout)
        layout.addWidget(steps_group)
        
        # Description
        desc_layout = QFormLayout()
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(60)
        self.description_edit.setPlaceholderText("ë°˜ë³µë¬¸ì— ëŒ€í•œ ì„¤ëª… (ì„ íƒì‚¬í•­)")
        desc_layout.addRow("ì„¤ëª…:", self.description_edit)
        layout.addLayout(desc_layout)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        
        # Set loop type
        type_map = {
            "count": 0,
            "while_image": 1,
            "for_each_row": 2
        }
        self.type_combo.setCurrentIndex(type_map.get(self.step.loop_type, 0))
        
        # Set count
        self.count_spin.setValue(self.step.loop_count)
        
        # Select loop steps
        for i in range(self.steps_list.count()):
            item = self.steps_list.item(i)
            step_id = item.data(Qt.UserRole)
            if step_id in self.step.loop_steps:
                item.setSelected(True)
                
        # Set description
        if hasattr(self.step, 'description'):
            self.description_edit.setText(self.step.description)
            
        self.update_selected_info()
        
    def on_type_changed(self, index):
        """Handle loop type change"""
        # Show/hide appropriate widgets
        self.count_widget.setVisible(index == 0)
        self.image_widget.setVisible(index == 1)
        self.row_widget.setVisible(index == 2)
        
    def update_selected_info(self):
        """Update selected steps info"""
        selected_count = len(self.steps_list.selectedItems())
        self.selected_info.setText(f"ì„ íƒëœ ë‹¨ê³„: {selected_count}ê°œ")
        
    def validate_and_accept(self):
        """Validate input and accept"""
        # Check if any steps are selected
        if not self.steps_list.selectedItems():
            QMessageBox.warning(
                self, "ê²½ê³ ",
                "ë°˜ë³µí•  ë‹¨ê³„ë¥¼ ìµœì†Œ 1ê°œ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”."
            )
            return
            
        # Check count for count type
        if self.type_combo.currentIndex() == 0 and self.count_spin.value() < 1:
            QMessageBox.warning(
                self, "ê²½ê³ ",
                "ë°˜ë³µ íšŸìˆ˜ëŠ” 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤."
            )
            return
            
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        # Get loop type
        type_map = {
            0: "count",
            1: "while_image",
            2: "for_each_row"
        }
        loop_type = type_map[self.type_combo.currentIndex()]
        
        # Get selected step IDs
        loop_steps = []
        for item in self.steps_list.selectedItems():
            loop_steps.append(item.data(Qt.UserRole))
            
        return {
            'name': self.name_edit.text() or "ë°˜ë³µë¬¸",
            'loop_type': loop_type,
            'loop_count': self.count_spin.value(),
            'loop_steps': loop_steps,
            'description': self.description_edit.toPlainText()
        }
</file>

<file path="src/vision/text_extractor.py">
"""
Text extraction using EasyOCR for dynamic text search
"""

import os
import numpy as np
from typing import Optional, List, Tuple, Dict, Any
from dataclasses import dataclass
import cv2
from PIL import Image
import mss
from logger.app_logger import get_logger
from utils.monitor_utils import get_total_screen_bounds, get_monitor_at_position

# EasyOCR is required
import easyocr

@dataclass
class TextResult:
    """Result from text detection"""
    text: str
    confidence: float
    bbox: Tuple[int, int, int, int]  # (x, y, width, height)
    center: Tuple[int, int]  # (center_x, center_y)

class TextExtractor:
    """Extract text from screen regions using EasyOCR"""
    
    _instance = None
    _reader = None
    
    def __new__(cls):
        """Singleton pattern to avoid multiple EasyOCR reader instances"""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        """Initialize text extractor"""
        if not hasattr(self, 'initialized'):
            self.logger = get_logger(__name__)
            self.sct = mss.mss()
            self.initialized = True
            
    def _get_reader(self) -> easyocr.Reader:
        """Get or create EasyOCR reader (lazy loading)"""
        if TextExtractor._reader is None:
            self.logger.info("Initializing EasyOCR reader with Korean and English support...")
            # Initialize with Korean and English
            TextExtractor._reader = easyocr.Reader(['ko', 'en'], gpu=False)
            self.logger.info("EasyOCR reader initialized successfully")
        return TextExtractor._reader
    
    def extract_text_from_region(self, region: Optional[Tuple[int, int, int, int]] = None,
                                confidence_threshold: float = 0.5) -> List[TextResult]:
        """
        Extract text from screen region
        
        Args:
            region: (x, y, width, height) or None for full screen
            confidence_threshold: Minimum confidence for text detection
            
        Returns:
            List of TextResult objects
        """
        try:
            # Capture screen region
            if region:
                x, y, width, height = region
                monitor = {"left": x, "top": y, "width": width, "height": height}
            else:
                monitor = self.sct.monitors[0]  # All monitors
                
            # Capture screenshot
            screenshot = self.sct.grab(monitor)
            
            # Convert to numpy array
            img = np.array(screenshot)
            # Convert BGRA to RGB
            img_rgb = cv2.cvtColor(img, cv2.COLOR_BGRA2RGB)
            
            # Get reader
            reader = self._get_reader()
            
            # Perform OCR
            results = reader.readtext(img_rgb)
            
            # Process results
            text_results = []
            for bbox, text, confidence in results:
                if confidence >= confidence_threshold:
                    # Convert bbox format
                    # EasyOCR returns [[x1,y1], [x2,y1], [x2,y2], [x1,y2]]
                    x_coords = [point[0] for point in bbox]
                    y_coords = [point[1] for point in bbox]
                    
                    min_x = int(min(x_coords))
                    min_y = int(min(y_coords))
                    max_x = int(max(x_coords))
                    max_y = int(max(y_coords))
                    
                    width = max_x - min_x
                    height = max_y - min_y
                    
                    # Calculate center point
                    center_x = min_x + width // 2
                    center_y = min_y + height // 2
                    
                    # Adjust coordinates if region was specified
                    if region:
                        min_x += region[0]
                        min_y += region[1]
                        center_x += region[0]
                        center_y += region[1]
                    else:
                        # When capturing all monitors, need to adjust for monitor offsets
                        monitor_info = self.sct.monitors[0]
                        min_x += monitor_info["left"]
                        min_y += monitor_info["top"]
                        center_x += monitor_info["left"]
                        center_y += monitor_info["top"]
                    
                    result = TextResult(
                        text=text,
                        confidence=confidence,
                        bbox=(min_x, min_y, width, height),
                        center=(center_x, center_y)
                    )
                    text_results.append(result)
                    
            self.logger.info(f"Extracted {len(text_results)} text items from region")
            return text_results
            
        except Exception as e:
            self.logger.error(f"Error extracting text: {e}")
            return []
    
    def find_text(self, target_text: str, region: Optional[Tuple[int, int, int, int]] = None,
                  exact_match: bool = False, confidence_threshold: float = 0.5) -> Optional[TextResult]:
        """
        Find specific text in screen region
        
        Args:
            target_text: Text to search for
            region: (x, y, width, height) or None for full screen
            exact_match: If True, requires exact match. If False, allows partial match
            confidence_threshold: Minimum OCR confidence
            
        Returns:
            TextResult if found, None otherwise
        """
        try:
            # Extract all text from region
            text_results = self.extract_text_from_region(region, confidence_threshold)
            
            # Normalize target text for comparison
            target_lower = target_text.lower().strip()
            
            # Find matching text
            best_match = None
            best_score = 0.0
            
            for result in text_results:
                text_lower = result.text.lower().strip()
                
                if exact_match:
                    if text_lower == target_lower:
                        return result
                else:
                    # Partial match - check if target is in detected text
                    if target_lower in text_lower:
                        # Score based on how much of the detected text matches
                        score = len(target_lower) / len(text_lower)
                        if score > best_score:
                            best_match = result
                            best_score = score
                    # Also check if detected text is in target (for partial OCR results)
                    elif text_lower in target_lower and len(text_lower) > 2:
                        score = len(text_lower) / len(target_lower)
                        if score > best_score:
                            best_match = result
                            best_score = score
            
            if best_match:
                self.logger.info(f"Found text '{target_text}' at {best_match.center}")
            else:
                self.logger.info(f"Text '{target_text}' not found in region")
                
            return best_match
            
        except Exception as e:
            self.logger.error(f"Error finding text: {e}")
            return None
    
    def find_all_text(self, target_text: str, region: Optional[Tuple[int, int, int, int]] = None,
                      exact_match: bool = False, confidence_threshold: float = 0.5) -> List[TextResult]:
        """
        Find all occurrences of text in screen region
        
        Args:
            target_text: Text to search for
            region: (x, y, width, height) or None for full screen
            exact_match: If True, requires exact match. If False, allows partial match
            confidence_threshold: Minimum OCR confidence
            
        Returns:
            List of TextResult objects
        """
        try:
            # Extract all text from region
            text_results = self.extract_text_from_region(region, confidence_threshold)
            
            # Normalize target text for comparison
            target_lower = target_text.lower().strip()
            
            # Find all matching text
            matches = []
            
            for result in text_results:
                text_lower = result.text.lower().strip()
                
                if exact_match:
                    if text_lower == target_lower:
                        matches.append(result)
                else:
                    # Partial match
                    if target_lower in text_lower or text_lower in target_lower:
                        matches.append(result)
            
            self.logger.info(f"Found {len(matches)} occurrences of '{target_text}'")
            return matches
            
        except Exception as e:
            self.logger.error(f"Error finding all text: {e}")
            return []
    
    def preload_models(self):
        """Preload OCR models to avoid delay on first use"""
        try:
            self.logger.info("Preloading EasyOCR models...")
            reader = self._get_reader()
            # Do a dummy recognition to load models
            dummy_img = np.zeros((100, 100, 3), dtype=np.uint8)
            reader.readtext(dummy_img)
            self.logger.info("EasyOCR models preloaded successfully")
        except Exception as e:
            self.logger.error(f"Error preloading models: {e}")
</file>

<file path="src/automation/engine.py">
"""
Main macro execution engine
"""

import time
import threading
from typing import Optional, Dict, Any, List, Callable
from enum import Enum
from PyQt5.QtCore import QThread, pyqtSignal, QObject
import pyautogui
from core.macro_types import Macro, MacroStep
from excel.excel_manager import ExcelManager
from logger.app_logger import get_logger
from config.settings import Settings
from automation.executor import StepExecutor
from automation.hotkey_listener import HotkeyListener
from logger.execution_logger import get_execution_logger

class ExecutionState(Enum):
    """Execution states"""
    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

class ExecutionResult:
    """Result of a single execution"""
    def __init__(self, row_index: int, success: bool, 
                 error: Optional[str] = None, duration_ms: float = 0):
        self.row_index = row_index
        self.success = success
        self.error = error
        self.duration_ms = duration_ms
        self.timestamp = time.time()

class ExecutionEngine(QThread):
    """Main macro execution engine"""
    
    # Signals
    stateChanged = pyqtSignal(ExecutionState)
    progressUpdated = pyqtSignal(int, int)  # current, total
    rowCompleted = pyqtSignal(ExecutionResult)
    stepExecuting = pyqtSignal(MacroStep, int)  # step, row_index
    executionFinished = pyqtSignal()
    error = pyqtSignal(str)
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.logger = get_logger(__name__)
        self.settings = settings
        
        # State management
        self._state = ExecutionState.IDLE
        self._state_lock = threading.Lock()
        self._pause_event = threading.Event()
        self._pause_event.set()  # Not paused by default
        
        # Execution components
        self.step_executor = StepExecutor(settings)
        self.hotkey_listener = HotkeyListener(settings)
        self.execution_logger = get_execution_logger()
        
        # Current execution context
        self.macro: Optional[Macro] = None
        self.excel_manager: Optional[ExcelManager] = None
        self.target_rows: List[int] = []
        self.current_row_index: Optional[int] = None
        
        # Configure PyAutoGUI
        self._configure_pyautogui()
        
        # Connect hotkey signals
        self.hotkey_listener.pausePressed.connect(self.toggle_pause)
        self.hotkey_listener.stopPressed.connect(self.stop_execution)
        
    def _configure_pyautogui(self):
        """Configure PyAutoGUI settings"""
        pyautogui.FAILSAFE = True  # Move mouse to corner to abort
        pyautogui.PAUSE = self.settings.get("execution.default_delay_ms", 100) / 1000.0
        
        # Log screen size for debugging
        screen_width, screen_height = pyautogui.size()
        self.logger.info(f"Screen size: {screen_width}x{screen_height}")
        
    @property
    def state(self) -> ExecutionState:
        """Get current execution state"""
        with self._state_lock:
            return self._state
            
    def _set_state(self, new_state: ExecutionState):
        """Set execution state"""
        with self._state_lock:
            old_state = self._state
            self._state = new_state
            
        if old_state != new_state:
            self.logger.info(f"State changed: {old_state.value} -> {new_state.value}")
            self.stateChanged.emit(new_state)
            
    def set_macro(self, macro: Macro, excel_manager: Optional[ExcelManager] = None):
        """Set macro and Excel manager for execution"""
        if self.state != ExecutionState.IDLE:
            raise RuntimeError("Cannot set macro while execution is active")
            
        self.macro = macro
        self.excel_manager = excel_manager
        
        # Validate macro
        errors = macro.validate()
        if errors:
            raise ValueError(f"Macro validation failed: {', '.join(errors)}")
            
    def set_target_rows(self, row_indices: List[int]):
        """Set specific rows to execute"""
        self.target_rows = row_indices
        
    def run(self):
        """Main execution thread"""
        if not self.macro:
            self.error.emit("No macro loaded")
            return
            
        try:
            self._set_state(ExecutionState.RUNNING)
            self.hotkey_listener.start()
            
            # Start CSV logging session
            excel_file = self.excel_manager.file_path if self.excel_manager else "Unknown"
            log_file = self.execution_logger.start_session(self.macro.name, excel_file)
            self.logger.info(f"Execution log started: {log_file}")
            
            # Determine execution mode
            if self.excel_manager:
                # Excel mode - execute for each row
                if not self.target_rows:
                    # Process all incomplete rows
                    self.target_rows = self.excel_manager.get_pending_rows()
                    
                total_rows = len(self.target_rows)
                self.logger.info(f"Starting execution for {total_rows} rows")
                
                # Track statistics
                successful_rows = 0
                failed_rows = 0
                
                # Execute each row
                for i, row_index in enumerate(self.target_rows):
                    # Check if stopping
                    if self.state == ExecutionState.STOPPING:
                        break
                        
                    # Handle pause
                    self._pause_event.wait()
                    
                    # Update progress
                    self.progressUpdated.emit(i + 1, total_rows)
                    self.current_row_index = row_index
                    
                    # Execute macro for this row
                    result = self._execute_row(row_index)
                    
                    # Update statistics
                    if result.success:
                        successful_rows += 1
                    else:
                        failed_rows += 1
                    
                    # Update Excel status
                    status = "ì™„ë£Œ" if result.success else f"ì‹¤íŒ¨: {result.error}"
                    self.excel_manager.update_row_status(row_index, status)
                    
                    # Emit result
                    self.rowCompleted.emit(result)
                    
                    # Small delay between rows
                    time.sleep(0.1)
                    
                # Save Excel file after all rows (only if data exists)
                if self.excel_manager and self.excel_manager._current_data:
                    self.excel_manager.save_file()
                
            else:
                # Standalone mode - execute once without Excel data
                self.logger.info("Starting standalone macro execution")
                total_rows = 1
                successful_rows = 0
                failed_rows = 0
                
                # Update progress
                self.progressUpdated.emit(1, 1)
                
                # Execute macro without row data
                result = self._execute_standalone()
                
                if result.success:
                    successful_rows = 1
                else:
                    failed_rows = 1
                    
                # Emit result
                self.rowCompleted.emit(result)
            
            # Log session summary
            self.execution_logger.log_session_end(
                total_rows=total_rows,
                successful_rows=successful_rows,
                failed_rows=failed_rows
            )
            
            self._set_state(ExecutionState.IDLE)
            self.executionFinished.emit()
            
        except Exception as e:
            self.logger.error(f"Execution error: {e}", exc_info=True)
            self.execution_logger.log_error("EXECUTION_ERROR", str(e), details=str(e))
            self.error.emit(str(e))
            self._set_state(ExecutionState.ERROR)
            
        finally:
            self.hotkey_listener.stop()
            self.current_row_index = None
            self.execution_logger.close()
            
    def _execute_row(self, row_index: int) -> ExecutionResult:
        """Execute macro for a single row"""
        start_time = time.time()
        
        try:
            # Get row data with mappings
            row_data = self.excel_manager.get_mapped_data(row_index)
            
            # Log row start
            self.execution_logger.log_row_start(row_index, row_data)
            
            # Set variables in executor context
            self.step_executor.set_variables(row_data)
            
            # Execute each step
            for step_index, step in enumerate(self.macro.steps):
                # Check if stopping
                if self.state == ExecutionState.STOPPING:
                    return ExecutionResult(row_index, False, "Execution stopped")
                    
                # Handle pause
                self._pause_event.wait()
                
                # Skip disabled steps
                if not step.enabled:
                    continue
                    
                # Emit step executing signal
                self.stepExecuting.emit(step, row_index)
                
                # Execute step
                step_start_time = time.time()
                step_success = False
                step_error = ""
                
                try:
                    self.step_executor.execute_step(step)
                    step_success = True
                except Exception as e:
                    error_msg = f"Step '{step.name}' failed: {str(e)}"
                    self.logger.error(error_msg)
                    step_error = str(e)
                    
                    # Emit detailed error for UI
                    if step.error_handling.value == "stop":
                        self.error.emit(error_msg)
                    
                    # Handle error based on step configuration
                    if step.error_handling.value == "stop":
                        # Log failed step
                        step_duration = (time.time() - step_start_time) * 1000
                        self.execution_logger.log_step_execution(
                            row_index, step_index, step.name, step.step_type.value,
                            False, step_duration, step_error
                        )
                        return ExecutionResult(row_index, False, error_msg)
                    elif step.error_handling.value == "retry":
                        # Retry logic
                        for retry in range(step.retry_count):
                            try:
                                time.sleep(1)  # Wait before retry
                                self.step_executor.execute_step(step)
                                step_success = True
                                step_error = ""
                                break
                            except:
                                if retry == step.retry_count - 1:
                                    # Log failed step after all retries
                                    step_duration = (time.time() - step_start_time) * 1000
                                    self.execution_logger.log_step_execution(
                                        row_index, step_index, step.name, step.step_type.value,
                                        False, step_duration, step_error
                                    )
                                    return ExecutionResult(row_index, False, error_msg)
                    # For "continue", just log and proceed
                
                # Log step execution result
                step_duration = (time.time() - step_start_time) * 1000
                self.execution_logger.log_step_execution(
                    row_index, step_index, step.name, step.step_type.value,
                    step_success, step_duration, step_error
                )
                    
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(row_index, True, duration_ms)
            return ExecutionResult(row_index, True, None, duration_ms)
            
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(row_index, False, duration_ms, str(e))
            return ExecutionResult(row_index, False, str(e), duration_ms)
    
    def _execute_standalone(self) -> ExecutionResult:
        """Execute macro without Excel data"""
        start_time = time.time()
        
        try:
            # Log standalone execution start
            self.execution_logger.log_row_start(0, {})
            
            # Set empty variables in executor context
            self.step_executor.set_variables({})
            
            # Execute each step
            for step_index, step in enumerate(self.macro.steps):
                # Check if stopping
                if self.state == ExecutionState.STOPPING:
                    return ExecutionResult(0, False, "Execution stopped")
                    
                # Handle pause
                self._pause_event.wait()
                
                # Skip disabled steps
                if not step.enabled:
                    continue
                    
                # Emit step executing signal
                self.stepExecuting.emit(step, 0)
                
                # Execute step
                step_start_time = time.time()
                step_success = False
                step_error = ""
                
                try:
                    self.step_executor.execute_step(step)
                    step_success = True
                except Exception as e:
                    error_msg = f"Step '{step.name}' failed: {str(e)}"
                    self.logger.error(error_msg)
                    step_error = str(e)
                    
                    # Emit detailed error for UI
                    if step.error_handling.value == "stop":
                        self.error.emit(error_msg)
                    
                    # Handle error based on step configuration
                    if step.error_handling.value == "stop":
                        # Log failed step
                        step_duration = (time.time() - step_start_time) * 1000
                        self.execution_logger.log_step_execution(
                            0, step_index, step.name, step.step_type.value,
                            False, step_duration, step_error
                        )
                        return ExecutionResult(0, False, error_msg)
                    elif step.error_handling.value == "retry":
                        # Retry logic
                        for retry in range(step.retry_count):
                            try:
                                time.sleep(1)  # Wait before retry
                                self.step_executor.execute_step(step)
                                step_success = True
                                step_error = ""
                                break
                            except:
                                if retry == step.retry_count - 1:
                                    # Log failed step after all retries
                                    step_duration = (time.time() - step_start_time) * 1000
                                    self.execution_logger.log_step_execution(
                                        0, step_index, step.name, step.step_type.value,
                                        False, step_duration, step_error
                                    )
                                    return ExecutionResult(0, False, error_msg)
                    # For "continue", just log and proceed
                
                # Log step execution result
                step_duration = (time.time() - step_start_time) * 1000
                self.execution_logger.log_step_execution(
                    0, step_index, step.name, step.step_type.value,
                    step_success, step_duration, step_error
                )
                    
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(0, True, duration_ms)
            return ExecutionResult(0, True, None, duration_ms)
            
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(0, False, duration_ms, str(e))
            return ExecutionResult(0, False, str(e), duration_ms)
            
    def toggle_pause(self):
        """Toggle pause state"""
        if self.state == ExecutionState.RUNNING:
            self._set_state(ExecutionState.PAUSED)
            self._pause_event.clear()
            self.logger.info("Execution paused")
        elif self.state == ExecutionState.PAUSED:
            self._set_state(ExecutionState.RUNNING)
            self._pause_event.set()
            self.logger.info("Execution resumed")
            
    def stop_execution(self):
        """Stop execution"""
        if self.state in [ExecutionState.RUNNING, ExecutionState.PAUSED]:
            self._set_state(ExecutionState.STOPPING)
            self._pause_event.set()  # Resume if paused
            self.logger.info("Stopping execution...")
            
    def is_running(self) -> bool:
        """Check if execution is active"""
        return self.state in [ExecutionState.RUNNING, ExecutionState.PAUSED]
</file>

<file path="src/automation/executor.py">
"""
Step executor for macro steps
"""

import re
import time
import os
from typing import Dict, Any, Optional, Tuple
import pyautogui
from core.macro_types import MacroStep, StepType
from config.settings import Settings
from logger.app_logger import get_logger

class StepExecutor:
    """Executes individual macro steps"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        self.variables: Dict[str, Any] = {}
        
        # Initialize image matcher
        self._image_matcher = None
        self._init_image_matcher()
        
        # Initialize text extractor
        self._text_extractor = None
        self._init_text_extractor()
        
        # Step handlers mapping
        self._handlers = {
            StepType.MOUSE_CLICK: self._execute_mouse_click,
            StepType.MOUSE_MOVE: self._execute_mouse_move,
            StepType.MOUSE_DRAG: self._execute_mouse_drag,
            StepType.MOUSE_SCROLL: self._execute_mouse_scroll,
            StepType.KEYBOARD_TYPE: self._execute_keyboard_type,
            StepType.KEYBOARD_HOTKEY: self._execute_keyboard_hotkey,
            StepType.WAIT_TIME: self._execute_wait_time,
            StepType.WAIT_IMAGE: self._execute_wait_image,
            StepType.SCREENSHOT: self._execute_screenshot,
            StepType.IMAGE_SEARCH: self._execute_image_search,
            StepType.OCR_TEXT: self._execute_text_search,
            StepType.IF_CONDITION: self._execute_if_condition,
            StepType.LOOP: self._execute_loop,
        }
        
    def _init_image_matcher(self):
        """Initialize image matcher with fallback"""
        try:
            from vision.image_matcher import ImageMatcher
            self._image_matcher = ImageMatcher(self.settings)
            self.logger.info("Using OpenCV-based image matcher")
        except ImportError:
            self.logger.warning("OpenCV not available, using pyautogui fallback")
            self._image_matcher = None
            
    def _init_text_extractor(self):
        """Initialize text extractor with fallback"""
        try:
            from vision.text_extractor import TextExtractor
            self._text_extractor = TextExtractor()
            self.logger.info("Using EasyOCR-based text extractor")
        except ImportError:
            self.logger.warning("EasyOCR not available, text search disabled")
            self._text_extractor = None
        
    def set_variables(self, variables: Dict[str, Any]):
        """Set variables for template substitution"""
        self.variables = variables
        
    def execute_step(self, step: MacroStep) -> Any:
        """Execute a single step"""
        handler = self._handlers.get(step.step_type)
        if not handler:
            raise NotImplementedError(f"No handler for step type: {step.step_type}")
            
        self.logger.debug(f"Executing step: {step.name} ({step.step_type.value})")
        
        try:
            result = handler(step)
            return result
        except Exception as e:
            self.logger.error(f"Step execution failed: {e}")
            raise
            
    def _substitute_variables(self, text: str) -> str:
        """Substitute variables in text"""
        if not text:
            return text
            
        # Find all {{variable}} patterns
        pattern = r'\{\{(\w+)\}\}'
        
        def replacer(match):
            var_name = match.group(1)
            if var_name in self.variables:
                return str(self.variables[var_name])
            return match.group(0)  # Keep original if not found
            
        return re.sub(pattern, replacer, text)
        
    def _get_absolute_position(self, x: int, y: int, relative_to: str) -> Tuple[int, int]:
        """Convert coordinates to absolute screen position"""
        if relative_to == "screen":
            return x, y
        elif relative_to == "window":
            # TODO: Implement window-relative coordinates
            # For now, treat as screen coordinates
            return x, y
        elif relative_to == "image":
            # TODO: Implement image-relative coordinates
            # For now, treat as screen coordinates
            return x, y
        else:
            return x, y
            
    # Mouse handlers
    
    def _execute_mouse_click(self, step) -> None:
        """Execute mouse click"""
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        
        pyautogui.click(
            x=x,
            y=y,
            clicks=step.clicks,
            interval=step.interval,
            button=step.button.value
        )
        
    def _execute_mouse_move(self, step) -> None:
        """Execute mouse move"""
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        
        if step.duration > 0:
            pyautogui.moveTo(x, y, duration=step.duration)
        else:
            pyautogui.moveTo(x, y)
            
    def _execute_mouse_drag(self, step) -> None:
        """Execute mouse drag"""
        # This would need to be implemented with proper drag coordinates
        # For now, using simple drag
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        pyautogui.dragTo(x, y, duration=step.duration, button=step.button.value)
        
    def _execute_mouse_scroll(self, step) -> None:
        """Execute mouse scroll"""
        pyautogui.scroll(step.clicks)
        
    # Keyboard handlers
    
    def _execute_keyboard_type(self, step) -> None:
        """Execute keyboard typing"""
        text = step.text
        
        # Substitute variables if enabled
        if step.use_variables:
            text = self._substitute_variables(text)
            
        pyautogui.typewrite(text, interval=step.interval)
        
    def _execute_keyboard_hotkey(self, step) -> None:
        """Execute keyboard hotkey"""
        if step.keys:
            pyautogui.hotkey(*step.keys)
            
    # Wait handlers
    
    def _execute_wait_time(self, step) -> None:
        """Execute time wait"""
        time.sleep(step.seconds)
        
    def _execute_wait_image(self, step) -> Optional[Tuple[int, int, int, int]]:
        """Execute wait for image"""
        if self._image_matcher:
            # Use OpenCV-based matcher
            result = self._image_matcher.wait_for_image(
                step.image_path,
                timeout=step.timeout,
                confidence=step.confidence,
                region=step.region
            )
            
            if result.found:
                self.logger.debug(f"Image found at: {result.location}")
                return result.location
            else:
                raise TimeoutError(f"Image not found within {step.timeout} seconds")
        else:
            # Fallback to pyautogui
            start_time = time.time()
            
            while time.time() - start_time < step.timeout:
                try:
                    # Try to locate image
                    location = pyautogui.locateOnScreen(
                        step.image_path,
                        confidence=step.confidence,
                        region=step.region
                    )
                    
                    if location:
                        self.logger.debug(f"Image found at: {location}")
                        return location
                        
                except Exception as e:
                    self.logger.debug(f"Image search error: {e}")
                    
                time.sleep(0.5)  # Check every 500ms
                
            raise TimeoutError(f"Image not found within {step.timeout} seconds")
        
    # Screen handlers
    
    def _execute_screenshot(self, step) -> str:
        """Execute screenshot"""
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        
        # Create screenshots directory
        screenshots_dir = os.path.join(
            os.path.dirname(__file__), 
            "../../screenshots"
        )
        os.makedirs(screenshots_dir, exist_ok=True)
        
        # Generate filename
        filename = os.path.join(
            screenshots_dir,
            f"screenshot_{timestamp}.png"
        )
        
        if self._image_matcher and hasattr(step, 'region') and step.region:
            # Capture specific region
            self._image_matcher.capture_region(step.region, filename)
        else:
            # Full screen capture
            pyautogui.screenshot(filename)
            
        self.logger.info(f"Screenshot saved: {filename}")
        return filename
        
    def _execute_image_search(self, step) -> Optional[Tuple[int, int, int, int]]:
        """Execute image search and optionally click"""
        location = None
        center = None
        
        if self._image_matcher:
            # Use OpenCV-based matcher
            result = self._image_matcher.find_image(
                step.image_path,
                confidence=step.confidence,
                region=step.region
            )
            
            if result.found:
                self.logger.debug(f"Image found at: {result.location}")
                location = result.location
                center = result.center
            else:
                self.logger.debug("Image not found with OpenCV matcher")
                return None
        else:
            # Fallback to pyautogui
            try:
                location = pyautogui.locateOnScreen(
                    step.image_path,
                    confidence=step.confidence,
                    region=step.region
                )
                if location:
                    center = pyautogui.center(location)
                else:
                    self.logger.debug("Image not found with pyautogui")
                    return None
            except Exception as e:
                self.logger.error(f"Error in image search: {e}")
                return None
        
        # If image was found and click is requested
        if location and center and step.click_after_find:
            # Apply click offset
            click_x = center[0] + step.click_offset[0]
            click_y = center[1] + step.click_offset[1]
            
            self.logger.info(f"Clicking at ({click_x}, {click_y})")
            
            # Perform click
            if step.double_click:
                pyautogui.doubleClick(click_x, click_y)
                self.logger.debug("Performed double click")
            else:
                pyautogui.click(click_x, click_y)
                self.logger.debug("Performed single click")
                
        return location
            
    def _execute_text_search(self, step) -> Optional[Tuple[int, int]]:
        """Execute text search and optionally click"""
        if not self._text_extractor:
            raise RuntimeError("Text extractor not available (EasyOCR not installed)")
            
        # Get search text
        search_text = step.search_text
        
        # If using Excel column, get value from variables
        if step.excel_column and step.excel_column in self.variables:
            search_text = str(self.variables[step.excel_column])
            
        if not search_text:
            raise ValueError("No search text specified")
            
        # Replace variables in search text
        search_text = self._substitute_variables(search_text)
        
        self.logger.info(f"Searching for text: {search_text}")
        
        # Find text on screen
        result = self._text_extractor.find_text(
            search_text,
            region=step.region,
            exact_match=step.exact_match,
            confidence_threshold=step.confidence
        )
        
        if result:
            self.logger.info(f"Text found at: {result.center}")
            
            # Click if requested
            if step.click_after_find:
                click_x = result.center[0] + step.click_offset[0]
                click_y = result.center[1] + step.click_offset[1]
                
                # Perform click
                if hasattr(step, 'double_click') and step.double_click:
                    pyautogui.doubleClick(click_x, click_y)
                    self.logger.debug(f"Double clicked at: ({click_x}, {click_y})")
                else:
                    pyautogui.click(click_x, click_y)
                    self.logger.debug(f"Clicked at: ({click_x}, {click_y})")
                
            return result.center
        else:
            self.logger.warning(f"Text not found: {search_text}")
            return None
    
    # Flow control handlers
    
    def _execute_if_condition(self, step) -> bool:
        """Execute if condition and run appropriate branch"""
        condition_result = False
        
        try:
            # Evaluate condition based on type
            if step.condition_type == "image_exists":
                # Check if image exists on screen
                image_path = step.condition_value.get('image_path', '')
                confidence = step.condition_value.get('confidence', 0.9)
                region = step.condition_value.get('region')
                
                if self._image_matcher:
                    result = self._image_matcher.find_image(
                        image_path,
                        confidence=confidence,
                        region=region
                    )
                    condition_result = result.found if result else False
                else:
                    # Fallback to pyautogui
                    try:
                        location = pyautogui.locateOnScreen(
                            image_path,
                            confidence=confidence,
                            region=region
                        )
                        condition_result = location is not None
                    except:
                        condition_result = False
                        
            elif step.condition_type == "text_exists":
                # Check if text exists on screen
                search_text = step.condition_value.get('text', '')
                exact_match = step.condition_value.get('exact_match', False)
                region = step.condition_value.get('region')
                
                # Substitute variables in search text
                search_text = self._substitute_variables(search_text)
                
                if self._text_extractor and search_text:
                    result = self._text_extractor.find_text(
                        search_text,
                        region=region,
                        exact_match=exact_match,
                        confidence_threshold=0.5
                    )
                    condition_result = result is not None
                else:
                    condition_result = False
                    
            elif step.condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
                # Variable comparison conditions
                variable_name = step.condition_value.get('variable', '')
                compare_value = step.condition_value.get('compare_value', '')
                
                # Get variable value
                variable_value = self.variables.get(variable_name, '')
                
                # Substitute variables in compare value
                compare_value = self._substitute_variables(compare_value)
                
                # Perform comparison
                if step.condition_type == "variable_equals":
                    condition_result = str(variable_value) == str(compare_value)
                elif step.condition_type == "variable_contains":
                    condition_result = str(compare_value) in str(variable_value)
                elif step.condition_type == "variable_greater":
                    try:
                        condition_result = float(variable_value) > float(compare_value)
                    except (ValueError, TypeError):
                        # If not numeric, do string comparison
                        condition_result = str(variable_value) > str(compare_value)
                elif step.condition_type == "variable_less":
                    try:
                        condition_result = float(variable_value) < float(compare_value)
                    except (ValueError, TypeError):
                        # If not numeric, do string comparison
                        condition_result = str(variable_value) < str(compare_value)
                        
            self.logger.info(f"Condition '{step.condition_type}' evaluated to: {condition_result}")
            
            # Execute appropriate branch
            if condition_result:
                # Execute true branch steps
                for nested_step in step.true_steps:
                    if nested_step.enabled:
                        self.execute_step(nested_step)
            else:
                # Execute false branch steps
                for nested_step in step.false_steps:
                    if nested_step.enabled:
                        self.execute_step(nested_step)
                        
            return condition_result
            
        except Exception as e:
            self.logger.error(f"Error evaluating condition: {e}")
            # On error, execute false branch
            for nested_step in step.false_steps:
                if nested_step.enabled:
                    self.execute_step(nested_step)
            return False
        
    def _execute_loop(self, step) -> None:
        """Execute loop"""
        # TODO: Implement loop execution
        # This would need to interact with the main engine
        pass
</file>

<file path="src/core/macro_storage.py">
"""
Macro storage and JSON serialization
"""

import json
import os
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
import shutil
from enum import Enum
from utils.encryption import EncryptionManager
from logger.app_logger import get_logger
from core.macro_types import Macro
from utils.macro_loader import load_macro_safe, save_macro_safe


class MacroFormat(Enum):
    """Supported macro file formats"""
    JSON = "json"
    ENCRYPTED = "encrypted"

class MacroStorage:
    """Handles macro storage, loading, and saving"""
    
    SCHEMA_VERSION = "1.0.0"
    
    def __init__(self, storage_dir: Optional[Path] = None):
        """Initialize macro storage"""
        self.logger = get_logger(__name__)
        self.storage_dir = storage_dir or Path.home() / ".excel_macro_automation" / "macros"
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        self.encryption_manager = EncryptionManager()
        
    def save_macro(self, macro: Macro, file_path: Optional[str] = None, 
                   format_type: MacroFormat = MacroFormat.JSON, create_backup: bool = True) -> bool:
        """Save macro to file"""
        if not file_path:
            file_name = f"{macro.name.replace(' ', '_')}_{macro.macro_id[:8]}.json"
            file_path = self.storage_dir / file_name
        else:
            file_path = Path(file_path)
            
        # Create backup if requested and file exists
        if create_backup and file_path.exists():
            self._create_backup(file_path)
            
        # Prepare data
        data = {
            "schema_version": self.SCHEMA_VERSION,
            "macro": macro.to_dict()
        }
        
        # Convert to JSON
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        
        # Save file
        try:
            if format_type == MacroFormat.ENCRYPTED:
                encrypted_data = self.encryption_manager.encrypt(json_str.encode('utf-8'))
                file_path = file_path.with_suffix('.emf')
                file_path.write_bytes(encrypted_data)
                self.logger.info(f"Saved encrypted macro: {file_path}")
            else:
                file_path.write_text(json_str, encoding='utf-8')
                self.logger.info(f"Saved macro: {file_path}")
                
            return True
        except Exception as e:
            self.logger.error(f"Failed to save macro: {e}")
            return False
        
    def load_macro(self, file_path: str) -> Macro:
        """Load macro from file"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Macro file not found: {file_path}")
            
        # Check if encrypted
        if file_path.suffix in ['.emacro', '.emf']:
            encrypted_data = file_path.read_bytes()
            json_data = self.encryption_manager.decrypt(encrypted_data).decode('utf-8')
            data = json.loads(json_data)
            
            # Check schema version
            schema_version = data.get("schema_version", "0.0.0")
            if schema_version != self.SCHEMA_VERSION:
                self.logger.warning(f"Schema version mismatch: {schema_version} != {self.SCHEMA_VERSION}")
                
            # Load macro
            macro_data = data.get("macro", {})
            macro = Macro.from_dict(macro_data)
            
            self.logger.info(f"Loaded macro: {macro.name} from {file_path}")
            return macro
        else:
            # Use safe loader for regular files
            macro = load_macro_safe(str(file_path))
            if not macro:
                raise ValueError(f"Failed to load macro from {file_path}")
            return macro
        
    def list_macros(self, include_encrypted: bool = True) -> List[Dict[str, Any]]:
        """List all saved macros"""
        macros = []
        
        # Search for macro files
        patterns = ['*.json']
        if include_encrypted:
            patterns.append('*.emacro')
            
        for pattern in patterns:
            for file_path in self.storage_dir.glob(pattern):
                try:
                    # Get basic info without fully loading
                    if file_path.suffix == '.emacro':
                        # For encrypted files, we need to decrypt to get info
                        macro = self.load_macro(str(file_path))
                        info = {
                            "file_path": str(file_path),
                            "file_name": file_path.name,
                            "macro_id": macro.macro_id,
                            "name": macro.name,
                            "description": macro.description,
                            "created_at": macro.created_at.isoformat(),
                            "updated_at": macro.updated_at.isoformat(),
                            "encrypted": True
                        }
                    else:
                        # For JSON files, we can peek without full parsing
                        data = json.loads(file_path.read_text(encoding='utf-8'))
                        macro_data = data.get("macro", {})
                        info = {
                            "file_path": str(file_path),
                            "file_name": file_path.name,
                            "macro_id": macro_data.get("macro_id", ""),
                            "name": macro_data.get("name", ""),
                            "description": macro_data.get("description", ""),
                            "created_at": macro_data.get("created_at", ""),
                            "updated_at": macro_data.get("updated_at", ""),
                            "encrypted": False
                        }
                    macros.append(info)
                except Exception as e:
                    self.logger.error(f"Failed to read macro file {file_path}: {e}")
                    
        # Sort by updated date
        macros.sort(key=lambda x: x["updated_at"], reverse=True)
        return macros
        
    def delete_macro(self, file_path: str, create_backup: bool = True) -> bool:
        """Delete a macro file"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            return False
            
        if create_backup:
            self._create_backup(file_path)
            
        file_path.unlink()
        self.logger.info(f"Deleted macro: {file_path}")
        return True
        
    def export_macro(self, macro: Macro, export_path: str) -> str:
        """Export macro for sharing"""
        export_path = Path(export_path)
        
        # Always export as unencrypted JSON for sharing
        data = {
            "schema_version": self.SCHEMA_VERSION,
            "macro": macro.to_dict(),
            "export_info": {
                "exported_at": datetime.now().isoformat(),
                "export_version": "1.0.0"
            }
        }
        
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        export_path.write_text(json_str, encoding='utf-8')
        
        self.logger.info(f"Exported macro: {export_path}")
        return str(export_path)
        
    def import_macro(self, import_path: str, save_to_storage: bool = True) -> Macro:
        """Import macro from external file"""
        import_path = Path(import_path)
        
        if not import_path.exists():
            raise FileNotFoundError(f"Import file not found: {import_path}")
            
        # Load the macro
        data = json.loads(import_path.read_text(encoding='utf-8'))
        
        # Check if it's an export file
        if "export_info" in data:
            self.logger.info(f"Importing from export: {data['export_info']}")
            
        macro_data = data.get("macro", {})
        macro = Macro.from_dict(macro_data)
        
        # Generate new ID to avoid conflicts
        import uuid
        macro.macro_id = str(uuid.uuid4())
        macro.updated_at = datetime.now()
        
        # Save to storage if requested
        if save_to_storage:
            self.save_macro(macro)
            
        self.logger.info(f"Imported macro: {macro.name}")
        return macro
        
    def _create_backup(self, file_path: Path):
        """Create backup of file"""
        backup_dir = self.storage_dir / "backups"
        backup_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{file_path.stem}_backup_{timestamp}{file_path.suffix}"
        backup_path = backup_dir / backup_name
        
        shutil.copy2(file_path, backup_path)
        self.logger.info(f"Created backup: {backup_path}")
        
        # Clean old backups (keep last 10)
        self._clean_old_backups(file_path.stem)
        
    def _clean_old_backups(self, file_stem: str, keep_count: int = 10):
        """Clean old backup files"""
        backup_dir = self.storage_dir / "backups"
        if not backup_dir.exists():
            return
            
        # Find all backups for this file
        backups = list(backup_dir.glob(f"{file_stem}_backup_*"))
        backups.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        # Delete old backups
        for backup in backups[keep_count:]:
            backup.unlink()
            self.logger.info(f"Deleted old backup: {backup}")
            
    def get_templates(self) -> List[Dict[str, Any]]:
        """Get available macro templates"""
        templates = [
            {
                "name": "ê¸°ë³¸ ìë™í™”",
                "description": "ë§ˆìš°ìŠ¤ í´ë¦­ê³¼ í…ìŠ¤íŠ¸ ì…ë ¥ì„ í¬í•¨í•œ ê¸°ë³¸ í…œí”Œë¦¿",
                "macro": self._create_basic_template()
            },
            {
                "name": "ì›¹ ìë™í™”",
                "description": "ì›¹ ë¸Œë¼ìš°ì € ìë™í™”ë¥¼ ìœ„í•œ í…œí”Œë¦¿",
                "macro": self._create_web_template()
            },
            {
                "name": "ì—‘ì…€ ë°ì´í„° ì…ë ¥",
                "description": "ì—‘ì…€ ë°ì´í„°ë¥¼ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì— ì…ë ¥í•˜ëŠ” í…œí”Œë¦¿",
                "macro": self._create_excel_input_template()
            }
        ]
        return templates
        
    def _create_basic_template(self) -> Macro:
        """Create basic automation template"""
        from core.macro_types import MouseClickStep, WaitTimeStep, KeyboardTypeStep
        
        macro = Macro(name="ê¸°ë³¸ ìë™í™” í…œí”Œë¦¿")
        
        # Add sample steps
        click_step = MouseClickStep(
            name="í”„ë¡œê·¸ë¨ í´ë¦­",
            description="ìë™í™”í•  í”„ë¡œê·¸ë¨ì„ í´ë¦­í•©ë‹ˆë‹¤"
        )
        macro.add_step(click_step)
        
        wait_step = WaitTimeStep(
            name="ëŒ€ê¸°",
            description="í”„ë¡œê·¸ë¨ì´ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°",
            seconds=2.0
        )
        macro.add_step(wait_step)
        
        type_step = KeyboardTypeStep(
            name="í…ìŠ¤íŠ¸ ì…ë ¥",
            description="ì…ë ¥í•  í…ìŠ¤íŠ¸",
            text="{{ì´ë¦„}}"
        )
        macro.add_step(type_step)
        
        return macro
        
    def _create_web_template(self) -> Macro:
        """Create web automation template"""
        from core.macro_types import WaitTimeStep, KeyboardHotkeyStep, KeyboardTypeStep
        
        macro = Macro(name="ì›¹ ìë™í™” í…œí”Œë¦¿")
        
        # Open browser
        hotkey_step = KeyboardHotkeyStep(
            name="ë¸Œë¼ìš°ì € ì—´ê¸°",
            description="ì›¹ ë¸Œë¼ìš°ì €ë¥¼ ì—½ë‹ˆë‹¤",
            keys=["win", "r"]
        )
        macro.add_step(hotkey_step)
        
        wait_step = WaitTimeStep(seconds=1.0)
        macro.add_step(wait_step)
        
        type_step = KeyboardTypeStep(
            name="ë¸Œë¼ìš°ì € ì‹¤í–‰",
            text="chrome"
        )
        macro.add_step(type_step)
        
        return macro
        
    def _create_excel_input_template(self) -> Macro:
        """Create Excel input template"""
        from core.macro_types import LoopStep, KeyboardTypeStep, KeyboardHotkeyStep
        
        macro = Macro(name="ì—‘ì…€ ë°ì´í„° ì…ë ¥ í…œí”Œë¦¿")
        
        # This is a placeholder - would need proper implementation
        # with Excel row iteration
        
        return macro
</file>

<file path="src/ui/dialogs/if_condition_step_dialog.py">
"""
If condition step configuration dialog
"""

from typing import Optional, Dict, Any, List
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox,
    QPushButton, QLabel, QGroupBox, QListWidget,
    QListWidgetItem, QTextEdit, QWidget, QSplitter,
    QMessageBox, QCompleter, QCheckBox, QFileDialog,
    QMenu
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QIcon
from core.macro_types import IfConditionStep, MacroStep, StepType
from ui.widgets.roi_selector import ROISelectorWidget

class DraggableStepButton(QPushButton):
    """Draggable button for step types"""
    
    def __init__(self, step_type: StepType, text: str):
        super().__init__(text)
        self.step_type = step_type
        self.setStyleSheet("""
            QPushButton {
                padding: 8px 12px;
                border: 2px solid #2196F3;
                border-radius: 4px;
                background-color: white;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #e3f2fd;
                cursor: move;
            }
        """)
        
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drag_start_position = event.pos()
            
    def mouseMoveEvent(self, event):
        if not (event.buttons() & Qt.LeftButton):
            return
            
        if (event.pos() - self.drag_start_position).manhattanLength() < 10:
            return
            
        # Start drag
        from PyQt5.QtGui import QDrag
        from PyQt5.QtCore import QMimeData, QByteArray, QDataStream, QIODevice
        
        drag = QDrag(self)
        mime_data = QMimeData()
        
        # Store step type in MIME data
        byte_array = QByteArray()
        stream = QDataStream(byte_array, QIODevice.WriteOnly)
        stream.writeQString(self.step_type.value)
        
        mime_data.setData("application/x-steptype", byte_array)
        mime_data.setText(self.text())
        drag.setMimeData(mime_data)
        
        drag.exec_(Qt.CopyAction)

class ConditionTypeWidget(QWidget):
    """Widget for configuring condition parameters based on type"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)
        
    def set_condition_type(self, condition_type: str, excel_columns: List[str] = None):
        """Update UI based on condition type"""
        # Clear existing widgets
        while self.layout.count():
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
                
        if condition_type == "image_exists":
            self._setup_image_condition()
        elif condition_type == "text_exists":
            self._setup_text_condition()
        elif condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            self._setup_variable_condition(excel_columns)
            
    def _setup_image_condition(self):
        """Setup UI for image exists condition"""
        form_layout = QFormLayout()
        
        # Image path
        self.image_path_edit = QLineEdit()
        self.image_browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°...")
        self.image_browse_btn.clicked.connect(self._browse_image)
        image_layout = QHBoxLayout()
        image_layout.addWidget(self.image_path_edit)
        image_layout.addWidget(self.image_browse_btn)
        form_layout.addRow("ì´ë¯¸ì§€ íŒŒì¼:", image_layout)
        
        # Confidence
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setRange(0.1, 1.0)
        self.confidence_spin.setSingleStep(0.1)
        self.confidence_spin.setValue(0.9)
        form_layout.addRow("ì •í™•ë„:", self.confidence_spin)
        
        # Region selector
        self.region_selector = ROISelectorWidget()
        form_layout.addRow("ê²€ìƒ‰ ì˜ì—­:", self.region_selector)
        
        # Test button
        self.test_btn = QPushButton("ì¡°ê±´ í…ŒìŠ¤íŠ¸")
        self.test_btn.setStyleSheet("""
            QPushButton {
                background-color: #4caf50;
                color: white;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.test_btn.clicked.connect(self._test_image_condition)
        
        # Test result
        self.test_result_label = QLabel()
        self.test_result_label.setWordWrap(True)
        
        test_layout = QVBoxLayout()
        test_layout.addWidget(self.test_btn)
        test_layout.addWidget(self.test_result_label)
        form_layout.addRow("", test_layout)
        
        self.layout.addLayout(form_layout)
        
    def _browse_image(self):
        """Browse for image file"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ",
            "",
            "Image Files (*.png *.jpg *.jpeg *.bmp *.gif);;All Files (*.*)"
        )
        if filename:
            self.image_path_edit.setText(filename)
        
    def _setup_text_condition(self):
        """Setup UI for text exists condition"""
        form_layout = QFormLayout()
        
        # Search text
        self.text_edit = QLineEdit()
        self.text_edit.setPlaceholderText("ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ ë˜ëŠ” {{ë³€ìˆ˜}}")
        form_layout.addRow("í…ìŠ¤íŠ¸:", self.text_edit)
        
        # Exact match
        self.exact_match_check = QCheckBox("ì •í™•íˆ ì¼ì¹˜")
        form_layout.addRow("", self.exact_match_check)
        
        # Region selector
        self.region_selector = ROISelectorWidget()
        form_layout.addRow("ê²€ìƒ‰ ì˜ì—­:", self.region_selector)
        
        self.layout.addLayout(form_layout)
        
    def _setup_variable_condition(self, excel_columns: List[str] = None):
        """Setup UI for variable comparison condition"""
        form_layout = QFormLayout()
        
        # Variable name
        self.variable_combo = QComboBox()
        self.variable_combo.setEditable(True)
        if excel_columns:
            self.variable_combo.addItems(excel_columns)
        form_layout.addRow("ë³€ìˆ˜:", self.variable_combo)
        
        # Comparison value
        self.compare_value_edit = QLineEdit()
        self.compare_value_edit.setPlaceholderText("ë¹„êµí•  ê°’ ë˜ëŠ” {{ë³€ìˆ˜}}")
        form_layout.addRow("ë¹„êµê°’:", self.compare_value_edit)
        
        self.layout.addLayout(form_layout)
        
    def get_condition_value(self) -> Dict[str, Any]:
        """Get condition parameters"""
        value = {}
        
        # Image exists
        if hasattr(self, 'image_path_edit'):
            value['image_path'] = self.image_path_edit.text()
            value['confidence'] = self.confidence_spin.value()
            value['region'] = self.region_selector.get_region()
            
        # Text exists
        elif hasattr(self, 'text_edit'):
            value['text'] = self.text_edit.text()
            value['exact_match'] = self.exact_match_check.isChecked()
            value['region'] = self.region_selector.get_region()
            
        # Variable comparison
        elif hasattr(self, 'variable_combo'):
            value['variable'] = self.variable_combo.currentText()
            value['compare_value'] = self.compare_value_edit.text()
            
        return value
        
    def _test_image_condition(self):
        """Test image condition"""
        image_path = self.image_path_edit.text()
        if not image_path:
            self.test_result_label.setText("âŒ ì´ë¯¸ì§€ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            self.test_result_label.setStyleSheet("color: red;")
            return
            
        try:
            import pyautogui
            # Test image search
            location = pyautogui.locateOnScreen(
                image_path,
                confidence=self.confidence_spin.value(),
                region=self.region_selector.get_region()
            )
            
            if location:
                self.test_result_label.setText(f"âœ… ì´ë¯¸ì§€ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤! ìœ„ì¹˜: ({location.left}, {location.top})")
                self.test_result_label.setStyleSheet("color: green; font-weight: bold;")
            else:
                self.test_result_label.setText("âŒ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                self.test_result_label.setStyleSheet("color: red;")
                
        except Exception as e:
            self.test_result_label.setText(f"âŒ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            self.test_result_label.setStyleSheet("color: red;")
        
    def set_condition_value(self, value: Dict[str, Any]):
        """Set condition parameters"""
        # Image exists
        if hasattr(self, 'image_path_edit') and 'image_path' in value:
            self.image_path_edit.setText(value.get('image_path', ''))
            self.confidence_spin.setValue(value.get('confidence', 0.9))
            if value.get('region'):
                self.region_selector.set_region(value['region'])
                
        # Text exists
        elif hasattr(self, 'text_edit') and 'text' in value:
            self.text_edit.setText(value.get('text', ''))
            self.exact_match_check.setChecked(value.get('exact_match', False))
            if value.get('region'):
                self.region_selector.set_region(value['region'])
                
        # Variable comparison
        elif hasattr(self, 'variable_combo') and 'variable' in value:
            self.variable_combo.setCurrentText(value.get('variable', ''))
            self.compare_value_edit.setText(value.get('compare_value', ''))

class StepListWidget(QListWidget):
    """Widget for displaying and managing nested steps"""
    
    stepAdded = pyqtSignal(MacroStep)
    stepRemoved = pyqtSignal(str)  # step_id
    stepEdited = pyqtSignal(MacroStep)
    
    def __init__(self):
        super().__init__()
        self.steps: List[MacroStep] = []
        self.setAcceptDrops(True)
        self.setDragDropMode(QListWidget.InternalMove)
        self.setStyleSheet("""
            QListWidget {
                background-color: white;
                border: 1px solid #ddd;
                border-radius: 3px;
                padding: 5px;
                min-height: 100px;
            }
            QListWidget::item {
                padding: 5px;
                margin: 2px;
                border: 1px solid #e0e0e0;
                border-radius: 3px;
            }
            QListWidget::item:hover {
                background-color: #f5f5f5;
                border-color: #bdbdbd;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
                border-color: #2196F3;
            }
        """)
        
    def add_step(self, step_type: StepType):
        """Add a new step of given type"""
        from core.macro_types import StepFactory
        step = StepFactory.create_step(step_type)
        
        # Set default name
        step_names = {
            StepType.MOUSE_CLICK: "ë§ˆìš°ìŠ¤ í´ë¦­",
            StepType.KEYBOARD_TYPE: "í…ìŠ¤íŠ¸ ì…ë ¥",
            StepType.WAIT_TIME: "ëŒ€ê¸°",
            StepType.IMAGE_SEARCH: "ì´ë¯¸ì§€ ê²€ìƒ‰",
            StepType.OCR_TEXT: "í…ìŠ¤íŠ¸ ê²€ìƒ‰"
        }
        step.name = step_names.get(step_type, step_type.value)
        
        self.steps.append(step)
        self._refresh_list()
        self.stepAdded.emit(step)
        
    def remove_selected(self):
        """Remove selected step"""
        current_row = self.currentRow()
        if 0 <= current_row < len(self.steps):
            removed_step = self.steps.pop(current_row)
            self._refresh_list()
            self.stepRemoved.emit(removed_step.step_id)
            
    def get_steps(self) -> List[MacroStep]:
        """Get all steps"""
        return self.steps
        
    def set_steps(self, steps: List[MacroStep]):
        """Set steps"""
        self.steps = steps.copy()
        self._refresh_list()
        
    def _refresh_list(self):
        """Refresh list display"""
        self.clear()
        
        for step in self.steps:
            icon = self._get_step_icon(step.step_type)
            text = f"{icon} {step.name}"
            if hasattr(step, 'description') and step.description:
                text += f" - {step.description}"
                
            item = QListWidgetItem(text)
            self.addItem(item)
            
    def _get_step_icon(self, step_type: StepType) -> str:
        """Get icon for step type"""
        icons = {
            StepType.MOUSE_CLICK: "ğŸ–±ï¸",
            StepType.KEYBOARD_TYPE: "âŒ¨ï¸",
            StepType.WAIT_TIME: "â±ï¸",
            StepType.IMAGE_SEARCH: "ğŸ”",
            StepType.OCR_TEXT: "ğŸ”¤"
        }
        return icons.get(step_type, "")
        
    def dragEnterEvent(self, event):
        """Handle drag enter event"""
        if event.mimeData().hasFormat("application/x-steptype"):
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)
            
    def dragMoveEvent(self, event):
        """Handle drag move event"""
        if event.mimeData().hasFormat("application/x-steptype"):
            event.acceptProposedAction()
        else:
            super().dragMoveEvent(event)
            
    def dropEvent(self, event):
        """Handle drop event"""
        if event.mimeData().hasFormat("application/x-steptype"):
            # Extract step type from mime data
            from PyQt5.QtCore import QDataStream, QIODevice
            byte_array = event.mimeData().data("application/x-steptype")
            stream = QDataStream(byte_array, QIODevice.ReadOnly)
            step_type_str_result = stream.readQString()
            step_type_str = step_type_str_result[0] if isinstance(step_type_str_result, tuple) else step_type_str_result
            
            # Create new step
            step_type = StepType(step_type_str)
            self.add_step(step_type)
            
            event.acceptProposedAction()
        else:
            super().dropEvent(event)

class IfConditionStepDialog(QDialog):
    """Dialog for configuring if condition step"""
    
    def __init__(self, step: Optional[IfConditionStep] = None, 
                 excel_columns: List[str] = None, parent=None):
        super().__init__(parent)
        self.step = step or IfConditionStep()
        self.excel_columns = excel_columns or []
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("ì¡°ê±´ë¬¸ ì„¤ì •")
        self.setModal(True)
        self.resize(800, 600)
        
        layout = QVBoxLayout()
        
        # Basic info
        info_group = QGroupBox("ê¸°ë³¸ ì •ë³´")
        info_layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        self.name_edit.setText(self.step.name or "ì¡°ê±´ë¬¸")
        info_layout.addRow("ì´ë¦„:", self.name_edit)
        
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(60)
        self.description_edit.setText(self.step.description)
        info_layout.addRow("ì„¤ëª…:", self.description_edit)
        
        info_group.setLayout(info_layout)
        layout.addWidget(info_group)
        
        # Condition configuration
        condition_group = QGroupBox("ì¡°ê±´ ì„¤ì •")
        condition_layout = QVBoxLayout()
        
        # Condition type
        type_layout = QHBoxLayout()
        type_layout.addWidget(QLabel("ì¡°ê±´ ìœ í˜•:"))
        
        self.condition_type_combo = QComboBox()
        
        # Add items with proper data
        condition_types = [
            ("ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´", "image_exists"),
            ("í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´", "text_exists"),
            ("ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´", "variable_equals"),
            ("ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´", "variable_contains"),
            ("ë³€ìˆ˜ê°€ í¬ë©´", "variable_greater"),
            ("ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´", "variable_less")
        ]
        
        for display_text, type_value in condition_types:
            self.condition_type_combo.addItem(display_text, type_value)
            
        self.condition_type_combo.currentIndexChanged.connect(self._on_condition_type_changed)
        type_layout.addWidget(self.condition_type_combo)
        type_layout.addStretch()
        condition_layout.addLayout(type_layout)
        
        # Condition parameters
        self.condition_widget = ConditionTypeWidget()
        condition_layout.addWidget(self.condition_widget)
        
        condition_group.setLayout(condition_layout)
        layout.addWidget(condition_group)
        
        # Branch steps
        branches_group = QGroupBox("ë¶„ê¸° ë™ì‘")
        branches_layout = QVBoxLayout()
        
        # Add help text
        help_text = QLabel("ğŸ’¡ íŒ: ì•„ë˜ ë‹¨ê³„ ìœ í˜•ì„ ë“œë˜ê·¸í•˜ì—¬ ì¡°ê±´ ë¶„ê¸°ì— ì¶”ê°€í•˜ê±°ë‚˜, 'ë‹¨ê³„ ì¶”ê°€' ë²„íŠ¼ì„ ì‚¬ìš©í•˜ì„¸ìš”.")
        help_text.setWordWrap(True)
        help_text.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        branches_layout.addWidget(help_text)
        
        # Add mini palette
        palette_layout = QHBoxLayout()
        palette_label = QLabel("ë‹¨ê³„ ìœ í˜•:")
        palette_label.setStyleSheet("font-weight: bold;")
        palette_layout.addWidget(palette_label)
        
        # Create draggable step type buttons
        step_types = [
            (StepType.MOUSE_CLICK, "ğŸ–±ï¸ í´ë¦­"),
            (StepType.KEYBOARD_TYPE, "âŒ¨ï¸ ì…ë ¥"),
            (StepType.WAIT_TIME, "â±ï¸ ëŒ€ê¸°"),
            (StepType.IMAGE_SEARCH, "ğŸ” ì´ë¯¸ì§€"),
        ]
        
        for step_type, label in step_types:
            btn = DraggableStepButton(step_type, label)
            palette_layout.addWidget(btn)
            
        palette_layout.addStretch()
        branches_layout.addLayout(palette_layout)
        
        # Create splitter for true/false branches
        splitter = QSplitter(Qt.Horizontal)
        
        # True branch
        true_widget = QWidget()
        true_widget.setStyleSheet("""
            QWidget {
                background-color: #e8f5e9;
                border: 2px solid #4caf50;
                border-radius: 5px;
                padding: 5px;
            }
        """)
        true_layout = QVBoxLayout()
        true_label = QLabel("âœ… ì¡°ê±´ì´ ì°¸ì¼ ë•Œ:")
        true_label.setStyleSheet("font-weight: bold; color: #2e7d32; font-size: 13px;")
        true_layout.addWidget(true_label)
        
        self.true_steps_list = StepListWidget()
        true_layout.addWidget(self.true_steps_list)
        
        # True branch buttons
        true_btn_layout = QHBoxLayout()
        
        add_true_menu = QPushButton("ë‹¨ê³„ ì¶”ê°€")
        add_true_menu.setMenu(self._create_step_menu(self.true_steps_list))
        true_btn_layout.addWidget(add_true_menu)
        
        remove_true_btn = QPushButton("ì‚­ì œ")
        remove_true_btn.clicked.connect(self.true_steps_list.remove_selected)
        true_btn_layout.addWidget(remove_true_btn)
        
        true_btn_layout.addStretch()
        true_layout.addLayout(true_btn_layout)
        
        true_widget.setLayout(true_layout)
        splitter.addWidget(true_widget)
        
        # False branch
        false_widget = QWidget()
        false_widget.setStyleSheet("""
            QWidget {
                background-color: #ffebee;
                border: 2px solid #f44336;
                border-radius: 5px;
                padding: 5px;
            }
        """)
        false_layout = QVBoxLayout()
        false_label = QLabel("âŒ ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œ:")
        false_label.setStyleSheet("font-weight: bold; color: #c62828; font-size: 13px;")
        false_layout.addWidget(false_label)
        
        self.false_steps_list = StepListWidget()
        false_layout.addWidget(self.false_steps_list)
        
        # False branch buttons
        false_btn_layout = QHBoxLayout()
        
        add_false_menu = QPushButton("ë‹¨ê³„ ì¶”ê°€")
        add_false_menu.setMenu(self._create_step_menu(self.false_steps_list))
        false_btn_layout.addWidget(add_false_menu)
        
        remove_false_btn = QPushButton("ì‚­ì œ")
        remove_false_btn.clicked.connect(self.false_steps_list.remove_selected)
        false_btn_layout.addWidget(remove_false_btn)
        
        false_btn_layout.addStretch()
        false_layout.addLayout(false_btn_layout)
        
        false_widget.setLayout(false_layout)
        splitter.addWidget(false_widget)
        
        branches_layout.addWidget(splitter)
        branches_group.setLayout(branches_layout)
        layout.addWidget(branches_group)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        ok_btn = QPushButton("í™•ì¸")
        ok_btn.clicked.connect(self.accept)
        button_layout.addWidget(ok_btn)
        
        cancel_btn = QPushButton("ì·¨ì†Œ")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
        # Initialize condition type
        self._on_condition_type_changed()
        
    def _create_step_menu(self, step_list: StepListWidget):
        """Create menu for adding steps"""
        menu = QMenu()
        
        # Simple steps only (no nested conditions)
        simple_steps = [
            (StepType.MOUSE_CLICK, "ğŸ–±ï¸ ë§ˆìš°ìŠ¤ í´ë¦­"),
            (StepType.KEYBOARD_TYPE, "âŒ¨ï¸ í…ìŠ¤íŠ¸ ì…ë ¥"),
            (StepType.WAIT_TIME, "â±ï¸ ëŒ€ê¸°"),
            (StepType.IMAGE_SEARCH, "ğŸ” ì´ë¯¸ì§€ ê²€ìƒ‰"),
            (StepType.OCR_TEXT, "ğŸ”¤ í…ìŠ¤íŠ¸ ê²€ìƒ‰")
        ]
        
        for step_type, name in simple_steps:
            action = menu.addAction(name)
            action.triggered.connect(lambda checked, st=step_type: step_list.add_step(st))
            
        return menu
        
    def _on_condition_type_changed(self):
        """Handle condition type change"""
        # Get selected type value
        condition_type = self.condition_type_combo.currentData(Qt.UserRole)
        if not condition_type:
            condition_type = self.condition_type_combo.currentText()
            
        # Map display text to type value
        type_mapping = {
            "ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´": "image_exists",
            "í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´": "text_exists",
            "ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´": "variable_equals",
            "ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´": "variable_contains",
            "ë³€ìˆ˜ê°€ í¬ë©´": "variable_greater",
            "ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´": "variable_less"
        }
        
        if condition_type in type_mapping:
            condition_type = type_mapping[condition_type]
            
        self.condition_widget.set_condition_type(condition_type, self.excel_columns)
        
    def load_step_data(self):
        """Load data from step"""
        if not self.step:
            return
            
        self.name_edit.setText(self.step.name)
        self.description_edit.setText(self.step.description)
        
        # Set condition type
        type_index = {
            "image_exists": 0,
            "text_exists": 1,
            "variable_equals": 2,
            "variable_contains": 3,
            "variable_greater": 4,
            "variable_less": 5
        }.get(self.step.condition_type, 0)
        
        self.condition_type_combo.setCurrentIndex(type_index)
        self.condition_widget.set_condition_value(self.step.condition_value)
        
        # Set branch steps
        self.true_steps_list.set_steps(self.step.true_steps)
        self.false_steps_list.set_steps(self.step.false_steps)
        
    def get_step_data(self) -> Dict[str, Any]:
        """Get configured step data"""
        # Get condition type
        condition_type = self.condition_type_combo.currentData(Qt.UserRole)
        if not condition_type:
            type_mapping = {
                "ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´": "image_exists",
                "í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´": "text_exists",
                "ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´": "variable_equals",
                "ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´": "variable_contains",
                "ë³€ìˆ˜ê°€ í¬ë©´": "variable_greater",
                "ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´": "variable_less"
            }
            condition_type = type_mapping.get(self.condition_type_combo.currentText(), "image_exists")
            
        return {
            'name': self.name_edit.text(),
            'description': self.description_edit.toPlainText(),
            'condition_type': condition_type,
            'condition_value': self.condition_widget.get_condition_value(),
            'true_steps': self.true_steps_list.get_steps(),
            'false_steps': self.false_steps_list.get_steps()
        }
        
    def accept(self):
        """Validate and accept"""
        # Basic validation
        if not self.name_edit.text():
            QMessageBox.warning(self, "ê²½ê³ ", "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
            return
            
        # Validate condition parameters
        condition_value = self.condition_widget.get_condition_value()
        condition_type = self.get_step_data()['condition_type']
        
        if condition_type == "image_exists" and not condition_value.get('image_path'):
            QMessageBox.warning(self, "ê²½ê³ ", "ì´ë¯¸ì§€ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return
            
        elif condition_type == "text_exists" and not condition_value.get('text'):
            QMessageBox.warning(self, "ê²½ê³ ", "ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
            return
            
        elif condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            if not condition_value.get('variable'):
                QMessageBox.warning(self, "ê²½ê³ ", "ë³€ìˆ˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.")
                return
            if not condition_value.get('compare_value'):
                QMessageBox.warning(self, "ê²½ê³ ", "ë¹„êµê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                return
                
        super().accept()
</file>

<file path="src/ui/dialogs/text_search_step_dialog.py">
"""
Dialog for configuring text search steps with Excel column binding
"""

from typing import Optional, Dict, Any, Tuple
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QPushButton, QLabel, QCheckBox, QSpinBox,
    QDoubleSpinBox, QComboBox, QGroupBox, QMessageBox,
    QDialogButtonBox, QWidget, QApplication
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor
from core.macro_types import TextSearchStep
from ui.widgets.roi_selector import ROISelectorOverlay
from vision.text_extractor import TextExtractor
from utils.monitor_utils import get_monitor_info
import pyautogui
import mss

class TextSearchStepDialog(QDialog):
    """Dialog for configuring text search steps"""
    
    def __init__(self, step: Optional[TextSearchStep] = None, 
                 excel_columns: list = None, parent=None):
        super().__init__(parent)
        self.step = step or TextSearchStep()
        self.excel_columns = excel_columns or []
        self.region = self.step.region
        self.text_extractor = TextExtractor()
        self.monitors = get_monitor_info()  # Get monitor information
        self.setWindowTitle("í…ìŠ¤íŠ¸ ê²€ìƒ‰ ë‹¨ê³„ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Basic info
        form_layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("ì˜ˆ: í™˜ì ì´ë¦„ ì°¾ê¸°")
        form_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        
        layout.addLayout(form_layout)
        
        # Text search configuration
        search_group = QGroupBox("í…ìŠ¤íŠ¸ ê²€ìƒ‰ ì„¤ì •")
        search_layout = QVBoxLayout()
        
        # Search text type selection
        text_type_layout = QHBoxLayout()
        text_type_layout.addWidget(QLabel("ê²€ìƒ‰ ë°©ë²•:"))
        
        self.fixed_text_radio = QCheckBox("ê³ ì • í…ìŠ¤íŠ¸")
        self.excel_column_radio = QCheckBox("ì—‘ì…€ ì—´ ë°ì´í„°")
        self.fixed_text_radio.setChecked(True)
        
        # Make them mutually exclusive
        self.fixed_text_radio.toggled.connect(
            lambda checked: self.excel_column_radio.setChecked(not checked) if checked else None
        )
        self.excel_column_radio.toggled.connect(
            lambda checked: self.fixed_text_radio.setChecked(not checked) if checked else None
        )
        
        text_type_layout.addWidget(self.fixed_text_radio)
        text_type_layout.addWidget(self.excel_column_radio)
        text_type_layout.addStretch()
        search_layout.addLayout(text_type_layout)
        
        # Fixed text input
        self.fixed_text_widget = QWidget()
        fixed_text_layout = QHBoxLayout()
        fixed_text_layout.setContentsMargins(0, 0, 0, 0)
        fixed_text_layout.addWidget(QLabel("ê²€ìƒ‰í•  í…ìŠ¤íŠ¸:"))
        self.search_text_edit = QLineEdit()
        self.search_text_edit.setPlaceholderText("ì˜ˆ: í™ê¸¸ë™")
        fixed_text_layout.addWidget(self.search_text_edit)
        self.fixed_text_widget.setLayout(fixed_text_layout)
        search_layout.addWidget(self.fixed_text_widget)
        
        # Excel column selection
        self.excel_column_widget = QWidget()
        excel_layout = QHBoxLayout()
        excel_layout.setContentsMargins(0, 0, 0, 0)
        excel_layout.addWidget(QLabel("ì—‘ì…€ ì—´:"))
        self.excel_column_combo = QComboBox()
        self.excel_column_combo.addItems(self.excel_columns)
        excel_layout.addWidget(self.excel_column_combo)
        self.excel_column_widget.setLayout(excel_layout)
        self.excel_column_widget.setVisible(False)
        search_layout.addWidget(self.excel_column_widget)
        
        # Connect radio buttons to show/hide widgets
        self.fixed_text_radio.toggled.connect(self.fixed_text_widget.setVisible)
        self.excel_column_radio.toggled.connect(self.excel_column_widget.setVisible)
        
        search_group.setLayout(search_layout)
        layout.addWidget(search_group)
        
        # Search region configuration
        region_group = QGroupBox("ê²€ìƒ‰ ì˜ì—­")
        region_layout = QVBoxLayout()
        
        # Search scope selection
        scope_layout = QHBoxLayout()
        scope_layout.addWidget(QLabel("ê²€ìƒ‰ ë²”ìœ„:"))
        
        self.search_scope_combo = QComboBox()
        # Dynamically add monitor options
        self._populate_monitor_options()
        self.search_scope_combo.currentIndexChanged.connect(self._on_search_scope_changed)
        scope_layout.addWidget(self.search_scope_combo)
        scope_layout.addStretch()
        region_layout.addLayout(scope_layout)
        
        # Region display
        self.region_label = QLabel("ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)")
        if self.region:
            self.region_label.setText(
                f"ì˜ì—­: ({self.region[0]}, {self.region[1]}) "
                f"í¬ê¸°: {self.region[2]}x{self.region[3]}"
            )
            self.search_scope_combo.setCurrentIndex(2)  # Set to "íŠ¹ì • ì˜ì—­ ì„ íƒ"
        region_layout.addWidget(self.region_label)
        
        # Region buttons
        self.region_buttons_widget = QWidget()
        region_btn_layout = QHBoxLayout()
        region_btn_layout.setContentsMargins(0, 0, 0, 0)
        
        self.select_region_btn = QPushButton("ì˜ì—­ ì„ íƒ")
        self.select_region_btn.clicked.connect(self._select_region)
        region_btn_layout.addWidget(self.select_region_btn)
        
        self.clear_region_btn = QPushButton("ì˜ì—­ ì´ˆê¸°í™”")
        self.clear_region_btn.clicked.connect(self._clear_region)
        region_btn_layout.addWidget(self.clear_region_btn)
        
        self.preview_region_btn = QPushButton("ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°")
        self.preview_region_btn.clicked.connect(self._preview_region)
        region_btn_layout.addWidget(self.preview_region_btn)
        
        self.region_buttons_widget.setLayout(region_btn_layout)
        self.region_buttons_widget.setVisible(False)  # Hidden by default
        
        region_layout.addWidget(self.region_buttons_widget)
        region_group.setLayout(region_layout)
        layout.addWidget(region_group)
        
        # Matching options
        options_group = QGroupBox("ë§¤ì¹­ ì˜µì…˜")
        options_layout = QFormLayout()
        
        self.exact_match_check = QCheckBox("ì •í™•íˆ ì¼ì¹˜")
        self.exact_match_check.setToolTip(
            "ì²´í¬ ì‹œ: ê²€ìƒ‰ í…ìŠ¤íŠ¸ì™€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ ì°¾ìŒ\n"
            "ì²´í¬ í•´ì œ ì‹œ: ë¶€ë¶„ ì¼ì¹˜ë„ í—ˆìš©"
        )
        options_layout.addRow("ë§¤ì¹­ ë°©ì‹:", self.exact_match_check)
        
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setRange(0.0, 1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.5)
        self.confidence_spin.setToolTip("OCR ì¸ì‹ ì‹ ë¢°ë„ (0.0~1.0)")
        options_layout.addRow("ì¸ì‹ ì‹ ë¢°ë„:", self.confidence_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Click options
        click_group = QGroupBox("í´ë¦­ ì˜µì…˜")
        click_layout = QFormLayout()
        
        self.click_after_find_check = QCheckBox("ì°¾ì€ í›„ í´ë¦­")
        self.click_after_find_check.setChecked(True)
        click_layout.addRow("ë™ì‘:", self.click_after_find_check)
        
        # Click type selection
        click_type_widget = QWidget()
        click_type_layout = QHBoxLayout()
        click_type_layout.setContentsMargins(0, 0, 0, 0)
        click_type_layout.addWidget(QLabel("í´ë¦­ ìœ í˜•:"))
        self.click_type_combo = QComboBox()
        self.click_type_combo.addItems(["í•œë²ˆ í´ë¦­", "ë”ë¸” í´ë¦­"])
        self.click_type_combo.setCurrentIndex(0)
        click_type_layout.addWidget(self.click_type_combo)
        click_type_layout.addStretch()
        click_type_widget.setLayout(click_type_layout)
        click_layout.addRow("", click_type_widget)
        
        # Enable/disable click type based on click checkbox
        self.click_after_find_check.toggled.connect(self.click_type_combo.setEnabled)
        
        # Click offset
        offset_widget = QWidget()
        offset_layout = QHBoxLayout()
        offset_layout.setContentsMargins(0, 0, 0, 0)
        
        offset_layout.addWidget(QLabel("X:"))
        self.offset_x_spin = QSpinBox()
        self.offset_x_spin.setRange(-100, 100)
        self.offset_x_spin.setValue(0)
        self.offset_x_spin.setToolTip("í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì—ì„œ X ì˜¤í”„ì…‹")
        offset_layout.addWidget(self.offset_x_spin)
        
        offset_layout.addWidget(QLabel("Y:"))
        self.offset_y_spin = QSpinBox()
        self.offset_y_spin.setRange(-100, 100)
        self.offset_y_spin.setValue(0)
        self.offset_y_spin.setToolTip("í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì—ì„œ Y ì˜¤í”„ì…‹")
        offset_layout.addWidget(self.offset_y_spin)
        
        offset_widget.setLayout(offset_layout)
        click_layout.addRow("í´ë¦­ ì˜¤í”„ì…‹:", offset_widget)
        
        click_group.setLayout(click_layout)
        layout.addWidget(click_group)
        
        # Test button
        self.test_btn = QPushButton("í…ŒìŠ¤íŠ¸")
        self.test_btn.clicked.connect(self._test_search)
        layout.addWidget(self.test_btn)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal, self
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        
        # Set search method
        if self.step.excel_column:
            self.excel_column_radio.setChecked(True)
            # Find and select the column
            index = self.excel_column_combo.findText(self.step.excel_column)
            if index >= 0:
                self.excel_column_combo.setCurrentIndex(index)
        else:
            self.fixed_text_radio.setChecked(True)
            self.search_text_edit.setText(self.step.search_text)
        
        # Set search scope based on region
        if self.region:
            # Check if region matches any monitor exactly
            matched_monitor_index = None
            for i, monitor in enumerate(self.monitors):
                if (self.region[0] == monitor['x'] and
                    self.region[1] == monitor['y'] and
                    self.region[2] == monitor['width'] and
                    self.region[3] == monitor['height']):
                    matched_monitor_index = i + 1  # +1 because index 0 is "ì „ì²´ í™”ë©´"
                    break
            
            if matched_monitor_index:
                self.search_scope_combo.setCurrentIndex(matched_monitor_index)
            else:
                # Custom region
                self.search_scope_combo.setCurrentIndex(len(self.monitors) + 1)  # Last option
        else:
            self.search_scope_combo.setCurrentIndex(0)  # ì „ì²´ í™”ë©´
        
        # Set options
        self.exact_match_check.setChecked(self.step.exact_match)
        self.confidence_spin.setValue(self.step.confidence)
        self.click_after_find_check.setChecked(self.step.click_after_find)
        self.offset_x_spin.setValue(self.step.click_offset[0])
        self.offset_y_spin.setValue(self.step.click_offset[1])
        
        # Set click type
        if hasattr(self.step, 'double_click'):
            self.click_type_combo.setCurrentIndex(1 if self.step.double_click else 0)
        
    def _select_region(self):
        """Select screen region"""
        # First, show monitor selection dialog
        monitor_dialog = QDialog(self)
        monitor_dialog.setWindowTitle("ëª¨ë‹ˆí„° ì„ íƒ")
        monitor_dialog.setModal(True)
        
        layout = QVBoxLayout()
        layout.addWidget(QLabel("ì˜ì—­ì„ ì„ íƒí•  ëª¨ë‹ˆí„°ë¥¼ ì„ íƒí•˜ì„¸ìš”:"))
        
        # Monitor list widget
        monitor_list = QComboBox()
        for i, monitor in enumerate(self.monitors):
            if monitor['is_primary']:
                name = f"ì£¼ ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            else:
                # Determine position-based name - check Y axis first
                x_offset_threshold = 300
                
                if monitor['y'] < -100:  # Above primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ìœ„ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ìœ„"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ìœ„"
                elif monitor['y'] > 100:  # Below primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ì•„ë˜ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ì•„ë˜"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ì•„ë˜"
                elif monitor['x'] < -100:  # Left of primary monitor
                    pos_name = "ì™¼ìª½"
                elif monitor['x'] > 100:  # Right of primary monitor
                    pos_name = "ì˜¤ë¥¸ìª½"
                else:
                    pos_name = "ë³´ì¡°"
                name = f"{pos_name} ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            monitor_list.addItem(name)
        
        layout.addWidget(monitor_list)
        
        # Buttons
        button_layout = QHBoxLayout()
        ok_button = QPushButton("í™•ì¸")
        cancel_button = QPushButton("ì·¨ì†Œ")
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)
        
        monitor_dialog.setLayout(layout)
        
        # Store selected monitor
        selected_monitor = [None]
        
        def on_ok():
            selected_monitor[0] = self.monitors[monitor_list.currentIndex()]
            monitor_dialog.accept()
            
        def on_cancel():
            monitor_dialog.reject()
            
        ok_button.clicked.connect(on_ok)
        cancel_button.clicked.connect(on_cancel)
        
        if monitor_dialog.exec_() == QDialog.Accepted and selected_monitor[0]:
            # Hide dialog temporarily
            self.hide()
            # Store selected monitor bounds
            self._selected_monitor_bounds = selected_monitor[0]
            # Give time for dialog to hide before showing ROI selector
            QTimer.singleShot(200, self._show_region_selector)
        
    def _show_region_selector(self):
        """Show region selector overlay"""
        try:
            print("DEBUG: Creating ROI selector")
            # Create ROI selector with monitor bounds if available
            monitor_bounds = getattr(self, '_selected_monitor_bounds', None)
            self.roi_selector = ROISelectorOverlay(parent=None, monitor_bounds=monitor_bounds)
            self.roi_selector.selectionComplete.connect(self._on_region_selected)
            self.roi_selector.selectionCancelled.connect(lambda: self.show())
            print("DEBUG: Starting ROI selection")
            self.roi_selector.start_selection()
        except Exception as e:
            print(f"DEBUG: Error in _show_region_selector: {e}")
            import traceback
            traceback.print_exc()
            self.show()
            
    def _on_selection_cancelled(self):
        """Handle selection cancellation"""
        print("DEBUG: Selection cancelled")
        self.show()
        
    def _on_region_selected(self, region: Tuple[int, int, int, int]):
        """Handle region selection"""
        try:
            # Ensure region is properly formatted
            if region and len(region) == 4:
                # Convert all values to integers to avoid any type issues
                formatted_region = tuple(int(x) for x in region)
                self.region = formatted_region
                self.region_label.setText(
                    f"ì˜ì—­: ({formatted_region[0]}, {formatted_region[1]}) "
                    f"í¬ê¸°: {formatted_region[2]}x{formatted_region[3]}"
                )
            else:
                self.region = None
                self.region_label.setText("ì „ì²´ í™”ë©´")
            
            # Restore dialog visibility
            self.show()
            self.raise_()
            self.activateWindow()
        except Exception as e:
            print(f"DEBUG: Error in _on_region_selected: {e}")
            import traceback
            traceback.print_exc()
            # Still try to show the dialog
            self.region = None
            self.region_label.setText("ì „ì²´ í™”ë©´")
            self.show()
        
    def _clear_region(self):
        """Clear selected region"""
        self.region = None
        self.region_label.setText("ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”")
        # Keep the scope combo at "íŠ¹ì • ì˜ì—­ ì„ íƒ"
        self.search_scope_combo.setCurrentIndex(2)
        
    def _preview_region(self):
        """Preview selected region"""
        if not self.region:
            QMessageBox.information(self, "ì•Œë¦¼", "ì„ íƒëœ ì˜ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
            
        try:
            # Take screenshot of region
            x, y, width, height = self.region
            screenshot = pyautogui.screenshot(region=(x, y, width, height))
            
            # Convert to QPixmap
            # Save to bytes first to avoid direct conversion issues
            import io
            bytes_io = io.BytesIO()
            screenshot.save(bytes_io, format='PNG')
            bytes_io.seek(0)
            
            pixmap = QPixmap()
            pixmap.loadFromData(bytes_io.read())
            
            if pixmap.isNull():
                QMessageBox.warning(self, "ê²½ê³ ", "ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                return
            
            # Create preview dialog
            preview_dialog = QDialog(self)
            preview_dialog.setWindowTitle("ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°")
            layout = QVBoxLayout()
            
            label = QLabel()
            # Scale pixmap if too large
            if not pixmap.isNull() and (pixmap.width() > 800 or pixmap.height() > 600):
                pixmap = pixmap.scaled(800, 600, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            if not pixmap.isNull():
                label.setPixmap(pixmap)
            layout.addWidget(label)
            
            # Add region info
            info_label = QLabel(f"ì˜ì—­: ({x}, {y}) - í¬ê¸°: {width}x{height}")
            layout.addWidget(info_label)
            
            preview_dialog.setLayout(layout)
            preview_dialog.exec_()
            
        except Exception as e:
            print(f"DEBUG: Error in preview: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(self, "ì˜¤ë¥˜", f"ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
            
    def _populate_monitor_options(self):
        """Populate monitor options in combo box"""
        options = ["ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)"]
        
        # Add each monitor as an option
        for i, monitor in enumerate(self.monitors):
            if monitor['is_primary']:
                name = f"ì£¼ ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            else:
                # Determine position-based name - check Y axis first
                # Consider small X offsets (< 300px) as vertically aligned
                x_offset_threshold = 300
                
                if monitor['y'] < -100:  # Above primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ìœ„ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ìœ„"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ìœ„"
                elif monitor['y'] > 100:  # Below primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ì•„ë˜ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ì•„ë˜"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ì•„ë˜"
                elif monitor['x'] < -100:  # Left of primary monitor
                    pos_name = "ì™¼ìª½"
                elif monitor['x'] > 100:  # Right of primary monitor
                    pos_name = "ì˜¤ë¥¸ìª½"
                else:
                    pos_name = "ë³´ì¡°"
                name = f"{pos_name} ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            options.append(name)
        
        # Add custom region selection at the end
        options.append("íŠ¹ì • ì˜ì—­ ì„ íƒ")
        
        self.search_scope_combo.addItems(options)
        
    def _on_search_scope_changed(self, index):
        """Handle search scope change"""
        if index == 0:  # ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)
            self.region = None
            self.region_label.setText("ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)")
            self.region_buttons_widget.setVisible(False)
        elif index > 0 and index <= len(self.monitors):  # Specific monitor
            # Get the selected monitor
            monitor = self.monitors[index - 1]
            self.region = (
                monitor['x'], 
                monitor['y'],
                monitor['width'],
                monitor['height']
            )
            # Create display text
            if monitor['is_primary']:
                monitor_name = "ì£¼ ëª¨ë‹ˆí„°"
            else:
                # Use position-based name - check Y axis first
                x_offset_threshold = 300
                
                if monitor['y'] < -100:  # Above primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        monitor_name = "ìœ„ìª½ ëª¨ë‹ˆí„°"
                    elif monitor['x'] < -x_offset_threshold:
                        monitor_name = "ì™¼ìª½ ìœ„ ëª¨ë‹ˆí„°"
                    else:
                        monitor_name = "ì˜¤ë¥¸ìª½ ìœ„ ëª¨ë‹ˆí„°"
                elif monitor['y'] > 100:  # Below primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        monitor_name = "ì•„ë˜ìª½ ëª¨ë‹ˆí„°"
                    elif monitor['x'] < -x_offset_threshold:
                        monitor_name = "ì™¼ìª½ ì•„ë˜ ëª¨ë‹ˆí„°"
                    else:
                        monitor_name = "ì˜¤ë¥¸ìª½ ì•„ë˜ ëª¨ë‹ˆí„°"
                elif monitor['x'] < -100:  # Left of primary monitor
                    monitor_name = "ì™¼ìª½ ëª¨ë‹ˆí„°"
                elif monitor['x'] > 100:  # Right of primary monitor
                    monitor_name = "ì˜¤ë¥¸ìª½ ëª¨ë‹ˆí„°"
                else:
                    monitor_name = "ë³´ì¡° ëª¨ë‹ˆí„°"
            
            self.region_label.setText(
                f"{monitor_name}: ({monitor['x']}, {monitor['y']}) "
                f"í¬ê¸°: {monitor['width']}x{monitor['height']}"
            )
            self.region_buttons_widget.setVisible(False)
        else:  # íŠ¹ì • ì˜ì—­ ì„ íƒ
            if not self.region:
                self.region_label.setText("ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”")
            self.region_buttons_widget.setVisible(True)
        
    def _test_search(self):
        """Test text search"""
        # Get search text
        if self.fixed_text_radio.isChecked():
            search_text = self.search_text_edit.text()
            if not search_text:
                QMessageBox.warning(self, "ê²½ê³ ", "ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
                return
        else:
            if self.excel_column_combo.currentText():
                search_text = f"[{self.excel_column_combo.currentText()} ì—´ì˜ ë°ì´í„°]"
            else:
                QMessageBox.warning(self, "ê²½ê³ ", "ì—‘ì…€ ì—´ì„ ì„ íƒí•˜ì„¸ìš”.")
                return
        
        # Perform test search
        self.hide()
        QTimer.singleShot(300, lambda: self._perform_test_search(search_text))
        
    def _perform_test_search(self, search_text: str):
        """Perform the actual test search"""
        try:
            print(f"DEBUG: Starting test search for: {search_text}")
            print(f"DEBUG: Current region: {self.region}")
            
            # For testing with Excel column, use sample text
            if self.excel_column_radio.isChecked():
                test_text = QMessageBox.getText(
                    self, "í…ŒìŠ¤íŠ¸ í…ìŠ¤íŠ¸",
                    f"{self.excel_column_combo.currentText()} ì—´ì˜ í…ŒìŠ¤íŠ¸ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”:",
                    text="í™ê¸¸ë™"
                )
                if test_text[1]:
                    search_text = test_text[0]
                else:
                    self.show()
                    return
            
            print("DEBUG: Extracting text from region...")
            # Extract text from region
            results = self.text_extractor.extract_text_from_region(
                self.region, 
                self.confidence_spin.value()
            )
            print(f"DEBUG: Found {len(results)} text results")
            
            print("DEBUG: Finding matching text...")
            # Find matching text
            found_result = self.text_extractor.find_text(
                search_text,
                self.region,
                self.exact_match_check.isChecked(),
                self.confidence_spin.value()
            )
            
            if found_result:
                print(f"DEBUG: Found text at {found_result.center}")
                # Show result
                if self.click_after_find_check.isChecked():
                    # Calculate click position
                    click_x = found_result.center[0] + self.offset_x_spin.value()
                    click_y = found_result.center[1] + self.offset_y_spin.value()
                    
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"í´ë¦­ ìœ„ì¹˜: ({click_x}, {click_y})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                else:
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                
                # Highlight found text briefly
                self._highlight_found_text(found_result)
                
            else:
                print("DEBUG: Text not found")
                # Show all found text for debugging
                if results:
                    all_text = "\n".join([f"- {r.text} (ì‹ ë¢°ë„: {r.confidence:.2f})" 
                                         for r in results[:10]])  # Show max 10
                else:
                    all_text = "í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                    
                message = (
                    f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n"
                    f"ë°œê²¬ëœ í…ìŠ¤íŠ¸:\n{all_text}"
                )
            
            QMessageBox.information(self, "í…ŒìŠ¤íŠ¸ ê²°ê³¼", message)
            
        except Exception as e:
            print(f"DEBUG: Error in test search: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
        finally:
            self.show()
            
    def _highlight_found_text(self, result):
        """Briefly highlight the found text on screen"""
        # This is a simplified version - in production, you might want
        # to create a temporary overlay window
        import time
        x, y = result.center
        pyautogui.moveTo(x, y, duration=0.5)
        
    def _perform_test_search_immediate(self, search_text: str):
        """Perform test search without hiding dialog (for Windows compatibility)"""
        loading_msg = None
        try:
            print(f"DEBUG: Starting immediate test search for: {search_text}")
            print(f"DEBUG: Current region: {self.region}")
            
            # Extract text from region first (before showing loading)
            results = self.text_extractor.extract_text_from_region(
                self.region, 
                self.confidence_spin.value()
            )
            print(f"DEBUG: Found {len(results)} text results")
            
            # Find matching text
            found_result = self.text_extractor.find_text(
                search_text,
                self.region,
                self.exact_match_check.isChecked(),
                self.confidence_spin.value()
            )
            
            if found_result:
                print(f"DEBUG: Found text at {found_result.center}")
                # Show result
                if self.click_after_find_check.isChecked():
                    # Calculate click position
                    click_x = found_result.center[0] + self.offset_x_spin.value()
                    click_y = found_result.center[1] + self.offset_y_spin.value()
                    
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"í´ë¦­ ìœ„ì¹˜: ({click_x}, {click_y})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                else:
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                
                QMessageBox.information(self, "í…ŒìŠ¤íŠ¸ ì„±ê³µ", message)
                
                # Highlight found text
                self._highlight_found_text(found_result)
                
            else:
                print("DEBUG: Text not found")
                # Show all found text for debugging
                if results:
                    all_text = "\n".join([f"â€¢ {r.text} (ì‹ ë¢°ë„: {r.confidence:.2f})" 
                                         for r in results[:10]])  # Show max 10
                else:
                    all_text = "ì¸ì‹ëœ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤."
                    
                message = (
                    f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n"
                    f"ê²€ìƒ‰ ì˜ì—­ì—ì„œ ë°œê²¬ëœ í…ìŠ¤íŠ¸:\n{all_text}"
                )
                
                QMessageBox.warning(self, "í…ŒìŠ¤íŠ¸ ê²°ê³¼", message)
                
        except Exception as e:
            print(f"DEBUG: Error in immediate test search: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{str(e)}")
        
    def get_step_data(self) -> Dict[str, Any]:
        """Get step configuration data"""
        return {
            'name': self.name_edit.text() or "í…ìŠ¤íŠ¸ ê²€ìƒ‰",
            'search_text': self.search_text_edit.text() if self.fixed_text_radio.isChecked() else "",
            'excel_column': self.excel_column_combo.currentText() if self.excel_column_radio.isChecked() else None,
            'region': self.region,
            'exact_match': self.exact_match_check.isChecked(),
            'confidence': self.confidence_spin.value(),
            'click_after_find': self.click_after_find_check.isChecked(),
            'click_offset': (self.offset_x_spin.value(), self.offset_y_spin.value()),
            'double_click': self.click_type_combo.currentIndex() == 1  # True if "ë”ë¸” í´ë¦­" selected
        }
</file>

<file path="src/ui/widgets/excel_widget.py">
"""
Main Excel integration widget
"""

from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QSplitter, QMessageBox,
    QProgressDialog
)
from PyQt5.QtCore import Qt, pyqtSignal, QThread
from ui.widgets.file_selector import FileSelectorWidget
from ui.widgets.sheet_mapper import SheetMapperWidget
from ui.widgets.data_preview import DataPreviewWidget
from excel.excel_manager import ExcelManager
from excel.models import ExcelFileInfo, ColumnMapping
from logger.app_logger import get_logger

class ExcelLoadThread(QThread):
    """Thread for loading Excel files"""
    
    fileLoaded = pyqtSignal(ExcelFileInfo)
    error = pyqtSignal(str)
    
    def __init__(self, excel_manager: ExcelManager, file_path: str):
        super().__init__()
        self.excel_manager = excel_manager
        self.file_path = file_path
        
    def run(self):
        """Run Excel loading in thread"""
        try:
            file_info = self.excel_manager.load_file(self.file_path)
            self.fileLoaded.emit(file_info)
        except Exception as e:
            self.error.emit(str(e))

class ExcelWidget(QWidget):
    """Main Excel integration widget"""
    
    dataReady = pyqtSignal(object)  # ExcelData
    
    def __init__(self):
        super().__init__()
        self.logger = get_logger(__name__)
        self.excel_manager = ExcelManager()
        self.current_file_info: Optional[ExcelFileInfo] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Create splitter for resizable sections
        splitter = QSplitter(Qt.Vertical)
        
        # File selector
        self.file_selector = FileSelectorWidget()
        self.file_selector.fileSelected.connect(self._on_file_selected)
        splitter.addWidget(self.file_selector)
        
        # Sheet mapper
        self.sheet_mapper = SheetMapperWidget()
        self.sheet_mapper.mappingComplete.connect(self._on_mapping_complete)
        splitter.addWidget(self.sheet_mapper)
        
        # Data preview
        self.data_preview = DataPreviewWidget()
        self.data_preview.rowSelected.connect(self._on_row_selected)
        splitter.addWidget(self.data_preview)
        
        # Set initial splitter sizes (30%, 30%, 40%)
        splitter.setSizes([300, 300, 400])
        
        layout.addWidget(splitter)
        self.setLayout(layout)
        
    def _on_file_selected(self, file_path: str):
        """Handle file selection"""
        # Show progress dialog
        progress = QProgressDialog("ì—‘ì…€ íŒŒì¼ ë¡œë”© ì¤‘...", None, 0, 0, self)
        progress.setWindowModality(Qt.WindowModal)
        progress.show()
        
        # Load file in thread
        self.load_thread = ExcelLoadThread(self.excel_manager, file_path)
        self.load_thread.fileLoaded.connect(lambda info: self._on_file_loaded(info, progress))
        self.load_thread.error.connect(lambda err: self._on_load_error(err, progress))
        self.load_thread.start()
        
    def _on_file_loaded(self, file_info: ExcelFileInfo, progress: QProgressDialog):
        """Handle successful file load"""
        progress.close()
        self.current_file_info = file_info
        self.sheet_mapper.set_file_info(file_info.sheets)
        self.logger.info(f"Loaded Excel file: {file_info.file_path}")
        
    def _on_load_error(self, error: str, progress: QProgressDialog):
        """Handle file load error"""
        progress.close()
        QMessageBox.critical(self, "íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜", f"ì—‘ì…€ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n{error}")
        self.logger.error(f"Failed to load Excel file: {error}")
        
    def _on_mapping_complete(self, sheet_name: str, mappings: list):
        """Handle mapping completion"""
        try:
            # Read sheet data
            excel_data = self.excel_manager.read_sheet(sheet_name)
            
            # Apply mappings
            for mapping in mappings:
                self.excel_manager.set_column_mapping(
                    mapping.excel_column,
                    mapping.variable_name,
                    mapping.data_type,
                    mapping.is_required
                )
            
            # Load data in preview
            self.data_preview.load_excel_data(excel_data)
            
            # Emit signal that data is ready
            self.dataReady.emit(excel_data)
            
            self.logger.info(f"Loaded sheet '{sheet_name}' with {len(mappings)} mappings")
            
        except Exception as e:
            QMessageBox.critical(self, "ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜", f"ì‹œíŠ¸ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n{str(e)}")
            self.logger.error(f"Failed to load sheet data: {e}")
            
    def _on_row_selected(self, row_index: int):
        """Handle row selection in preview"""
        self.logger.debug(f"Row {row_index} selected for execution")
        
    def get_excel_manager(self) -> ExcelManager:
        """Get Excel manager instance"""
        return self.excel_manager
    
    def has_data(self) -> bool:
        """Check if Excel data is loaded"""
        return hasattr(self.excel_manager, '_current_data') and self.excel_manager._current_data is not None
        
    def save_current_file(self):
        """Save current Excel file with updates"""
        if self.excel_manager._current_data:
            try:
                save_path = self.excel_manager.save_file()
                QMessageBox.information(self, "ì €ì¥ ì™„ë£Œ", f"íŒŒì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:\n{save_path}")
                self.logger.info(f"Saved Excel file: {save_path}")
            except Exception as e:
                QMessageBox.critical(self, "ì €ì¥ ì˜¤ë¥˜", f"íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
                self.logger.error(f"Failed to save Excel file: {e}")
                
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the Excel widget"""
        # Find the splitter
        splitter = self.findChild(QSplitter)
        
        if is_compact:
            # Reduce splitter sizes and spacing
            if splitter:
                splitter.setSizes([200, 200, 300])
                
            # Apply compact mode to child widgets
            if hasattr(self.file_selector, 'set_compact_mode'):
                self.file_selector.set_compact_mode(is_compact)
            if hasattr(self.sheet_mapper, 'set_compact_mode'):
                self.sheet_mapper.set_compact_mode(is_compact)
            if hasattr(self.data_preview, 'set_compact_mode'):
                self.data_preview.set_compact_mode(is_compact)
                
            # Reduce layout margins
            self.layout().setContentsMargins(5, 5, 5, 5)
            self.layout().setSpacing(5)
        else:
            # Reset to normal sizes
            if splitter:
                splitter.setSizes([300, 300, 400])
                
            # Reset child widgets
            if hasattr(self.file_selector, 'set_compact_mode'):
                self.file_selector.set_compact_mode(is_compact)
            if hasattr(self.sheet_mapper, 'set_compact_mode'):
                self.sheet_mapper.set_compact_mode(is_compact)
            if hasattr(self.data_preview, 'set_compact_mode'):
                self.data_preview.set_compact_mode(is_compact)
                
            # Reset layout margins
            self.layout().setContentsMargins(9, 9, 9, 9)
            self.layout().setSpacing(6)
</file>

<file path="src/ui/widgets/roi_selector.py">
"""
Region of Interest (ROI) selector widget with transparent overlay
"""

from typing import Optional, Tuple, Callable
from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QVBoxLayout, QDialog
from PyQt5.QtCore import Qt, QRect, QPoint, pyqtSignal, QTimer
from PyQt5.QtGui import QPainter, QPen, QColor, QBrush, QPixmap, QFont, QCursor, QPalette
import sys

class ROISelectorOverlay(QDialog):
    """Transparent overlay for ROI selection"""
    
    # Signals
    selectionComplete = pyqtSignal(tuple)  # (x, y, width, height)
    selectionCancelled = pyqtSignal()
    
    def __init__(self, parent=None, monitor_bounds=None):
        super().__init__(parent)
        
        # Selection state
        self.selecting = False
        self.start_point = QPoint()
        self.end_point = QPoint()
        self.selection_rect = QRect()
        self.monitor_bounds = monitor_bounds  # Restrict to specific monitor if provided
        
        # UI setup
        # Use flags that work well on Windows
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Dialog)
        self.setModal(True)
        
        # Make window transparent
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setWindowOpacity(1.0)
        
        # Cursor and mouse tracking
        self.setCursor(Qt.CrossCursor)
        self.setMouseTracking(True)
        self.setFocusPolicy(Qt.StrongFocus)
        
        # Setup monitor coverage
        if monitor_bounds:
            self._setup_single_monitor(monitor_bounds)
        else:
            self._setup_multi_monitor()
        
    def _setup_multi_monitor(self):
        """Setup to cover all monitors"""
        # Get combined screen geometry
        desktop = QApplication.desktop()
        total_rect = QRect()
        
        for i in range(desktop.screenCount()):
            screen_rect = desktop.screenGeometry(i)
            total_rect = total_rect.united(screen_rect)
            
        self.setGeometry(total_rect)
        
    def _setup_single_monitor(self, monitor_bounds):
        """Setup to cover a single monitor"""
        x = monitor_bounds['x']
        y = monitor_bounds['y']
        width = monitor_bounds['width']
        height = monitor_bounds['height']
        self.setGeometry(x, y, width, height)
        
    def start_selection(self):
        """Start ROI selection"""
        print("DEBUG: ROI start_selection called")
        
        # Setup monitor coverage is already done in __init__
        
        # Show window using exec_ for modal dialog
        print(f"DEBUG: Showing ROI window")
        
        # Start with a slight delay to ensure proper display
        QTimer.singleShot(100, self._prepare_selection)
        
        # Show as modal dialog
        self.exec_()
        
    def _prepare_selection(self):
        """Prepare for selection after dialog is shown"""
        print("DEBUG: _prepare_selection called")
        self.raise_()
        self.activateWindow()
        self.grabMouse()
        self.grabKeyboard()
        self.update()
        
    def _grab_input(self):
        """Grab mouse and keyboard input after delay"""
        print("DEBUG: _grab_input called")
        try:
            self.grabMouse()
            self.grabKeyboard()
            self.setFocus()
            print("DEBUG: Input grabbed successfully")
        except Exception as e:
            print(f"DEBUG: Error grabbing input: {e}")
        
    def mousePressEvent(self, event):
        """Handle mouse press"""
        if event.button() == Qt.LeftButton:
            self.selecting = True
            self.start_point = event.globalPos()
            self.end_point = self.start_point
            self.update()
            
    def mouseMoveEvent(self, event):
        """Handle mouse move"""
        if self.selecting:
            end_point = event.globalPos()
            
            # If monitor bounds are set, constrain the end point
            if self.monitor_bounds:
                min_x = self.monitor_bounds['x']
                min_y = self.monitor_bounds['y']
                max_x = min_x + self.monitor_bounds['width']
                max_y = min_y + self.monitor_bounds['height']
                
                # Clamp the end point to monitor bounds
                end_point.setX(max(min_x, min(end_point.x(), max_x)))
                end_point.setY(max(min_y, min(end_point.y(), max_y)))
            
            self.end_point = end_point
            self.update()
            
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() == Qt.LeftButton and self.selecting:
            self.selecting = False
            self.end_point = event.globalPos()
            
            # Calculate selection rectangle
            x = min(self.start_point.x(), self.end_point.x())
            y = min(self.start_point.y(), self.end_point.y())
            w = abs(self.end_point.x() - self.start_point.x())
            h = abs(self.end_point.y() - self.start_point.y())
            
            # Emit result if selection is valid
            if w > 5 and h > 5:
                region = (int(x), int(y), int(w), int(h))
                self.selectionComplete.emit(region)
            
            self.close()
            
    def keyPressEvent(self, event):
        """Handle key press"""
        if event.key() == Qt.Key_Escape:
            self.selecting = False
            self.selectionCancelled.emit()
            self.close()
            
    def paintEvent(self, event):
        """Paint overlay and selection"""
        print("DEBUG: paintEvent called")
        painter = QPainter(self)
        
        # Fill with semi-transparent color (reduced opacity for better visibility)
        painter.fillRect(self.rect(), QColor(0, 0, 0, 80))
        
        # If selecting, clear the selection area for better visibility
        if self.selecting or (self.start_point and self.end_point):
            # Calculate selection rectangle
            x = min(self.start_point.x(), self.end_point.x())
            y = min(self.start_point.y(), self.end_point.y())
            w = abs(self.end_point.x() - self.start_point.x())
            h = abs(self.end_point.y() - self.start_point.y())
            
            # Adjust to widget coordinates
            selection = QRect(x - self.x(), y - self.y(), w, h)
            
            # Clear the selection area (make it transparent)
            painter.setCompositionMode(QPainter.CompositionMode_Clear)
            painter.fillRect(selection, Qt.transparent)
            painter.setCompositionMode(QPainter.CompositionMode_SourceOver)
            
            # Draw selection border
            painter.setPen(QPen(QColor(50, 150, 250), 3, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(selection)
        
        # Draw visible text
        painter.setPen(QColor(255, 255, 255))
        font = QFont()
        font.setPointSize(24)
        font.setBold(True)
        painter.setFont(font)
        
        instructions = "ë§ˆìš°ìŠ¤ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”. ESCë¡œ ì·¨ì†Œ"
        rect = self.rect()
        rect.setTop(50)
        painter.drawText(rect, Qt.AlignTop | Qt.AlignHCenter, instructions)
        
        if self.selecting or (self.start_point and self.end_point):
            
            # Draw dimensions text
            if w > 50 and h > 30:
                painter.setPen(QColor(255, 255, 255))
                font = QFont()
                font.setPointSize(12)
                font.setBold(True)
                painter.setFont(font)
                
                text = f"{w} Ã— {h}"
                text_rect = selection.adjusted(5, 5, -5, -5)
                painter.drawText(text_rect, Qt.AlignTop | Qt.AlignLeft, text)
                
            # Draw corner handles
            self._draw_handles(painter, selection)
            
    def _draw_handles(self, painter: QPainter, rect: QRect):
        """Draw resize handles at corners"""
        handle_size = 8
        painter.setBrush(QBrush(QColor(50, 150, 250)))
        painter.setPen(Qt.NoPen)
        
        # Top-left
        painter.drawRect(rect.x() - handle_size//2, 
                        rect.y() - handle_size//2,
                        handle_size, handle_size)
        
        # Top-right
        painter.drawRect(rect.x() + rect.width() - handle_size//2,
                        rect.y() - handle_size//2,
                        handle_size, handle_size)
        
        # Bottom-left
        painter.drawRect(rect.x() - handle_size//2,
                        rect.y() + rect.height() - handle_size//2,
                        handle_size, handle_size)
        
        # Bottom-right
        painter.drawRect(rect.x() + rect.width() - handle_size//2,
                        rect.y() + rect.height() - handle_size//2,
                        handle_size, handle_size)
                        
    def close(self):
        """Clean up and close"""
        print("DEBUG: ROI close() called")
        self.releaseMouse()
        self.releaseKeyboard()
        self.accept()  # Close the dialog properly

class ROISelectorWidget(QWidget):
    """Widget for ROI selection with preview"""
    
    regionSelected = pyqtSignal(tuple)  # (x, y, width, height)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_region: Optional[Tuple[int, int, int, int]] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Preview label
        self.preview_label = QLabel()
        self.preview_label.setMinimumSize(200, 150)
        self.preview_label.setMaximumSize(400, 300)
        self.preview_label.setScaledContents(True)
        self.preview_label.setStyleSheet("""
            QLabel {
                border: 2px solid #ccc;
                background-color: #f0f0f0;
            }
        """)
        self.preview_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.preview_label)
        
        # Info label
        self.info_label = QLabel("ì„ íƒëœ ì˜ì—­ ì—†ìŒ")
        self.info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.info_label)
        
        self.setLayout(layout)
        
    def start_selection(self):
        """Start ROI selection"""
        self.selector = ROISelectorOverlay()
        self.selector.selectionComplete.connect(self._on_selection_complete)
        self.selector.selectionCancelled.connect(self._on_selection_cancelled)
        self.selector.start_selection()
        
    def _on_selection_complete(self, region: Tuple[int, int, int, int]):
        """Handle selection completion"""
        self.current_region = region
        self.info_label.setText(f"ì˜ì—­: {region[0]}, {region[1]} - {region[2]}Ã—{region[3]}")
        self.regionSelected.emit(region)
        
        # Capture and show preview
        self._update_preview()
        
    def _on_selection_cancelled(self):
        """Handle selection cancellation"""
        self.info_label.setText("ì„ íƒ ì·¨ì†Œë¨")
        
    def _update_preview(self):
        """Update preview of selected region"""
        if not self.current_region:
            return
            
        try:
            # Capture the selected region
            import mss
            import numpy as np
            from PIL import Image
            
            with mss.mss() as sct:
                monitor = {
                    "left": self.current_region[0],
                    "top": self.current_region[1],
                    "width": self.current_region[2],
                    "height": self.current_region[3]
                }
                
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.bgra, "raw", "BGRX")
                
                # Convert to QPixmap
                qpixmap = QPixmap.fromImage(self._pil_to_qimage(img))
                self.preview_label.setPixmap(qpixmap)
                
        except Exception as e:
            self.info_label.setText(f"Preview error: {str(e)}")
            
    def _pil_to_qimage(self, pil_image):
        """Convert PIL image to QImage"""
        from PyQt5.QtGui import QImage
        
        if pil_image.mode == "RGB":
            r, g, b = pil_image.split()
            pil_image = Image.merge("RGB", (b, g, r))
        elif pil_image.mode == "RGBA":
            r, g, b, a = pil_image.split()
            pil_image = Image.merge("RGBA", (b, g, r, a))
            
        width, height = pil_image.size
        data = pil_image.tobytes("raw", pil_image.mode)
        
        if pil_image.mode == "RGB":
            qimage = QImage(data, width, height, QImage.Format_RGB888)
        elif pil_image.mode == "RGBA":
            qimage = QImage(data, width, height, QImage.Format_RGBA8888)
            
        return qimage
        
    def set_region(self, region: Optional[Tuple[int, int, int, int]]):
        """Set region programmatically"""
        self.current_region = region
        if region:
            self.info_label.setText(f"ì˜ì—­: {region[0]}, {region[1]} - {region[2]}Ã—{region[3]}")
            self._update_preview()
        else:
            self.info_label.setText("ì„ íƒëœ ì˜ì—­ ì—†ìŒ")
            self.preview_label.clear()
        
    def get_region(self) -> Optional[Tuple[int, int, int, int]]:
        """Get current region"""
        return self.current_region
</file>

<file path="src/ui/main_window.py">
"""
Main application window
"""

from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QMenuBar, QMenu, QAction, QStatusBar, QLabel,
    QMessageBox, QTabWidget, QFileDialog
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QIcon
from config.settings import Settings
from logger.app_logger import get_logger
from core.macro_storage import MacroStorage, MacroFormat
from core.macro_types import Macro
import os
from typing import List, Optional

class MainWindow(QMainWindow):
    """Main application window"""
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
        # Macro storage
        self.macro_storage = MacroStorage()
        self.current_macro_path: Optional[str] = None
        self.recent_macros: List[str] = self.settings.get("macro.recent_files", [])
        
        self.init_ui()
        self.load_window_state()
        
        # Apply compact mode if enabled
        if self.settings.get("ui.compact_mode", False):
            self.apply_compact_mode(True)
        
    def init_ui(self):
        """Initialize user interface"""
        self.setWindowTitle("Excel Macro Automation")
        
        # Set window size from settings
        window_size = self.settings.get("ui.window_size", [1280, 720])
        self.resize(*window_size)
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Create main layout
        layout = QVBoxLayout(central_widget)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        
        # Add Excel widget
        from ui.widgets.excel_widget import ExcelWidget
        self.excel_widget = ExcelWidget()
        self.tab_widget.addTab(self.excel_widget, "Excel")
        
        # Add Macro Editor widget
        from ui.widgets.macro_editor import MacroEditorWidget
        self.macro_editor = MacroEditorWidget()
        self.tab_widget.addTab(self.macro_editor, "Editor")
        
        # Add Execution widget
        from ui.widgets.execution_widget import ExecutionWidget
        self.execution_widget = ExecutionWidget(self.settings)
        self.tab_widget.addTab(self.execution_widget, "Run")
        
        # Connect Excel and Macro widgets to Execution
        self.excel_widget.dataReady.connect(self._on_excel_data_ready)
        self.macro_editor.macroChanged.connect(self._on_macro_changed)
        
        # Create menu bar
        self.create_menu_bar()
        
        # Create status bar
        self.create_status_bar()
        
    def create_menu_bar(self):
        """Create application menu bar"""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        new_action = QAction("New Project", self)
        new_action.setShortcut("Ctrl+N")
        file_menu.addAction(new_action)
        
        open_action = QAction("Open Project", self)
        open_action.setShortcut("Ctrl+O")
        file_menu.addAction(open_action)
        
        save_action = QAction("Save Project", self)
        save_action.setShortcut("Ctrl+Alt+S")
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        # Macro menu items
        save_macro_action = QAction("Save Macro", self)
        save_macro_action.setShortcut("Ctrl+S")
        save_macro_action.triggered.connect(self.save_macro)
        file_menu.addAction(save_macro_action)
        
        load_macro_action = QAction("Load Macro", self)
        load_macro_action.setShortcut("Ctrl+O")
        load_macro_action.triggered.connect(self.load_macro)
        file_menu.addAction(load_macro_action)
        
        export_macro_action = QAction("Export Macro", self)
        export_macro_action.setShortcut("Ctrl+E")
        export_macro_action.triggered.connect(self.export_macro)
        file_menu.addAction(export_macro_action)
        
        file_menu.addSeparator()
        
        # Recent macros submenu
        self.recent_macros_menu = QMenu("Recent Macros", self)
        file_menu.addMenu(self.recent_macros_menu)
        self.update_recent_macros_menu()
        
        file_menu.addSeparator()
        
        exit_action = QAction("Exit", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Edit menu
        edit_menu = menubar.addMenu("Edit")
        
        settings_action = QAction("Settings", self)
        settings_action.setShortcut("Ctrl+,")
        edit_menu.addAction(settings_action)
        
        # View menu
        view_menu = menubar.addMenu("View")
        
        theme_action = QAction("Toggle Theme", self)
        view_menu.addAction(theme_action)
        
        # Add compact mode toggle
        self.compact_mode_action = QAction("Compact Mode", self)
        self.compact_mode_action.setCheckable(True)
        self.compact_mode_action.setChecked(self.settings.get("ui.compact_mode", False))
        self.compact_mode_action.setShortcut("Ctrl+Shift+C")
        self.compact_mode_action.setStatusTip("Toggle compact mode to reduce UI spacing (Ctrl+Shift+C)")
        self.compact_mode_action.triggered.connect(self.toggle_compact_mode)
        view_menu.addAction(self.compact_mode_action)
        
        view_menu.addSeparator()
        
        log_viewer_action = QAction("Execution Logs", self)
        log_viewer_action.setShortcut("Ctrl+L")
        log_viewer_action.triggered.connect(self.show_log_viewer)
        view_menu.addAction(log_viewer_action)
        
        # Help menu
        help_menu = menubar.addMenu("Help")
        
        about_action = QAction("About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
        
    def create_status_bar(self):
        """Create application status bar"""
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        
        # Add permanent widgets
        self.status_label = QLabel("Ready")
        self.status_bar.addPermanentWidget(self.status_label)
        
    def show_about(self):
        """Show about dialog"""
        QMessageBox.about(
            self,
            "About Excel Macro Automation",
            "Excel-based Task Automation Macro\n\n"
            "Version: 1.0.0\n"
            "Automate repetitive tasks using Excel data"
        )
        
    def show_log_viewer(self):
        """Show log viewer dialog"""
        from ui.dialogs.log_viewer_dialog import LogViewerDialog
        dialog = LogViewerDialog(parent=self)
        dialog.show()  # Non-modal
        
    def closeEvent(self, event):
        """Handle window close event"""
        if self.settings.get("ui.confirm_exit", True):
            reply = QMessageBox.question(
                self,
                "Confirm Exit",
                "Are you sure you want to exit?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                self.save_window_state()
                event.accept()
            else:
                event.ignore()
        else:
            self.save_window_state()
            event.accept()
            
    def save_window_state(self):
        """Save window size and position"""
        self.settings.set("ui.window_size", [self.width(), self.height()])
        self.settings.save()
        
    def load_window_state(self):
        """Load window size and position"""
        # Window state loading is handled in init_ui
        pass
        
    def _on_excel_data_ready(self, excel_data):
        """Handle Excel data ready"""
        excel_manager = self.excel_widget.get_excel_manager()
        macro = self.macro_editor.get_macro()
        self.execution_widget.set_macro_and_excel(macro, excel_manager)
        
    def _on_macro_changed(self, macro):
        """Handle macro change"""
        excel_manager = self.excel_widget.get_excel_manager()
        # Always update macro, even without Excel
        self.execution_widget.set_macro_and_excel(macro, excel_manager)
            
    def save_macro(self):
        """Save current macro to file"""
        try:
            macro = self.macro_editor.get_macro()
            if not macro or not macro.steps:
                QMessageBox.warning(self, "Warning", "No macro to save.")
                return
                
            # Get save path
            if self.current_macro_path:
                # Use current path
                file_path = self.current_macro_path
            else:
                # Show save dialog
                file_path, selected_filter = QFileDialog.getSaveFileName(
                    self,
                    "Save Macro",
                    os.path.expanduser("~/"),
                    "JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
                )
                
                if not file_path:
                    return
                    
            # Determine format based on extension
            if file_path.endswith('.emf'):
                format_type = MacroFormat.ENCRYPTED
            else:
                format_type = MacroFormat.JSON
                if not file_path.endswith('.json'):
                    file_path += '.json'
                    
            # Save macro
            success = self.macro_storage.save_macro(macro, file_path, format_type)
            
            if success:
                self.current_macro_path = file_path
                self.add_to_recent_macros(file_path)
                self.update_window_title()
                self.status_label.setText(f"Macro saved to {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", "Macro saved successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to save macro.")
                
        except Exception as e:
            self.logger.error(f"Error saving macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to save macro: {str(e)}")
            
    def load_macro(self):
        """Load macro from file"""
        try:
            # Show open dialog
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Load Macro",
                os.path.expanduser("~/"),
                "Macro files (*.json *.emf);;JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
            )
            
            if not file_path:
                return
                
            # Load macro
            macro = self.macro_storage.load_macro(file_path)
            
            if macro:
                self.macro_editor.set_macro(macro)
                self.current_macro_path = file_path
                self.add_to_recent_macros(file_path)
                self.update_window_title()
                self.status_label.setText(f"Macro loaded from {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", "Macro loaded successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to load macro.")
                
        except Exception as e:
            self.logger.error(f"Error loading macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load macro: {str(e)}")
            
    def export_macro(self):
        """Export selected macro steps"""
        try:
            # Get selected steps from macro editor
            selected_steps = self.macro_editor.get_selected_steps()
            
            if not selected_steps:
                QMessageBox.warning(self, "Warning", "No steps selected for export.")
                return
                
            # Create partial macro
            macro = self.macro_editor.get_macro()
            partial_macro = Macro(
                name=f"{macro.name}_partial",
                description=f"Partial export of {macro.name}",
                steps=selected_steps,
                variables=macro.variables  # Include all variables for now
            )
            
            # Show save dialog
            file_path, selected_filter = QFileDialog.getSaveFileName(
                self,
                "Export Macro Steps",
                os.path.expanduser("~/"),
                "JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
            )
            
            if not file_path:
                return
                
            # Determine format
            if file_path.endswith('.emf'):
                format_type = MacroFormat.ENCRYPTED
            else:
                format_type = MacroFormat.JSON
                if not file_path.endswith('.json'):
                    file_path += '.json'
                    
            # Save partial macro
            success = self.macro_storage.save_macro(partial_macro, file_path, format_type)
            
            if success:
                self.status_label.setText(f"Exported {len(selected_steps)} steps to {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", f"Exported {len(selected_steps)} steps successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to export macro steps.")
                
        except Exception as e:
            self.logger.error(f"Error exporting macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to export macro: {str(e)}")
            
    def add_to_recent_macros(self, file_path: str):
        """Add file to recent macros list"""
        # Remove if already exists
        if file_path in self.recent_macros:
            self.recent_macros.remove(file_path)
            
        # Add to front
        self.recent_macros.insert(0, file_path)
        
        # Keep only last 5
        self.recent_macros = self.recent_macros[:5]
        
        # Save to settings
        self.settings.set("macro.recent_files", self.recent_macros)
        self.settings.save()
        
        # Update menu
        self.update_recent_macros_menu()
        
    def update_recent_macros_menu(self):
        """Update recent macros menu"""
        self.recent_macros_menu.clear()
        
        if not self.recent_macros:
            action = QAction("(No recent macros)", self)
            action.setEnabled(False)
            self.recent_macros_menu.addAction(action)
            return
            
        for file_path in self.recent_macros:
            if os.path.exists(file_path):
                action = QAction(os.path.basename(file_path), self)
                action.setStatusTip(file_path)
                action.triggered.connect(lambda checked, path=file_path: self.load_recent_macro(path))
                self.recent_macros_menu.addAction(action)
                
    def load_recent_macro(self, file_path: str):
        """Load a recent macro"""
        try:
            macro = self.macro_storage.load_macro(file_path)
            
            if macro:
                self.macro_editor.set_macro(macro)
                self.current_macro_path = file_path
                self.update_window_title()
                self.status_label.setText(f"Macro loaded from {os.path.basename(file_path)}")
            else:
                QMessageBox.critical(self, "Error", f"Failed to load macro from {os.path.basename(file_path)}")
                self.recent_macros.remove(file_path)
                self.update_recent_macros_menu()
                
        except Exception as e:
            self.logger.error(f"Error loading recent macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load macro: {str(e)}")
            
    def update_window_title(self):
        """Update window title with current macro file"""
        title = "Excel Macro Automation"
        if self.current_macro_path:
            title += f" - {os.path.basename(self.current_macro_path)}"
        self.setWindowTitle(title)
        
    def toggle_compact_mode(self):
        """Toggle compact mode for the UI"""
        is_compact = self.compact_mode_action.isChecked()
        self.settings.set("ui.compact_mode", is_compact)
        self.settings.save()
        
        # Apply compact mode styling
        self.apply_compact_mode(is_compact)
        self.status_label.setText(f"Compact mode {'enabled' if is_compact else 'disabled'}")
        
    def apply_compact_mode(self, is_compact: bool):
        """Apply compact mode styling to the application"""
        if is_compact:
            # Compact mode stylesheet
            compact_style = """
            /* General compact styling */
            QWidget {
                font-size: 11px;
            }
            
            /* Reduce padding in tabs */
            QTabBar::tab {
                padding: 3px 8px;
                min-height: 20px;
            }
            
            /* Compact buttons */
            QPushButton {
                padding: 3px 8px;
                min-height: 22px;
            }
            
            /* Compact list items */
            QListWidget::item {
                padding: 2px;
                min-height: 20px;
            }
            
            /* Compact table rows */
            QTableWidget::item {
                padding: 2px;
            }
            
            /* Compact menu items */
            QMenu::item {
                padding: 3px 20px 3px 10px;
            }
            
            /* Compact group boxes */
            QGroupBox {
                margin-top: 1ex;
                padding-top: 10px;
            }
            
            QGroupBox::title {
                top: -7px;
                left: 10px;
            }
            
            /* Compact status bar */
            QStatusBar {
                min-height: 18px;
                font-size: 10px;
            }
            
            /* Compact splitters */
            QSplitter::handle {
                background-color: #ddd;
                height: 3px;
            }
            
            /* Compact scroll bars */
            QScrollBar:vertical {
                width: 10px;
            }
            
            QScrollBar:horizontal {
                height: 10px;
            }
            
            /* Compact line edits */
            QLineEdit, QTextEdit, QPlainTextEdit {
                padding: 2px;
            }
            
            /* Compact spin boxes */
            QSpinBox, QDoubleSpinBox {
                padding: 2px;
                min-height: 20px;
            }
            
            /* Compact combo boxes */
            QComboBox {
                padding: 2px 5px;
                min-height: 20px;
            }
            
            /* Compact tool buttons */
            QToolButton {
                padding: 2px;
                min-height: 20px;
                min-width: 20px;
            }
            
            /* Compact dialogs */
            QDialog {
                font-size: 11px;
            }
            
            /* Compact labels */
            QLabel {
                margin: 1px;
            }
            
            /* Compact progress bars */
            QProgressBar {
                min-height: 14px;
                max-height: 14px;
                font-size: 10px;
            }
            
            /* Compact checkboxes and radio buttons */
            QCheckBox, QRadioButton {
                spacing: 3px;
            }
            
            /* Compact tree widget */
            QTreeWidget::item {
                padding: 1px;
                min-height: 18px;
            }
            """
            self.setStyleSheet(compact_style)
            
            # Apply specific compact settings to widgets
            self._apply_compact_to_widgets(True)
        else:
            # Reset to normal styling
            self.setStyleSheet("")
            self._apply_compact_to_widgets(False)
            
    def _apply_compact_to_widgets(self, is_compact: bool):
        """Apply compact mode settings to specific widgets"""
        # Set tab widget spacing
        if is_compact:
            self.tab_widget.setDocumentMode(True)
            self.centralWidget().layout().setContentsMargins(5, 5, 5, 5)
            self.centralWidget().layout().setSpacing(5)
        else:
            self.tab_widget.setDocumentMode(False)
            self.centralWidget().layout().setContentsMargins(9, 9, 9, 9)
            self.centralWidget().layout().setSpacing(6)
            
        # Apply to child widgets if they have compact mode support
        for i in range(self.tab_widget.count()):
            widget = self.tab_widget.widget(i)
            if hasattr(widget, 'set_compact_mode'):
                widget.set_compact_mode(is_compact)
</file>

<file path="src/ui/widgets/execution_widget.py">
"""
Macro execution control widget
"""

from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QProgressBar, QTableWidget, QTableWidgetItem, QGroupBox,
    QTextEdit, QSplitter, QHeaderView, QCheckBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QColor, QBrush, QFont
from automation.engine import ExecutionEngine, ExecutionState, ExecutionResult
from excel.excel_manager import ExcelManager
from core.macro_types import Macro, MacroStep
from config.settings import Settings
from logger.app_logger import get_logger

class ExecutionStatusWidget(QWidget):
    """Widget showing execution status"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Status label
        self.status_label = QLabel("ëŒ€ê¸° ì¤‘")
        self.status_label.setAlignment(Qt.AlignCenter)
        font = QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.status_label.setFont(font)
        layout.addWidget(self.status_label)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(True)
        layout.addWidget(self.progress_bar)
        
        # Statistics
        stats_layout = QHBoxLayout()
        
        self.total_label = QLabel("ì „ì²´: 0")
        stats_layout.addWidget(self.total_label)
        
        self.completed_label = QLabel("ì™„ë£Œ: 0")
        self.completed_label.setStyleSheet("color: green;")
        stats_layout.addWidget(self.completed_label)
        
        self.failed_label = QLabel("ì‹¤íŒ¨: 0")
        self.failed_label.setStyleSheet("color: red;")
        stats_layout.addWidget(self.failed_label)
        
        self.time_label = QLabel("ì†Œìš”ì‹œê°„: 0:00")
        stats_layout.addWidget(self.time_label)
        
        stats_layout.addStretch()
        layout.addLayout(stats_layout)
        
        self.setLayout(layout)
        
    def update_status(self, state: ExecutionState):
        """Update status display"""
        status_map = {
            ExecutionState.IDLE: ("ëŒ€ê¸° ì¤‘", "#000000"),
            ExecutionState.RUNNING: ("ì‹¤í–‰ ì¤‘", "#00aa00"),
            ExecutionState.PAUSED: ("ì¼ì‹œì •ì§€", "#ff8800"),
            ExecutionState.STOPPING: ("ì •ì§€ ì¤‘...", "#aa0000"),
            ExecutionState.STOPPED: ("ì •ì§€ë¨", "#aa0000"),
            ExecutionState.ERROR: ("ì˜¤ë¥˜", "#ff0000")
        }
        
        text, color = status_map.get(state, ("ì•Œ ìˆ˜ ì—†ìŒ", "#000000"))
        self.status_label.setText(text)
        self.status_label.setStyleSheet(f"color: {color};")
        
    def update_progress(self, current: int, total: int):
        """Update progress bar"""
        self.progress_bar.setMaximum(total)
        self.progress_bar.setValue(current)
        self.progress_bar.setFormat(f"{current}/{total} ({current/total*100:.1f}%)")
        
    def update_statistics(self, total: int, completed: int, failed: int, elapsed_seconds: float):
        """Update statistics"""
        self.total_label.setText(f"ì „ì²´: {total}")
        self.completed_label.setText(f"ì™„ë£Œ: {completed}")
        self.failed_label.setText(f"ì‹¤íŒ¨: {failed}")
        
        minutes = int(elapsed_seconds // 60)
        seconds = int(elapsed_seconds % 60)
        self.time_label.setText(f"ì†Œìš”ì‹œê°„: {minutes}:{seconds:02d}")

class ExecutionLogWidget(QTableWidget):
    """Widget showing execution log"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Set columns
        self.setColumnCount(5)
        self.setHorizontalHeaderLabels(["ì‹œê°„", "í–‰", "ë‹¨ê³„", "ìƒíƒœ", "ë©”ì‹œì§€"])
        
        # Configure table
        self.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(3, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        
        self.setColumnWidth(1, 60)  # Row
        self.setColumnWidth(3, 80)  # Status
        
        # Style
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QTableWidget.SelectRows)
        
    def add_log_entry(self, timestamp: str, row: int, step_name: str, 
                      success: bool, message: str = ""):
        """Add log entry"""
        row_count = self.rowCount()
        self.insertRow(row_count)
        
        # Time
        self.setItem(row_count, 0, QTableWidgetItem(timestamp))
        
        # Row number
        row_item = QTableWidgetItem(str(row + 1))
        row_item.setTextAlignment(Qt.AlignCenter)
        self.setItem(row_count, 1, row_item)
        
        # Step name
        self.setItem(row_count, 2, QTableWidgetItem(step_name))
        
        # Status
        status_item = QTableWidgetItem("ì„±ê³µ" if success else "ì‹¤íŒ¨")
        status_item.setTextAlignment(Qt.AlignCenter)
        if success:
            status_item.setForeground(QBrush(QColor(0, 150, 0)))
        else:
            status_item.setForeground(QBrush(QColor(200, 0, 0)))
        self.setItem(row_count, 3, status_item)
        
        # Message
        self.setItem(row_count, 4, QTableWidgetItem(message))
        
        # Auto scroll to bottom
        self.scrollToBottom()

class ExecutionControlWidget(QWidget):
    """Execution control buttons"""
    
    startRequested = pyqtSignal()
    pauseRequested = pyqtSignal()
    stopRequested = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        # Start button
        self.start_btn = QPushButton("â–¶ ì‹œì‘")
        self.start_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.start_btn.clicked.connect(self.startRequested.emit)
        layout.addWidget(self.start_btn)
        
        # Pause button
        self.pause_btn = QPushButton("â¸ ì¼ì‹œì •ì§€")
        self.pause_btn.setEnabled(False)
        self.pause_btn.clicked.connect(self.pauseRequested.emit)
        layout.addWidget(self.pause_btn)
        
        # Stop button
        self.stop_btn = QPushButton("â¹ ì •ì§€")
        self.stop_btn.setEnabled(False)
        self.stop_btn.setStyleSheet("""
            QPushButton:enabled {
                background-color: #f44336;
                color: white;
            }
        """)
        self.stop_btn.clicked.connect(self.stopRequested.emit)
        layout.addWidget(self.stop_btn)
        
        layout.addStretch()
        
        # Hotkey info
        hotkey_label = QLabel("ë‹¨ì¶•í‚¤: F9(ì¼ì‹œì •ì§€), ESC(ì •ì§€)")
        hotkey_label.setStyleSheet("color: #666; font-style: italic;")
        layout.addWidget(hotkey_label)
        
        self.setLayout(layout)
        
    def set_running_state(self, is_running: bool, is_paused: bool = False):
        """Update button states"""
        self.start_btn.setEnabled(not is_running)
        self.pause_btn.setEnabled(is_running)
        self.stop_btn.setEnabled(is_running)
        
        if is_paused:
            self.pause_btn.setText("â–¶ ì¬ê°œ")
        else:
            self.pause_btn.setText("â¸ ì¼ì‹œì •ì§€")

class ExecutionWidget(QWidget):
    """Complete execution widget"""
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
        # Execution engine
        self.engine = ExecutionEngine(settings)
        self.current_macro: Optional[Macro] = None
        self.excel_manager: Optional[ExcelManager] = None
        
        # Statistics
        self.start_time = None
        self.completed_count = 0
        self.failed_count = 0
        
        # Timer for elapsed time
        self.timer = QTimer()
        self.timer.timeout.connect(self._update_elapsed_time)
        
        self.init_ui()
        self.connect_signals()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Control buttons
        self.control_widget = ExecutionControlWidget()
        layout.addWidget(self.control_widget)
        
        # Status display
        status_group = QGroupBox("ì‹¤í–‰ ìƒíƒœ")
        status_layout = QVBoxLayout()
        self.status_widget = ExecutionStatusWidget()
        status_layout.addWidget(self.status_widget)
        status_group.setLayout(status_layout)
        layout.addWidget(status_group)
        
        # Options
        options_layout = QHBoxLayout()
        self.incomplete_only_checkbox = QCheckBox("ë¯¸ì™„ë£Œ í•­ëª©ë§Œ ì‹¤í–‰")
        self.incomplete_only_checkbox.setChecked(True)
        options_layout.addWidget(self.incomplete_only_checkbox)
        options_layout.addStretch()
        layout.addLayout(options_layout)
        
        # Log display
        log_group = QGroupBox("ì‹¤í–‰ ë¡œê·¸")
        log_layout = QVBoxLayout()
        
        # Log toolbar
        log_toolbar_layout = QHBoxLayout()
        log_toolbar_layout.addStretch()
        
        view_logs_btn = QPushButton("CSV ë¡œê·¸ ë³´ê¸°")
        view_logs_btn.clicked.connect(self.show_log_viewer)
        log_toolbar_layout.addWidget(view_logs_btn)
        
        log_layout.addLayout(log_toolbar_layout)
        
        self.log_widget = ExecutionLogWidget()
        log_layout.addWidget(self.log_widget)
        log_group.setLayout(log_layout)
        layout.addWidget(log_group)
        
        self.setLayout(layout)
        
    def connect_signals(self):
        """Connect signals"""
        # Control signals
        self.control_widget.startRequested.connect(self.start_execution)
        self.control_widget.pauseRequested.connect(self.toggle_pause)
        self.control_widget.stopRequested.connect(self.stop_execution)
        
        # Engine signals
        self.engine.stateChanged.connect(self._on_state_changed)
        self.engine.progressUpdated.connect(self._on_progress_updated)
        self.engine.rowCompleted.connect(self._on_row_completed)
        self.engine.stepExecuting.connect(self._on_step_executing)
        self.engine.executionFinished.connect(self._on_execution_finished)
        self.engine.error.connect(self._on_error)
        
    def set_macro_and_excel(self, macro: Macro, excel_manager: Optional[ExcelManager] = None):
        """Set macro and Excel manager"""
        self.current_macro = macro
        self.excel_manager = excel_manager
        
        # Show/hide Excel-specific controls
        self.incomplete_only_checkbox.setVisible(excel_manager is not None)
        
    def start_execution(self):
        """Start macro execution"""
        if not self.current_macro:
            self.logger.warning("No macro loaded")
            return
            
        # Reset statistics
        self.completed_count = 0
        self.failed_count = 0
        from PyQt5.QtCore import QTime
        self.start_time = QTime.currentTime()
        self.log_widget.setRowCount(0)
        
        # Configure engine
        self.engine.set_macro(self.current_macro, self.excel_manager)
        
        # Set target rows based on Excel availability
        if self.excel_manager:
            if self.incomplete_only_checkbox.isChecked():
                # Let engine use default (incomplete rows)
                self.engine.set_target_rows([])
            else:
                # Execute all rows
                total_rows = len(self.excel_manager._current_data.dataframe)
                self.engine.set_target_rows(list(range(total_rows)))
        else:
            # No Excel - standalone mode
            self.engine.set_target_rows([])
            
        # Start execution
        self.engine.start()
        self.timer.start(1000)  # Update every second
        
    def toggle_pause(self):
        """Toggle pause state"""
        self.engine.toggle_pause()
        
    def stop_execution(self):
        """Stop execution"""
        self.engine.stop_execution()
        
    def _on_state_changed(self, state: ExecutionState):
        """Handle state change"""
        self.status_widget.update_status(state)
        
        is_running = state in [ExecutionState.RUNNING, ExecutionState.PAUSED]
        is_paused = state == ExecutionState.PAUSED
        self.control_widget.set_running_state(is_running, is_paused)
        
        if not is_running:
            self.timer.stop()
            
    def _on_progress_updated(self, current: int, total: int):
        """Handle progress update"""
        self.status_widget.update_progress(current, total)
        
    def _on_row_completed(self, result: ExecutionResult):
        """Handle row completion"""
        if result.success:
            self.completed_count += 1
        else:
            self.failed_count += 1
            
        # Add to log
        import time
        timestamp = time.strftime("%H:%M:%S", time.localtime(result.timestamp))
        self.log_widget.add_log_entry(
            timestamp,
            result.row_index,
            "í–‰ ì™„ë£Œ",
            result.success,
            result.error or f"ì†Œìš”ì‹œê°„: {result.duration_ms:.0f}ms"
        )
        
    def _on_step_executing(self, step: MacroStep, row_index: int):
        """Handle step execution"""
        # Could add detailed step logging here if needed
        pass
        
    def _on_execution_finished(self):
        """Handle execution finished"""
        self.logger.info("Execution finished")
        self.timer.stop()
        
    def _on_error(self, error_msg: str):
        """Handle execution error"""
        self.logger.error(f"Execution error: {error_msg}")
        
        # Show error dialog
        from ui.dialogs.error_report_dialog import ErrorReportDialog
        from logger.execution_logger import get_execution_logger
        
        log_file = get_execution_logger().get_current_log_file()
        ErrorReportDialog.show_error(
            "Execution Error",
            error_msg,
            log_file=log_file,
            parent=self
        )
        
    def _update_elapsed_time(self):
        """Update elapsed time display"""
        if self.start_time:
            from PyQt5.QtCore import QTime
            elapsed = self.start_time.secsTo(QTime.currentTime())
            total = self.completed_count + self.failed_count
            self.status_widget.update_statistics(
                total, self.completed_count, self.failed_count, elapsed
            )
            
    def show_log_viewer(self):
        """Show log viewer dialog"""
        from ui.dialogs.log_viewer_dialog import LogViewerDialog
        from logger.execution_logger import get_execution_logger
        
        # Open with current log file if available
        log_file = get_execution_logger().get_current_log_file()
        dialog = LogViewerDialog(log_file=log_file, parent=self)
        dialog.show()  # Non-modal
        
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the execution widget"""
        if is_compact:
            # Reduce spacing in main layout
            self.layout().setSpacing(5)
            self.layout().setContentsMargins(5, 5, 5, 5)
            
            # Adjust group boxes
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(5, 15, 5, 5)
                
            # Set compact height for log table rows
            self.log_widget.verticalHeader().setDefaultSectionSize(22)
        else:
            # Reset to normal spacing
            self.layout().setSpacing(10)
            self.layout().setContentsMargins(10, 10, 10, 10)
            
            # Reset group boxes
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(9, 20, 9, 9)
                
            # Reset log table row height
            self.log_widget.verticalHeader().setDefaultSectionSize(30)
</file>

<file path="WINDOWS_RUN.bat">
@echo off
chcp 65001 >nul
REM === Excel Macro Automation - C Drive Direct Run ===

cls

echo ===============================
echo Excel Macro Automation Tool
echo ===============================
echo.

REM Set current path
set "CURRENT_PATH=%~dp0"
echo Execution Path: %CURRENT_PATH%

REM Change to project directory
cd /d "%~dp0"
if errorlevel 1 (
    echo.
    echo [ERROR] Failed to change to project directory!
    echo Path: %~dp0
    echo.
    pause
    exit /b
)

echo Current Directory: %CD%
echo.

:CHECK_PYTHON
REM Check Python
echo.
echo Checking Python...
python --version >nul 2>&1
if errorlevel 1 (
    echo.
    echo [ERROR] Python is not installed!
    echo.
    echo 1. Download Python from https://python.org
    echo 2. Check "Add Python to PATH" during installation
    echo.
    pause
    exit /b
)

python --version
echo.

REM Install required packages
echo Installing packages... (This may take time on first run)
echo.
echo Main packages:
echo - PyQt5 (GUI framework)
echo - pandas, openpyxl (Excel processing)
echo - pyautogui, opencv-python (Screen automation)
echo - easyocr (Text recognition) - May take time to install
echo.

REM Upgrade pip
python -m pip install --upgrade pip >nul 2>&1

REM Install base packages
echo Installing base packages...
pip install PyQt5 pandas openpyxl pyautogui pillow screeninfo cryptography opencv-python numpy mss --quiet --no-warn-script-location

REM Install EasyOCR separately
echo.
echo Installing EasyOCR... (Model download may take time on first run)
pip install easyocr --quiet --no-warn-script-location

if errorlevel 1 (
    echo.
    echo [WARNING] Some packages failed to install. Manual installation may be required.
    echo.
)

REM Check for execution file
echo.
echo Checking execution files...
if exist "run_main.py" (
    set "EXEC_FILE=run_main.py"
    echo Using primary launcher: run_main.py
) else if exist "run_main_fixed.py" (
    set "EXEC_FILE=run_main_fixed.py"
    echo Using fallback launcher: run_main_fixed.py
) else (
    echo.
    echo [ERROR] No execution file found!
    echo Looking for: run_main.py or run_main_fixed.py
    echo Current directory: %CD%
    echo.
    echo Directory contents:
    dir *.py
    echo.
    pause
    exit /b
)

REM Execute
echo.
echo ===============================
echo Starting application...
echo ===============================
echo.

python "%EXEC_FILE%"

REM Check execution result
set EXIT_CODE=%errorlevel%

REM Exit handling
echo.
if %EXIT_CODE% neq 0 (
    echo ===============================
    echo [ERROR] Application error occurred.
    echo Error code: %EXIT_CODE%
    echo ===============================
) else (
    echo ===============================
    echo Application terminated successfully.
    echo ===============================
)

echo.
echo Press any key to close...
pause >nul

REM No cleanup needed - running directly from project directory

exit /b %EXIT_CODE%
</file>

<file path="src/core/macro_types.py">
"""
Macro step type definitions
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Union, Tuple
from enum import Enum
import uuid
from datetime import datetime

class StepType(Enum):
    """Available macro step types"""
    # Mouse actions
    MOUSE_CLICK = "mouse_click"
    MOUSE_MOVE = "mouse_move"
    MOUSE_DRAG = "mouse_drag"
    MOUSE_SCROLL = "mouse_scroll"
    
    # Keyboard actions
    KEYBOARD_TYPE = "keyboard_type"
    KEYBOARD_HOTKEY = "keyboard_hotkey"
    
    # Wait actions
    WAIT_TIME = "wait_time"
    WAIT_IMAGE = "wait_image"
    WAIT_TEXT = "wait_text"
    
    # Screen actions
    SCREENSHOT = "screenshot"
    IMAGE_SEARCH = "image_search"
    OCR_TEXT = "ocr_text"
    
    # Flow control
    IF_CONDITION = "if_condition"
    LOOP = "loop"
    
    # Excel operations
    EXCEL_READ = "excel_read"
    EXCEL_WRITE = "excel_write"

class ErrorHandling(Enum):
    """Error handling strategies"""
    STOP = "stop"           # Stop execution on error
    CONTINUE = "continue"   # Continue to next step
    RETRY = "retry"         # Retry the step

class MouseButton(Enum):
    """Mouse button types"""
    LEFT = "left"
    RIGHT = "right"
    MIDDLE = "middle"

class ConditionOperator(Enum):
    """Condition operators for conditional steps"""
    EQUALS = "equals"
    NOT_EQUALS = "not_equals"
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    GREATER_THAN = "greater_than"
    LESS_THAN = "less_than"
    EXISTS = "exists"
    NOT_EXISTS = "not_exists"

@dataclass
class MacroStep(ABC):
    """Base class for all macro steps"""
    step_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    step_type: StepType = field(init=False)
    name: str = ""
    description: str = ""
    enabled: bool = True
    error_handling: ErrorHandling = ErrorHandling.STOP
    retry_count: int = 0
    
    @abstractmethod
    def validate(self) -> List[str]:
        """Validate step configuration"""
        pass
    
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """Convert step to dictionary"""
        base_dict = {
            "step_id": self.step_id,
            "step_type": self.step_type.value,
            "name": self.name,
            "description": self.description,
            "enabled": self.enabled,
            "error_handling": self.error_handling.value,
            "retry_count": self.retry_count
        }
        return base_dict
    
    @classmethod
    @abstractmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MacroStep':
        """Create step from dictionary"""
        pass

# Mouse Steps

@dataclass
class MouseClickStep(MacroStep):
    """Mouse click action"""
    step_type: StepType = field(default=StepType.MOUSE_CLICK, init=False)
    x: int = 0
    y: int = 0
    button: MouseButton = MouseButton.LEFT
    clicks: int = 1
    interval: float = 0.0
    relative_to: str = "screen"  # screen, window, image
    
    def validate(self) -> List[str]:
        errors = []
        # Allow negative coordinates for multi-monitor setups
        # No validation needed for x and y coordinates
        if self.clicks < 1:
            errors.append("Click count must be at least 1")
        if self.interval < 0:
            errors.append("Interval must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "x": self.x,
            "y": self.y,
            "button": self.button.value,
            "clicks": self.clicks,
            "interval": self.interval,
            "relative_to": self.relative_to
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MouseClickStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            x=data.get("x", 0),
            y=data.get("y", 0),
            button=MouseButton(data.get("button", "left")),
            clicks=data.get("clicks", 1),
            interval=data.get("interval", 0.0),
            relative_to=data.get("relative_to", "screen")
        )

@dataclass
class MouseMoveStep(MacroStep):
    """Mouse move action"""
    step_type: StepType = field(default=StepType.MOUSE_MOVE, init=False)
    x: int = 0
    y: int = 0
    duration: float = 0.0
    relative_to: str = "screen"
    
    def validate(self) -> List[str]:
        errors = []
        # Allow negative coordinates for multi-monitor setups
        # No validation needed for x and y coordinates
        if self.duration < 0:
            errors.append("Duration must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "x": self.x,
            "y": self.y,
            "duration": self.duration,
            "relative_to": self.relative_to
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MouseMoveStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            x=data.get("x", 0),
            y=data.get("y", 0),
            duration=data.get("duration", 0.0),
            relative_to=data.get("relative_to", "screen")
        )

# Keyboard Steps

@dataclass
class KeyboardTypeStep(MacroStep):
    """Keyboard typing action"""
    step_type: StepType = field(default=StepType.KEYBOARD_TYPE, init=False)
    text: str = ""
    interval: float = 0.0
    use_variables: bool = True
    
    def validate(self) -> List[str]:
        errors = []
        if not self.text:
            errors.append("Text cannot be empty")
        if self.interval < 0:
            errors.append("Interval must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "text": self.text,
            "interval": self.interval,
            "use_variables": self.use_variables
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'KeyboardTypeStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            text=data.get("text", ""),
            interval=data.get("interval", 0.0),
            use_variables=data.get("use_variables", True)
        )

@dataclass
class KeyboardHotkeyStep(MacroStep):
    """Keyboard hotkey action"""
    step_type: StepType = field(default=StepType.KEYBOARD_HOTKEY, init=False)
    keys: List[str] = field(default_factory=list)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.keys:
            errors.append("At least one key must be specified")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "keys": self.keys
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'KeyboardHotkeyStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            keys=data.get("keys", [])
        )

# Wait Steps

@dataclass
class WaitTimeStep(MacroStep):
    """Wait for specified time"""
    step_type: StepType = field(default=StepType.WAIT_TIME, init=False)
    seconds: float = 1.0
    
    def validate(self) -> List[str]:
        errors = []
        if self.seconds <= 0:
            errors.append("Wait time must be positive")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "seconds": self.seconds
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WaitTimeStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            seconds=data.get("seconds", 1.0)
        )

@dataclass
class WaitImageStep(MacroStep):
    """Wait for image to appear"""
    step_type: StepType = field(default=StepType.WAIT_IMAGE, init=False)
    image_path: str = ""
    timeout: float = 10.0
    confidence: float = 0.9
    region: Optional[tuple] = None  # (x, y, width, height)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.image_path:
            errors.append("Image path cannot be empty")
        if self.timeout <= 0:
            errors.append("Timeout must be positive")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "image_path": self.image_path,
            "timeout": self.timeout,
            "confidence": self.confidence,
            "region": list(self.region) if self.region else None
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WaitImageStep':
        region = data.get("region")
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            image_path=data.get("image_path", ""),
            timeout=data.get("timeout", 10.0),
            confidence=data.get("confidence", 0.9),
            region=tuple(region) if region else None
        )

@dataclass
class TextSearchStep(MacroStep):
    """Search for dynamic text and click"""
    step_type: StepType = field(default=StepType.OCR_TEXT, init=False)
    search_text: str = ""  # Text to search for (can include {{variables}})
    excel_column: Optional[str] = None  # Excel column to bind for dynamic text
    region: Optional[tuple] = None  # (x, y, width, height)
    exact_match: bool = False
    confidence: float = 0.5
    click_after_find: bool = True
    click_offset: Tuple[int, int] = (0, 0)  # Offset from center of found text
    double_click: bool = False  # Whether to double click
    
    def validate(self) -> List[str]:
        errors = []
        if not self.search_text and not self.excel_column:
            errors.append("Either search text or Excel column must be specified")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "search_text": self.search_text,
            "excel_column": self.excel_column,
            "region": list(self.region) if self.region else None,
            "exact_match": self.exact_match,
            "confidence": self.confidence,
            "click_after_find": self.click_after_find,
            "click_offset": list(self.click_offset),
            "double_click": self.double_click
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TextSearchStep':
        region = data.get("region")
        click_offset = data.get("click_offset", [0, 0])
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            search_text=data.get("search_text", ""),
            excel_column=data.get("excel_column"),
            region=tuple(region) if region else None,
            exact_match=data.get("exact_match", False),
            confidence=data.get("confidence", 0.5),
            click_after_find=data.get("click_after_find", True),
            click_offset=tuple(click_offset),
            double_click=data.get("double_click", False)
        )

# Flow Control Steps

@dataclass
class IfConditionStep(MacroStep):
    """Conditional execution"""
    step_type: StepType = field(default=StepType.IF_CONDITION, init=False)
    condition_type: str = "image_exists"  # image_exists, text_exists, variable_equals, variable_contains, variable_greater, variable_less
    condition_value: Dict[str, Any] = field(default_factory=dict)  # Store all condition parameters
    true_steps: List['MacroStep'] = field(default_factory=list)  # Nested steps for true branch
    false_steps: List['MacroStep'] = field(default_factory=list)  # Nested steps for false branch
    
    def validate(self) -> List[str]:
        errors = []
        if not self.condition_type:
            errors.append("Condition type must be specified")
            
        # Validate based on condition type
        if self.condition_type == "image_exists":
            if not self.condition_value.get("image_path"):
                errors.append("Image path must be specified for image_exists condition")
        elif self.condition_type == "text_exists":
            if not self.condition_value.get("text"):
                errors.append("Text must be specified for text_exists condition")
        elif self.condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            if not self.condition_value.get("variable"):
                errors.append("Variable name must be specified")
            if not self.condition_value.get("compare_value"):
                errors.append("Comparison value must be specified")
                
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "condition_type": self.condition_type,
            "condition_value": self.condition_value,
            "true_steps": [step.to_dict() for step in self.true_steps],
            "false_steps": [step.to_dict() for step in self.false_steps]
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'IfConditionStep':
        # StepFactory will be defined later in this module
        # We need to reference it dynamically to avoid forward reference issues
        import sys
        module = sys.modules[__name__]
        StepFactory = getattr(module, 'StepFactory')
        
        # Create true/false steps from data
        true_steps = []
        for step_data in data.get("true_steps", []):
            true_steps.append(StepFactory.from_dict(step_data))
            
        false_steps = []
        for step_data in data.get("false_steps", []):
            false_steps.append(StepFactory.from_dict(step_data))
            
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            condition_type=data.get("condition_type", "image_exists"),
            condition_value=data.get("condition_value", {}),
            true_steps=true_steps,
            false_steps=false_steps
        )

@dataclass
class LoopStep(MacroStep):
    """Loop execution"""
    step_type: StepType = field(default=StepType.LOOP, init=False)
    loop_type: str = "count"  # count, while_image, for_each_row
    loop_count: int = 1
    loop_steps: List[str] = field(default_factory=list)  # Step IDs to loop
    
    def validate(self) -> List[str]:
        errors = []
        if self.loop_type == "count" and self.loop_count < 1:
            errors.append("Loop count must be at least 1")
        if not self.loop_steps:
            errors.append("Loop must contain at least one step")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "loop_type": self.loop_type,
            "loop_count": self.loop_count,
            "loop_steps": self.loop_steps
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LoopStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            loop_type=data.get("loop_type", "count"),
            loop_count=data.get("loop_count", 1),
            loop_steps=data.get("loop_steps", [])
        )

# Additional Step Classes

@dataclass
class ImageSearchStep(MacroStep):
    """Image search and click action"""
    step_type: StepType = field(default=StepType.IMAGE_SEARCH, init=False)
    image_path: str = ""
    confidence: float = 0.9
    region: Optional[tuple] = None  # (x, y, width, height)
    click_after_find: bool = True
    click_offset: Tuple[int, int] = (0, 0)
    double_click: bool = False
    
    def validate(self) -> List[str]:
        errors = []
        if not self.image_path:
            errors.append("Image path cannot be empty")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "image_path": self.image_path,
            "confidence": self.confidence,
            "region": list(self.region) if self.region else None,
            "click_after_find": self.click_after_find,
            "click_offset": list(self.click_offset),
            "double_click": self.double_click
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ImageSearchStep':
        region = data.get("region")
        click_offset = data.get("click_offset", [0, 0])
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            image_path=data.get("image_path", ""),
            confidence=data.get("confidence", 0.9),
            region=tuple(region) if region else None,
            click_after_find=data.get("click_after_find", True),
            click_offset=tuple(click_offset),
            double_click=data.get("double_click", False)
        )

@dataclass
class ScreenshotStep(MacroStep):
    """Take screenshot action"""
    step_type: StepType = field(default=StepType.SCREENSHOT, init=False)
    filename_pattern: str = "screenshot_{timestamp}.png"
    save_directory: str = "./screenshots/"
    region: Optional[tuple] = None  # (x, y, width, height)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.filename_pattern:
            errors.append("Filename pattern cannot be empty")
        if not self.save_directory:
            errors.append("Save directory cannot be empty")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "filename_pattern": self.filename_pattern,
            "save_directory": self.save_directory,
            "region": list(self.region) if self.region else None
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ScreenshotStep':
        region = data.get("region")
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            filename_pattern=data.get("filename_pattern", "screenshot_{timestamp}.png"),
            save_directory=data.get("save_directory", "./screenshots/"),
            region=tuple(region) if region else None
        )

# Step Factory

class StepFactory:
    """Factory for creating macro steps"""
    
    _step_classes = {
        StepType.MOUSE_CLICK: MouseClickStep,
        StepType.MOUSE_MOVE: MouseMoveStep,
        StepType.KEYBOARD_TYPE: KeyboardTypeStep,
        StepType.KEYBOARD_HOTKEY: KeyboardHotkeyStep,
        StepType.WAIT_TIME: WaitTimeStep,
        StepType.WAIT_IMAGE: WaitImageStep,
        StepType.IMAGE_SEARCH: ImageSearchStep,
        StepType.SCREENSHOT: ScreenshotStep,
        StepType.OCR_TEXT: TextSearchStep,
        StepType.IF_CONDITION: IfConditionStep,
        StepType.LOOP: LoopStep
    }
    
    @classmethod
    def create_step(cls, step_type: StepType) -> MacroStep:
        """Create a new step of given type"""
        step_class = cls._step_classes.get(step_type)
        if not step_class:
            raise ValueError(f"Unknown step type: {step_type}")
        return step_class()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> MacroStep:
        """Create step from dictionary"""
        step_type = StepType(data.get("step_type"))
        step_class = cls._step_classes.get(step_type)
        if not step_class:
            raise ValueError(f"Unknown step type: {step_type}")
        return step_class.from_dict(data)

# Macro Definition

@dataclass
class Macro:
    """Complete macro definition"""
    macro_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = "ìƒˆ ë§¤í¬ë¡œ"
    description: str = ""
    version: str = "1.0.0"
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    steps: List[MacroStep] = field(default_factory=list)
    variables: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def add_step(self, step: MacroStep, index: Optional[int] = None):
        """Add step to macro"""
        if index is None:
            self.steps.append(step)
        else:
            self.steps.insert(index, step)
        self.updated_at = datetime.now()
    
    def remove_step(self, step_id: str):
        """Remove step by ID"""
        self.steps = [s for s in self.steps if s.step_id != step_id]
        self.updated_at = datetime.now()
    
    def move_step(self, step_id: str, new_index: int):
        """Move step to new position"""
        step = None
        for i, s in enumerate(self.steps):
            if s.step_id == step_id:
                step = self.steps.pop(i)
                break
        
        if step:
            self.steps.insert(new_index, step)
            self.updated_at = datetime.now()
    
    def validate(self) -> List[str]:
        """Validate entire macro"""
        errors = []
        if not self.name:
            errors.append("Macro name cannot be empty")
        
        # Validate each step
        for i, step in enumerate(self.steps):
            step_errors = step.validate()
            for error in step_errors:
                errors.append(f"Step {i+1} ({step.name}): {error}")
        
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert macro to dictionary"""
        return {
            "macro_id": self.macro_id,
            "name": self.name,
            "description": self.description,
            "version": self.version,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "steps": [step.to_dict() for step in self.steps],
            "variables": self.variables,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Macro':
        """Create macro from dictionary"""
        # StepFactory is defined in this module
        import sys
        module = sys.modules[__name__]
        StepFactory = getattr(module, 'StepFactory')
        
        steps = []
        for step_data in data.get("steps", []):
            steps.append(StepFactory.from_dict(step_data))
        
        return cls(
            macro_id=data.get("macro_id", str(uuid.uuid4())),
            name=data.get("name", "ìƒˆ ë§¤í¬ë¡œ"),
            description=data.get("description", ""),
            version=data.get("version", "1.0.0"),
            created_at=datetime.fromisoformat(data.get("created_at", datetime.now().isoformat())),
            updated_at=datetime.fromisoformat(data.get("updated_at", datetime.now().isoformat())),
            steps=steps,
            variables=data.get("variables", {}),
            metadata=data.get("metadata", {})
        )
</file>

<file path="src/ui/dialogs/image_step_dialog.py">
"""
Configuration dialogs for image-based macro steps
"""

import os
from typing import Optional, Dict, Any, Tuple
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QLineEdit, QSpinBox, QDoubleSpinBox, QGroupBox, QFileDialog,
    QDialogButtonBox, QMessageBox, QCheckBox, QComboBox, QWidget
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QImage, QKeySequence
from PyQt5.QtWidgets import QShortcut
from core.macro_types import MacroStep, WaitImageStep, StepType
from vision.image_matcher import ImageMatcher
from config.settings import Settings
from ui.widgets.roi_selector import ROISelectorOverlay
from utils.clipboard_utils import save_clipboard_image
from utils.monitor_utils import get_monitor_info

class ImageStepDialog(QDialog):
    """Base dialog for image step configuration"""
    
    def __init__(self, step: Optional[MacroStep] = None, 
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(parent)
        self.step = step
        self.settings = settings or Settings()
        self.image_matcher = ImageMatcher(self.settings)
        self.monitors = get_monitor_info()  # Get monitor information
        self.region = None  # Selected region
        
        # Step data
        self.step_data: Dict[str, Any] = {}
        if step:
            self.step_data = step.to_dict()
            # Load region from step if available
            if hasattr(step, 'region'):
                self.region = step.region
            
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize base UI"""
        self.setModal(True)
        self.setMinimumWidth(600)
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        
        layout = QVBoxLayout()
        
        # Name input
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("ë‹¨ê³„ ì´ë¦„:"))
        self.name_input = QLineEdit()
        name_layout.addWidget(self.name_input)
        layout.addLayout(name_layout)
        
        # Image selection group
        image_group = QGroupBox("ì°¸ì¡° ì´ë¯¸ì§€")
        image_layout = QVBoxLayout()
        
        # Image path
        path_layout = QHBoxLayout()
        path_layout.addWidget(QLabel("ì´ë¯¸ì§€ ê²½ë¡œ:"))
        self.image_path_input = QLineEdit()
        self.image_path_input.setReadOnly(True)
        path_layout.addWidget(self.image_path_input)
        
        # Browse button
        self.browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°...")
        self.browse_btn.clicked.connect(self._browse_image)
        path_layout.addWidget(self.browse_btn)
        
        # Capture button
        self.capture_btn = QPushButton("ìº¡ì²˜")
        self.capture_btn.clicked.connect(self._capture_image)
        path_layout.addWidget(self.capture_btn)
        
        # Paste button for clipboard
        self.paste_btn = QPushButton("ë¶™ì—¬ë„£ê¸° (Ctrl+V)")
        self.paste_btn.clicked.connect(self._paste_from_clipboard)
        path_layout.addWidget(self.paste_btn)
        
        # Add Ctrl+V shortcut
        paste_shortcut = QShortcut(QKeySequence("Ctrl+V"), self)
        paste_shortcut.activated.connect(self._paste_from_clipboard)
        
        image_layout.addLayout(path_layout)
        
        # Image preview
        self.image_preview = QLabel()
        self.image_preview.setMinimumHeight(150)
        self.image_preview.setMaximumHeight(300)
        self.image_preview.setScaledContents(False)  # Don't stretch image
        self.image_preview.setAlignment(Qt.AlignCenter)
        self.image_preview.setStyleSheet("""
            QLabel {
                border: 1px solid #ccc;
                background-color: #f9f9f9;
            }
        """)
        image_layout.addWidget(self.image_preview)
        
        # Help text
        help_label = QLabel(
            "ğŸ’¡ íŒ: Shift + Win + S ë¡œ í™”ë©´ì„ ìº¡ì²˜í•œ í›„ Ctrl+V ë˜ëŠ” 'ë¶™ì—¬ë„£ê¸°' ë²„íŠ¼ìœ¼ë¡œ ì´ë¯¸ì§€ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
        )
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px; margin-top: 5px;")
        image_layout.addWidget(help_label)
        
        image_group.setLayout(image_layout)
        layout.addWidget(image_group)
        
        # Search region configuration
        region_group = QGroupBox("ê²€ìƒ‰ ì˜ì—­")
        region_layout = QVBoxLayout()
        
        # Search scope selection
        scope_layout = QHBoxLayout()
        scope_layout.addWidget(QLabel("ê²€ìƒ‰ ë²”ìœ„:"))
        
        self.search_scope_combo = QComboBox()
        # Dynamically add monitor options
        self._populate_monitor_options()
        self.search_scope_combo.currentIndexChanged.connect(self._on_search_scope_changed)
        scope_layout.addWidget(self.search_scope_combo)
        scope_layout.addStretch()
        region_layout.addLayout(scope_layout)
        
        # Region display
        self.region_label = QLabel("ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)")
        region_layout.addWidget(self.region_label)
        
        # Region buttons (only visible for custom region selection)
        self.region_buttons_widget = QWidget()
        region_btn_layout = QHBoxLayout()
        region_btn_layout.setContentsMargins(0, 0, 0, 0)
        
        self.select_region_btn = QPushButton("ì˜ì—­ ì„ íƒ")
        self.select_region_btn.clicked.connect(self._select_region)
        region_btn_layout.addWidget(self.select_region_btn)
        
        self.clear_region_btn = QPushButton("ì˜ì—­ ì´ˆê¸°í™”")
        self.clear_region_btn.clicked.connect(self._clear_region)
        region_btn_layout.addWidget(self.clear_region_btn)
        
        self.preview_region_btn = QPushButton("ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°")
        self.preview_region_btn.clicked.connect(self._preview_region)
        region_btn_layout.addWidget(self.preview_region_btn)
        
        self.region_buttons_widget.setLayout(region_btn_layout)
        self.region_buttons_widget.setVisible(False)  # Hidden by default
        
        region_layout.addWidget(self.region_buttons_widget)
        region_group.setLayout(region_layout)
        layout.addWidget(region_group)
        
        # Additional controls (implemented by subclasses)
        self.add_custom_controls(layout)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
        # Update preview after dialog is shown
        from PyQt5.QtCore import QTimer
        QTimer.singleShot(100, self._update_preview)
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Override to add step-specific controls"""
        pass
        
    def _populate_monitor_options(self):
        """Populate monitor options in combo box"""
        options = ["ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)"]
        
        # Add each monitor as an option
        for i, monitor in enumerate(self.monitors):
            if monitor['is_primary']:
                name = f"ì£¼ ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            else:
                # Determine position-based name - check Y axis first
                x_offset_threshold = 300
                
                if monitor['y'] < -100:  # Above primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ìœ„ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ìœ„"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ìœ„"
                elif monitor['y'] > 100:  # Below primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ì•„ë˜ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ì•„ë˜"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ì•„ë˜"
                elif monitor['x'] < -100:  # Left of primary monitor
                    pos_name = "ì™¼ìª½"
                elif monitor['x'] > 100:  # Right of primary monitor
                    pos_name = "ì˜¤ë¥¸ìª½"
                else:
                    pos_name = "ë³´ì¡°"
                name = f"{pos_name} ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            options.append(name)
        
        # Add custom region selection at the end
        options.append("íŠ¹ì • ì˜ì—­ ì„ íƒ")
        
        self.search_scope_combo.addItems(options)
        
    def _on_search_scope_changed(self, index):
        """Handle search scope change"""
        if index == 0:  # ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)
            self.region = None
            self.region_label.setText("ì „ì²´ í™”ë©´ (ëª¨ë“  ëª¨ë‹ˆí„°)")
            self.region_buttons_widget.setVisible(False)
        elif index > 0 and index <= len(self.monitors):  # Specific monitor
            # Get the selected monitor
            monitor = self.monitors[index - 1]
            self.region = (
                monitor['x'], 
                monitor['y'],
                monitor['width'],
                monitor['height']
            )
            # Create display text
            if monitor['is_primary']:
                monitor_name = "ì£¼ ëª¨ë‹ˆí„°"
            else:
                # Use position-based name - check Y axis first
                x_offset_threshold = 300
                
                if monitor['y'] < -100:  # Above primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        monitor_name = "ìœ„ìª½ ëª¨ë‹ˆí„°"
                    elif monitor['x'] < -x_offset_threshold:
                        monitor_name = "ì™¼ìª½ ìœ„ ëª¨ë‹ˆí„°"
                    else:
                        monitor_name = "ì˜¤ë¥¸ìª½ ìœ„ ëª¨ë‹ˆí„°"
                elif monitor['y'] > 100:  # Below primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        monitor_name = "ì•„ë˜ìª½ ëª¨ë‹ˆí„°"
                    elif monitor['x'] < -x_offset_threshold:
                        monitor_name = "ì™¼ìª½ ì•„ë˜ ëª¨ë‹ˆí„°"
                    else:
                        monitor_name = "ì˜¤ë¥¸ìª½ ì•„ë˜ ëª¨ë‹ˆí„°"
                elif monitor['x'] < -100:  # Left of primary monitor
                    monitor_name = "ì™¼ìª½ ëª¨ë‹ˆí„°"
                elif monitor['x'] > 100:  # Right of primary monitor
                    monitor_name = "ì˜¤ë¥¸ìª½ ëª¨ë‹ˆí„°"
                else:
                    monitor_name = "ë³´ì¡° ëª¨ë‹ˆí„°"
            
            self.region_label.setText(
                f"{monitor_name}: ({monitor['x']}, {monitor['y']}) "
                f"í¬ê¸°: {monitor['width']}x{monitor['height']}"
            )
            self.region_buttons_widget.setVisible(False)
        else:  # íŠ¹ì • ì˜ì—­ ì„ íƒ
            if not self.region:
                self.region_label.setText("ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”")
            self.region_buttons_widget.setVisible(True)
        
    def _browse_image(self):
        """Browse for image file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "ì°¸ì¡° ì´ë¯¸ì§€ ì„ íƒ",
            "",
            "ì´ë¯¸ì§€ íŒŒì¼ (*.png *.jpg *.jpeg *.bmp);;ëª¨ë“  íŒŒì¼ (*.*)"
        )
        
        if file_path:
            self.image_path_input.setText(file_path)
            self._update_preview()
            
    def _capture_image(self):
        """Capture new reference image"""
        # Show instructions for Windows screen capture
        reply = QMessageBox.question(
            self,
            "í™”ë©´ ìº¡ì²˜ ì•ˆë‚´",
            "Windows í™”ë©´ ìº¡ì²˜ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n"
            "1. Shift + Win + S í‚¤ë¥¼ ëˆŒëŸ¬ í™”ë©´ ìº¡ì²˜\n"
            "2. ìº¡ì²˜í•  ì˜ì—­ì„ ì„ íƒ\n"
            "3. 'ë¶™ì—¬ë„£ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì´ë¯¸ì§€ ì¶”ê°€\n\n"
            "ì´ ë°©ë²•ì„ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Just show the message and let user use Windows capture
            QMessageBox.information(
                self,
                "ì•ˆë‚´",
                "ì§€ê¸ˆ Shift + Win + S ë¥¼ ëˆŒëŸ¬ì„œ í™”ë©´ì„ ìº¡ì²˜í•˜ì„¸ìš”.\n"
                "ìº¡ì²˜ í›„ 'ë¶™ì—¬ë„£ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”."
            )
        else:
            # Just show the same instruction for consistency
            QMessageBox.information(
                self,
                "ì•ˆë‚´",
                "Windows í™”ë©´ ìº¡ì²˜ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”:\n\n"
                "1. Shift + Win + S ë¥¼ ëˆŒëŸ¬ì„œ í™”ë©´ì„ ìº¡ì²˜\n"
                "2. ìº¡ì²˜í•  ì˜ì—­ì„ ì„ íƒ\n"
                "3. 'ë¶™ì—¬ë„£ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì´ë¯¸ì§€ ì¶”ê°€"
            )
        
    def _paste_from_clipboard(self):
        """Paste image from clipboard"""
        # Use the unified clipboard utility
        file_path = save_clipboard_image()
        
        if file_path and os.path.exists(file_path):
            # Update UI
            self.image_path_input.setText(file_path)
            # Delay preview update to ensure dialog is properly sized
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(50, self._update_preview)
            QMessageBox.information(self, "ì„±ê³µ", "í´ë¦½ë³´ë“œì—ì„œ ì´ë¯¸ì§€ë¥¼ ë¶™ì—¬ë„£ì—ˆìŠµë‹ˆë‹¤.")
        else:
            QMessageBox.information(
                self, 
                "ì•ˆë‚´", 
                "í´ë¦½ë³´ë“œì— ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.\n\n"
                "ì‚¬ìš© ë°©ë²•:\n"
                "1. Windows: Shift + Win + S ë¡œ í™”ë©´ ìº¡ì²˜\n"
                "2. ì´ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ë¶™ì—¬ë„£ê¸°\n\n"
                "ì°¸ê³ : WSL í™˜ê²½ì—ì„œëŠ” Windows PowerShellì„ í†µí•´\n"
                "í´ë¦½ë³´ë“œì— ì ‘ê·¼í•©ë‹ˆë‹¤."
            )
    
        
    def _update_preview(self):
        """Update image preview"""
        image_path = self.image_path_input.text()
        if os.path.exists(image_path):
            pixmap = QPixmap(image_path)
            if not pixmap.isNull():
                # Get the preview label size
                label_width = self.image_preview.width() - 10  # Account for padding
                label_height = self.image_preview.height() - 10
                
                # Scale to fit preview while keeping aspect ratio
                # Use the smaller of the two dimensions to ensure it fits
                scaled = pixmap.scaled(
                    label_width,
                    label_height,
                    Qt.KeepAspectRatio,
                    Qt.SmoothTransformation
                )
                self.image_preview.setPixmap(scaled)
                
                # Show original size info
                size_text = f"ì›ë³¸ í¬ê¸°: {pixmap.width()} x {pixmap.height()}"
                self.image_preview.setToolTip(size_text)
            else:
                self.image_preview.setText("ì˜ëª»ëœ ì´ë¯¸ì§€")
                self.image_preview.setToolTip("")
        else:
            self.image_preview.setText("ì„ íƒëœ ì´ë¯¸ì§€ ì—†ìŒ")
            self.image_preview.setToolTip("")
            
    def _select_region(self):
        """Start region selection"""
        # First, show monitor selection dialog
        monitor_dialog = QDialog(self)
        monitor_dialog.setWindowTitle("ëª¨ë‹ˆí„° ì„ íƒ")
        monitor_dialog.setModal(True)
        
        layout = QVBoxLayout()
        layout.addWidget(QLabel("ì˜ì—­ì„ ì„ íƒí•  ëª¨ë‹ˆí„°ë¥¼ ì„ íƒí•˜ì„¸ìš”:"))
        
        # Monitor list widget
        monitor_list = QComboBox()
        for i, monitor in enumerate(self.monitors):
            if monitor['is_primary']:
                name = f"ì£¼ ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            else:
                # Determine position-based name - check Y axis first
                x_offset_threshold = 300
                
                if monitor['y'] < -100:  # Above primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ìœ„ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ìœ„"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ìœ„"
                elif monitor['y'] > 100:  # Below primary monitor
                    if abs(monitor['x']) < x_offset_threshold:
                        pos_name = "ì•„ë˜ìª½"
                    elif monitor['x'] < -x_offset_threshold:
                        pos_name = "ì™¼ìª½ ì•„ë˜"
                    else:
                        pos_name = "ì˜¤ë¥¸ìª½ ì•„ë˜"
                elif monitor['x'] < -100:  # Left of primary monitor
                    pos_name = "ì™¼ìª½"
                elif monitor['x'] > 100:  # Right of primary monitor
                    pos_name = "ì˜¤ë¥¸ìª½"
                else:
                    pos_name = "ë³´ì¡°"
                name = f"{pos_name} ëª¨ë‹ˆí„° ({monitor['width']}x{monitor['height']})"
            monitor_list.addItem(name)
        
        layout.addWidget(monitor_list)
        
        # Buttons
        button_layout = QHBoxLayout()
        ok_button = QPushButton("í™•ì¸")
        cancel_button = QPushButton("ì·¨ì†Œ")
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)
        
        monitor_dialog.setLayout(layout)
        
        # Store selected monitor
        selected_monitor = [None]
        
        def on_ok():
            selected_monitor[0] = self.monitors[monitor_list.currentIndex()]
            monitor_dialog.accept()
            
        def on_cancel():
            monitor_dialog.reject()
            
        ok_button.clicked.connect(on_ok)
        cancel_button.clicked.connect(on_cancel)
        
        if monitor_dialog.exec_() == QDialog.Accepted and selected_monitor[0]:
            # Hide dialog temporarily
            self.hide()
            # Store selected monitor bounds
            self._selected_monitor_bounds = selected_monitor[0]
            # Give time for dialog to hide before showing ROI selector
            QTimer.singleShot(200, self._show_region_selector)
        
    def _show_region_selector(self):
        """Show region selector overlay"""
        # Try simple selector first (better for WSL)
        try:
            # Create ROI selector with monitor bounds if available
            monitor_bounds = getattr(self, '_selected_monitor_bounds', None)
            selector = ROISelectorOverlay(parent=None, monitor_bounds=monitor_bounds)
            
            def on_selection_complete(region):
                try:
                    print(f"DEBUG: ROI selection complete with region: {region}, type: {type(region)}")
                    # Ensure region is properly formatted
                    if region and len(region) == 4:
                        # Convert all values to integers to avoid any type issues
                        formatted_region = tuple(int(x) for x in region)
                        self.region = formatted_region
                        self.region_label.setText(
                            f"ì„ íƒëœ ì˜ì—­: ({formatted_region[0]}, {formatted_region[1]}) "
                            f"í¬ê¸°: {formatted_region[2]}x{formatted_region[3]}"
                        )
                        print(f"DEBUG: set region successful with formatted region: {formatted_region}")
                    else:
                        print(f"DEBUG: Invalid region format: {region}")
                        self.region = None
                        self.region_label.setText("ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”")
                    
                    # Show dialog and ensure it stays visible
                    self.setVisible(True)
                    self.show()
                    self.raise_()
                    self.activateWindow()
                    print(f"DEBUG: dialog.show() successful")
                    
                    # Force dialog to process events
                    from PyQt5.QtWidgets import QApplication
                    QApplication.processEvents()
                    
                    # Delay selector cleanup to ensure dialog is fully shown
                    from PyQt5.QtCore import QTimer
                    QTimer.singleShot(1000, selector.deleteLater)
                except Exception as e:
                    print(f"DEBUG: Error in on_selection_complete: {e}")
                    import traceback
                    traceback.print_exc()
                    # Still try to show the dialog
                    self.setVisible(True)
                    self.show()
                    self.raise_()
                    self.activateWindow()
                    from PyQt5.QtWidgets import QApplication
                    QApplication.processEvents()
                    from PyQt5.QtCore import QTimer
                    QTimer.singleShot(1000, selector.deleteLater)
                
            def on_selection_cancelled():
                self.setVisible(True)
                self.show()
                self.raise_()
                self.activateWindow()
                from PyQt5.QtWidgets import QApplication
                QApplication.processEvents()
                from PyQt5.QtCore import QTimer
                QTimer.singleShot(1000, selector.deleteLater)
                
            selector.selectionComplete.connect(on_selection_complete)
            selector.selectionCancelled.connect(on_selection_cancelled)
            
            # Start selection
            selector.start_selection()
            
        except Exception as e:
            print(f"Selector error: {e}")
            import traceback
            traceback.print_exc()
            self.show()
            QMessageBox.warning(self, "ì˜¤ë¥˜", "ì˜ì—­ ì„ íƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
        
    def _clear_region(self):
        """Clear selected region"""
        self.region = None
        self.region_label.setText("ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”")
        # Keep the scope combo at "íŠ¹ì • ì˜ì—­ ì„ íƒ"
        self.search_scope_combo.setCurrentIndex(len(self.monitors) + 1)
        
    def _preview_region(self):
        """Preview selected region"""
        if not self.region:
            QMessageBox.information(self, "ì•Œë¦¼", "ì„ íƒëœ ì˜ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
            
        try:
            # Take screenshot of region
            import pyautogui
            x, y, width, height = self.region
            screenshot = pyautogui.screenshot(region=(x, y, width, height))
            
            # Convert to QPixmap
            import io
            bytes_io = io.BytesIO()
            screenshot.save(bytes_io, format='PNG')
            bytes_io.seek(0)
            
            pixmap = QPixmap()
            pixmap.loadFromData(bytes_io.read())
            
            if pixmap.isNull():
                QMessageBox.warning(self, "ê²½ê³ ", "ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                return
            
            # Create preview dialog
            preview_dialog = QDialog(self)
            preview_dialog.setWindowTitle("ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°")
            layout = QVBoxLayout()
            
            label = QLabel()
            # Scale pixmap if too large
            if not pixmap.isNull() and (pixmap.width() > 800 or pixmap.height() > 600):
                pixmap = pixmap.scaled(800, 600, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            if not pixmap.isNull():
                label.setPixmap(pixmap)
            layout.addWidget(label)
            
            # Add region info
            info_label = QLabel(f"ì˜ì—­: ({x}, {y}) - í¬ê¸°: {width}x{height}")
            layout.addWidget(info_label)
            
            preview_dialog.setLayout(layout)
            preview_dialog.exec_()
            
        except Exception as e:
            print(f"DEBUG: Error in preview: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(self, "ì˜¤ë¥˜", f"ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
        
    def load_step_data(self):
        """Load data from existing step"""
        if self.step:
            self.name_input.setText(self.step.name)
            
            # Load image path if available
            if hasattr(self.step, 'image_path'):
                self.image_path_input.setText(self.step.image_path)
                self._update_preview()
                
            # Load region if available
            if hasattr(self.step, 'region') and self.step.region:
                self.region = self.step.region
                # Set search scope based on region
                if self.region:
                    # Check if region matches any monitor exactly
                    matched_monitor_index = None
                    for i, monitor in enumerate(self.monitors):
                        if (self.region[0] == monitor['x'] and
                            self.region[1] == monitor['y'] and
                            self.region[2] == monitor['width'] and
                            self.region[3] == monitor['height']):
                            matched_monitor_index = i + 1  # +1 because index 0 is "ì „ì²´ í™”ë©´"
                            break
                    
                    if matched_monitor_index:
                        self.search_scope_combo.setCurrentIndex(matched_monitor_index)
                    else:
                        # Custom region
                        self.search_scope_combo.setCurrentIndex(len(self.monitors) + 1)  # Last option
                
    def get_step_data(self) -> Dict[str, Any]:
        """Get configured step data"""
        data = {
            'name': self.name_input.text(),
            'image_path': self.image_path_input.text(),
            'region': self.region
        }
        
        # Add custom data from subclasses
        data.update(self.get_custom_data())
        
        return data
        
    def get_custom_data(self) -> Dict[str, Any]:
        """Override to return step-specific data"""
        return {}
        
    def accept(self):
        """Validate and accept dialog"""
        # Basic validation
        if not self.name_input.text():
            QMessageBox.warning(self, "í™•ì¸ ì˜¤ë¥˜", "ë‹¨ê³„ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”")
            return
            
        if not self.image_path_input.text():
            QMessageBox.warning(self, "í™•ì¸ ì˜¤ë¥˜", "ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”")
            return
            
        if not os.path.exists(self.image_path_input.text()):
            QMessageBox.warning(self, "í™•ì¸ ì˜¤ë¥˜", "ì„ íƒí•œ ì´ë¯¸ì§€ íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            return
            
        super().accept()

class WaitImageStepDialog(ImageStepDialog):
    """Dialog for configuring wait image steps"""
    
    def __init__(self, step: Optional[WaitImageStep] = None, 
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(step, settings, parent)
        self.setWindowTitle("ì´ë¯¸ì§€ ëŒ€ê¸° ë‹¨ê³„ ì„¤ì •")
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Add wait-specific controls"""
        # Matching parameters group
        params_group = QGroupBox("Matching Parameters")
        params_layout = QVBoxLayout()
        
        # Timeout
        timeout_layout = QHBoxLayout()
        timeout_layout.addWidget(QLabel("Timeout (seconds):"))
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setMinimum(1)
        self.timeout_spin.setMaximum(300)
        self.timeout_spin.setValue(30)
        timeout_layout.addWidget(self.timeout_spin)
        params_layout.addLayout(timeout_layout)
        
        # Confidence
        confidence_layout = QHBoxLayout()
        confidence_layout.addWidget(QLabel("Confidence:"))
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setMinimum(0.1)
        self.confidence_spin.setMaximum(1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.9)
        self.confidence_spin.setDecimals(2)
        confidence_layout.addWidget(self.confidence_spin)
        
        # Test button
        self.test_btn = QPushButton("Test Match")
        self.test_btn.clicked.connect(self._test_match)
        confidence_layout.addWidget(self.test_btn)
        
        params_layout.addLayout(confidence_layout)
        
        # Test result
        self.test_result_label = QLabel()
        params_layout.addWidget(self.test_result_label)
        
        params_group.setLayout(params_layout)
        layout.addWidget(params_group)
        
    def load_step_data(self):
        """Load wait image step data"""
        super().load_step_data()
        
        if isinstance(self.step, WaitImageStep):
            self.timeout_spin.setValue(int(self.step.timeout))
            self.confidence_spin.setValue(self.step.confidence)
            
    def get_custom_data(self) -> Dict[str, Any]:
        """Get wait-specific data"""
        return {
            'step_type': StepType.WAIT_IMAGE,
            'timeout': self.timeout_spin.value(),
            'confidence': self.confidence_spin.value()
        }
        
    def _test_match(self):
        """Test image matching with current settings"""
        image_path = self.image_path_input.text()
        if not image_path or not os.path.exists(image_path):
            self.test_result_label.setText("Please select a valid image first")
            return
            
        # Perform test match
        result = self.image_matcher.find_image(
            image_path,
            confidence=self.confidence_spin.value(),
            region=self.region
        )
        
        if result.found:
            self.test_result_label.setText(
                f"âœ“ Match found at ({result.center[0]}, {result.center[1]}) "
                f"with confidence {result.confidence:.2f}"
            )
            self.test_result_label.setStyleSheet("color: green;")
        else:
            self.test_result_label.setText(
                f"âœ— No match found (best confidence: {result.confidence:.2f})"
            )
            self.test_result_label.setStyleSheet("color: red;")

class ImageSearchStepDialog(ImageStepDialog):
    """Dialog for configuring image search steps"""
    
    def __init__(self, step: Optional[MacroStep] = None,
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(step, settings, parent)
        self.setWindowTitle("ì´ë¯¸ì§€ ê²€ìƒ‰ ë‹¨ê³„ ì„¤ì •")
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Add search-specific controls"""
        # Search parameters group
        params_group = QGroupBox("ê²€ìƒ‰ íŒŒë¼ë¯¸í„°")
        params_layout = QVBoxLayout()
        
        # Confidence
        confidence_layout = QHBoxLayout()
        confidence_layout.addWidget(QLabel("ì‹ ë¢°ë„:"))
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setMinimum(0.1)
        self.confidence_spin.setMaximum(1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.9)
        self.confidence_spin.setDecimals(2)
        confidence_layout.addWidget(self.confidence_spin)
        params_layout.addLayout(confidence_layout)
        
        # Search all occurrences
        self.search_all_check = QCheckBox("ëª¨ë“  í•­ëª© ì°¾ê¸°")
        params_layout.addWidget(self.search_all_check)
        
        # Max results (when search all is checked)
        max_results_layout = QHBoxLayout()
        max_results_layout.addWidget(QLabel("ìµœëŒ€ ê²°ê³¼:"))
        self.max_results_spin = QSpinBox()
        self.max_results_spin.setMinimum(1)
        self.max_results_spin.setMaximum(100)
        self.max_results_spin.setValue(10)
        self.max_results_spin.setEnabled(False)
        max_results_layout.addWidget(self.max_results_spin)
        params_layout.addLayout(max_results_layout)
        
        # Connect search all checkbox
        self.search_all_check.toggled.connect(self.max_results_spin.setEnabled)
        
        # Test button
        test_layout = QHBoxLayout()
        self.test_btn = QPushButton("í…ŒìŠ¤íŠ¸")
        self.test_btn.clicked.connect(self._test_search)
        test_layout.addWidget(self.test_btn)
        test_layout.addStretch()
        params_layout.addLayout(test_layout)
        
        # Test result label
        self.test_result_label = QLabel()
        params_layout.addWidget(self.test_result_label)
        
        params_group.setLayout(params_layout)
        layout.addWidget(params_group)
        
        # Click action group
        click_group = QGroupBox("í´ë¦­ ì˜µì…˜")
        click_layout = QVBoxLayout()
        
        # Click after find checkbox
        self.click_after_find_check = QCheckBox("ì°¾ì€ í›„ í´ë¦­")
        self.click_after_find_check.setChecked(True)
        click_layout.addWidget(self.click_after_find_check)
        
        # Click type selection
        click_type_layout = QHBoxLayout()
        click_type_layout.addWidget(QLabel("í´ë¦­ ìœ í˜•:"))
        self.click_type_combo = QComboBox()
        self.click_type_combo.addItems(["í•œë²ˆ í´ë¦­", "ë”ë¸” í´ë¦­"])
        self.click_type_combo.setCurrentIndex(0)
        click_type_layout.addWidget(self.click_type_combo)
        click_type_layout.addStretch()
        click_layout.addLayout(click_type_layout)
        
        # Click offset
        offset_layout = QHBoxLayout()
        offset_layout.addWidget(QLabel("í´ë¦­ ì˜¤í”„ì…‹:"))
        
        offset_layout.addWidget(QLabel("X:"))
        self.offset_x_spin = QSpinBox()
        self.offset_x_spin.setMinimum(-500)
        self.offset_x_spin.setMaximum(500)
        self.offset_x_spin.setValue(0)
        offset_layout.addWidget(self.offset_x_spin)
        
        offset_layout.addWidget(QLabel("Y:"))
        self.offset_y_spin = QSpinBox()
        self.offset_y_spin.setMinimum(-500)
        self.offset_y_spin.setMaximum(500)
        self.offset_y_spin.setValue(0)
        offset_layout.addWidget(self.offset_y_spin)
        
        offset_layout.addStretch()
        click_layout.addLayout(offset_layout)
        
        # Enable/disable click options based on click checkbox
        self.click_after_find_check.toggled.connect(self.click_type_combo.setEnabled)
        self.click_after_find_check.toggled.connect(self.offset_x_spin.setEnabled)
        self.click_after_find_check.toggled.connect(self.offset_y_spin.setEnabled)
        
        click_group.setLayout(click_layout)
        layout.addWidget(click_group)
        
    def get_custom_data(self) -> Dict[str, Any]:
        """Get search-specific data"""
        return {
            'step_type': StepType.IMAGE_SEARCH,
            'confidence': self.confidence_spin.value(),
            'search_all': self.search_all_check.isChecked(),
            'max_results': self.max_results_spin.value(),
            'click_after_find': self.click_after_find_check.isChecked(),
            'click_offset': (self.offset_x_spin.value(), self.offset_y_spin.value()),
            'double_click': self.click_type_combo.currentIndex() == 1  # True if "ë”ë¸” í´ë¦­" selected
        }
        
    def load_step_data(self):
        """Load image search step data"""
        super().load_step_data()
        
        if self.step and hasattr(self.step, 'confidence'):
            self.confidence_spin.setValue(self.step.confidence)
            
        if self.step and hasattr(self.step, 'click_after_find'):
            self.click_after_find_check.setChecked(self.step.click_after_find)
            
        if self.step and hasattr(self.step, 'click_offset'):
            offset = self.step.click_offset
            if offset and len(offset) >= 2:
                self.offset_x_spin.setValue(offset[0])
                self.offset_y_spin.setValue(offset[1])
                
        if self.step and hasattr(self.step, 'double_click'):
            self.click_type_combo.setCurrentIndex(1 if self.step.double_click else 0)
            
    def _test_search(self):
        """Test image search with current settings"""
        image_path = self.image_path_input.text()
        if not image_path or not os.path.exists(image_path):
            self.test_result_label.setText("ë¨¼ì € ìœ íš¨í•œ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”")
            self.test_result_label.setStyleSheet("color: red;")
            return
            
        # Hide dialog temporarily for testing
        self.hide()
        QTimer.singleShot(300, lambda: self._perform_test_search(image_path))
        
    def _perform_test_search(self, image_path: str):
        """Perform the actual test search"""
        try:
            # Perform image search
            result = self.image_matcher.find_image(
                image_path,
                confidence=self.confidence_spin.value(),
                region=self.region
            )
            
            if result.found:
                # Show result
                if self.click_after_find_check.isChecked():
                    # Calculate click position
                    click_x = result.center[0] + self.offset_x_spin.value()
                    click_y = result.center[1] + self.offset_y_spin.value()
                    
                    message = (
                        f"âœ“ ì´ë¯¸ì§€ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!\n"
                        f"ìœ„ì¹˜: ({result.center[0]}, {result.center[1]})\n"
                        f"í´ë¦­ ìœ„ì¹˜: ({click_x}, {click_y})\n"
                        f"ì‹ ë¢°ë„: {result.confidence:.2f}"
                    )
                else:
                    message = (
                        f"âœ“ ì´ë¯¸ì§€ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!\n"
                        f"ìœ„ì¹˜: ({result.center[0]}, {result.center[1]})\n"
                        f"ì‹ ë¢°ë„: {result.confidence:.2f}"
                    )
                
                self.test_result_label.setText(message.replace('\n', ' '))
                self.test_result_label.setStyleSheet("color: green;")
                
                # Highlight found image briefly
                self._highlight_found_image(result)
                
            else:
                self.test_result_label.setText(
                    f"âœ— ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (ìµœê³  ì‹ ë¢°ë„: {result.confidence:.2f})"
                )
                self.test_result_label.setStyleSheet("color: red;")
                
                # Show message box with more info
                QMessageBox.information(
                    self, 
                    "í…ŒìŠ¤íŠ¸ ê²°ê³¼",
                    f"ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n"
                    f"ìµœê³  ì‹ ë¢°ë„: {result.confidence:.2f}\n"
                    f"ì„¤ì •ëœ ì‹ ë¢°ë„: {self.confidence_spin.value()}\n\n"
                    f"íŒ:\n"
                    f"- ì‹ ë¢°ë„ë¥¼ ë‚®ì¶°ë³´ì„¸ìš” (í˜„ì¬: {self.confidence_spin.value()})\n"
                    f"- ì´ë¯¸ì§€ê°€ í™”ë©´ì— í‘œì‹œë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”\n"
                    f"- ê²€ìƒ‰ ì˜ì—­ì´ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•˜ì„¸ìš”"
                )
                
        except Exception as e:
            print(f"DEBUG: Error in test search: {e}")
            import traceback
            traceback.print_exc()
            self.test_result_label.setText(f"ì˜¤ë¥˜: {str(e)}")
            self.test_result_label.setStyleSheet("color: red;")
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{str(e)}")
        finally:
            self.show()
            
    def _highlight_found_image(self, result):
        """Briefly highlight the found image on screen"""
        try:
            import pyautogui
            x, y = result.center
            # Move mouse to the found location
            pyautogui.moveTo(x, y, duration=0.5)
            
            # Optional: Draw a rectangle around the found area
            # This would require a temporary overlay window
        except Exception as e:
            print(f"Error highlighting image: {e}")
</file>

<file path="src/ui/widgets/macro_editor.py">
"""
Drag and drop macro editor widget
"""

from typing import Optional, List, Dict, Any
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QLabel, QScrollArea, QFrame, QMenu, QMessageBox,
    QSplitter, QGroupBox, QToolButton, QDialog
)
from PyQt5.QtCore import Qt, pyqtSignal, QMimeData, QByteArray, QDataStream, QIODevice
from PyQt5.QtGui import QDrag, QDragEnterEvent, QDropEvent, QPalette, QIcon, QCursor
from core.macro_types import (
    MacroStep, StepType, Macro, StepFactory,
    MouseClickStep, KeyboardTypeStep, WaitTimeStep
)

class StepPaletteItem(QListWidgetItem):
    """Draggable step type item"""
    
    def __init__(self, step_type: StepType, display_name: str, icon: Optional[QIcon] = None):
        super().__init__(display_name)
        self.step_type = step_type
        if icon:
            self.setIcon(icon)
        self.setToolTip(self._get_tooltip())
        
    def _get_tooltip(self) -> str:
        """Get tooltip for step type"""
        tooltips = {
            StepType.MOUSE_CLICK: "ë§ˆìš°ìŠ¤ í´ë¦­ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.MOUSE_MOVE: "ë§ˆìš°ìŠ¤ ì´ë™ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.KEYBOARD_TYPE: "í…ìŠ¤íŠ¸ ì…ë ¥ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.KEYBOARD_HOTKEY: "ë‹¨ì¶•í‚¤ ì…ë ¥ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.WAIT_TIME: "ì§€ì •ëœ ì‹œê°„ë§Œí¼ ëŒ€ê¸°í•©ë‹ˆë‹¤",
            StepType.WAIT_IMAGE: "ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ ëŒ€ê¸°í•©ë‹ˆë‹¤",
            StepType.IMAGE_SEARCH: "í™”ë©´ì—ì„œ ì´ë¯¸ì§€ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤",
            StepType.OCR_TEXT: "í™”ë©´ì—ì„œ í…ìŠ¤íŠ¸ë¥¼ ê²€ìƒ‰í•˜ê³  í´ë¦­í•©ë‹ˆë‹¤",
            StepType.SCREENSHOT: "í™”ë©´ì„ ìº¡ì²˜í•©ë‹ˆë‹¤",
            StepType.IF_CONDITION: "ì¡°ê±´ë¬¸ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.LOOP: "ë°˜ë³µë¬¸ì„ ì¶”ê°€í•©ë‹ˆë‹¤"
        }
        return tooltips.get(self.step_type, "")

class StepPalette(QListWidget):
    """Palette of draggable step types"""
    
    def __init__(self):
        super().__init__()
        self.setDragEnabled(True)
        self.setDefaultDropAction(Qt.CopyAction)
        self.setMaximumWidth(200)
        self.init_steps()
        
    def init_steps(self):
        """Initialize available step types"""
        step_configs = [
            (StepType.MOUSE_CLICK, "ë§ˆìš°ìŠ¤ í´ë¦­", "ğŸ–±ï¸"),
            (StepType.MOUSE_MOVE, "ë§ˆìš°ìŠ¤ ì´ë™", "â†—ï¸"),
            (StepType.KEYBOARD_TYPE, "í…ìŠ¤íŠ¸ ì…ë ¥", "âŒ¨ï¸"),
            (StepType.KEYBOARD_HOTKEY, "ë‹¨ì¶•í‚¤", "âŒ˜"),
            (StepType.WAIT_TIME, "ëŒ€ê¸°", "â±ï¸"),
            (StepType.WAIT_IMAGE, "ì´ë¯¸ì§€ ëŒ€ê¸°", "ğŸ–¼ï¸"),
            (StepType.IMAGE_SEARCH, "ì´ë¯¸ì§€ ê²€ìƒ‰", "ğŸ”"),
            (StepType.OCR_TEXT, "í…ìŠ¤íŠ¸ ê²€ìƒ‰", "ğŸ”¤"),
            (StepType.SCREENSHOT, "í™”ë©´ ìº¡ì²˜", "ğŸ“·"),
            (StepType.IF_CONDITION, "ì¡°ê±´ë¬¸", "â“"),
            (StepType.LOOP, "ë°˜ë³µë¬¸", "ğŸ”„"),
        ]
        
        for step_type, name, emoji in step_configs:
            item = StepPaletteItem(step_type, f"{emoji} {name}")
            self.addItem(item)
            
    def startDrag(self, supportedActions):
        """Start dragging a step type"""
        item = self.currentItem()
        if isinstance(item, StepPaletteItem):
            drag = QDrag(self)
            mime_data = QMimeData()
            
            # Store step type in MIME data
            byte_array = QByteArray()
            stream = QDataStream(byte_array, QIODevice.WriteOnly)
            stream.writeQString(item.step_type.value)
            
            mime_data.setData("application/x-steptype", byte_array)
            mime_data.setText(item.text())
            drag.setMimeData(mime_data)
            
            drag.exec_(Qt.CopyAction)

class MacroStepWidget(QFrame):
    """Widget representing a single macro step"""
    
    editRequested = pyqtSignal(MacroStep)
    deleteRequested = pyqtSignal(str)  # step_id
    moveRequested = pyqtSignal(str, int)  # step_id, new_index
    selectionChanged = pyqtSignal(str, bool)  # step_id, selected
    
    def __init__(self, step: MacroStep, index: int):
        super().__init__()
        self.step = step
        self.index = index
        self.selected = False
        self.setFrameStyle(QFrame.Box)
        self.setAcceptDrops(True)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        layout.setContentsMargins(5, 5, 5, 5)
        
        
        # Drag handle
        self.handle = QLabel("â‰¡")
        self.handle.setStyleSheet("font-size: 16px; color: #888;")
        self.handle.setCursor(Qt.OpenHandCursor)
        layout.addWidget(self.handle)
        
        # Step info
        info_layout = QVBoxLayout()
        
        # Step name and type with icon
        step_icon = self._get_step_icon()
        name_text = f"{step_icon} <b>{self.step.name or self.step.step_type.value}</b>"
        name_label = QLabel(name_text)
        info_layout.addWidget(name_label)
        
        # Step details based on type
        details_text = self._get_step_details()
        if details_text:
            details_label = QLabel(details_text)
            details_label.setWordWrap(True)
            details_label.setStyleSheet("color: #666; font-size: 11px;")
            details_label.setTextFormat(Qt.RichText)  # Enable HTML formatting
            info_layout.addWidget(details_label)
            
        # Step description
        if self.step.description:
            desc_label = QLabel(self.step.description)
            desc_label.setWordWrap(True)
            desc_label.setStyleSheet("color: #666; font-size: 11px;")
            info_layout.addWidget(desc_label)
            
        layout.addLayout(info_layout)
        layout.addStretch()
        
        # Enable/disable checkbox
        self.enable_btn = QToolButton()
        self.enable_btn.setCheckable(True)
        self.enable_btn.setChecked(self.step.enabled)
        self.enable_btn.setText("âœ“" if self.step.enabled else "âœ—")
        self.enable_btn.setToolTip(
            "ë‹¨ê³„ í™œì„±í™”/ë¹„í™œì„±í™”\n"
            "âœ“ í™œì„±í™”: ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œ ì´ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤\n"
            "âœ— ë¹„í™œì„±í™”: ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œ ì´ ë‹¨ê³„ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤"
        )
        self.enable_btn.toggled.connect(self._on_enable_toggled)
        layout.addWidget(self.enable_btn)
        
        # Edit button
        edit_btn = QToolButton()
        edit_btn.setText("âœï¸")
        edit_btn.setToolTip("í¸ì§‘")
        edit_btn.clicked.connect(lambda: self.editRequested.emit(self.step))
        layout.addWidget(edit_btn)
        
        # Delete button
        delete_btn = QToolButton()
        delete_btn.setText("ğŸ—‘ï¸")
        delete_btn.setToolTip("ì‚­ì œ")
        delete_btn.clicked.connect(lambda: self.deleteRequested.emit(self.step.step_id))
        layout.addWidget(delete_btn)
        
        self.setLayout(layout)
        self._update_style()
        
    def _get_step_icon(self) -> str:
        """Get icon for step type"""
        icons = {
            StepType.MOUSE_CLICK: "ğŸ–±ï¸",
            StepType.MOUSE_MOVE: "â†—ï¸",
            StepType.KEYBOARD_TYPE: "âŒ¨ï¸",
            StepType.KEYBOARD_HOTKEY: "âŒ˜",
            StepType.WAIT_TIME: "â±ï¸",
            StepType.WAIT_IMAGE: "ğŸ–¼ï¸",
            StepType.IMAGE_SEARCH: "ğŸ”",
            StepType.OCR_TEXT: "ğŸ”¤",
            StepType.SCREENSHOT: "ğŸ“·",
            StepType.IF_CONDITION: "â“",
            StepType.LOOP: "ğŸ”„"
        }
        return icons.get(self.step.step_type, "")
        
    def _get_step_details(self) -> str:
        """Get step details based on type"""
        details = []
        
        if self.step.step_type == StepType.WAIT_IMAGE:
            if hasattr(self.step, 'image_path') and self.step.image_path:
                import os
                filename = os.path.basename(self.step.image_path)
                details.append(f"ì´ë¯¸ì§€: {filename}")
            if hasattr(self.step, 'timeout'):
                details.append(f"ëŒ€ê¸°ì‹œê°„: {self.step.timeout}ì´ˆ")
            if hasattr(self.step, 'confidence'):
                details.append(f"ì •í™•ë„: {int(self.step.confidence * 100)}%")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("âœ“ ì˜ì—­ ì§€ì •ë¨")
                
        elif self.step.step_type == StepType.IMAGE_SEARCH:
            if hasattr(self.step, 'image_path') and self.step.image_path:
                import os
                filename = os.path.basename(self.step.image_path)
                details.append(f"ì´ë¯¸ì§€: {filename}")
            if hasattr(self.step, 'confidence'):
                details.append(f"ì •í™•ë„: {int(self.step.confidence * 100)}%")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("âœ“ ì˜ì—­ ì§€ì •ë¨")
                
        elif self.step.step_type == StepType.MOUSE_CLICK:
            if hasattr(self.step, 'x') and hasattr(self.step, 'y'):
                details.append(f"ìœ„ì¹˜: ({self.step.x}, {self.step.y})")
            if hasattr(self.step, 'clicks') and self.step.clicks > 1:
                details.append(f"í´ë¦­ ìˆ˜: {self.step.clicks}")
                
        elif self.step.step_type == StepType.KEYBOARD_TYPE:
            if hasattr(self.step, 'text') and self.step.text:
                text_preview = self.step.text[:30] + "..." if len(self.step.text) > 30 else self.step.text
                details.append(f"í…ìŠ¤íŠ¸: {text_preview}")
                
        elif self.step.step_type == StepType.WAIT_TIME:
            if hasattr(self.step, 'seconds'):
                details.append(f"ëŒ€ê¸°: {self.step.seconds}ì´ˆ")
                
        elif self.step.step_type == StepType.OCR_TEXT:
            if hasattr(self.step, 'excel_column') and self.step.excel_column:
                details.append(f"ì—‘ì…€ ì—´: {self.step.excel_column}")
            elif hasattr(self.step, 'search_text') and self.step.search_text:
                text_preview = self.step.search_text[:20] + "..." if len(self.step.search_text) > 20 else self.step.search_text
                details.append(f"í…ìŠ¤íŠ¸: {text_preview}")
            if hasattr(self.step, 'exact_match') and self.step.exact_match:
                details.append("ì •í™•íˆ ì¼ì¹˜")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("âœ“ ì˜ì—­ ì§€ì •ë¨")
                
        elif self.step.step_type == StepType.IF_CONDITION:
            if hasattr(self.step, 'condition_type'):
                condition_names = {
                    "image_exists": "ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´",
                    "text_exists": "í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´",
                    "variable_equals": "ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´",
                    "variable_contains": "ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´",
                    "variable_greater": "ë³€ìˆ˜ê°€ í¬ë©´",
                    "variable_less": "ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´"
                }
                details.append(condition_names.get(self.step.condition_type, self.step.condition_type))
            if hasattr(self.step, 'true_steps'):
                details.append(f"<span style='color: #4caf50'>âœ“ ì°¸: {len(self.step.true_steps)}ê°œ</span>")
            if hasattr(self.step, 'false_steps'):
                details.append(f"<span style='color: #f44336'>âœ— ê±°ì§“: {len(self.step.false_steps)}ê°œ</span>")
                
        elif self.step.step_type == StepType.SCREENSHOT:
            if hasattr(self.step, 'filename_pattern'):
                details.append(f"íŒŒì¼ëª…: {self.step.filename_pattern}")
            if hasattr(self.step, 'save_directory'):
                details.append(f"ì €ì¥ ê²½ë¡œ: {self.step.save_directory}")
            if hasattr(self.step, 'region') and self.step.region:
                x, y, w, h = self.step.region
                details.append(f"ì˜ì—­: ({x}, {y}) {w}x{h}")
            else:
                details.append("ì „ì²´ í™”ë©´")
                
        elif self.step.step_type == StepType.LOOP:
            if hasattr(self.step, 'loop_type'):
                loop_names = {
                    "count": "íšŸìˆ˜ ë°˜ë³µ",
                    "while_image": "ì´ë¯¸ì§€ ëŒ€ê¸°",
                    "for_each_row": "í–‰ë³„ ë°˜ë³µ"
                }
                details.append(loop_names.get(self.step.loop_type, self.step.loop_type))
            if hasattr(self.step, 'loop_count') and self.step.loop_type == "count":
                details.append(f"{self.step.loop_count}íšŒ")
            if hasattr(self.step, 'loop_steps'):
                details.append(f"{len(self.step.loop_steps)}ê°œ ë‹¨ê³„ ë°˜ë³µ")
                
        return " | ".join(details) if details else ""
        
    def _on_enable_toggled(self, checked: bool):
        """Handle enable/disable toggle"""
        self.step.enabled = checked
        self.enable_btn.setText("âœ“" if checked else "âœ—")
        self._update_style()
        
    def _update_style(self):
        """Update widget style based on state"""
        # Special styling for IF_CONDITION and LOOP
        if self.step.step_type == StepType.IF_CONDITION:
            base_color = "#fff3e0"  # Orange tint
            border_color = "#ff9800"
        elif self.step.step_type == StepType.LOOP:
            base_color = "#f3e5f5"  # Purple tint
            border_color = "#9c27b0"
        else:
            base_color = "white"
            border_color = "#ddd"
            
        if self.step.enabled:
            self.setStyleSheet(f"""
                MacroStepWidget {{
                    background-color: {base_color};
                    border: 2px solid {border_color};
                    border-radius: 5px;
                }}
                MacroStepWidget:hover {{
                    border-color: #999;
                }}
            """)
        else:
            self.setStyleSheet(f"""
                MacroStepWidget {{
                    background-color: #f5f5f5;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    opacity: 0.7;
                }}
            """)
            
            
    def mousePressEvent(self, event):
        """Handle mouse press for dragging"""
        if event.button() == Qt.LeftButton:
            # Check if clicking on handle
            handle_rect = self.handle.geometry()
            if handle_rect.contains(event.pos()):
                self.drag_start_position = event.pos()
                
    def mouseMoveEvent(self, event):
        """Handle mouse move for dragging"""
        if not (event.buttons() & Qt.LeftButton):
            return
            
        if not hasattr(self, 'drag_start_position'):
            return
            
        if (event.pos() - self.drag_start_position).manhattanLength() < 10:
            return
            
        # Start drag
        drag = QDrag(self)
        mime_data = QMimeData()
        
        # Store step data
        byte_array = QByteArray()
        stream = QDataStream(byte_array, QIODevice.WriteOnly)
        stream.writeQString(self.step.step_id)
        stream.writeInt(self.index)
        
        mime_data.setData("application/x-macrostep", byte_array)
        mime_data.setText(self.step.name or self.step.step_type.value)
        drag.setMimeData(mime_data)
        
        drag.exec_(Qt.MoveAction)

class MacroFlowWidget(QWidget):
    """Widget displaying the macro flow with drag/drop support"""
    
    stepAdded = pyqtSignal(MacroStep, int)  # step, index
    stepMoved = pyqtSignal(str, int)  # step_id, new_index
    stepDeleted = pyqtSignal(str)  # step_id
    stepEdited = pyqtSignal(MacroStep)
    
    def __init__(self):
        super().__init__()
        self.macro = Macro()
        self.step_widgets: Dict[str, MacroStepWidget] = {}
        self.selected_steps: Dict[str, bool] = {}  # step_id -> selected
        self.setAcceptDrops(True)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        self.layout = QVBoxLayout()
        self.layout.setSpacing(5)
        
        # Empty state label
        self.empty_label = QLabel("ë‹¨ê³„ë¥¼ ì—¬ê¸°ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”")
        self.empty_label.setAlignment(Qt.AlignCenter)
        self.empty_label.setStyleSheet("""
            QLabel {
                color: #999;
                font-size: 14px;
                padding: 50px;
                border: 2px dashed #ddd;
                border-radius: 5px;
            }
        """)
        self.layout.addWidget(self.empty_label)
        
        self.layout.addStretch()
        self.setLayout(self.layout)
        
    def set_macro(self, macro: Macro):
        """Set the macro to display"""
        self.macro = macro
        self._rebuild_ui()
        
    def _rebuild_ui(self):
        """Rebuild UI from macro"""
        # Clear existing widgets
        for widget in self.step_widgets.values():
            widget.deleteLater()
        self.step_widgets.clear()
        
        # Remove all items from layout
        while self.layout.count() > 0:
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
                
        # Show empty label or steps
        if not self.macro.steps:
            try:
                if self.empty_label:
                    self.layout.addWidget(self.empty_label)
                    self.empty_label.show()
            except RuntimeError:
                # Empty label was deleted, recreate it
                self.empty_label = QLabel("ë‹¨ê³„ë¥¼ ì—¬ê¸°ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”")
                self.empty_label.setAlignment(Qt.AlignCenter)
                self.empty_label.setStyleSheet("""
                    QLabel {
                        color: #999;
                        font-size: 14px;
                        padding: 50px;
                        border: 2px dashed #ddd;
                        border-radius: 5px;
                    }
                """)
                self.layout.addWidget(self.empty_label)
        else:
            if self.empty_label:
                try:
                    self.empty_label.hide()
                except RuntimeError:
                    pass
            for i, step in enumerate(self.macro.steps):
                widget = self._create_step_widget(step, i)
                self.layout.insertWidget(i, widget)
                self.step_widgets[step.step_id] = widget
                
        self.layout.addStretch()
        
    def _create_step_widget(self, step: MacroStep, index: int) -> MacroStepWidget:
        """Create widget for a step"""
        widget = MacroStepWidget(step, index)
        widget.editRequested.connect(self._on_step_edit)
        widget.deleteRequested.connect(self._on_step_delete)
        widget.moveRequested.connect(self.stepMoved.emit)
        widget.selectionChanged.connect(self._on_selection_changed)
        
        # Restore selection state
        if step.step_id in self.selected_steps:
            widget.set_selected(self.selected_steps[step.step_id])
            
        return widget
        
    def _on_step_edit(self, step: MacroStep):
        """Handle step edit request"""
        if not step:
            return
            
        try:
            step_id = step.step_id  # Define step_id here
            print(f"DEBUG: _on_step_edit called for step type: {step.step_type}")
            
            # Open appropriate dialog based on step type
            if step.step_type == StepType.WAIT_IMAGE:
                from ui.dialogs.image_step_dialog import WaitImageStepDialog
                dialog = WaitImageStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.image_path = step_data['image_path']
                    step.timeout = step_data['timeout']
                    step.confidence = step_data['confidence']
                    step.region = step_data['region']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.IMAGE_SEARCH:
                from ui.dialogs.image_step_dialog import ImageSearchStepDialog
                dialog = ImageSearchStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.image_path = step_data['image_path']
                    step.confidence = step_data['confidence']
                    step.region = step_data['region']
                    step.click_after_find = step_data.get('click_after_find', True)
                    step.click_offset = step_data.get('click_offset', (0, 0))
                    step.double_click = step_data.get('double_click', False)
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.OCR_TEXT:
                from ui.dialogs.text_search_step_dialog import TextSearchStepDialog
                # Get Excel columns from parent widget
                excel_columns = []
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'excel_widget'):
                        excel_manager = parent.excel_widget.get_excel_manager()
                        if excel_manager and excel_manager._current_data is not None:
                            excel_columns = list(excel_manager._current_data.columns)
                        break
                    parent = parent.parent()
                    
                dialog = TextSearchStepDialog(step, excel_columns, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.search_text = step_data['search_text']
                    step.excel_column = step_data['excel_column']
                    step.region = step_data['region']
                    step.exact_match = step_data['exact_match']
                    step.confidence = step_data['confidence']
                    step.click_after_find = step_data['click_after_find']
                    step.click_offset = step_data['click_offset']
                    step.double_click = step_data.get('double_click', False)
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.IF_CONDITION:
                print(f"DEBUG: Opening IF_CONDITION dialog for step: {step.step_id}")
                try:
                    from ui.dialogs.if_condition_step_dialog import IfConditionStepDialog
                    print(f"DEBUG: Successfully imported IfConditionStepDialog")
                    
                    # Get Excel columns from parent widget
                    excel_columns = []
                    parent = self.parent()
                    while parent:
                        if hasattr(parent, 'excel_widget'):
                            excel_manager = parent.excel_widget.get_excel_manager()
                            if excel_manager and excel_manager._current_data is not None:
                                excel_columns = list(excel_manager._current_data.columns)
                            break
                        parent = parent.parent()
                    print(f"DEBUG: Excel columns: {excel_columns}")
                    
                    # Create and show dialog
                    print(f"DEBUG: Creating IfConditionStepDialog")
                    dialog = IfConditionStepDialog(step, excel_columns, parent=self)
                    print(f"DEBUG: Executing IfConditionStepDialog")
                    
                    if dialog.exec_() == QDialog.Accepted:
                        # Update step with new data
                        step_data = dialog.get_step_data()
                        print(f"DEBUG: Got step data: {step_data.keys()}")
                        
                        step.name = step_data['name']
                        step.description = step_data.get('description', '')
                        step.condition_type = step_data['condition_type']
                        step.condition_value = step_data['condition_value']
                        step.true_steps = step_data['true_steps']
                        step.false_steps = step_data['false_steps']
                        
                        print(f"DEBUG: Updated step, rebuilding UI")
                        self._rebuild_ui()
                        self.stepEdited.emit(step)
                    else:
                        print(f"DEBUG: Dialog was cancelled")
                        
                except Exception as e:
                    print(f"ERROR in IF_CONDITION dialog: {e}")
                    import traceback
                    traceback.print_exc()
                    QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì¡°ê±´ë¬¸ í¸ì§‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
                    
            elif step.step_type == StepType.MOUSE_CLICK:
                from ui.dialogs.mouse_click_step_dialog import MouseClickStepDialog
                dialog = MouseClickStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.x = step_data['x']
                    step.y = step_data['y']
                    step.button = step_data['button']
                    step.clicks = step_data['clicks']
                    step.interval = step_data['interval']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.MOUSE_MOVE:
                from ui.dialogs.mouse_move_step_dialog import MouseMoveStepDialog
                dialog = MouseMoveStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.x = step_data['x']
                    step.y = step_data['y']
                    step.duration = step_data['duration']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.KEYBOARD_TYPE:
                from ui.dialogs.keyboard_type_step_dialog import KeyboardTypeStepDialog
                # Get Excel columns from parent widget
                excel_columns = []
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'excel_widget'):
                        excel_manager = parent.excel_widget.get_excel_manager()
                        if excel_manager and excel_manager._current_data is not None:
                            excel_columns = list(excel_manager._current_data.columns)
                        break
                    parent = parent.parent()
                    
                dialog = KeyboardTypeStepDialog(step, excel_columns, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.text = step_data['text']
                    step.interval = step_data['interval']
                    step.use_variables = step_data['use_variables']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.KEYBOARD_HOTKEY:
                from ui.dialogs.keyboard_hotkey_step_dialog import KeyboardHotkeyStepDialog
                dialog = KeyboardHotkeyStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.keys = step_data['keys']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.WAIT_TIME:
                print(f"DEBUG: Importing WaitTimeStepDialog")
                from ui.dialogs.wait_time_step_dialog import WaitTimeStepDialog
                print(f"DEBUG: Creating WaitTimeStepDialog")
                dialog = WaitTimeStepDialog(step, parent=self)
                print(f"DEBUG: Executing WaitTimeStepDialog")
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.seconds = step_data['seconds']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.SCREENSHOT:
                from ui.dialogs.screenshot_step_dialog import ScreenshotStepDialog
                dialog = ScreenshotStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.filename_pattern = step_data['filename_pattern']
                    step.save_directory = step_data['save_directory']
                    step.region = step_data['region']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.LOOP:
                print(f"DEBUG: Opening LOOP dialog for step: {step.step_id}")
                try:
                    from ui.dialogs.loop_step_dialog import LoopStepDialog
                    print(f"DEBUG: Successfully imported LoopStepDialog")
                    
                    # Get all steps in macro for selection
                    all_steps = self.macro.steps
                    print(f"DEBUG: Available steps for loop: {len(all_steps)}")
                    
                    # Create and show dialog
                    print(f"DEBUG: Creating LoopStepDialog")
                    dialog = LoopStepDialog(step, all_steps, parent=self)
                    print(f"DEBUG: Executing LoopStepDialog")
                    
                    if dialog.exec_() == QDialog.Accepted:
                        step_data = dialog.get_step_data()
                        print(f"DEBUG: Got step data: {step_data}")
                        
                        step.name = step_data['name']
                        step.loop_type = step_data['loop_type']
                        step.loop_count = step_data['loop_count']
                        step.loop_steps = step_data['loop_steps']
                        if 'description' in step_data:
                            step.description = step_data['description']
                            
                        print(f"DEBUG: Updated loop step, rebuilding UI")
                        self._rebuild_ui()
                        self.stepEdited.emit(step)
                    else:
                        print(f"DEBUG: Dialog was cancelled")
                        
                except Exception as e:
                    print(f"ERROR in LOOP dialog: {e}")
                    import traceback
                    traceback.print_exc()
                    QMessageBox.critical(self, "ì˜¤ë¥˜", f"ë°˜ë³µë¬¸ í¸ì§‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
                    
            else:
                # For other step types, emit the signal as before
                self.stepEdited.emit(step)
                
        except Exception as e:
            print(f"DEBUG: Exception in _on_step_edit: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ë‹¨ê³„ í¸ì§‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
        
    def _on_step_delete(self, step_id: str):
        """Handle step deletion"""
        reply = QMessageBox.question(
            self, "ë‹¨ê³„ ì‚­ì œ", 
            "ì´ ë‹¨ê³„ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.macro.remove_step(step_id)
            self._rebuild_ui()
            self.stepDeleted.emit(step_id)
            
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter"""
        if event.mimeData().hasFormat("application/x-steptype") or \
           event.mimeData().hasFormat("application/x-macrostep"):
            event.acceptProposedAction()
            
    def dragMoveEvent(self, event):
        """Handle drag move"""
        if event.mimeData().hasFormat("application/x-steptype") or \
           event.mimeData().hasFormat("application/x-macrostep"):
            event.acceptProposedAction()
            
    def dropEvent(self, event: QDropEvent):
        """Handle drop"""
        try:
            # Calculate drop index
            drop_index = self._get_drop_index(event.pos())
            
            if event.mimeData().hasFormat("application/x-steptype"):
                # New step from palette
                byte_array = event.mimeData().data("application/x-steptype")
                stream = QDataStream(byte_array, QIODevice.ReadOnly)
                step_type_str_result = stream.readQString()
                step_type_str = step_type_str_result[0] if isinstance(step_type_str_result, tuple) else step_type_str_result
                
                step_type = StepType(step_type_str)
                new_step = StepFactory.create_step(step_type)
                
                # Set default name
                step_names = {
                    StepType.MOUSE_CLICK: "ë§ˆìš°ìŠ¤ í´ë¦­",
                    StepType.MOUSE_MOVE: "ë§ˆìš°ìŠ¤ ì´ë™",
                    StepType.KEYBOARD_TYPE: "í…ìŠ¤íŠ¸ ì…ë ¥",
                    StepType.KEYBOARD_HOTKEY: "ë‹¨ì¶•í‚¤",
                    StepType.WAIT_TIME: "ëŒ€ê¸°",
                    StepType.WAIT_IMAGE: "ì´ë¯¸ì§€ ëŒ€ê¸°",
                    StepType.IMAGE_SEARCH: "ì´ë¯¸ì§€ ê²€ìƒ‰",
                    StepType.OCR_TEXT: "í…ìŠ¤íŠ¸ ê²€ìƒ‰",
                    StepType.SCREENSHOT: "í™”ë©´ ìº¡ì²˜",
                    StepType.IF_CONDITION: "ì¡°ê±´ë¬¸",
                    StepType.LOOP: "ë°˜ë³µë¬¸"
                }
                new_step.name = step_names.get(step_type, step_type.value)
                
                self.macro.add_step(new_step, drop_index)
                self._rebuild_ui()
                self.stepAdded.emit(new_step, drop_index)
                
                # Automatically open configuration dialog for new step
                self._on_step_edit(new_step)
                
            elif event.mimeData().hasFormat("application/x-macrostep"):
                # Moving existing step
                byte_array = event.mimeData().data("application/x-macrostep")
                stream = QDataStream(byte_array, QIODevice.ReadOnly)
                step_id_result = stream.readQString()
                step_id = step_id_result[0] if isinstance(step_id_result, tuple) else step_id_result
                old_index_result = stream.readInt()
                old_index = old_index_result[0] if isinstance(old_index_result, tuple) else old_index_result
                
                # Adjust drop index if moving down
                if old_index < drop_index:
                    drop_index -= 1
                    
                self.macro.move_step(step_id, drop_index)
                self._rebuild_ui()
                self.stepMoved.emit(step_id, drop_index)
                
            event.acceptProposedAction()
            
        except Exception as e:
            QMessageBox.critical(self, "\uc624\ub958", f"\ub4dc\ub798\uadf8 \uc568 \ub4dc\ub86d \uc911 \uc624\ub958\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4:\n{str(e)}")
            print(f"Drop event error: {e}")
            import traceback
            traceback.print_exc()
        
    def _get_drop_index(self, pos) -> int:
        """Calculate index where item should be dropped"""
        if not self.macro.steps:
            return 0
            
        # Find the widget under the cursor
        for i, step in enumerate(self.macro.steps):
            widget = self.step_widgets.get(step.step_id)
            if widget:
                widget_rect = widget.geometry()
                if pos.y() < widget_rect.center().y():
                    return i
                    
        return len(self.macro.steps)
        
    def _on_selection_changed(self, step_id: str, selected: bool):
        """Handle step selection change"""
        self.selected_steps[step_id] = selected
        
    def get_selected_steps(self) -> List[MacroStep]:
        """Get list of selected steps"""
        selected = []
        for step in self.macro.steps:
            if self.selected_steps.get(step.step_id, False):
                selected.append(step)
        return selected

class MacroEditorWidget(QWidget):
    """Complete macro editor with palette and flow"""
    
    macroChanged = pyqtSignal(Macro)
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        # Create splitter
        splitter = QSplitter(Qt.Horizontal)
        
        # Step palette
        palette_group = QGroupBox("ë‹¨ê³„ íŒ”ë ˆíŠ¸")
        palette_layout = QVBoxLayout()
        
        palette_label = QLabel("ë‹¨ê³„ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”")
        palette_label.setWordWrap(True)
        palette_layout.addWidget(palette_label)
        
        self.palette = StepPalette()
        palette_layout.addWidget(self.palette)
        
        palette_group.setLayout(palette_layout)
        splitter.addWidget(palette_group)
        
        # Macro flow
        flow_group = QGroupBox("ë§¤í¬ë¡œ íë¦„")
        flow_layout = QVBoxLayout()
        
        # Scroll area for flow
        scroll = QScrollArea()
        self.flow_widget = MacroFlowWidget()
        self.flow_widget.stepAdded.connect(self._on_change)
        self.flow_widget.stepMoved.connect(self._on_change)
        self.flow_widget.stepDeleted.connect(self._on_change)
        self.flow_widget.stepEdited.connect(self._on_step_edit)
        
        scroll.setWidget(self.flow_widget)
        scroll.setWidgetResizable(True)
        flow_layout.addWidget(scroll)
        
        flow_group.setLayout(flow_layout)
        splitter.addWidget(flow_group)
        
        # Set splitter sizes (20% palette, 80% flow)
        splitter.setSizes([200, 800])
        
        layout.addWidget(splitter)
        self.setLayout(layout)
        
    def set_macro(self, macro: Macro):
        """Set the macro to edit"""
        self.flow_widget.set_macro(macro)
        
    def get_macro(self) -> Macro:
        """Get the current macro"""
        return self.flow_widget.macro
        
    def get_selected_steps(self) -> List[MacroStep]:
        """Get list of selected steps"""
        return self.flow_widget.get_selected_steps()
        
    def _on_change(self):
        """Handle macro change"""
        self.macroChanged.emit(self.flow_widget.macro)
        
    def _on_step_edit(self, step: MacroStep):
        """Handle step edit request"""
        # This will be connected to step configuration dialog
        pass
        
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the macro editor"""
        if is_compact:
            # Adjust palette width
            self.palette.setMaximumWidth(150)
            
            # Find the splitter and adjust sizes
            splitter = self.findChild(QSplitter)
            if splitter:
                splitter.setSizes([150, 850])
                
            # Adjust group box margins
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(5, 15, 5, 5)
        else:
            # Reset to normal sizes
            self.palette.setMaximumWidth(200)
            
            # Reset splitter
            splitter = self.findChild(QSplitter)
            if splitter:
                splitter.setSizes([200, 800])
                
            # Reset group box margins
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(9, 20, 9, 9)
</file>

</files>
