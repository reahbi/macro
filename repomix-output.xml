This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.vooster/
  project.json
resources/
  locales/
    en.json
    ko.json
src/
  automation/
    __init__.py
    engine.py
    executor.py
    hotkey_listener.py
  config/
    settings.py
  core/
    __init__.py
    macro_storage.py
    macro_types.py
  excel/
    excel_manager.py
    models.py
  logger/
    app_logger.py
    execution_logger.py
  ui/
    dialogs/
      __init__.py
      error_report_dialog.py
      if_condition_step_dialog.py
      image_step_dialog.py
      keyboard_hotkey_step_dialog.py
      keyboard_type_step_dialog.py
      log_viewer_dialog.py
      loop_step_dialog.py
      macro_save_dialog.py
      mouse_click_step_dialog.py
      mouse_move_step_dialog.py
      screenshot_step_dialog.py
      text_search_step_dialog.py
      wait_time_step_dialog.py
    widgets/
      __init__.py
      data_preview.py
      excel_widget.py
      execution_widget.py
      file_selector.py
      macro_editor.py
      roi_selector.py
      sheet_mapper.py
      simple_roi_selector.py
    main_window.py
  utils/
    clipboard_utils.py
    encryption.py
    monitor_utils.py
    path_utils.py
  vision/
    __init__.py
    image_matcher.py
    text_extractor.py
  __init__.py
test_results/
  drag_drop_test_report.json
  test_drag_drop_integration_result.json
  test_report_20250716_115250.html
  test_results_20250716_115250.csv
  test_step_configuration_result.json
uploads/
  XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250715_225040.json
  XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_111655.json
  XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_230208.json
.gitignore
.mcp.json
APPLICATION_GUIDE.md
claude.md
CURRENT_STATUS.md
package.json
prd.md
pyproject.toml
README.md
requirements.txt
run_from_windows_native.ps1
run_main_fixed.py
run_main.py
RUN_ON_WINDOWS.bat
run_simple.py
run_windows_wsl.sh
run_windows.ps1
run_with_debug.py
RUNNING_GUIDE.md
setup_wsl_gui.sh
start_gui.sh
trd.md
usage_tracking2.json
web_macro.json
web_ui_enhanced.py
web_ui_integrated_working.py
web_ui_launcher.py
WINDOWS_GUIDE.md
WINDOWS_WSL_SETUP.md
WSL_GUI_GUIDE.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(cp:*)",
      "Bash(sed:*)",
      "Bash(rm:*)",
      "Bash(mkdir:*)",
      "Bash(python3:*)",
      "Bash(pip3 install:*)",
      "Bash(QT_QPA_PLATFORM=offscreen python3 -m pytest tests/integration/test_execution_logging.py::TestExecutionLogging::test_log_statistics_calculation -v)",
      "Bash(ls:*)",
      "Bash(grep:*)",
      "Bash(pip install:*)",
      "Bash(touch:*)",
      "Bash(true)",
      "Bash(timeout:*)",
      "Bash(find:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)"
    ],
    "deny": []
  },
  "enabledMcpjsonServers": [
    "vooster-ai",
    "playwright"
  ],
  "enableAllProjectMcpServers": true
}
</file>

<file path=".vooster/project.json">
{
  "projectUid": "X179",
  "projectName": "엑셀(Excel) 파일의 작업 목록을 기반으로, 사용자가 설정한 순서대로 작업을 자동 수...",
  "description": "엑셀(Excel) 파일의 작업 목록을 기반으로, 사용자가 설정한 순서대로 작업을 자동 수행하고 완료 여부를 표시하는 매크로 프로그램에 대한 제품 요구사항을 기술합니다. 사용자는 직관적인 그래픽 사용자 인터페이스(GUI)를 통해 자동화할 작업을 단계별로 쉽게 입력하고 관리할 수 있습니다. 이 프로그램은 반복적인 수작업을 자동화하여 업무 효율성을 극대화하는 것을 목표로 합니다.",
  "version": "1.0.0",
  "agent": "claude-code"
}
</file>

<file path="resources/locales/en.json">
{
  "app": {
    "name": "Excel Macro Automation",
    "description": "Excel-based task automation tool"
  },
  "menu": {
    "file": "File",
    "edit": "Edit",
    "view": "View",
    "help": "Help",
    "new_project": "New Project",
    "open_project": "Open Project",
    "save_project": "Save Project",
    "exit": "Exit",
    "settings": "Settings",
    "toggle_theme": "Toggle Theme",
    "about": "About"
  },
  "tabs": {
    "excel": "Excel",
    "editor": "Editor",
    "run": "Run"
  },
  "status": {
    "ready": "Ready",
    "running": "Running",
    "paused": "Paused",
    "stopped": "Stopped",
    "error": "Error"
  },
  "dialog": {
    "confirm_exit": "Are you sure you want to exit?",
    "yes": "Yes",
    "no": "No",
    "ok": "OK",
    "cancel": "Cancel"
  }
}
</file>

<file path="resources/locales/ko.json">
{
  "app": {
    "name": "엑셀 매크로 자동화",
    "description": "엑셀 기반 작업 자동화 도구"
  },
  "menu": {
    "file": "파일",
    "edit": "편집",
    "view": "보기",
    "help": "도움말",
    "new_project": "새 프로젝트",
    "open_project": "프로젝트 열기",
    "save_project": "프로젝트 저장",
    "exit": "종료",
    "settings": "설정",
    "toggle_theme": "테마 전환",
    "about": "정보"
  },
  "tabs": {
    "excel": "엑셀",
    "editor": "편집기",
    "run": "실행"
  },
  "status": {
    "ready": "준비",
    "running": "실행 중",
    "paused": "일시정지",
    "stopped": "중지됨",
    "error": "오류"
  },
  "dialog": {
    "confirm_exit": "종료하시겠습니까?",
    "yes": "예",
    "no": "아니오",
    "ok": "확인",
    "cancel": "취소"
  }
}
</file>

<file path="src/automation/__init__.py">
# Automation module
</file>

<file path="src/automation/hotkey_listener.py">
"""
Global hotkey listener for execution control
"""

import threading
from typing import Optional, Dict, Callable
from PyQt5.QtCore import QObject, pyqtSignal
try:
    from pynput import keyboard
except ImportError:
    # Fallback for systems without pynput
    keyboard = None
from config.settings import Settings
from logger.app_logger import get_logger

class HotkeyListener(QObject):
    """Listens for global hotkeys"""
    
    # Signals
    pausePressed = pyqtSignal()
    stopPressed = pyqtSignal()
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        self._listener: Optional[keyboard.Listener] = None
        self._running = False
        
        # Get hotkey settings
        self.pause_key = self._parse_key(settings.get("hotkeys.pause", "F9"))
        self.stop_key = self._parse_key(settings.get("hotkeys.stop", "Escape"))
        
        # Current key states
        self._pressed_keys = set()
        
    def _parse_key(self, key_string: str):
        """Parse key string to pynput key"""
        if not keyboard:
            return None
            
        # Map common key names
        key_map = {
            "F1": keyboard.Key.f1,
            "F2": keyboard.Key.f2,
            "F3": keyboard.Key.f3,
            "F4": keyboard.Key.f4,
            "F5": keyboard.Key.f5,
            "F6": keyboard.Key.f6,
            "F7": keyboard.Key.f7,
            "F8": keyboard.Key.f8,
            "F9": keyboard.Key.f9,
            "F10": keyboard.Key.f10,
            "F11": keyboard.Key.f11,
            "F12": keyboard.Key.f12,
            "Escape": keyboard.Key.esc,
            "Space": keyboard.Key.space,
            "Enter": keyboard.Key.enter,
            "Tab": keyboard.Key.tab,
            "Backspace": keyboard.Key.backspace,
            "Delete": keyboard.Key.delete,
            "Home": keyboard.Key.home,
            "End": keyboard.Key.end,
            "PageUp": keyboard.Key.page_up,
            "PageDown": keyboard.Key.page_down,
            "Left": keyboard.Key.left,
            "Right": keyboard.Key.right,
            "Up": keyboard.Key.up,
            "Down": keyboard.Key.down,
        }
        
        return key_map.get(key_string, key_string.lower())
        
    def start(self):
        """Start listening for hotkeys"""
        if not keyboard:
            self.logger.warning("pynput not available, hotkeys disabled")
            return
            
        if self._running:
            return
            
        self._running = True
        
        try:
            self._listener = keyboard.Listener(
                on_press=self._on_press,
                on_release=self._on_release
            )
            self._listener.start()
            self.logger.info(f"Hotkey listener started (Pause: {self.pause_key}, Stop: {self.stop_key})")
        except Exception as e:
            self.logger.error(f"Failed to start hotkey listener: {e}")
            
    def stop(self):
        """Stop listening for hotkeys"""
        if not self._running:
            return
            
        self._running = False
        
        if self._listener:
            self._listener.stop()
            self._listener = None
            
        self.logger.info("Hotkey listener stopped")
        
    def _on_press(self, key):
        """Handle key press"""
        try:
            # Add to pressed keys
            self._pressed_keys.add(key)
            
            # Check for pause hotkey
            if self._check_key(key, self.pause_key):
                self.logger.debug("Pause hotkey pressed")
                self.pausePressed.emit()
                
            # Check for stop hotkey
            elif self._check_key(key, self.stop_key):
                self.logger.debug("Stop hotkey pressed")
                self.stopPressed.emit()
                
        except Exception as e:
            self.logger.error(f"Error in key press handler: {e}")
            
    def _on_release(self, key):
        """Handle key release"""
        try:
            # Remove from pressed keys
            self._pressed_keys.discard(key)
        except Exception as e:
            self.logger.error(f"Error in key release handler: {e}")
            
    def _check_key(self, key, target_key) -> bool:
        """Check if pressed key matches target"""
        if not target_key:
            return False
            
        # Direct key comparison
        if key == target_key:
            return True
            
        # String comparison for character keys
        try:
            if hasattr(key, 'char') and key.char == target_key:
                return True
        except:
            pass
            
        return False

class SimpleHotkeyListener(QObject):
    """Simple hotkey listener using QShortcut (fallback)"""
    
    pausePressed = pyqtSignal()
    stopPressed = pyqtSignal()
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
    def start(self):
        """Start listening (no-op for simple listener)"""
        self.logger.info("Using simple hotkey listener (widget must have focus)")
        
    def stop(self):
        """Stop listening (no-op for simple listener)"""
        pass
</file>

<file path="src/excel/models.py">
"""
Excel data models and types
"""

from dataclasses import dataclass
from typing import List, Dict, Any, Optional
from enum import Enum
import pandas as pd

class ColumnType(Enum):
    """Excel column data types"""
    TEXT = "text"
    NUMBER = "number"
    DATE = "date"
    BOOLEAN = "boolean"
    MIXED = "mixed"
    EMPTY = "empty"

@dataclass
class ColumnInfo:
    """Information about an Excel column"""
    name: str
    index: int
    data_type: ColumnType
    sample_values: List[Any]
    null_count: int
    unique_count: int

@dataclass
class SheetInfo:
    """Information about an Excel sheet"""
    name: str
    row_count: int
    column_count: int
    columns: List[ColumnInfo]

@dataclass
class ExcelFileInfo:
    """Information about an Excel file"""
    file_path: str
    file_size: int
    sheet_count: int
    sheets: List[SheetInfo]
    
@dataclass
class ColumnMapping:
    """Maps Excel columns to macro variables"""
    excel_column: str
    variable_name: str
    data_type: ColumnType
    is_required: bool = True
    default_value: Any = None

class ExcelData:
    """Container for Excel data with metadata"""
    
    def __init__(self, dataframe: pd.DataFrame, sheet_name: str, file_path: str):
        self.dataframe = dataframe
        self.sheet_name = sheet_name
        self.file_path = file_path
        self._status_column = None
        
    @property
    def row_count(self) -> int:
        return len(self.dataframe)
    
    @property
    def column_count(self) -> int:
        return len(self.dataframe.columns)
    
    @property
    def columns(self) -> List[str]:
        return self.dataframe.columns.tolist()
    
    def get_status_column(self) -> Optional[str]:
        """Get the status column name"""
        return self._status_column
    
    def set_status_column(self, column_name: str):
        """Set the status column"""
        if column_name not in self.columns:
            self.dataframe[column_name] = ""
        self._status_column = column_name
    
    def update_row_status(self, row_index: int, status: str):
        """Update status for a specific row"""
        if self._status_column:
            self.dataframe.at[row_index, self._status_column] = status
    
    def get_incomplete_rows(self) -> pd.DataFrame:
        """Get rows that haven't been completed"""
        if not self._status_column:
            return self.dataframe
        
        return self.dataframe[
            (self.dataframe[self._status_column] != "완료") & 
            (self.dataframe[self._status_column] != "Completed")
        ]
    
    def get_row_data(self, row_index: int) -> Dict[str, Any]:
        """Get data for a specific row as dictionary"""
        return self.dataframe.iloc[row_index].to_dict()
</file>

<file path="src/logger/app_logger.py">
"""
Application logging configuration
"""

import logging
import sys
from pathlib import Path
from datetime import datetime
from logging.handlers import RotatingFileHandler
from typing import Optional

def setup_logger(log_dir: Optional[Path] = None, level: int = logging.INFO) -> logging.Logger:
    """Setup application logger with file and console handlers"""
    # Create logs directory
    if log_dir is None:
        log_dir = Path.home() / ".excel_macro_automation" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    
    # Create logger
    logger = logging.getLogger("excel_macro")
    logger.setLevel(level)
    
    # Clear existing handlers
    logger.handlers.clear()
    
    # Create formatters
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_formatter = logging.Formatter(
        '%(levelname)s: %(message)s'
    )
    
    # File handler with rotation
    log_file = log_dir / f"app_{datetime.now().strftime('%Y%m%d')}.log"
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=10 * 1024 * 1024,  # 10MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)
    
    return logger

def get_logger(name: str) -> logging.Logger:
    """Get a logger instance for a specific module"""
    return logging.getLogger(f"excel_macro.{name}")
</file>

<file path="src/logger/execution_logger.py">
"""
CSV execution logger for macro runs
"""

import csv
import os
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any
import threading
from queue import Queue
import atexit

class ExecutionLogger:
    """Logs macro execution details to CSV files"""
    
    def __init__(self, log_dir: Optional[Path] = None):
        """Initialize execution logger
        
        Args:
            log_dir: Directory to save log files. Defaults to user logs directory.
        """
        # Set log directory
        if log_dir is None:
            self.log_dir = Path.home() / ".excel_macro_automation" / "execution_logs"
        else:
            self.log_dir = Path(log_dir)
            
        # Create directory if not exists
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Current log file
        self.current_file: Optional[Path] = None
        self.csv_writer: Optional[csv.DictWriter] = None
        self.file_handle = None
        
        # Buffering for performance
        self.write_queue = Queue()
        self.writer_thread = None
        self.running = False
        
        # Register cleanup on exit
        atexit.register(self.close)
        
    def start_session(self, macro_name: str, excel_file: str) -> Path:
        """Start a new logging session
        
        Args:
            macro_name: Name of the macro being executed
            excel_file: Path to the Excel file being processed
            
        Returns:
            Path to the created log file
        """
        # Close previous session if any
        self.close()
        
        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_macro_name = "".join(c for c in macro_name if c.isalnum() or c in "._- ")[:50]
        filename = f"execution_{safe_macro_name}_{timestamp}.csv"
        self.current_file = self.log_dir / filename
        
        # Open file and create CSV writer
        self.file_handle = open(self.current_file, 'w', newline='', encoding='utf-8')
        
        # Define CSV fields
        self.fieldnames = [
            'timestamp',
            'elapsed_ms',
            'row_index',
            'row_data',
            'step_index',
            'step_name',
            'step_type',
            'status',
            'error_message',
            'duration_ms',
            'details'
        ]
        
        self.csv_writer = csv.DictWriter(self.file_handle, fieldnames=self.fieldnames)
        self.csv_writer.writeheader()
        
        # Write session info
        self.csv_writer.writerow({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': 0,
            'row_index': -1,
            'row_data': f"Session Start - Macro: {macro_name}",
            'step_index': -1,
            'step_name': "SESSION_START",
            'step_type': "INFO",
            'status': "INFO",
            'error_message': "",
            'duration_ms': 0,
            'details': f"Excel: {excel_file}"
        })
        
        # Start writer thread
        self.running = True
        self.writer_thread = threading.Thread(target=self._writer_loop, daemon=True)
        self.writer_thread.start()
        
        self.session_start_time = datetime.now()
        
        return self.current_file
        
    def log_row_start(self, row_index: int, row_data: Dict[str, Any]):
        """Log the start of processing a row"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': str(row_data),
            'step_index': -1,
            'step_name': "ROW_START",
            'step_type': "INFO",
            'status': "START",
            'error_message': "",
            'duration_ms': 0,
            'details': f"Processing row {row_index + 1}"
        })
        
    def log_step_execution(self, row_index: int, step_index: int, step_name: str, 
                          step_type: str, success: bool, duration_ms: float,
                          error_message: str = "", details: str = ""):
        """Log execution of a single step"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': "",
            'step_index': step_index,
            'step_name': step_name,
            'step_type': step_type,
            'status': "SUCCESS" if success else "FAILED",
            'error_message': error_message,
            'duration_ms': round(duration_ms, 2),
            'details': details
        })
        
    def log_row_complete(self, row_index: int, success: bool, total_duration_ms: float,
                        error_message: str = ""):
        """Log completion of a row"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': "",
            'step_index': -1,
            'step_name': "ROW_COMPLETE",
            'step_type': "INFO",
            'status': "SUCCESS" if success else "FAILED",
            'error_message': error_message,
            'duration_ms': round(total_duration_ms, 2),
            'details': f"Row {row_index + 1} completed"
        })
        
    def log_session_end(self, total_rows: int, successful_rows: int, failed_rows: int):
        """Log end of session with summary"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': -1,
            'row_data': f"Session End - Total: {total_rows}, Success: {successful_rows}, Failed: {failed_rows}",
            'step_index': -1,
            'step_name': "SESSION_END",
            'step_type': "INFO",
            'status': "INFO",
            'error_message': "",
            'duration_ms': self._get_elapsed_ms(),
            'details': f"Success rate: {(successful_rows/total_rows*100) if total_rows > 0 else 0:.1f}%"
        })
        
    def log_error(self, error_type: str, error_message: str, details: str = ""):
        """Log a general error"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': -1,
            'row_data': "",
            'step_index': -1,
            'step_name': error_type,
            'step_type': "ERROR",
            'status': "ERROR",
            'error_message': error_message,
            'duration_ms': 0,
            'details': details
        })
        
    def flush(self):
        """Force flush any pending logs"""
        if self.file_handle:
            # Wait for queue to empty
            self.write_queue.join()
            self.file_handle.flush()
            
    def close(self):
        """Close the current logging session"""
        if self.running:
            # Signal thread to stop
            self.running = False
            self._enqueue_log(None)  # Sentinel value
            
            # Wait for thread to finish
            if self.writer_thread and self.writer_thread.is_alive():
                self.writer_thread.join(timeout=5.0)
                
        # Close file
        if self.file_handle:
            self.file_handle.close()
            self.file_handle = None
            self.csv_writer = None
            
    def get_current_log_file(self) -> Optional[Path]:
        """Get path to current log file"""
        return self.current_file
        
    def _enqueue_log(self, log_entry: Optional[Dict[str, Any]]):
        """Add log entry to write queue"""
        self.write_queue.put(log_entry)
        
    def _writer_loop(self):
        """Background thread for writing logs"""
        while self.running:
            try:
                # Get log entry from queue
                log_entry = self.write_queue.get(timeout=0.1)
                
                # Check for sentinel
                if log_entry is None:
                    break
                    
                # Write to CSV
                if self.csv_writer:
                    self.csv_writer.writerow(log_entry)
                    
                # Mark task done
                self.write_queue.task_done()
                
            except:
                # Timeout or error, continue
                pass
                
    def _get_elapsed_ms(self) -> float:
        """Get elapsed time since session start"""
        if hasattr(self, 'session_start_time'):
            elapsed = datetime.now() - self.session_start_time
            return elapsed.total_seconds() * 1000
        return 0

# Global instance
_execution_logger = None

def get_execution_logger() -> ExecutionLogger:
    """Get the global execution logger instance"""
    global _execution_logger
    if _execution_logger is None:
        _execution_logger = ExecutionLogger()
    return _execution_logger
</file>

<file path="src/ui/dialogs/__init__.py">
# UI dialogs module
</file>

<file path="src/ui/dialogs/error_report_dialog.py">
"""
Error reporting dialog with detailed information and solutions
"""

import traceback
import os
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTextEdit,
    QPushButton, QLabel, QGroupBox, QTabWidget,
    QWidget, QCheckBox, QMessageBox
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont, QIcon
import pyautogui

class ErrorReportDialog(QDialog):
    """Dialog for displaying detailed error information"""
    
    # Error solutions database
    ERROR_SOLUTIONS = {
        "Image not found": {
            "원인": [
                "화면 해상도가 변경되었습니다",
                "대상 프로그램의 UI가 변경되었습니다",
                "이미지 파일이 손상되었거나 이동되었습니다",
                "화면 배율(DPI) 설정이 다릅니다"
            ],
            "해결 방법": [
                "이미지를 다시 캡처하세요",
                "화면 해상도를 원래대로 복원하세요",
                "Windows 디스플레이 설정에서 배율을 100%로 설정하세요",
                "대상 프로그램을 최대화하고 다시 시도하세요"
            ]
        },
        "Text not found": {
            "원인": [
                "텍스트가 화면에 표시되지 않았습니다",
                "OCR 인식 실패",
                "폰트나 텍스트 크기가 변경되었습니다",
                "검색 영역이 잘못 지정되었습니다"
            ],
            "해결 방법": [
                "검색할 텍스트가 화면에 표시되는지 확인하세요",
                "검색 영역을 다시 지정하세요",
                "정확한 텍스트 대신 부분 일치를 사용하세요",
                "대기 시간을 늘려보세요"
            ]
        },
        "Permission denied": {
            "원인": [
                "관리자 권한이 필요합니다",
                "파일이 다른 프로그램에서 사용 중입니다",
                "폴더에 쓰기 권한이 없습니다"
            ],
            "해결 방법": [
                "프로그램을 관리자 권한으로 실행하세요",
                "다른 프로그램에서 파일을 닫고 다시 시도하세요",
                "다른 위치에 저장해보세요"
            ]
        },
        "Excel": {
            "원인": [
                "Excel 파일이 열려있습니다",
                "시트 이름이 변경되었습니다",
                "열 이름이 변경되었습니다"
            ],
            "해결 방법": [
                "Excel 파일을 닫고 다시 시도하세요",
                "시트 매핑을 다시 설정하세요",
                "열 매핑을 확인하세요"
            ]
        }
    }
    
    def __init__(self, error_type: str, error_message: str, 
                 error_details: Optional[str] = None,
                 log_file: Optional[Path] = None,
                 parent=None):
        super().__init__(parent)
        self.error_type = error_type
        self.error_message = error_message
        self.error_details = error_details or traceback.format_exc()
        self.log_file = log_file
        self.screenshot_path = None
        
        self.init_ui()
        self.load_error_info()
        
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("오류 보고서")
        self.setModal(True)
        self.resize(700, 500)
        
        layout = QVBoxLayout()
        
        # Error summary
        error_group = QGroupBox("오류 요약")
        error_layout = QVBoxLayout()
        
        # Error icon and message
        message_layout = QHBoxLayout()
        
        # Error type label with red color
        type_label = QLabel(f"❌ {self.error_type}")
        type_label.setStyleSheet("color: red; font-size: 14px; font-weight: bold;")
        error_layout.addWidget(type_label)
        
        # Error message
        message_label = QLabel(self.error_message)
        message_label.setWordWrap(True)
        message_label.setStyleSheet("font-size: 12px; margin: 10px 0;")
        error_layout.addWidget(message_label)
        
        error_group.setLayout(error_layout)
        layout.addWidget(error_group)
        
        # Tab widget for details
        self.tabs = QTabWidget()
        
        # Solutions tab
        self.solutions_widget = self.create_solutions_tab()
        self.tabs.addTab(self.solutions_widget, "해결 방법")
        
        # Details tab
        self.details_widget = self.create_details_tab()
        self.tabs.addTab(self.details_widget, "상세 정보")
        
        # Log tab
        if self.log_file:
            self.log_widget = self.create_log_tab()
            self.tabs.addTab(self.log_widget, "실행 로그")
            
        layout.addWidget(self.tabs)
        
        # Actions
        action_layout = QHBoxLayout()
        
        # Screenshot checkbox
        self.screenshot_check = QCheckBox("오류 화면 캡처 포함")
        self.screenshot_check.setChecked(True)
        action_layout.addWidget(self.screenshot_check)
        
        action_layout.addStretch()
        
        # Copy button
        copy_btn = QPushButton("오류 정보 복사")
        copy_btn.clicked.connect(self.copy_error_info)
        action_layout.addWidget(copy_btn)
        
        # Save button
        save_btn = QPushButton("보고서 저장")
        save_btn.clicked.connect(self.save_report)
        action_layout.addWidget(save_btn)
        
        layout.addLayout(action_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        # Open log folder button
        if self.log_file:
            log_folder_btn = QPushButton("로그 폴더 열기")
            log_folder_btn.clicked.connect(self.open_log_folder)
            button_layout.addWidget(log_folder_btn)
        
        # OK button
        ok_btn = QPushButton("확인")
        ok_btn.setDefault(True)
        ok_btn.clicked.connect(self.accept)
        button_layout.addWidget(ok_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def create_solutions_tab(self) -> QWidget:
        """Create solutions tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Find matching error type
        matching_solution = None
        for key, solution in self.ERROR_SOLUTIONS.items():
            if key.lower() in self.error_message.lower():
                matching_solution = solution
                break
                
        if matching_solution:
            # Possible causes
            causes_group = QGroupBox("가능한 원인")
            causes_layout = QVBoxLayout()
            
            for cause in matching_solution["원인"]:
                cause_label = QLabel(f"• {cause}")
                cause_label.setWordWrap(True)
                causes_layout.addWidget(cause_label)
                
            causes_group.setLayout(causes_layout)
            layout.addWidget(causes_group)
            
            # Solutions
            solutions_group = QGroupBox("해결 방법")
            solutions_layout = QVBoxLayout()
            
            for i, solution in enumerate(matching_solution["해결 방법"], 1):
                solution_label = QLabel(f"{i}. {solution}")
                solution_label.setWordWrap(True)
                solution_label.setStyleSheet("margin: 5px 0;")
                solutions_layout.addWidget(solution_label)
                
            solutions_group.setLayout(solutions_layout)
            layout.addWidget(solutions_group)
        else:
            # Generic solutions
            generic_label = QLabel(
                "일반적인 해결 방법:\n\n"
                "1. 프로그램을 다시 시작해보세요\n"
                "2. 대상 프로그램이 정상적으로 실행 중인지 확인하세요\n"
                "3. 화면 해상도나 배율 설정을 확인하세요\n"
                "4. 매크로 단계를 다시 설정해보세요\n"
                "5. 문제가 지속되면 로그 파일과 함께 문의하세요"
            )
            generic_label.setWordWrap(True)
            layout.addWidget(generic_label)
            
        layout.addStretch()
        widget.setLayout(layout)
        return widget
        
    def create_details_tab(self) -> QWidget:
        """Create error details tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Error details text
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        self.details_text.setFont(QFont("Consolas", 9))
        self.details_text.setPlainText(self.error_details)
        
        layout.addWidget(self.details_text)
        widget.setLayout(layout)
        return widget
        
    def create_log_tab(self) -> QWidget:
        """Create log file tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Log file path
        path_label = QLabel(f"로그 파일: {self.log_file}")
        path_label.setWordWrap(True)
        layout.addWidget(path_label)
        
        # Log preview (last 50 lines)
        log_text = QTextEdit()
        log_text.setReadOnly(True)
        log_text.setFont(QFont("Consolas", 9))
        
        try:
            with open(self.log_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                # Show last 50 lines
                last_lines = lines[-50:] if len(lines) > 50 else lines
                log_text.setPlainText(''.join(last_lines))
        except Exception as e:
            log_text.setPlainText(f"로그 파일을 읽을 수 없습니다: {e}")
            
        layout.addWidget(log_text)
        widget.setLayout(layout)
        return widget
        
    def load_error_info(self):
        """Load additional error information"""
        # Could load more context here
        pass
        
    def copy_error_info(self):
        """Copy error information to clipboard"""
        from PyQt5.QtWidgets import QApplication
        
        info = f"""오류 타입: {self.error_type}
오류 메시지: {self.error_message}
발생 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

상세 정보:
{self.error_details}
"""
        
        if self.log_file:
            info += f"\n로그 파일: {self.log_file}"
            
        QApplication.clipboard().setText(info)
        QMessageBox.information(self, "복사 완료", "오류 정보가 클립보드에 복사되었습니다.")
        
    def save_report(self):
        """Save error report to file"""
        from PyQt5.QtWidgets import QFileDialog
        
        # Take screenshot if requested
        if self.screenshot_check.isChecked():
            self.capture_screenshot()
            
        # Get save location
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_name = f"error_report_{timestamp}.txt"
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "오류 보고서 저장",
            default_name,
            "Text Files (*.txt);;All Files (*.*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(f"오류 보고서\n")
                    f.write(f"=" * 50 + "\n\n")
                    f.write(f"발생 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"오류 타입: {self.error_type}\n")
                    f.write(f"오류 메시지: {self.error_message}\n\n")
                    
                    # Add solutions if available
                    for key, solution in self.ERROR_SOLUTIONS.items():
                        if key.lower() in self.error_message.lower():
                            f.write("\n가능한 원인:\n")
                            for cause in solution["원인"]:
                                f.write(f"  • {cause}\n")
                            f.write("\n해결 방법:\n")
                            for i, sol in enumerate(solution["해결 방법"], 1):
                                f.write(f"  {i}. {sol}\n")
                            break
                            
                    f.write(f"\n상세 정보:\n")
                    f.write(f"{self.error_details}\n")
                    
                    if self.log_file:
                        f.write(f"\n로그 파일: {self.log_file}\n")
                        
                    if self.screenshot_path:
                        f.write(f"\n스크린샷: {self.screenshot_path}\n")
                        
                QMessageBox.information(self, "저장 완료", f"오류 보고서가 저장되었습니다:\n{file_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "저장 실패", f"보고서 저장 중 오류가 발생했습니다:\n{str(e)}")
                
    def capture_screenshot(self):
        """Capture screenshot of current screen"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            screenshot_dir = Path.home() / ".excel_macro_automation" / "error_screenshots"
            screenshot_dir.mkdir(parents=True, exist_ok=True)
            
            self.screenshot_path = screenshot_dir / f"error_{timestamp}.png"
            pyautogui.screenshot(str(self.screenshot_path))
            
        except Exception as e:
            self.screenshot_path = None
            
    def open_log_folder(self):
        """Open log folder in file explorer"""
        if self.log_file:
            log_dir = os.path.dirname(self.log_file)
            os.startfile(log_dir)  # Windows only
            
    @staticmethod
    def show_error(error_type: str, error_message: str, 
                   error_details: Optional[str] = None,
                   log_file: Optional[Path] = None,
                   parent=None):
        """Static method to show error dialog"""
        dialog = ErrorReportDialog(error_type, error_message, error_details, log_file, parent)
        dialog.exec_()
        return dialog
</file>

<file path="src/ui/dialogs/keyboard_hotkey_step_dialog.py">
"""
Keyboard hotkey step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QListWidget, QListWidgetItem, QMessageBox
)
from PyQt5.QtCore import Qt, QEvent
from PyQt5.QtGui import QKeySequence
from core.macro_types import KeyboardHotkeyStep


class KeyCaptureButton(QPushButton):
    """Button that captures key combinations"""
    
    def __init__(self, text="클릭하고 키를 누르세요"):
        super().__init__(text)
        self.keys = []
        self.recording = False
        self.default_text = text
        
    def mousePressEvent(self, event):
        """Start recording on click"""
        super().mousePressEvent(event)
        if event.button() == Qt.LeftButton:
            self.recording = True
            self.keys = []
            self.setText("키를 누르세요...")
            self.setFocus()
            
    def keyPressEvent(self, event):
        """Capture key press"""
        if not self.recording:
            return
            
        key = event.key()
        key_name = QKeySequence(key).toString()
        
        # Handle modifiers
        modifiers = event.modifiers()
        if modifiers & Qt.ControlModifier and 'ctrl' not in self.keys:
            self.keys.append('ctrl')
        if modifiers & Qt.AltModifier and 'alt' not in self.keys:
            self.keys.append('alt')
        if modifiers & Qt.ShiftModifier and 'shift' not in self.keys:
            self.keys.append('shift')
        if modifiers & Qt.MetaModifier and 'win' not in self.keys:
            self.keys.append('win')
            
        # Add regular key if not a modifier
        if key not in [Qt.Key_Control, Qt.Key_Alt, Qt.Key_Shift, Qt.Key_Meta] and key_name:
            self.keys.append(key_name.lower())
            
        self.update_display()
        
    def keyReleaseEvent(self, event):
        """Stop recording on key release"""
        if self.recording and self.keys:
            self.recording = False
            
    def focusOutEvent(self, event):
        """Stop recording when focus lost"""
        super().focusOutEvent(event)
        self.recording = False
        
    def update_display(self):
        """Update button text with captured keys"""
        if self.keys:
            self.setText(" + ".join(self.keys))
        else:
            self.setText(self.default_text)
            
    def get_keys(self):
        """Get captured keys"""
        return self.keys
        
    def set_keys(self, keys):
        """Set keys programmatically"""
        self.keys = keys
        self.update_display()


class KeyboardHotkeyStepDialog(QDialog):
    """Dialog for configuring keyboard hotkey step"""
    
    def __init__(self, step: KeyboardHotkeyStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("단축키 설정")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("단계 이름:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Hotkey capture
        hotkey_group = QGroupBox("단축키")
        hotkey_layout = QVBoxLayout()
        
        # Capture button
        self.capture_button = KeyCaptureButton()
        hotkey_layout.addWidget(self.capture_button)
        
        # Common hotkeys
        common_label = QLabel("일반적인 단축키:")
        common_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        hotkey_layout.addWidget(common_label)
        
        # Hotkey list
        self.hotkey_list = QListWidget()
        self.hotkey_list.setMaximumHeight(150)
        
        common_hotkeys = [
            ("복사", ["ctrl", "c"]),
            ("붙여넣기", ["ctrl", "v"]),
            ("잘라내기", ["ctrl", "x"]),
            ("실행 취소", ["ctrl", "z"]),
            ("다시 실행", ["ctrl", "y"]),
            ("모두 선택", ["ctrl", "a"]),
            ("저장", ["ctrl", "s"]),
            ("새로 만들기", ["ctrl", "n"]),
            ("열기", ["ctrl", "o"]),
            ("인쇄", ["ctrl", "p"]),
            ("찾기", ["ctrl", "f"]),
            ("탭 전환", ["alt", "tab"]),
            ("창 닫기", ["alt", "f4"]),
        ]
        
        for name, keys in common_hotkeys:
            item = QListWidgetItem(f"{name}: {' + '.join(keys)}")
            item.setData(Qt.UserRole, keys)
            self.hotkey_list.addItem(item)
            
        self.hotkey_list.itemDoubleClicked.connect(self.use_common_hotkey)
        hotkey_layout.addWidget(self.hotkey_list)
        
        hotkey_group.setLayout(hotkey_layout)
        layout.addWidget(hotkey_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        if self.step.keys:
            self.capture_button.set_keys(self.step.keys)
            
    def use_common_hotkey(self, item):
        """Use a common hotkey"""
        keys = item.data(Qt.UserRole)
        self.capture_button.set_keys(keys)
        
    def validate_and_accept(self):
        """Validate input and accept"""
        if not self.capture_button.get_keys():
            QMessageBox.warning(
                self, "경고",
                "단축키를 설정해주세요."
            )
            return
            
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'keys': self.capture_button.get_keys()
        }
</file>

<file path="src/ui/dialogs/keyboard_type_step_dialog.py">
"""
Keyboard type step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QDialogButtonBox, QTextEdit,
    QFormLayout, QGroupBox, QCheckBox, QListWidget
)
from PyQt5.QtCore import Qt
from core.macro_types import KeyboardTypeStep


class KeyboardTypeStepDialog(QDialog):
    """Dialog for configuring keyboard type step"""
    
    def __init__(self, step: KeyboardTypeStep, excel_columns=None, parent=None):
        super().__init__(parent)
        self.step = step
        self.excel_columns = excel_columns or []
        self.setWindowTitle("텍스트 입력 설정")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("단계 이름:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Text input
        text_group = QGroupBox("입력할 텍스트")
        text_layout = QVBoxLayout()
        
        # Text edit
        self.text_edit = QTextEdit()
        self.text_edit.setPlaceholderText("입력할 텍스트를 작성하세요.\n변수는 {{변수명}} 형식으로 사용할 수 있습니다.")
        text_layout.addWidget(self.text_edit)
        
        # Variable help
        if self.excel_columns:
            help_layout = QHBoxLayout()
            help_layout.addWidget(QLabel("사용 가능한 Excel 열:"))
            
            # Variable list
            self.var_list = QListWidget()
            self.var_list.setMaximumHeight(100)
            for col in self.excel_columns:
                self.var_list.addItem(f"{{{{{col}}}}}")
            self.var_list.itemDoubleClicked.connect(self.insert_variable)
            help_layout.addWidget(self.var_list)
            
            text_layout.addLayout(help_layout)
        
        text_group.setLayout(text_layout)
        layout.addWidget(text_group)
        
        # Typing options
        options_group = QGroupBox("입력 옵션")
        options_layout = QFormLayout()
        
        # Typing interval
        self.interval_spin = QSpinBox()
        self.interval_spin.setRange(0, 1000)
        self.interval_spin.setSuffix(" ms")
        self.interval_spin.setValue(0)
        options_layout.addRow("키 입력 간격:", self.interval_spin)
        
        # Use variables checkbox
        self.use_variables_check = QCheckBox("변수 치환 사용")
        self.use_variables_check.setChecked(True)
        options_layout.addRow("", self.use_variables_check)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.text_edit.setPlainText(self.step.text)
        self.interval_spin.setValue(int(self.step.interval * 1000))
        self.use_variables_check.setChecked(self.step.use_variables)
        
    def insert_variable(self, item):
        """Insert variable at cursor position"""
        cursor = self.text_edit.textCursor()
        cursor.insertText(item.text())
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'text': self.text_edit.toPlainText(),
            'interval': self.interval_spin.value() / 1000.0,
            'use_variables': self.use_variables_check.isChecked()
        }
</file>

<file path="src/ui/dialogs/log_viewer_dialog.py">
"""
CSV log viewer dialog for analyzing execution logs
"""

import csv
import os
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QGroupBox, QComboBox, QLineEdit,
    QWidget, QSplitter, QTextEdit, QFileDialog, QMessageBox,
    QHeaderView, QProgressBar
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QColor, QFont
try:
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
    from matplotlib.figure import Figure
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False

class LogStatisticsWidget(QWidget):
    """Widget showing log statistics and charts"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Summary statistics
        self.stats_group = QGroupBox("실행 통계")
        stats_layout = QVBoxLayout()
        
        self.total_rows_label = QLabel("전체 행: 0")
        self.success_rows_label = QLabel("성공: 0 (0.0%)")
        self.failed_rows_label = QLabel("실패: 0 (0.0%)")
        self.total_time_label = QLabel("총 실행 시간: 0분 0초")
        self.avg_time_label = QLabel("평균 행 처리 시간: 0.0초")
        
        stats_layout.addWidget(self.total_rows_label)
        stats_layout.addWidget(self.success_rows_label)
        stats_layout.addWidget(self.failed_rows_label)
        stats_layout.addWidget(self.total_time_label)
        stats_layout.addWidget(self.avg_time_label)
        
        self.stats_group.setLayout(stats_layout)
        layout.addWidget(self.stats_group)
        
        # Chart (if matplotlib available)
        if HAS_MATPLOTLIB:
            self.figure = Figure(figsize=(5, 3))
            self.canvas = FigureCanvas(self.figure)
            layout.addWidget(self.canvas)
        else:
            no_chart_label = QLabel("차트를 표시하려면 matplotlib를 설치하세요")
            no_chart_label.setStyleSheet("color: #666; padding: 20px;")
            no_chart_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(no_chart_label)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def update_statistics(self, log_data: List[Dict[str, Any]]):
        """Update statistics from log data"""
        if not log_data:
            return
            
        # Calculate statistics
        total_rows = 0
        successful_rows = 0
        failed_rows = 0
        total_elapsed_ms = 0
        row_times = []
        
        # Process log entries
        processed_rows = set()
        for entry in log_data:
            if entry['row_index'] and entry['row_index'] != '-1':
                row_idx = int(entry['row_index'])
                
                if entry['step_name'] == 'ROW_COMPLETE' and row_idx not in processed_rows:
                    processed_rows.add(row_idx)
                    total_rows += 1
                    
                    if entry['status'] == 'SUCCESS':
                        successful_rows += 1
                    else:
                        failed_rows += 1
                        
                    if entry['duration_ms']:
                        row_times.append(float(entry['duration_ms']))
                        
            # Get total elapsed time from session end
            if entry['step_name'] == 'SESSION_END' and entry['elapsed_ms']:
                total_elapsed_ms = float(entry['elapsed_ms'])
                
        # Update labels
        self.total_rows_label.setText(f"전체 행: {total_rows}")
        
        if total_rows > 0:
            success_rate = (successful_rows / total_rows) * 100
            self.success_rows_label.setText(f"성공: {successful_rows} ({success_rate:.1f}%)")
            self.failed_rows_label.setText(f"실패: {failed_rows} ({100-success_rate:.1f}%)")
        else:
            self.success_rows_label.setText("성공: 0 (0.0%)")
            self.failed_rows_label.setText("실패: 0 (0.0%)")
            
        # Time statistics
        if total_elapsed_ms > 0:
            total_seconds = total_elapsed_ms / 1000
            minutes = int(total_seconds // 60)
            seconds = int(total_seconds % 60)
            self.total_time_label.setText(f"총 실행 시간: {minutes}분 {seconds}초")
            
        if row_times:
            avg_time = sum(row_times) / len(row_times) / 1000  # Convert to seconds
            self.avg_time_label.setText(f"평균 행 처리 시간: {avg_time:.1f}초")
            
        # Update chart
        self.update_chart(successful_rows, failed_rows)
        
    def update_chart(self, success: int, failed: int):
        """Update pie chart"""
        if not HAS_MATPLOTLIB:
            return
            
        self.figure.clear()
        
        if success == 0 and failed == 0:
            return
            
        ax = self.figure.add_subplot(111)
        
        # Data
        sizes = [success, failed]
        labels = ['성공', '실패']
        colors = ['#4CAF50', '#F44336']
        
        # Create pie chart
        wedges, texts, autotexts = ax.pie(
            sizes, labels=labels, colors=colors, autopct='%1.1f%%',
            shadow=True, startangle=90
        )
        
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax.axis('equal')
        ax.set_title('실행 결과 분포')
        
        self.canvas.draw()

class LogViewerDialog(QDialog):
    """Dialog for viewing and analyzing CSV execution logs"""
    
    def __init__(self, log_file: Optional[Path] = None, parent=None):
        super().__init__(parent)
        self.log_data: List[Dict[str, Any]] = []
        self.filtered_data: List[Dict[str, Any]] = []
        
        self.init_ui()
        
        if log_file:
            self.load_log_file(log_file)
            
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("실행 로그 뷰어")
        self.setModal(False)  # Non-modal to allow interaction with main window
        self.resize(1200, 700)
        
        layout = QVBoxLayout()
        
        # Toolbar
        toolbar_layout = QHBoxLayout()
        
        # Open file button
        open_btn = QPushButton("로그 파일 열기...")
        open_btn.clicked.connect(self.open_log_file)
        toolbar_layout.addWidget(open_btn)
        
        # Refresh button
        self.refresh_btn = QPushButton("새로고침")
        self.refresh_btn.clicked.connect(self.refresh_current_file)
        self.refresh_btn.setEnabled(False)
        toolbar_layout.addWidget(self.refresh_btn)
        
        toolbar_layout.addWidget(QLabel("필터:"))
        
        # Status filter
        self.status_filter = QComboBox()
        self.status_filter.addItems(["전체", "성공", "실패", "오류"])
        self.status_filter.currentTextChanged.connect(self.apply_filters)
        toolbar_layout.addWidget(self.status_filter)
        
        # Search
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("검색...")
        self.search_edit.textChanged.connect(self.apply_filters)
        toolbar_layout.addWidget(self.search_edit)
        
        # Export button
        export_btn = QPushButton("내보내기...")
        export_btn.clicked.connect(self.export_filtered_data)
        toolbar_layout.addWidget(export_btn)
        
        toolbar_layout.addStretch()
        layout.addLayout(toolbar_layout)
        
        # Current file label
        self.file_label = QLabel("로그 파일이 선택되지 않았습니다")
        self.file_label.setStyleSheet("color: #666; padding: 5px;")
        layout.addWidget(self.file_label)
        
        # Main content splitter
        splitter = QSplitter(Qt.Horizontal)
        
        # Statistics widget
        self.stats_widget = LogStatisticsWidget()
        splitter.addWidget(self.stats_widget)
        
        # Log table
        self.log_table = QTableWidget()
        self.setup_table()
        splitter.addWidget(self.log_table)
        
        # Set splitter sizes (30% stats, 70% table)
        splitter.setSizes([300, 700])
        
        layout.addWidget(splitter)
        
        # Status bar
        self.status_label = QLabel("준비")
        layout.addWidget(self.status_label)
        
        self.setLayout(layout)
        
        # Auto-refresh timer
        self.auto_refresh_timer = QTimer()
        self.auto_refresh_timer.timeout.connect(self.refresh_current_file)
        
    def setup_table(self):
        """Setup log table"""
        headers = [
            "시간", "경과(초)", "행", "단계", "타입", 
            "상태", "소요시간(ms)", "오류 메시지", "상세"
        ]
        
        self.log_table.setColumnCount(len(headers))
        self.log_table.setHorizontalHeaderLabels(headers)
        
        # Set column widths
        header = self.log_table.horizontalHeader()
        header.setStretchLastSection(True)
        self.log_table.setColumnWidth(0, 150)  # Time
        self.log_table.setColumnWidth(1, 80)   # Elapsed
        self.log_table.setColumnWidth(2, 60)   # Row
        self.log_table.setColumnWidth(3, 150)  # Step
        self.log_table.setColumnWidth(4, 100)  # Type
        self.log_table.setColumnWidth(5, 80)   # Status
        self.log_table.setColumnWidth(6, 100)  # Duration
        self.log_table.setColumnWidth(7, 200)  # Error
        
        # Enable sorting
        self.log_table.setSortingEnabled(True)
        
        # Row selection
        self.log_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.log_table.itemSelectionChanged.connect(self.on_selection_changed)
        
    def open_log_file(self):
        """Open a log file"""
        log_dir = Path.home() / ".excel_macro_automation" / "execution_logs"
        log_dir.mkdir(parents=True, exist_ok=True)
        
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "실행 로그 파일 선택",
            str(log_dir),
            "CSV Files (*.csv);;All Files (*.*)"
        )
        
        if file_path:
            self.load_log_file(Path(file_path))
            
    def load_log_file(self, file_path: Path):
        """Load CSV log file"""
        self.current_file = file_path
        self.file_label.setText(f"로그 파일: {file_path.name}")
        self.refresh_btn.setEnabled(True)
        
        try:
            self.log_data = []
            
            with open(file_path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    self.log_data.append(row)
                    
            self.apply_filters()
            self.status_label.setText(f"{len(self.log_data)}개 항목 로드됨")
            
            # Update statistics
            self.stats_widget.update_statistics(self.log_data)
            
            # Enable auto-refresh for current session
            if self.is_current_session():
                self.auto_refresh_timer.start(2000)  # Refresh every 2 seconds
            else:
                self.auto_refresh_timer.stop()
                
        except Exception as e:
            QMessageBox.critical(self, "오류", f"로그 파일 로드 실패:\n{str(e)}")
            
    def is_current_session(self) -> bool:
        """Check if loaded file is from current session"""
        if not hasattr(self, 'current_file'):
            return False
            
        # Check if file was modified recently (within last minute)
        try:
            mtime = os.path.getmtime(self.current_file)
            age = datetime.now().timestamp() - mtime
            return age < 60  # Less than 1 minute old
        except:
            return False
            
    def refresh_current_file(self):
        """Refresh current log file"""
        if hasattr(self, 'current_file'):
            self.load_log_file(self.current_file)
            
    def apply_filters(self):
        """Apply filters to log data"""
        # Get filter criteria
        status_filter = self.status_filter.currentText()
        search_text = self.search_edit.text().lower()
        
        # Filter data
        self.filtered_data = []
        
        for entry in self.log_data:
            # Status filter
            if status_filter != "전체":
                if status_filter == "성공" and entry['status'] != 'SUCCESS':
                    continue
                elif status_filter == "실패" and entry['status'] != 'FAILED':
                    continue
                elif status_filter == "오류" and entry['status'] != 'ERROR':
                    continue
                    
            # Search filter
            if search_text:
                found = False
                for value in entry.values():
                    if search_text in str(value).lower():
                        found = True
                        break
                if not found:
                    continue
                    
            self.filtered_data.append(entry)
            
        # Update table
        self.update_table()
        
    def update_table(self):
        """Update table with filtered data"""
        self.log_table.setRowCount(len(self.filtered_data))
        
        for i, entry in enumerate(self.filtered_data):
            # Timestamp
            timestamp = entry.get('timestamp', '')
            if timestamp:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    timestamp = dt.strftime('%Y-%m-%d %H:%M:%S')
                except:
                    pass
            self.log_table.setItem(i, 0, QTableWidgetItem(timestamp))
            
            # Elapsed time in seconds
            elapsed_ms = entry.get('elapsed_ms', '')
            if elapsed_ms:
                try:
                    elapsed_sec = float(elapsed_ms) / 1000
                    elapsed_str = f"{elapsed_sec:.1f}"
                except:
                    elapsed_str = elapsed_ms
            else:
                elapsed_str = ""
            self.log_table.setItem(i, 1, QTableWidgetItem(elapsed_str))
            
            # Row index (1-based for display)
            row_idx = entry.get('row_index', '')
            if row_idx and row_idx != '-1':
                try:
                    row_display = str(int(row_idx) + 1)
                except:
                    row_display = row_idx
            else:
                row_display = ""
            self.log_table.setItem(i, 2, QTableWidgetItem(row_display))
            
            # Step name
            self.log_table.setItem(i, 3, QTableWidgetItem(entry.get('step_name', '')))
            
            # Step type
            self.log_table.setItem(i, 4, QTableWidgetItem(entry.get('step_type', '')))
            
            # Status with color
            status = entry.get('status', '')
            status_item = QTableWidgetItem(status)
            if status == 'SUCCESS':
                status_item.setForeground(QColor(0, 128, 0))
            elif status in ['FAILED', 'ERROR']:
                status_item.setForeground(QColor(255, 0, 0))
            self.log_table.setItem(i, 5, status_item)
            
            # Duration
            self.log_table.setItem(i, 6, QTableWidgetItem(entry.get('duration_ms', '')))
            
            # Error message
            self.log_table.setItem(i, 7, QTableWidgetItem(entry.get('error_message', '')))
            
            # Details
            self.log_table.setItem(i, 8, QTableWidgetItem(entry.get('details', '')))
            
        self.status_label.setText(f"{len(self.filtered_data)}개 항목 표시 중")
        
    def on_selection_changed(self):
        """Handle row selection"""
        # Could show more details in a separate panel
        pass
        
    def export_filtered_data(self):
        """Export filtered data to CSV"""
        if not self.filtered_data:
            QMessageBox.information(self, "내보내기", "내보낼 데이터가 없습니다.")
            return
            
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "로그 내보내기",
            f"filtered_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            "CSV Files (*.csv);;All Files (*.*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', newline='', encoding='utf-8') as f:
                    if self.filtered_data:
                        writer = csv.DictWriter(f, fieldnames=self.filtered_data[0].keys())
                        writer.writeheader()
                        writer.writerows(self.filtered_data)
                        
                QMessageBox.information(self, "내보내기 완료", f"로그가 내보내졌습니다:\n{file_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "내보내기 실패", f"로그 내보내기 중 오류:\n{str(e)}")
                
    def closeEvent(self, event):
        """Handle dialog close"""
        self.auto_refresh_timer.stop()
        super().closeEvent(event)
</file>

<file path="src/ui/dialogs/macro_save_dialog.py">
"""
Macro save and load dialogs
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QTextEdit, QRadioButton, QButtonGroup, QPushButton,
    QCheckBox, QSpinBox, QGroupBox, QProgressBar,
    QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from core.macro_types import Macro, MacroStep
from typing import List, Optional


class MacroSaveDialog(QDialog):
    """Dialog for saving macro with options"""
    
    def __init__(self, macro: Macro, parent=None):
        super().__init__(parent)
        self.macro = macro
        self.setWindowTitle("Save Macro")
        self.setModal(True)
        self.resize(400, 300)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Macro name
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("Name:"))
        self.name_edit = QLineEdit(self.macro.name)
        name_layout.addWidget(self.name_edit)
        layout.addLayout(name_layout)
        
        # Description
        layout.addWidget(QLabel("Description:"))
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.macro.description)
        self.desc_edit.setMaximumHeight(80)
        layout.addWidget(self.desc_edit)
        
        # Format selection
        format_group = QGroupBox("File Format")
        format_layout = QVBoxLayout()
        
        self.format_group = QButtonGroup()
        self.json_radio = QRadioButton("JSON (Human readable)")
        self.json_radio.setChecked(True)
        self.encrypted_radio = QRadioButton("Encrypted (Secure)")
        
        self.format_group.addButton(self.json_radio, 0)
        self.format_group.addButton(self.encrypted_radio, 1)
        
        format_layout.addWidget(self.json_radio)
        format_layout.addWidget(self.encrypted_radio)
        format_group.setLayout(format_layout)
        layout.addWidget(format_group)
        
        # Options
        options_group = QGroupBox("Options")
        options_layout = QVBoxLayout()
        
        self.include_vars_cb = QCheckBox("Include variables")
        self.include_vars_cb.setChecked(True)
        options_layout.addWidget(self.include_vars_cb)
        
        self.compress_cb = QCheckBox("Compress file")
        self.compress_cb.setChecked(False)
        options_layout.addWidget(self.compress_cb)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        save_btn.setDefault(True)
        btn_layout.addWidget(save_btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        
    def get_options(self) -> dict:
        """Get save options"""
        return {
            'name': self.name_edit.text(),
            'description': self.desc_edit.toPlainText(),
            'format': 'encrypted' if self.encrypted_radio.isChecked() else 'json',
            'include_variables': self.include_vars_cb.isChecked(),
            'compress': self.compress_cb.isChecked()
        }


class PartialMacroExportDialog(QDialog):
    """Dialog for exporting selected macro steps"""
    
    def __init__(self, selected_steps: List[MacroStep], all_variables: dict, parent=None):
        super().__init__(parent)
        self.selected_steps = selected_steps
        self.all_variables = all_variables
        self.setWindowTitle("Export Macro Steps")
        self.setModal(True)
        self.resize(450, 400)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Info
        info_label = QLabel(f"Exporting {len(self.selected_steps)} selected steps")
        info_label.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(info_label)
        
        # Name
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("Export Name:"))
        self.name_edit = QLineEdit("Partial Macro Export")
        name_layout.addWidget(self.name_edit)
        layout.addLayout(name_layout)
        
        # Description
        layout.addWidget(QLabel("Description:"))
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText("Exported macro steps")
        self.desc_edit.setMaximumHeight(60)
        layout.addWidget(self.desc_edit)
        
        # Variable dependencies
        var_group = QGroupBox("Variable Dependencies")
        var_layout = QVBoxLayout()
        
        # Check which variables are used
        used_vars = self._check_variable_usage()
        
        if used_vars:
            var_label = QLabel(f"The following variables are used in selected steps:")
            var_layout.addWidget(var_label)
            
            for var_name in used_vars:
                cb = QCheckBox(f"Include '{var_name}'")
                cb.setChecked(True)
                cb.setObjectName(var_name)
                var_layout.addWidget(cb)
        else:
            var_label = QLabel("No variables are used in selected steps")
            var_layout.addWidget(var_label)
            
        var_group.setLayout(var_layout)
        layout.addWidget(var_group)
        
        # Format
        format_group = QGroupBox("Export Format")
        format_layout = QVBoxLayout()
        
        self.format_group = QButtonGroup()
        self.json_radio = QRadioButton("JSON (Human readable)")
        self.json_radio.setChecked(True)
        self.encrypted_radio = QRadioButton("Encrypted (Secure)")
        
        self.format_group.addButton(self.json_radio, 0)
        self.format_group.addButton(self.encrypted_radio, 1)
        
        format_layout.addWidget(self.json_radio)
        format_layout.addWidget(self.encrypted_radio)
        format_group.setLayout(format_layout)
        layout.addWidget(format_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        export_btn = QPushButton("Export")
        export_btn.clicked.connect(self.accept)
        export_btn.setDefault(True)
        btn_layout.addWidget(export_btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        
    def _check_variable_usage(self) -> List[str]:
        """Check which variables are used in selected steps"""
        used_vars = set()
        
        for step in self.selected_steps:
            # Check various step properties for variable usage
            step_dict = step.to_dict()
            self._find_variables_in_dict(step_dict, used_vars)
            
        return sorted(list(used_vars))
        
    def _find_variables_in_dict(self, d: dict, used_vars: set):
        """Recursively find variable references in dictionary"""
        for key, value in d.items():
            if isinstance(value, str) and value.startswith('${') and value.endswith('}'):
                var_name = value[2:-1]
                if var_name in self.all_variables:
                    used_vars.add(var_name)
            elif isinstance(value, dict):
                self._find_variables_in_dict(value, used_vars)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, dict):
                        self._find_variables_in_dict(item, used_vars)
                        
    def get_export_data(self) -> dict:
        """Get export data"""
        # Collect selected variables
        selected_vars = {}
        var_group = self.findChild(QGroupBox, "Variable Dependencies")
        if var_group:
            for cb in var_group.findChildren(QCheckBox):
                if cb.isChecked():
                    var_name = cb.objectName()
                    if var_name in self.all_variables:
                        selected_vars[var_name] = self.all_variables[var_name]
                        
        return {
            'name': self.name_edit.text(),
            'description': self.desc_edit.toPlainText(),
            'format': 'encrypted' if self.encrypted_radio.isChecked() else 'json',
            'steps': self.selected_steps,
            'variables': selected_vars
        }


class MacroLoadProgressDialog(QDialog):
    """Progress dialog for loading macros"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Loading Macro")
        self.setModal(True)
        self.setFixedSize(300, 100)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        self.label = QLabel("Loading macro file...")
        layout.addWidget(self.label)
        
        self.progress = QProgressBar()
        self.progress.setRange(0, 0)  # Indeterminate
        layout.addWidget(self.progress)
        
        self.setLayout(layout)
        
    def set_message(self, message: str):
        """Set progress message"""
        self.label.setText(message)
</file>

<file path="src/ui/dialogs/mouse_click_step_dialog.py">
"""
Mouse click step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QComboBox, QDialogButtonBox,
    QFormLayout, QGroupBox, QCheckBox, QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QCursor
import pyautogui
from core.macro_types import MouseClickStep, MouseButton
from ui.widgets.roi_selector import ROISelectorWidget
from utils.monitor_utils import get_monitor_name_for_position, get_monitor_info


class MouseClickStepDialog(QDialog):
    """Dialog for configuring mouse click step"""
    
    def __init__(self, step: MouseClickStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("마우스 클릭 설정")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("단계 이름:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Position group
        position_group = QGroupBox("클릭 위치")
        position_layout = QVBoxLayout()
        
        # Position inputs
        coord_layout = QHBoxLayout()
        coord_layout.addWidget(QLabel("X:"))
        self.x_spin = QSpinBox()
        self.x_spin.setRange(-9999, 9999)  # 음수 좌표 허용 (듀얼 모니터)
        coord_layout.addWidget(self.x_spin)
        
        coord_layout.addWidget(QLabel("Y:"))
        self.y_spin = QSpinBox()
        self.y_spin.setRange(-9999, 9999)  # 음수 좌표 허용 (듀얼 모니터)
        coord_layout.addWidget(self.y_spin)
        
        coord_layout.addStretch()
        position_layout.addLayout(coord_layout)
        
        # Capture button
        self.capture_button = QPushButton("현재 마우스 위치 캡처 (F3)")
        self.capture_button.clicked.connect(self.capture_position)
        position_layout.addWidget(self.capture_button)
        
        # Set up F3 shortcut
        from PyQt5.QtWidgets import QShortcut
        from PyQt5.QtGui import QKeySequence
        self.capture_shortcut = QShortcut(QKeySequence("F3"), self)
        self.capture_shortcut.activated.connect(self.capture_position)
        
        # Select area button
        self.select_area_button = QPushButton("화면에서 선택...")
        self.select_area_button.clicked.connect(self.select_from_screen)
        position_layout.addWidget(self.select_area_button)
        
        position_group.setLayout(position_layout)
        layout.addWidget(position_group)
        
        # Help text for F3
        help_label = QLabel("💡 팁: F3 키를 누르면 현재 마우스 위치를 즉시 캡처합니다.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        layout.addWidget(help_label)
        
        # Monitor info
        self.add_monitor_info(layout)
        
        # Click options
        options_group = QGroupBox("클릭 옵션")
        options_layout = QFormLayout()
        
        # Button selection
        self.button_combo = QComboBox()
        self.button_combo.addItems(["왼쪽 버튼", "오른쪽 버튼", "가운데 버튼"])
        options_layout.addRow("마우스 버튼:", self.button_combo)
        
        # Click count
        self.clicks_spin = QSpinBox()
        self.clicks_spin.setRange(1, 10)
        self.clicks_spin.setValue(1)
        options_layout.addRow("클릭 횟수:", self.clicks_spin)
        
        # Interval
        self.interval_spin = QSpinBox()
        self.interval_spin.setRange(0, 5000)
        self.interval_spin.setSuffix(" ms")
        self.interval_spin.setValue(0)
        options_layout.addRow("클릭 간격:", self.interval_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def add_monitor_info(self, parent_layout):
        """Add monitor information display"""
        monitors = get_monitor_info()
        
        if len(monitors) > 1:
            monitor_group = QGroupBox("모니터 정보")
            monitor_layout = QVBoxLayout()
            
            info_text = f"감지된 모니터: {len(monitors)}개\n"
            for i, monitor in enumerate(monitors):
                name = "주 모니터" if monitor['is_primary'] else f"모니터 {i+1}"
                info_text += f"• {name}: {monitor['width']}x{monitor['height']} (위치: {monitor['x']}, {monitor['y']})\n"
            
            monitor_label = QLabel(info_text.strip())
            monitor_label.setStyleSheet("color: #666; font-size: 11px;")
            monitor_layout.addWidget(monitor_label)
            
            monitor_group.setLayout(monitor_layout)
            parent_layout.addWidget(monitor_group)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.x_spin.setValue(self.step.x)
        self.y_spin.setValue(self.step.y)
        
        # Set button
        button_map = {
            MouseButton.LEFT: 0,
            MouseButton.RIGHT: 1,
            MouseButton.MIDDLE: 2
        }
        self.button_combo.setCurrentIndex(button_map.get(self.step.button, 0))
        
        self.clicks_spin.setValue(self.step.clicks)
        self.interval_spin.setValue(int(self.step.interval * 1000))
        
    def capture_position(self):
        """Capture current mouse position"""
        # Capture immediately when F3 is pressed
        x, y = pyautogui.position()
        self.x_spin.setValue(x)
        self.y_spin.setValue(y)
        
        # Get monitor name for the position
        monitor_name = get_monitor_name_for_position(x, y)
        
        # Flash the button to indicate capture with monitor info
        self.capture_button.setText(f"캡처됨! ({monitor_name}: {x}, {y})")
        QTimer.singleShot(1500, lambda: self.capture_button.setText("현재 마우스 위치 캡처 (F3)"))
        
        
    def select_from_screen(self):
        """Select position from screen"""
        self.hide()
        
        selector = ROISelectorWidget()
        # For now, just use capture position
        # TODO: Implement proper screen selection
        self.capture_position()
        return
        
        self.show()
        
        if result:
            x, y = result
            self.x_spin.setValue(x)
            self.y_spin.setValue(y)
            
    def get_step_data(self):
        """Get configured step data"""
        # Map combo index to button
        button_map = {
            0: MouseButton.LEFT,
            1: MouseButton.RIGHT,
            2: MouseButton.MIDDLE
        }
        
        return {
            'name': self.name_edit.text(),
            'x': self.x_spin.value(),
            'y': self.y_spin.value(),
            'button': button_map[self.button_combo.currentIndex()],
            'clicks': self.clicks_spin.value(),
            'interval': self.interval_spin.value() / 1000.0
        }
</file>

<file path="src/ui/dialogs/mouse_move_step_dialog.py">
"""
Mouse move step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QDoubleSpinBox, QDialogButtonBox,
    QFormLayout, QGroupBox, QMessageBox
)
from PyQt5.QtCore import Qt, QTimer
import pyautogui
from core.macro_types import MouseMoveStep
from ui.widgets.roi_selector import ROISelectorWidget
from utils.monitor_utils import get_monitor_name_for_position, get_monitor_info


class MouseMoveStepDialog(QDialog):
    """Dialog for configuring mouse move step"""
    
    def __init__(self, step: MouseMoveStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("마우스 이동 설정")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("단계 이름:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Position group
        position_group = QGroupBox("이동 위치")
        position_layout = QVBoxLayout()
        
        # Position inputs
        coord_layout = QHBoxLayout()
        coord_layout.addWidget(QLabel("X:"))
        self.x_spin = QSpinBox()
        self.x_spin.setRange(-9999, 9999)  # 음수 좌표 허용 (듀얼 모니터)
        coord_layout.addWidget(self.x_spin)
        
        coord_layout.addWidget(QLabel("Y:"))
        self.y_spin = QSpinBox()
        self.y_spin.setRange(-9999, 9999)  # 음수 좌표 허용 (듀얼 모니터)
        coord_layout.addWidget(self.y_spin)
        
        coord_layout.addStretch()
        position_layout.addLayout(coord_layout)
        
        # Capture button
        self.capture_button = QPushButton("현재 마우스 위치 캡처 (F3)")
        self.capture_button.clicked.connect(self.capture_position)
        position_layout.addWidget(self.capture_button)
        
        # Set up F3 shortcut
        from PyQt5.QtWidgets import QShortcut
        from PyQt5.QtGui import QKeySequence
        self.capture_shortcut = QShortcut(QKeySequence("F3"), self)
        self.capture_shortcut.activated.connect(self.capture_position)
        
        # Select area button
        self.select_area_button = QPushButton("화면에서 선택...")
        self.select_area_button.clicked.connect(self.select_from_screen)
        position_layout.addWidget(self.select_area_button)
        
        position_group.setLayout(position_layout)
        layout.addWidget(position_group)
        
        # Help text for F3
        help_label = QLabel("💡 팁: F3 키를 누르면 현재 마우스 위치를 즉시 캡처합니다.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        layout.addWidget(help_label)
        
        # Monitor info
        self.add_monitor_info(layout)
        
        # Move options
        options_group = QGroupBox("이동 옵션")
        options_layout = QFormLayout()
        
        # Duration
        self.duration_spin = QDoubleSpinBox()
        self.duration_spin.setRange(0, 10.0)
        self.duration_spin.setSingleStep(0.1)
        self.duration_spin.setDecimals(1)
        self.duration_spin.setSuffix(" 초")
        self.duration_spin.setValue(0.0)
        options_layout.addRow("이동 시간:", self.duration_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Help text
        help_label = QLabel("이동 시간을 0으로 설정하면 즉시 이동합니다.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-size: 12px;")
        layout.addWidget(help_label)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def add_monitor_info(self, parent_layout):
        """Add monitor information display"""
        monitors = get_monitor_info()
        
        if len(monitors) > 1:
            monitor_group = QGroupBox("모니터 정보")
            monitor_layout = QVBoxLayout()
            
            info_text = f"감지된 모니터: {len(monitors)}개\n"
            for i, monitor in enumerate(monitors):
                name = "주 모니터" if monitor['is_primary'] else f"모니터 {i+1}"
                info_text += f"• {name}: {monitor['width']}x{monitor['height']} (위치: {monitor['x']}, {monitor['y']})\n"
            
            monitor_label = QLabel(info_text.strip())
            monitor_label.setStyleSheet("color: #666; font-size: 11px;")
            monitor_layout.addWidget(monitor_label)
            
            monitor_group.setLayout(monitor_layout)
            parent_layout.addWidget(monitor_group)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.x_spin.setValue(self.step.x)
        self.y_spin.setValue(self.step.y)
        self.duration_spin.setValue(self.step.duration)
        
    def capture_position(self):
        """Capture current mouse position"""
        # Capture immediately when F3 is pressed
        x, y = pyautogui.position()
        self.x_spin.setValue(x)
        self.y_spin.setValue(y)
        
        # Get monitor name for the position
        monitor_name = get_monitor_name_for_position(x, y)
        
        # Flash the button to indicate capture with monitor info
        self.capture_button.setText(f"캡처됨! ({monitor_name}: {x}, {y})")
        QTimer.singleShot(1500, lambda: self.capture_button.setText("현재 마우스 위치 캡처 (F3)"))
        
        
    def select_from_screen(self):
        """Select position from screen"""
        self.hide()
        
        selector = ROISelectorWidget()
        # For now, just use capture position
        # TODO: Implement proper screen selection
        self.capture_position()
        return
        
        self.show()
        
        if result:
            x, y = result
            self.x_spin.setValue(x)
            self.y_spin.setValue(y)
            
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'x': self.x_spin.value(),
            'y': self.y_spin.value(),
            'duration': self.duration_spin.value()
        }
</file>

<file path="src/ui/dialogs/screenshot_step_dialog.py">
"""
Screenshot step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QComboBox, QCheckBox, QFileDialog, QMessageBox
)
from PyQt5.QtCore import Qt
from core.macro_types import ScreenshotStep
import os
from datetime import datetime


class ScreenshotStepDialog(QDialog):
    """Dialog for configuring screenshot step"""
    
    def __init__(self, step: ScreenshotStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("화면 캡처 설정")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("단계 이름:", self.name_edit)
        layout.addLayout(name_layout)
        
        # File settings group
        file_group = QGroupBox("파일 설정")
        file_layout = QVBoxLayout()
        
        # Filename pattern
        pattern_layout = QHBoxLayout()
        pattern_layout.addWidget(QLabel("파일명 패턴:"))
        self.filename_edit = QLineEdit()
        self.filename_edit.setPlaceholderText("예: screenshot_{timestamp}.png")
        pattern_layout.addWidget(self.filename_edit)
        file_layout.addLayout(pattern_layout)
        
        # Help text for filename patterns
        help_text = QLabel(
            "사용 가능한 변수:\n"
            "• {timestamp} - 현재 시간 (YYYYMMDD_HHMMSS)\n"
            "• {date} - 현재 날짜 (YYYYMMDD)\n"
            "• {time} - 현재 시간 (HHMMSS)\n"
            "• {index} - 순번 (자동 증가)"
        )
        help_text.setWordWrap(True)
        help_text.setStyleSheet("color: #666; font-size: 11px; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        file_layout.addWidget(help_text)
        
        # Save directory
        dir_layout = QHBoxLayout()
        dir_layout.addWidget(QLabel("저장 경로:"))
        self.directory_edit = QLineEdit()
        self.directory_edit.setPlaceholderText("기본: ./screenshots/")
        dir_layout.addWidget(self.directory_edit)
        
        self.browse_btn = QPushButton("찾아보기...")
        self.browse_btn.clicked.connect(self.browse_directory)
        dir_layout.addWidget(self.browse_btn)
        file_layout.addLayout(dir_layout)
        
        file_group.setLayout(file_layout)
        layout.addWidget(file_group)
        
        # Capture options group
        options_group = QGroupBox("캡처 옵션")
        options_layout = QVBoxLayout()
        
        # Full screen or region
        self.full_screen_checkbox = QCheckBox("전체 화면 캡처")
        self.full_screen_checkbox.setChecked(True)
        self.full_screen_checkbox.toggled.connect(self.on_full_screen_toggled)
        options_layout.addWidget(self.full_screen_checkbox)
        
        # Region settings (disabled by default)
        region_layout = QHBoxLayout()
        region_layout.addWidget(QLabel("영역:"))
        
        self.x_edit = QLineEdit("0")
        self.x_edit.setMaximumWidth(80)
        self.x_edit.setEnabled(False)
        region_layout.addWidget(QLabel("X:"))
        region_layout.addWidget(self.x_edit)
        
        self.y_edit = QLineEdit("0")
        self.y_edit.setMaximumWidth(80)
        self.y_edit.setEnabled(False)
        region_layout.addWidget(QLabel("Y:"))
        region_layout.addWidget(self.y_edit)
        
        self.width_edit = QLineEdit("0")
        self.width_edit.setMaximumWidth(80)
        self.width_edit.setEnabled(False)
        region_layout.addWidget(QLabel("너비:"))
        region_layout.addWidget(self.width_edit)
        
        self.height_edit = QLineEdit("0")
        self.height_edit.setMaximumWidth(80)
        self.height_edit.setEnabled(False)
        region_layout.addWidget(QLabel("높이:"))
        region_layout.addWidget(self.height_edit)
        
        region_layout.addStretch()
        options_layout.addLayout(region_layout)
        
        # Select region button
        self.select_region_btn = QPushButton("화면에서 영역 선택...")
        self.select_region_btn.setEnabled(False)
        self.select_region_btn.clicked.connect(self.select_region)
        options_layout.addWidget(self.select_region_btn)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.filename_edit.setText(self.step.filename_pattern)
        self.directory_edit.setText(self.step.save_directory)
        
        if self.step.region:
            self.full_screen_checkbox.setChecked(False)
            x, y, width, height = self.step.region
            self.x_edit.setText(str(x))
            self.y_edit.setText(str(y))
            self.width_edit.setText(str(width))
            self.height_edit.setText(str(height))
        else:
            self.full_screen_checkbox.setChecked(True)
            
    def on_full_screen_toggled(self, checked):
        """Handle full screen checkbox toggle"""
        self.x_edit.setEnabled(not checked)
        self.y_edit.setEnabled(not checked)
        self.width_edit.setEnabled(not checked)
        self.height_edit.setEnabled(not checked)
        self.select_region_btn.setEnabled(not checked)
        
    def browse_directory(self):
        """Browse for save directory"""
        directory = QFileDialog.getExistingDirectory(
            self,
            "저장 경로 선택",
            self.directory_edit.text() or "./screenshots/"
        )
        if directory:
            self.directory_edit.setText(directory)
            
    def select_region(self):
        """Select region from screen"""
        # TODO: Implement screen region selection
        # For now, just show a message
        QMessageBox.information(
            self,
            "기능 구현 예정",
            "화면 영역 선택 기능은 추후 구현 예정입니다.\n수동으로 좌표를 입력해주세요."
        )
        
    def validate_and_accept(self):
        """Validate input and accept"""
        # Default filename if empty
        if not self.filename_edit.text():
            self.filename_edit.setText("screenshot_{timestamp}.png")
            
        # Default directory if empty
        if not self.directory_edit.text():
            self.directory_edit.setText("./screenshots/")
            
        # Validate region if not full screen
        if not self.full_screen_checkbox.isChecked():
            try:
                x = int(self.x_edit.text())
                y = int(self.y_edit.text())
                width = int(self.width_edit.text())
                height = int(self.height_edit.text())
                
                if width <= 0 or height <= 0:
                    raise ValueError("너비와 높이는 0보다 커야 합니다")
                    
            except ValueError as e:
                QMessageBox.warning(
                    self, "경고",
                    f"잘못된 영역 설정: {str(e)}"
                )
                return
                
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        region = None
        if not self.full_screen_checkbox.isChecked():
            region = (
                int(self.x_edit.text()),
                int(self.y_edit.text()),
                int(self.width_edit.text()),
                int(self.height_edit.text())
            )
            
        return {
            'name': self.name_edit.text() or "화면 캡처",
            'filename_pattern': self.filename_edit.text() or "screenshot_{timestamp}.png",
            'save_directory': self.directory_edit.text() or "./screenshots/",
            'region': region
        }
</file>

<file path="src/ui/dialogs/wait_time_step_dialog.py">
"""
Wait time step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, 
    QDoubleSpinBox, QDialogButtonBox, QFormLayout
)
from PyQt5.QtCore import Qt
from core.macro_types import WaitTimeStep


class WaitTimeStepDialog(QDialog):
    """Dialog for configuring wait time step"""
    
    def __init__(self, step: WaitTimeStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("대기 시간 설정")
        self.setModal(True)
        self.setFixedWidth(300)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Form layout
        form_layout = QFormLayout()
        
        # Step name
        self.name_edit = QLineEdit()
        form_layout.addRow("단계 이름:", self.name_edit)
        
        # Wait time
        self.seconds_spin = QDoubleSpinBox()
        self.seconds_spin.setRange(0.1, 3600.0)
        self.seconds_spin.setSingleStep(0.5)
        self.seconds_spin.setDecimals(1)
        self.seconds_spin.setSuffix(" 초")
        self.seconds_spin.setValue(1.0)
        form_layout.addRow("대기 시간:", self.seconds_spin)
        
        layout.addLayout(form_layout)
        
        # Help text
        help_label = QLabel("지정된 시간 동안 실행을 일시 정지합니다.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-size: 12px;")
        layout.addWidget(help_label)
        
        layout.addStretch()
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.seconds_spin.setValue(self.step.seconds)
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'seconds': self.seconds_spin.value()
        }
</file>

<file path="src/ui/widgets/__init__.py">
# UI Widgets
</file>

<file path="src/ui/widgets/data_preview.py">
"""
Excel data preview widget with pagination
"""

from typing import Optional, List
import pandas as pd
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, 
    QTableWidgetItem, QPushButton, QLabel, QSpinBox,
    QComboBox, QLineEdit, QCheckBox, QHeaderView,
    QGroupBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QColor, QBrush
from excel.models import ExcelData, ColumnType

class DataPreviewTable(QTableWidget):
    """Table widget for previewing Excel data"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Configure table appearance
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QTableWidget.SelectRows)
        self.horizontalHeader().setStretchLastSection(True)
        self.verticalHeader().setDefaultSectionSize(24)
        
    def load_data(self, dataframe: pd.DataFrame, start_row: int = 0, 
                  rows_per_page: int = 100, highlight_status: bool = True):
        """Load data into table"""
        # Clear existing data
        self.clear()
        
        # Set columns
        columns = dataframe.columns.tolist()
        self.setColumnCount(len(columns))
        self.setHorizontalHeaderLabels(columns)
        
        # Determine rows to display
        end_row = min(start_row + rows_per_page, len(dataframe))
        display_rows = end_row - start_row
        self.setRowCount(display_rows)
        
        # Find status column
        status_col_idx = None
        if highlight_status:
            status_columns = ['상태', 'Status', '완료여부', '처리상태', 'status', 'STATUS']
            for idx, col in enumerate(columns):
                if col in status_columns:
                    status_col_idx = idx
                    break
        
        # Populate data
        for row in range(display_rows):
            df_row = start_row + row
            
            # Set row header to show actual row number
            self.setVerticalHeaderItem(row, QTableWidgetItem(str(df_row + 1)))
            
            for col in range(len(columns)):
                value = dataframe.iloc[df_row, col]
                
                # Handle different data types
                if pd.isna(value):
                    item_text = ""
                elif isinstance(value, float):
                    item_text = f"{value:.2f}" if value % 1 else str(int(value))
                else:
                    item_text = str(value)
                
                item = QTableWidgetItem(item_text)
                
                # Apply status highlighting
                if col == status_col_idx and highlight_status:
                    if value in ['완료', 'Completed', 'Complete', 'Done']:
                        item.setBackground(QBrush(QColor(200, 255, 200)))
                    elif value in ['실패', 'Failed', 'Error']:
                        item.setBackground(QBrush(QColor(255, 200, 200)))
                    elif value in ['진행중', 'Processing', 'In Progress']:
                        item.setBackground(QBrush(QColor(255, 255, 200)))
                
                self.setItem(row, col, item)
        
        # Resize columns to content
        self.resizeColumnsToContents()

class DataPreviewWidget(QWidget):
    """Complete data preview widget with controls"""
    
    rowSelected = pyqtSignal(int)  # Emit actual dataframe row index
    
    def __init__(self):
        super().__init__()
        self.excel_data: Optional[ExcelData] = None
        self.current_page = 0
        self.rows_per_page = 100
        self.filtered_indices: Optional[List[int]] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Filter controls
        filter_group = QGroupBox("필터 옵션")
        filter_layout = QHBoxLayout()
        
        # Status filter
        self.incomplete_only = QCheckBox("미완료 항목만 표시")
        self.incomplete_only.stateChanged.connect(self._apply_filter)
        filter_layout.addWidget(self.incomplete_only)
        
        # Search
        filter_layout.addWidget(QLabel("검색:"))
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("검색어 입력...")
        self.search_input.textChanged.connect(self._apply_filter)
        filter_layout.addWidget(self.search_input)
        
        filter_layout.addStretch()
        filter_group.setLayout(filter_layout)
        layout.addWidget(filter_group)
        
        # Data table
        self.data_table = DataPreviewTable()
        self.data_table.cellDoubleClicked.connect(self._on_cell_double_clicked)
        layout.addWidget(self.data_table)
        
        # Pagination controls
        pagination_layout = QHBoxLayout()
        
        # Page size
        pagination_layout.addWidget(QLabel("행/페이지:"))
        self.page_size_spin = QSpinBox()
        self.page_size_spin.setRange(10, 1000)
        self.page_size_spin.setSingleStep(50)
        self.page_size_spin.setValue(self.rows_per_page)
        self.page_size_spin.valueChanged.connect(self._on_page_size_changed)
        pagination_layout.addWidget(self.page_size_spin)
        
        pagination_layout.addStretch()
        
        # Page navigation
        self.prev_btn = QPushButton("◀ 이전")
        self.prev_btn.clicked.connect(self._prev_page)
        pagination_layout.addWidget(self.prev_btn)
        
        self.page_label = QLabel("1 / 1")
        pagination_layout.addWidget(self.page_label)
        
        self.next_btn = QPushButton("다음 ▶")
        self.next_btn.clicked.connect(self._next_page)
        pagination_layout.addWidget(self.next_btn)
        
        pagination_layout.addStretch()
        
        # Row count info
        self.row_info_label = QLabel()
        pagination_layout.addWidget(self.row_info_label)
        
        layout.addLayout(pagination_layout)
        self.setLayout(layout)
        
    def load_excel_data(self, excel_data: ExcelData):
        """Load Excel data for preview"""
        self.excel_data = excel_data
        self.current_page = 0
        self.filtered_indices = None
        self._apply_filter()
        
    def _apply_filter(self):
        """Apply current filter settings"""
        if not self.excel_data:
            return
            
        df = self.excel_data.dataframe
        
        # Start with all rows
        mask = pd.Series([True] * len(df))
        
        # Apply incomplete filter
        if self.incomplete_only.isChecked():
            status_col = self.excel_data.get_status_column()
            if status_col:
                mask &= ~df[status_col].isin(['완료', 'Completed', 'Complete', 'Done'])
        
        # Apply search filter
        search_text = self.search_input.text().strip()
        if search_text:
            search_mask = pd.Series([False] * len(df))
            for col in df.columns:
                if df[col].dtype == 'object':  # String columns only
                    search_mask |= df[col].astype(str).str.contains(
                        search_text, case=False, na=False
                    )
            mask &= search_mask
        
        # Get filtered indices
        self.filtered_indices = df[mask].index.tolist()
        
        # Reset to first page
        self.current_page = 0
        self._update_display()
        
    def _update_display(self):
        """Update table display"""
        if not self.excel_data:
            return
            
        df = self.excel_data.dataframe
        
        # Use filtered data if available
        if self.filtered_indices is not None:
            if not self.filtered_indices:
                self.data_table.setRowCount(0)
                self._update_pagination_controls()
                return
            display_df = df.loc[self.filtered_indices]
        else:
            display_df = df
        
        # Calculate page boundaries
        start_idx = self.current_page * self.rows_per_page
        
        # Load data into table
        self.data_table.load_data(
            display_df,
            start_row=start_idx,
            rows_per_page=self.rows_per_page
        )
        
        self._update_pagination_controls()
        
    def _update_pagination_controls(self):
        """Update pagination control states"""
        if not self.excel_data:
            return
            
        # Calculate total pages
        if self.filtered_indices is not None:
            total_rows = len(self.filtered_indices)
        else:
            total_rows = len(self.excel_data.dataframe)
            
        total_pages = max(1, (total_rows + self.rows_per_page - 1) // self.rows_per_page)
        
        # Update label
        self.page_label.setText(f"{self.current_page + 1} / {total_pages}")
        
        # Update button states
        self.prev_btn.setEnabled(self.current_page > 0)
        self.next_btn.setEnabled(self.current_page < total_pages - 1)
        
        # Update row info
        if self.filtered_indices is not None:
            self.row_info_label.setText(
                f"표시: {len(self.filtered_indices)} / 전체: {len(self.excel_data.dataframe)} 행"
            )
        else:
            self.row_info_label.setText(f"전체: {total_rows} 행")
        
    def _on_page_size_changed(self, value: int):
        """Handle page size change"""
        self.rows_per_page = value
        self.current_page = 0
        self._update_display()
        
    def _prev_page(self):
        """Go to previous page"""
        if self.current_page > 0:
            self.current_page -= 1
            self._update_display()
            
    def _next_page(self):
        """Go to next page"""
        self.current_page += 1
        self._update_display()
        
    def _on_cell_double_clicked(self, row: int, column: int):
        """Handle cell double click"""
        # Calculate actual dataframe row index
        actual_row = self.current_page * self.rows_per_page + row
        
        if self.filtered_indices is not None:
            if actual_row < len(self.filtered_indices):
                df_row_index = self.filtered_indices[actual_row]
                self.rowSelected.emit(df_row_index)
        else:
            self.rowSelected.emit(actual_row)
</file>

<file path="src/ui/widgets/file_selector.py">
"""
Excel file selection widget with drag-drop support
"""

import os
from pathlib import Path
from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
    QLabel, QListWidget, QListWidgetItem, QFileDialog,
    QGroupBox, QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QMimeData
from PyQt5.QtGui import QDragEnterEvent, QDropEvent, QIcon

class FileDropArea(QLabel):
    """Drag and drop area for Excel files"""
    
    fileDropped = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setAcceptDrops(True)
        self.setAlignment(Qt.AlignCenter)
        self.setStyleSheet("""
            QLabel {
                border: 2px dashed #aaa;
                border-radius: 5px;
                padding: 20px;
                background-color: #f5f5f5;
                min-height: 100px;
            }
            QLabel:hover {
                border-color: #555;
                background-color: #e8e8e8;
            }
        """)
        self.setText("엑셀 파일을 여기에 드래그하거나\n아래 버튼을 클릭하세요")
        
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event"""
        if event.mimeData().hasUrls():
            # Check if any file is Excel
            for url in event.mimeData().urls():
                if url.isLocalFile():
                    path = url.toLocalFile()
                    if path.lower().endswith(('.xlsx', '.xls', '.xlsm')):
                        event.acceptProposedAction()
                        self.setStyleSheet("""
                            QLabel {
                                border: 2px solid #4CAF50;
                                border-radius: 5px;
                                padding: 20px;
                                background-color: #e8f5e9;
                                min-height: 100px;
                            }
                        """)
                        return
        event.ignore()
        
    def dragLeaveEvent(self, event):
        """Handle drag leave event"""
        self.setStyleSheet("""
            QLabel {
                border: 2px dashed #aaa;
                border-radius: 5px;
                padding: 20px;
                background-color: #f5f5f5;
                min-height: 100px;
            }
        """)
        
    def dropEvent(self, event: QDropEvent):
        """Handle drop event"""
        for url in event.mimeData().urls():
            if url.isLocalFile():
                path = url.toLocalFile()
                if path.lower().endswith(('.xlsx', '.xls', '.xlsm')):
                    self.fileDropped.emit(path)
                    event.acceptProposedAction()
                    self.dragLeaveEvent(None)
                    return

class RecentFilesList(QListWidget):
    """List of recently opened Excel files"""
    
    fileSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setMaximumHeight(150)
        self.itemDoubleClicked.connect(self._on_item_double_clicked)
        
    def add_recent_file(self, file_path: str):
        """Add file to recent files list"""
        # Check if already exists
        for i in range(self.count()):
            if self.item(i).data(Qt.UserRole) == file_path:
                # Move to top
                item = self.takeItem(i)
                self.insertItem(0, item)
                return
        
        # Add new item
        file_name = os.path.basename(file_path)
        item = QListWidgetItem(file_name)
        item.setData(Qt.UserRole, file_path)
        item.setToolTip(file_path)
        self.insertItem(0, item)
        
        # Keep only 10 recent files
        while self.count() > 10:
            self.takeItem(self.count() - 1)
            
    def _on_item_double_clicked(self, item: QListWidgetItem):
        """Handle double click on item"""
        file_path = item.data(Qt.UserRole)
        if file_path and os.path.exists(file_path):
            self.fileSelected.emit(file_path)

class FileSelectorWidget(QWidget):
    """Excel file selection widget"""
    
    fileSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.current_file: Optional[str] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Current file info
        self.file_info_label = QLabel("선택된 파일: 없음")
        self.file_info_label.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(self.file_info_label)
        
        # Drop area
        self.drop_area = FileDropArea()
        self.drop_area.fileDropped.connect(self._on_file_selected)
        layout.addWidget(self.drop_area)
        
        # Browse button
        browse_button = QPushButton("파일 찾아보기...")
        browse_button.clicked.connect(self._browse_file)
        layout.addWidget(browse_button)
        
        # Recent files
        recent_group = QGroupBox("최근 파일")
        recent_layout = QVBoxLayout()
        self.recent_files = RecentFilesList()
        self.recent_files.fileSelected.connect(self._on_file_selected)
        recent_layout.addWidget(self.recent_files)
        recent_group.setLayout(recent_layout)
        layout.addWidget(recent_group)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def _browse_file(self):
        """Open file dialog to select Excel file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "엑셀 파일 선택",
            "",
            "Excel Files (*.xlsx *.xls *.xlsm);;All Files (*.*)"
        )
        
        if file_path:
            self._on_file_selected(file_path)
            
    def _on_file_selected(self, file_path: str):
        """Handle file selection"""
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "파일 오류", f"파일을 찾을 수 없습니다:\n{file_path}")
            return
            
        self.current_file = file_path
        self.file_info_label.setText(f"선택된 파일: {os.path.basename(file_path)}")
        self.recent_files.add_recent_file(file_path)
        self.fileSelected.emit(file_path)
        
    def get_recent_files(self) -> list:
        """Get list of recent files"""
        files = []
        for i in range(self.recent_files.count()):
            item = self.recent_files.item(i)
            files.append(item.data(Qt.UserRole))
        return files
        
    def set_recent_files(self, files: list):
        """Set recent files list"""
        self.recent_files.clear()
        for file_path in files:
            if os.path.exists(file_path):
                self.recent_files.add_recent_file(file_path)
</file>

<file path="src/ui/widgets/sheet_mapper.py">
"""
Sheet and column mapping UI widget
"""

from typing import Dict, List, Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QComboBox, 
    QTableWidget, QTableWidgetItem, QPushButton,
    QLabel, QGroupBox, QHeaderView, QCheckBox,
    QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from excel.models import SheetInfo, ColumnInfo, ColumnMapping, ColumnType

class SheetSelectorWidget(QWidget):
    """Widget for selecting Excel sheet"""
    
    sheetSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.sheets: List[SheetInfo] = []
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        layout.addWidget(QLabel("시트 선택:"))
        
        self.sheet_combo = QComboBox()
        self.sheet_combo.setMinimumWidth(200)
        self.sheet_combo.currentTextChanged.connect(self.sheetSelected.emit)
        layout.addWidget(self.sheet_combo)
        
        self.info_label = QLabel()
        layout.addWidget(self.info_label)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def set_sheets(self, sheets: List[SheetInfo]):
        """Set available sheets"""
        self.sheets = sheets
        self.sheet_combo.clear()
        
        for sheet in sheets:
            display_text = f"{sheet.name} ({sheet.row_count}행 × {sheet.column_count}열)"
            self.sheet_combo.addItem(display_text, sheet.name)
            
        if sheets:
            self.sheetSelected.emit(sheets[0].name)
            
    def get_selected_sheet(self) -> Optional[str]:
        """Get currently selected sheet name"""
        if self.sheet_combo.currentData():
            return self.sheet_combo.currentData()
        return None

class ColumnMappingTable(QTableWidget):
    """Table widget for column mapping"""
    
    mappingChanged = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        self.columns: List[ColumnInfo] = []
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Set headers
        self.setColumnCount(6)
        self.setHorizontalHeaderLabels([
            "사용", "엑셀 열", "변수명", "데이터 타입", "샘플 데이터", "필수"
        ])
        
        # Configure table
        self.horizontalHeader().setStretchLastSection(False)
        self.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(5, QHeaderView.Fixed)
        
        self.setColumnWidth(0, 50)  # 사용
        self.setColumnWidth(5, 50)  # 필수
        
        # Enable sorting
        self.setSortingEnabled(True)
        
    def set_columns(self, columns: List[ColumnInfo]):
        """Set columns for mapping"""
        self.columns = columns
        self.setRowCount(len(columns))
        
        for row, col_info in enumerate(columns):
            # Use checkbox
            use_checkbox = QCheckBox()
            use_checkbox.setChecked(True)
            use_checkbox.stateChanged.connect(self.mappingChanged.emit)
            self.setCellWidget(row, 0, use_checkbox)
            
            # Excel column name
            col_item = QTableWidgetItem(col_info.name)
            col_item.setFlags(col_item.flags() & ~Qt.ItemIsEditable)
            self.setItem(row, 1, col_item)
            
            # Variable name (editable)
            var_name = self._generate_variable_name(col_info.name)
            var_item = QTableWidgetItem(var_name)
            self.setItem(row, 2, var_item)
            
            # Data type
            type_combo = QComboBox()
            type_combo.addItems([t.value for t in ColumnType])
            type_combo.setCurrentText(col_info.data_type.value)
            self.setCellWidget(row, 3, type_combo)
            
            # Sample data
            sample_text = ", ".join(str(v) for v in col_info.sample_values[:3])
            if len(col_info.sample_values) > 3:
                sample_text += "..."
            sample_item = QTableWidgetItem(sample_text)
            sample_item.setFlags(sample_item.flags() & ~Qt.ItemIsEditable)
            sample_item.setToolTip("\n".join(str(v) for v in col_info.sample_values))
            self.setItem(row, 4, sample_item)
            
            # Required checkbox
            required_checkbox = QCheckBox()
            required_checkbox.setChecked(False)
            self.setCellWidget(row, 5, required_checkbox)
            
    def _generate_variable_name(self, column_name: str) -> str:
        """Generate variable name from column name"""
        # Remove special characters and convert to snake_case
        import re
        var_name = re.sub(r'[^\w\s]', '', column_name)
        var_name = var_name.strip().lower().replace(' ', '_')
        
        # Ensure it starts with letter
        if var_name and not var_name[0].isalpha():
            var_name = 'col_' + var_name
            
        return var_name or 'column'
        
    def get_mappings(self) -> List[ColumnMapping]:
        """Get current column mappings"""
        mappings = []
        
        for row in range(self.rowCount()):
            use_checkbox = self.cellWidget(row, 0)
            if not use_checkbox.isChecked():
                continue
                
            excel_col = self.item(row, 1).text()
            var_name = self.item(row, 2).text()
            type_combo = self.cellWidget(row, 3)
            required_checkbox = self.cellWidget(row, 5)
            
            if var_name.strip():  # Only add if variable name is not empty
                mapping = ColumnMapping(
                    excel_column=excel_col,
                    variable_name=var_name.strip(),
                    data_type=ColumnType(type_combo.currentText()),
                    is_required=required_checkbox.isChecked()
                )
                mappings.append(mapping)
                
        return mappings

class SheetMapperWidget(QWidget):
    """Complete sheet and column mapping widget"""
    
    mappingComplete = pyqtSignal(str, list)  # sheet_name, mappings
    
    def __init__(self):
        super().__init__()
        self.current_sheet: Optional[SheetInfo] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Sheet selector
        self.sheet_selector = SheetSelectorWidget()
        self.sheet_selector.sheetSelected.connect(self._on_sheet_selected)
        layout.addWidget(self.sheet_selector)
        
        # Column mapping
        mapping_group = QGroupBox("열 매핑 설정")
        mapping_layout = QVBoxLayout()
        
        # Mapping table
        self.mapping_table = ColumnMappingTable()
        mapping_layout.addWidget(self.mapping_table)
        
        # Auto-detect status column
        auto_layout = QHBoxLayout()
        self.auto_detect_btn = QPushButton("상태 열 자동 감지")
        self.auto_detect_btn.clicked.connect(self._auto_detect_status)
        auto_layout.addWidget(self.auto_detect_btn)
        
        self.status_label = QLabel()
        auto_layout.addWidget(self.status_label)
        auto_layout.addStretch()
        
        mapping_layout.addLayout(auto_layout)
        mapping_group.setLayout(mapping_layout)
        layout.addWidget(mapping_group)
        
        # Apply button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        self.apply_btn = QPushButton("매핑 적용")
        self.apply_btn.clicked.connect(self._apply_mapping)
        button_layout.addWidget(self.apply_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def set_file_info(self, sheets: List[SheetInfo]):
        """Set file information"""
        self.sheet_selector.set_sheets(sheets)
        
    def _on_sheet_selected(self, sheet_name: str):
        """Handle sheet selection"""
        # Find sheet info
        for sheet in self.sheet_selector.sheets:
            if sheet.name == sheet_name:
                self.current_sheet = sheet
                self.mapping_table.set_columns(sheet.columns)
                self._auto_detect_status()
                break
                
    def _auto_detect_status(self):
        """Auto-detect status column"""
        if not self.current_sheet:
            return
            
        status_keywords = ['상태', 'Status', '완료', '처리', 'status', 'STATUS']
        
        for row in range(self.mapping_table.rowCount()):
            col_name = self.mapping_table.item(row, 1).text()
            
            # Check if column name contains status keywords
            for keyword in status_keywords:
                if keyword in col_name:
                    # Set as status column
                    self.mapping_table.item(row, 2).setText('status')
                    required_checkbox = self.mapping_table.cellWidget(row, 5)
                    required_checkbox.setChecked(True)
                    self.status_label.setText(f"상태 열 감지됨: {col_name}")
                    return
                    
        self.status_label.setText("상태 열을 찾을 수 없음 (자동 생성됨)")
        
    def _apply_mapping(self):
        """Apply current mapping"""
        if not self.sheet_selector.get_selected_sheet():
            QMessageBox.warning(self, "경고", "시트를 선택해주세요.")
            return
            
        mappings = self.mapping_table.get_mappings()
        if not mappings:
            QMessageBox.warning(self, "경고", "최소 하나 이상의 열을 매핑해주세요.")
            return
            
        # Check for duplicate variable names
        var_names = [m.variable_name for m in mappings]
        if len(var_names) != len(set(var_names)):
            QMessageBox.warning(self, "경고", "변수명이 중복되었습니다.")
            return
            
        self.mappingComplete.emit(
            self.sheet_selector.get_selected_sheet(),
            mappings
        )
</file>

<file path="src/utils/clipboard_utils.py">
"""
Clipboard utilities for cross-platform image handling
"""

import os
import sys
import time
import subprocess
from typing import Optional
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtWidgets import QApplication
from utils.path_utils import get_captures_dir, is_wsl


def save_clipboard_image() -> Optional[str]:
    """
    Try multiple methods to save clipboard image to file
    Returns the saved file path or None if no image found
    """
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    filename = f"clipboard_{timestamp}.png"
    
    # Create captures directory using path utility
    captures_dir = get_captures_dir()
    file_path = os.path.join(captures_dir, filename)
    
    # Method 1: Try Windows PowerShell if in WSL
    if is_wsl():
        if save_from_windows_clipboard(file_path):
            return file_path
    
    # Method 2: Try Qt clipboard
    if save_from_qt_clipboard(file_path):
        return file_path
    
    # Method 3: Try PIL
    if save_from_pil_clipboard(file_path):
        return file_path
    
    return None


def save_from_windows_clipboard(file_path: str) -> bool:
    """
    Use PowerShell to save clipboard image (WSL specific)
    """
    try:
        # Convert WSL path to Windows path
        win_path = subprocess.check_output(['wslpath', '-w', file_path]).decode().strip()
        
        # PowerShell script to save clipboard image
        ps_script = f'''
        Add-Type -Assembly System.Windows.Forms
        $clipboard = [System.Windows.Forms.Clipboard]::GetImage()
        if ($clipboard -ne $null) {{
            $clipboard.Save("{win_path}", [System.Drawing.Imaging.ImageFormat]::Png)
            Write-Host "SUCCESS"
        }} else {{
            Write-Host "NO_IMAGE"
        }}
        '''
        
        # Run PowerShell command
        result = subprocess.run(
            ['powershell.exe', '-Command', ps_script],
            capture_output=True,
            text=True
        )
        
        if "SUCCESS" in result.stdout:
            print("Successfully saved image from Windows clipboard")
            return True
        elif "NO_IMAGE" in result.stdout:
            print("No image in Windows clipboard")
        else:
            print(f"PowerShell error: {result.stderr}")
            
    except Exception as e:
        print(f"Windows clipboard error: {e}")
    
    return False


def save_from_qt_clipboard(file_path: str) -> bool:
    """
    Save image from Qt clipboard
    """
    try:
        clipboard = QApplication.clipboard()
        
        # Try image first
        if clipboard.mimeData().hasImage():
            image = clipboard.image()
            if not image.isNull():
                if image.save(file_path, "PNG"):
                    print("Successfully saved image from Qt clipboard")
                    return True
        
        # Try pixmap
        pixmap = clipboard.pixmap()
        if not pixmap.isNull():
            if pixmap.save(file_path, "PNG"):
                print("Successfully saved pixmap from Qt clipboard")
                return True
                
    except Exception as e:
        print(f"Qt clipboard error: {e}")
    
    return False


def save_from_pil_clipboard(file_path: str) -> bool:
    """
    Save image from PIL clipboard
    """
    try:
        from PIL import ImageGrab
        
        # Try multiple times with delay
        for attempt in range(3):
            if attempt > 0:
                time.sleep(0.1)
                
            img = ImageGrab.grabclipboard()
            if img:
                img.save(file_path)
                print("Successfully saved image from PIL clipboard")
                return True
                
    except Exception as e:
        print(f"PIL clipboard error: {e}")
    
    return False
</file>

<file path="src/utils/encryption.py">
"""
AES-256 encryption utilities for secure storage
"""

import os
from pathlib import Path
from typing import Optional
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
import base64

class EncryptionManager:
    """Handles AES-256 encryption/decryption for configuration and macro files"""
    
    def __init__(self, key_file: Optional[Path] = None):
        """Initialize encryption manager with key"""
        self.key_file = key_file or Path.home() / ".excel_macro_automation" / ".key"
        self.key = self._load_or_generate_key()
    
    def _load_or_generate_key(self) -> bytes:
        """Load existing key or generate new one"""
        if self.key_file.exists():
            return base64.b64decode(self.key_file.read_bytes())
        else:
            # Generate new key
            key = os.urandom(32)  # 256 bits
            self.key_file.parent.mkdir(parents=True, exist_ok=True)
            self.key_file.write_bytes(base64.b64encode(key))
            # Set restrictive permissions (Unix-like systems)
            if hasattr(os, 'chmod'):
                os.chmod(self.key_file, 0o600)
            return key
    
    def derive_key(self, password: str, salt: bytes) -> bytes:
        """Derive key from password using PBKDF2"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        return kdf.derive(password.encode())
    
    def encrypt(self, data: bytes, password: Optional[str] = None) -> bytes:
        """Encrypt data using AES-256-CBC"""
        # Use password-derived key if provided, otherwise use stored key
        if password:
            salt = os.urandom(16)
            key = self.derive_key(password, salt)
        else:
            salt = b''
            key = self.key
        
        # Generate IV
        iv = os.urandom(16)
        
        # Pad data to block size
        padder = padding.PKCS7(128).padder()
        padded_data = padder.update(data) + padder.finalize()
        
        # Encrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        
        # Return salt + iv + encrypted data
        return salt + iv + encrypted_data
    
    def decrypt(self, encrypted_data: bytes, password: Optional[str] = None) -> bytes:
        """Decrypt data using AES-256-CBC"""
        # Extract components
        if password:
            salt = encrypted_data[:16]
            iv = encrypted_data[16:32]
            ciphertext = encrypted_data[32:]
            key = self.derive_key(password, salt)
        else:
            iv = encrypted_data[:16]
            ciphertext = encrypted_data[16:]
            key = self.key
        
        # Decrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(ciphertext) + decryptor.finalize()
        
        # Remove padding
        unpadder = padding.PKCS7(128).unpadder()
        data = unpadder.update(padded_data) + unpadder.finalize()
        
        return data
    
    def encrypt_file(self, input_path: Path, output_path: Path, password: Optional[str] = None) -> None:
        """Encrypt a file"""
        data = input_path.read_bytes()
        encrypted_data = self.encrypt(data, password)
        output_path.write_bytes(encrypted_data)
    
    def decrypt_file(self, input_path: Path, output_path: Path, password: Optional[str] = None) -> None:
        """Decrypt a file"""
        encrypted_data = input_path.read_bytes()
        data = self.decrypt(encrypted_data, password)
        output_path.write_bytes(data)


# Global encryption manager instance
_encryption_manager = None


def get_encryption_manager() -> EncryptionManager:
    """Get global encryption manager instance"""
    global _encryption_manager
    if _encryption_manager is None:
        _encryption_manager = EncryptionManager()
    return _encryption_manager


def encrypt_data(data: str, password: str) -> bytes:
    """Encrypt string data with password"""
    manager = get_encryption_manager()
    return manager.encrypt(data.encode('utf-8'), password)


def decrypt_data(encrypted_data: bytes, password: str) -> str:
    """Decrypt data with password and return as string"""
    manager = get_encryption_manager()
    decrypted_bytes = manager.decrypt(encrypted_data, password)
    return decrypted_bytes.decode('utf-8')
</file>

<file path="src/utils/monitor_utils.py">
"""
Monitor detection and coordinate utilities
"""

from typing import Dict, List, Tuple, Optional
import logging

logger = logging.getLogger(__name__)


def get_monitor_info() -> List[Dict]:
    """
    Get information about all connected monitors
    Returns list of monitor dictionaries with x, y, width, height, is_primary
    """
    monitors = []
    
    try:
        # Try using screeninfo library if available
        from screeninfo import get_monitors
        
        for m in get_monitors():
            monitors.append({
                'name': m.name,
                'x': m.x,
                'y': m.y,
                'width': m.width,
                'height': m.height,
                'is_primary': m.is_primary if hasattr(m, 'is_primary') else (m.x == 0 and m.y == 0)
            })
            
    except ImportError:
        logger.warning("screeninfo not installed, using fallback method")
        # Fallback to tkinter method
        try:
            import tkinter as tk
            root = tk.Tk()
            root.withdraw()  # Hide the window
            
            # Get primary monitor info
            primary_width = root.winfo_screenwidth()
            primary_height = root.winfo_screenheight()
            
            # Get virtual screen size (all monitors)
            virtual_width = root.winfo_vrootwidth()
            virtual_height = root.winfo_vrootheight()
            
            monitors.append({
                'name': 'Primary',
                'x': 0,
                'y': 0,
                'width': primary_width,
                'height': primary_height,
                'is_primary': True
            })
            
            # If virtual size is larger, we have multiple monitors
            if virtual_width > primary_width:
                # Assume second monitor is to the right
                monitors.append({
                    'name': 'Secondary',
                    'x': primary_width,
                    'y': 0,
                    'width': virtual_width - primary_width,
                    'height': primary_height,
                    'is_primary': False
                })
            elif virtual_width < 0:
                # Monitor might be to the left
                monitors.insert(0, {
                    'name': 'Secondary',
                    'x': virtual_width,
                    'y': 0,
                    'width': -virtual_width,
                    'height': primary_height,
                    'is_primary': False
                })
                
            root.destroy()
            
        except Exception as e:
            logger.error(f"Failed to get monitor info: {e}")
            # Return at least one monitor
            monitors.append({
                'name': 'Default',
                'x': 0,
                'y': 0,
                'width': 1920,
                'height': 1080,
                'is_primary': True
            })
    
    return monitors


def get_monitor_at_position(x: int, y: int) -> Optional[Dict]:
    """
    Get monitor information for the monitor containing the given position
    """
    monitors = get_monitor_info()
    
    for monitor in monitors:
        if (monitor['x'] <= x < monitor['x'] + monitor['width'] and
            monitor['y'] <= y < monitor['y'] + monitor['height']):
            return monitor
            
    # If no monitor found, return the primary monitor
    for monitor in monitors:
        if monitor['is_primary']:
            return monitor
            
    return monitors[0] if monitors else None


def get_monitor_name_for_position(x: int, y: int) -> str:
    """
    Get a friendly name for the monitor at the given position
    """
    monitor = get_monitor_at_position(x, y)
    
    if not monitor:
        return "알 수 없는 모니터"
        
    # Create a friendly name based on position
    if monitor['is_primary']:
        return "주 모니터"
    elif monitor['x'] < 0:
        return "왼쪽 모니터"
    elif monitor['x'] > 0:
        return "오른쪽 모니터"
    elif monitor['y'] < 0:
        return "위쪽 모니터"
    elif monitor['y'] > 0:
        return "아래쪽 모니터"
    else:
        return monitor.get('name', '보조 모니터')


def get_total_screen_bounds() -> Tuple[int, int, int, int]:
    """
    Get the total bounds of all monitors combined
    Returns: (min_x, min_y, max_x, max_y)
    """
    monitors = get_monitor_info()
    
    if not monitors:
        return (0, 0, 1920, 1080)
        
    min_x = min(m['x'] for m in monitors)
    min_y = min(m['y'] for m in monitors)
    max_x = max(m['x'] + m['width'] for m in monitors)
    max_y = max(m['y'] + m['height'] for m in monitors)
    
    return (min_x, min_y, max_x, max_y)


def is_position_valid(x: int, y: int) -> bool:
    """
    Check if a position is within any monitor bounds
    """
    return get_monitor_at_position(x, y) is not None
</file>

<file path="src/utils/path_utils.py">
"""
Cross-platform path utilities for Windows/WSL compatibility
"""

import os
import sys
import platform


def normalize_path(path: str) -> str:
    """
    Normalize path for the current platform
    Handles both Windows and WSL/Linux paths
    """
    if not path:
        return path
    
    # Convert to absolute path if relative
    if not os.path.isabs(path):
        path = os.path.abspath(path)
    
    # Normalize separators
    path = os.path.normpath(path)
    
    return path


def get_project_root() -> str:
    """
    Get the project root directory in a platform-independent way
    """
    # Get the directory of this file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Go up two levels (utils -> src -> project_root)
    project_root = os.path.dirname(os.path.dirname(current_dir))
    
    return normalize_path(project_root)


def get_captures_dir() -> str:
    """
    Get the captures directory, creating it if necessary
    """
    captures_dir = os.path.join(get_project_root(), "captures")
    os.makedirs(captures_dir, exist_ok=True)
    return captures_dir


def get_logs_dir() -> str:
    """
    Get the logs directory, creating it if necessary
    """
    logs_dir = os.path.join(get_project_root(), "logs")
    os.makedirs(logs_dir, exist_ok=True)
    return logs_dir


def is_wsl() -> bool:
    """
    Check if running in WSL environment
    """
    return 'microsoft' in platform.uname().release.lower()


def is_windows_native() -> bool:
    """
    Check if running in native Windows (not WSL)
    """
    return sys.platform == 'win32' and not is_wsl()


def convert_wsl_to_windows_path(wsl_path: str) -> str:
    """
    Convert WSL path to Windows path
    Example: /home/user/file -> \\\\wsl$\\Ubuntu\\home\\user\\file
    """
    if not wsl_path.startswith('/'):
        return wsl_path
    
    # Get WSL distribution name (default to Ubuntu)
    import subprocess
    try:
        result = subprocess.run(['wslpath', '-w', wsl_path], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass
    
    # Fallback conversion
    windows_path = wsl_path.replace('/', '\\')
    return f"\\\\wsl$\\Ubuntu{windows_path}"


def convert_windows_to_wsl_path(windows_path: str) -> str:
    """
    Convert Windows path to WSL path
    Example: C:\\Users\\file -> /mnt/c/Users/file
    """
    if ':' not in windows_path:
        return windows_path
    
    # Use wslpath if available
    import subprocess
    try:
        result = subprocess.run(['wslpath', '-u', windows_path], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass
    
    # Fallback conversion
    drive = windows_path[0].lower()
    path = windows_path[2:].replace('\\', '/')
    return f"/mnt/{drive}{path}"
</file>

<file path="src/vision/image_matcher.py">
"""
OpenCV-based image matching engine with DPI scaling and multi-monitor support
"""

import time
from typing import Optional, Tuple, List, Dict, Any
from dataclasses import dataclass
import numpy as np
import cv2
import pyautogui
from PIL import Image
import mss
from config.settings import Settings
from logger.app_logger import get_logger

@dataclass
class MatchResult:
    """Result of image matching operation"""
    found: bool
    confidence: float
    location: Optional[Tuple[int, int, int, int]] = None  # x, y, width, height
    center: Optional[Tuple[int, int]] = None  # center x, y
    
@dataclass 
class MonitorInfo:
    """Monitor information"""
    index: int
    left: int
    top: int
    width: int
    height: int
    scale: float = 1.0

class ImageMatcher:
    """Advanced image matching with OpenCV"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        self._template_cache: Dict[str, np.ndarray] = {}
        self._sct = mss.mss()
        self._monitors = self._detect_monitors()
        
    def _detect_monitors(self) -> List[MonitorInfo]:
        """Detect all monitors and their properties"""
        monitors = []
        
        for i, monitor in enumerate(self._sct.monitors[1:], 1):  # Skip combined monitor
            info = MonitorInfo(
                index=i,
                left=monitor["left"],
                top=monitor["top"],
                width=monitor["width"],
                height=monitor["height"]
            )
            
            # Detect DPI scaling (simplified - may need platform-specific code)
            try:
                # Get actual screen size vs reported size
                actual_size = pyautogui.size()
                if i == 1:  # Primary monitor
                    scale_x = actual_size.width / monitor["width"]
                    scale_y = actual_size.height / monitor["height"]
                    info.scale = max(scale_x, scale_y)
            except:
                info.scale = 1.0
                
            monitors.append(info)
            self.logger.debug(f"Detected monitor {i}: {info}")
            
        return monitors
        
    def _load_template(self, image_path: str, scale: float = 1.0) -> np.ndarray:
        """Load and cache template image with scaling"""
        cache_key = f"{image_path}_{scale}"
        
        if cache_key in self._template_cache:
            return self._template_cache[cache_key]
            
        try:
            # Load template
            template = cv2.imread(image_path)
            if template is None:
                raise ValueError(f"Failed to load image: {image_path}")
                
            # Apply DPI scaling if needed
            if scale != 1.0:
                width = int(template.shape[1] * scale)
                height = int(template.shape[0] * scale)
                template = cv2.resize(template, (width, height), interpolation=cv2.INTER_LINEAR)
                
            # Convert to grayscale for faster matching
            template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
            
            # Cache the processed template
            self._template_cache[cache_key] = template_gray
            
            return template_gray
            
        except Exception as e:
            self.logger.error(f"Error loading template {image_path}: {e}")
            raise
            
    def _capture_screen(self, region: Optional[Tuple[int, int, int, int]] = None,
                       monitor_index: Optional[int] = None) -> np.ndarray:
        """Capture screen or region"""
        try:
            if region:
                # Capture specific region
                monitor = {
                    "left": region[0],
                    "top": region[1], 
                    "width": region[2],
                    "height": region[3]
                }
            elif monitor_index is not None and 0 <= monitor_index < len(self._monitors):
                # Capture specific monitor
                mon_info = self._monitors[monitor_index]
                monitor = {
                    "left": mon_info.left,
                    "top": mon_info.top,
                    "width": mon_info.width,
                    "height": mon_info.height
                }
            else:
                # Capture all monitors
                monitor = self._sct.monitors[0]
                
            # Capture screenshot
            screenshot = self._sct.grab(monitor)
            
            # Convert to numpy array
            img = np.array(screenshot)
            
            # Convert BGRA to BGR
            img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
            
            return img
            
        except Exception as e:
            self.logger.error(f"Error capturing screen: {e}")
            raise
            
    def find_image(self, template_path: str, 
                   confidence: float = 0.9,
                   region: Optional[Tuple[int, int, int, int]] = None,
                   monitor_index: Optional[int] = None,
                   grayscale: bool = True) -> MatchResult:
        """Find image on screen using template matching"""
        
        try:
            # Determine scale factor
            scale = 1.0
            if monitor_index is not None and 0 <= monitor_index < len(self._monitors):
                scale = self._monitors[monitor_index].scale
                
            # Load template
            template = self._load_template(template_path, scale)
            
            # Capture screen
            screenshot = self._capture_screen(region, monitor_index)
            
            # Convert to grayscale if needed
            if grayscale:
                screenshot_gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
            else:
                screenshot_gray = screenshot
                
            # Perform template matching
            result = cv2.matchTemplate(screenshot_gray, template, cv2.TM_CCOEFF_NORMED)
            
            # Find best match
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
            
            if max_val >= confidence:
                # Calculate absolute coordinates
                h, w = template.shape[:2]
                x, y = max_loc
                
                # Adjust for region offset if applicable
                if region:
                    x += region[0]
                    y += region[1]
                elif monitor_index is not None:
                    mon_info = self._monitors[monitor_index]
                    x += mon_info.left
                    y += mon_info.top
                    
                location = (x, y, w, h)
                center = (x + w // 2, y + h // 2)
                
                return MatchResult(
                    found=True,
                    confidence=max_val,
                    location=location,
                    center=center
                )
            else:
                return MatchResult(found=False, confidence=max_val)
                
        except Exception as e:
            self.logger.error(f"Error in find_image: {e}")
            return MatchResult(found=False, confidence=0.0)
            
    def find_all_images(self, template_path: str,
                       confidence: float = 0.9,
                       region: Optional[Tuple[int, int, int, int]] = None,
                       limit: int = 10) -> List[MatchResult]:
        """Find all occurrences of image on screen"""
        
        results = []
        
        try:
            # Load template
            template = self._load_template(template_path)
            
            # Capture screen  
            screenshot = self._capture_screen(region)
            screenshot_gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
            
            # Perform template matching
            match_result = cv2.matchTemplate(screenshot_gray, template, cv2.TM_CCOEFF_NORMED)
            
            # Find all matches above threshold
            locations = np.where(match_result >= confidence)
            
            h, w = template.shape[:2]
            
            # Process matches
            for pt in zip(*locations[::-1]):
                if len(results) >= limit:
                    break
                    
                x, y = pt
                
                # Adjust for region offset
                if region:
                    x += region[0]
                    y += region[1]
                    
                location = (x, y, w, h)
                center = (x + w // 2, y + h // 2)
                
                # Get confidence for this match
                conf = match_result[y, x]
                
                results.append(MatchResult(
                    found=True,
                    confidence=float(conf),
                    location=location,
                    center=center
                ))
                
        except Exception as e:
            self.logger.error(f"Error in find_all_images: {e}")
            
        return results
        
    def wait_for_image(self, template_path: str,
                      timeout: float = 30.0,
                      confidence: float = 0.9,
                      region: Optional[Tuple[int, int, int, int]] = None,
                      check_interval: float = 0.5) -> MatchResult:
        """Wait for image to appear on screen"""
        
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            result = self.find_image(template_path, confidence, region)
            
            if result.found:
                return result
                
            time.sleep(check_interval)
            
        # Timeout reached
        return MatchResult(found=False, confidence=0.0)
        
    def capture_region(self, region: Tuple[int, int, int, int], 
                      save_path: Optional[str] = None) -> np.ndarray:
        """Capture a specific region of the screen"""
        
        screenshot = self._capture_screen(region)
        
        if save_path:
            cv2.imwrite(save_path, screenshot)
            self.logger.info(f"Saved screenshot to {save_path}")
            
        return screenshot
        
    def clear_cache(self):
        """Clear template cache"""
        self._template_cache.clear()
        self.logger.debug("Template cache cleared")

class ImageMatcherLegacy:
    """Legacy image matcher using pyautogui for fallback"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        
    def find_image(self, template_path: str,
                   confidence: float = 0.9,
                   region: Optional[Tuple[int, int, int, int]] = None) -> MatchResult:
        """Find image using pyautogui"""
        
        try:
            location = pyautogui.locateOnScreen(
                template_path,
                confidence=confidence,
                region=region
            )
            
            if location:
                center = pyautogui.center(location)
                return MatchResult(
                    found=True,
                    confidence=confidence,
                    location=location,
                    center=center
                )
            else:
                return MatchResult(found=False, confidence=0.0)
                
        except Exception as e:
            self.logger.error(f"Error in legacy find_image: {e}")
            return MatchResult(found=False, confidence=0.0)
</file>

<file path="src/__init__.py">
# Excel Macro Automation Package
</file>

<file path="test_results/drag_drop_test_report.json">
{"created": 1752635947.0595722, "duration": 2.1377406120300293, "exitcode": 0, "root": "/home/nosky/macro", "environment": {}, "summary": {"passed": 6, "total": 6, "collected": 6}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py", "type": "Module"}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "outcome": "passed", "result": []}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "type": "Function", "lineno": 42}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "type": "Function", "lineno": 72}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "type": "Function", "lineno": 102}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "type": "Function", "lineno": 130}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "type": "Function", "lineno": 157}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "type": "Function", "lineno": 177}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "type": "Class"}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "type": "Class"}]}], "tests": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "lineno": 42, "outcome": "passed", "keywords": ["test_drag_new_step_from_palette", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.14800998900318518, "outcome": "passed"}, "call": {"duration": 0.20660709802177735, "outcome": "passed"}, "teardown": {"duration": 0.0007801619940437376, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "lineno": 72, "outcome": "passed", "keywords": ["test_drag_multiple_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.0966931150178425, "outcome": "passed"}, "call": {"duration": 0.4246597609890159, "outcome": "passed"}, "teardown": {"duration": 0.0003640960203483701, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "lineno": 102, "outcome": "passed", "keywords": ["test_reorder_existing_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09244555799523368, "outcome": "passed"}, "call": {"duration": 0.26532694601337425, "outcome": "passed"}, "teardown": {"duration": 0.00038110199966467917, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "lineno": 130, "outcome": "passed", "keywords": ["test_drop_at_specific_positions", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09779455501120538, "outcome": "passed"}, "call": {"duration": 0.21195768300094642, "outcome": "passed"}, "teardown": {"duration": 0.0003567070234566927, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "lineno": 157, "outcome": "passed", "keywords": ["test_drag_cancel", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09215356002096087, "outcome": "passed"}, "call": {"duration": 0.10171863497816958, "outcome": "passed"}, "teardown": {"duration": 0.0003038999857380986, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "lineno": 177, "outcome": "passed", "keywords": ["test_invalid_mime_data", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09534229998826049, "outcome": "passed"}, "call": {"duration": 0.1021027640090324, "outcome": "passed"}, "teardown": {"duration": 0.0003029129875358194, "outcome": "passed"}}], "warnings": [{"message": "cannot collect test class 'TestScenario' because it has a __init__ constructor (from: tests/integration/test_drag_drop_integration.py)", "category": "PytestCollectionWarning", "when": "collect", "filename": "/home/nosky/macro/tests/test_helpers.py", "lineno": 227}]}
</file>

<file path="test_results/test_report_20250716_115250.html">
<!DOCTYPE html>
<html>
<head>
    <title>Test Report - 2025-07-16 11:52:50</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #333;
        }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 14px;
        }
        .stat-card .value {
            font-size: 32px;
            font-weight: bold;
            color: #333;
        }
        .success { color: #28a745; }
        .failure { color: #dc3545; }
        .warning { color: #ffc107; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .test-detail {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        pre {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-fill {
            height: 100%;
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Excel Macro Automation - Test Report</h1>
        <p>Generated on: 2025-07-16 11:52:50</p>
        
        <h2>Summary</h2>
        <div class="summary">
            <div class="stat-card">
                <h3>Total Tests</h3>
                <div class="value">0</div>
            </div>
            <div class="stat-card">
                <h3>Passed</h3>
                <div class="value success">0</div>
            </div>
            <div class="stat-card">
                <h3>Failed</h3>
                <div class="value failure">0</div>
            </div>
            <div class="stat-card">
                <h3>Success Rate</h3>
                <div class="value">0.0%</div>
            </div>
            <div class="stat-card">
                <h3>Duration</h3>
                <div class="value">0.4s</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" style="width: 0%">
                0.0%
            </div>
        </div>
        
        <h2>Test Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Test File</th>
                    <th>Total</th>
                    <th>Passed</th>
                    <th>Failed</th>
                    <th>Duration</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>

                <tr>
                    <td>test_drag_drop_integration.py</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0.20s</td>
                    <td class="warning">⚠️ Error</td>
                </tr>

                <tr>
                    <td>test_step_configuration.py</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0.12s</td>
                    <td class="warning">⚠️ Error</td>
                </tr>

                <tr>
                    <td>test_execution_logging.py</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0.11s</td>
                    <td class="warning">⚠️ Error</td>
                </tr>

            </tbody>
        </table>
        
        <h2>Detailed Results</h2>

    </div>
</body>
</html>
</file>

<file path="test_results/test_results_20250716_115250.csv">

</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250715_225040.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_111655.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-15T10:00:00.000Z",
      "endTime": "2025-07-15T15:00:00.000Z",
      "actualEndTime": "2025-07-15T14:41:16.998Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2152,
            "outputTokens": 89802,
            "cacheCreationTokens": 2254600,
            "cacheReadTokens": 54716499,
            "totalTokens": 91954
          },
          "costUSD": 131.115928,
          "entriesCount": 644
        }
      },
      "totalTokens": 459770,
      "totalTokensOld": 91954,
      "costUSD": 131.115928,
      "entries": 647,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-15T14:41:16.998Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-16T00:00:00.000Z",
      "endTime": "2025-07-16T05:00:00.000Z",
      "actualEndTime": "2025-07-16T02:16:52.142Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1517,
            "outputTokens": 51006,
            "cacheCreationTokens": 1964228,
            "cacheReadTokens": 31405887,
            "totalTokens": 52523
          },
          "costUSD": 87.78631,
          "entriesCount": 393
        }
      },
      "totalTokens": 262615,
      "totalTokensOld": 52523,
      "costUSD": 87.78631,
      "entries": 408,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:45:24.854Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:46:52.080Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:00:13.826Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:20:13.306Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_230208.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-15T10:00:00.000Z",
      "endTime": "2025-07-15T15:00:00.000Z",
      "actualEndTime": "2025-07-15T14:41:16.998Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2152,
            "outputTokens": 89802,
            "cacheCreationTokens": 2254600,
            "cacheReadTokens": 54716499,
            "totalTokens": 91954
          },
          "costUSD": 131.115928,
          "entriesCount": 644
        }
      },
      "totalTokens": 459770,
      "totalTokensOld": 91954,
      "costUSD": 131.115928,
      "entries": 647,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-15T14:41:16.998Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-16T00:00:00.000Z",
      "endTime": "2025-07-16T05:00:00.000Z",
      "actualEndTime": "2025-07-16T03:50:31.984Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1758,
            "outputTokens": 57412,
            "cacheCreationTokens": 2744546,
            "cacheReadTokens": 41214649,
            "totalTokens": 59170
          },
          "costUSD": 117.614481,
          "entriesCount": 486
        }
      },
      "totalTokens": 295850,
      "totalTokensOld": 59170,
      "costUSD": 117.614481,
      "entries": 503,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:45:24.854Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:46:52.080Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:00:13.826Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:20:13.306Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T03:50:31.984Z",
          "content": "Claude AI usage limit reached|1752642000",
          "resetTime": "2025-07-16T05:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# Custom
*.enc
*.encrypted
config/settings.json
logs/
temp/
.DS_Store
.idea/
.vscode/
*.swp
*.swo
</file>

<file path="APPLICATION_GUIDE.md">
# Excel Macro Automation - 애플리케이션 가이드

## 🚀 애플리케이션 실행 방법

### 1. 의존성 확인
```bash
# 이미 설치됨 (pip3 install -r requirements.txt)
# 주요 패키지: PyQt5, pandas, opencv-python, pyautogui, easyocr
```

### 2. 애플리케이션 실행
```bash
# 프로젝트 루트에서 실행
cd /home/nosky/macro
python3 main.py

# 또는 (경로 문제가 있을 경우)
python3 test_app.py
```

## 📋 주요 기능

### 1. Excel 탭
- **파일 선택**: Excel 파일을 드래그 앤 드롭 또는 찾아보기로 선택
- **시트 선택**: 드롭다운에서 작업할 시트 선택
- **열 매핑**: 각 열의 데이터 타입 자동 감지
- **미리보기**: 선택한 데이터의 처음 10행 표시
- **상태 열**: 작업 완료 상태를 기록할 열 자동 감지/생성

### 2. Editor 탭 (매크로 편집기)
- **드래그 앤 드롭**: 왼쪽 팔레트에서 단계를 드래그하여 추가
- **지원되는 단계 타입**:
  - 🖱️ 마우스 클릭/이동
  - ⌨️ 텍스트 입력/단축키
  - ⏱️ 대기 시간
  - 🖼️ 이미지 대기/검색
  - 📷 화면 캡처
  - ❓ 조건문 (구현 예정)
  - 🔄 반복문 (구현 예정)
- **단계 편집**: 각 단계 더블클릭으로 상세 설정
- **변수 사용**: {{column_name}} 형식으로 Excel 데이터 참조

### 3. Run 탭 (실행)
- **실행 제어**: 시작/일시정지/정지 버튼
- **핫키 지원**: 
  - F9: 일시정지/재개
  - ESC: 정지
- **진행 상태**: 실시간 진행률 표시
- **실행 로그**: 각 단계별 성공/실패 기록
- **옵션**: 미완료 항목만 실행 체크박스

## 🎯 사용 시나리오

### 시나리오 1: 반복적인 데이터 입력
1. Excel 파일에 입력할 데이터 목록 준비
2. 매크로 편집기에서 다음 단계 구성:
   - 마우스 클릭 (입력 필드 위치)
   - 텍스트 입력 ({{이름}} 변수 사용)
   - 대기 (0.5초)
   - 다음 필드로 이동...
3. 실행하면 Excel의 각 행마다 자동 입력

### 시나리오 2: 이미지 기반 자동화
1. 이미지 대기 단계 추가
2. "Capture" 버튼으로 대상 이미지 캡처
3. ROI(관심 영역) 설정으로 검색 범위 제한
4. 이미지가 나타나면 다음 동작 수행

## ⚠️ 주의사항

### 현재 상태
- ✅ 기본 자동화 기능 구현 완료
- ✅ 이미지 인식 (OpenCV) 구현 완료
- ❌ OCR 텍스트 인식 미구현
- ❌ 조건문/반복문 실제 동작 미구현
- ❌ 매크로 저장/불러오기 미구현

### 실행 환경
- GUI 환경 필요 (X11, Wayland 등)
- 관리자 권한 불필요
- Python 3.8+ 필요

## 🔧 문제 해결

### 1. ImportError 발생 시
```bash
# 프로젝트 루트에서 실행 확인
cd /home/nosky/macro
export PYTHONPATH=$PWD/src:$PYTHONPATH
python3 main.py
```

### 2. Qt 플랫폼 에러
```bash
# Linux에서 X11 forwarding 필요
export DISPLAY=:0
# 또는 SSH의 경우
ssh -X user@host
```

### 3. 의존성 문제
```bash
# 개별 패키지 재설치
pip3 install --upgrade PyQt5
pip3 install --upgrade opencv-python
```

## 📝 다음 단계

1. **OCR 기능 구현** (T-006)
   - EasyOCR을 사용한 동적 텍스트 검색
   - Excel 데이터 기반 텍스트 찾기 및 클릭

2. **조건문 구현** (T-007)
   - If-Then-Else 로직
   - 이미지/텍스트 존재 여부 판단

3. **매크로 저장/불러오기** (T-008)
   - JSON 형식으로 매크로 저장
   - 재사용 가능한 매크로 라이브러리

4. **고급 로깅** (T-009)
   - CSV 형식 실행 로그
   - 오류 스크린샷 자동 저장
</file>

<file path="claude.md">
# Git Commit Message Rules

## Format Structure
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

## Types (Required)
- `feat`: new feature
- `fix`: bug fix
- `docs`: documentation only
- `style`: formatting, missing semi colons, etc
- `refactor`: code change that neither fixes bug nor adds feature
- `perf`: performance improvement
- `test`: adding missing tests
- `chore`: updating grunt tasks, dependencies, etc
- `ci`: changes to CI configuration
- `build`: changes affecting build system
- `revert`: reverting previous commit

## Scope (Optional)
- Component, file, or feature area affected
- Use kebab-case: `user-auth`, `payment-api`
- Omit if change affects multiple areas

## Description Rules
- Use imperative mood: "add" not "added" or "adds"
- No capitalization of first letter
- No period at end
- Max 50 characters
- Be specific and actionable

## Body Guidelines
- Wrap at 72 characters
- Explain what and why, not how
- Separate from description with blank line
- Use bullet points for multiple changes

## Footer Format
- `BREAKING CHANGE:` for breaking changes
- `Closes #123` for issue references
- `Co-authored-by: Name <email>`

## Examples
```
feat(auth): add OAuth2 Google login

fix: resolve memory leak in user session cleanup

docs(api): update authentication endpoints

refactor(utils): extract validation helpers to separate module

BREAKING CHANGE: remove deprecated getUserData() method
```

## Workflow Integration
**ALWAYS write a commit message after completing any development task, feature, or bug fix.**

## Validation Checklist
- [ ] Type is from approved list
- [ ] Description under 50 chars
- [ ] Imperative mood used
- [ ] No trailing period
- [ ] Meaningful and clear context

# TDD Process Guidelines - Cursor Rules

## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification

**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**

## Core Cycle: Red → Green → Refactor

### 1. RED Phase
- Write a failing test FIRST
- Test the simplest scenario
- Verify test fails for the right reason
- One test at a time

### 2. GREEN Phase  
- Write MINIMAL code to pass
- "Fake it till you make it" is OK
- No premature optimization
- YAGNI principle

### 3. REFACTOR Phase
- Remove duplication
- Improve naming
- Simplify structure
- Keep tests passing

## Test Quality: FIRST Principles
- **Fast**: Milliseconds, not seconds
- **Independent**: No shared state
- **Repeatable**: Same result every time
- **Self-validating**: Pass/fail, no manual checks
- **Timely**: Written just before code

## Test Structure: AAA Pattern
```
// Arrange
Set up test data and dependencies

// Act
Execute the function/method

// Assert
Verify expected outcome
```

## Implementation Flow
1. **List scenarios** before coding
2. **Pick one scenario** → Write test
3. **Run test** → See it fail (Red)
4. **Implement** → Make it pass (Green)
5. **Refactor** → Clean up (Still Green)
6. **Commit** → Small, frequent commits
7. **Repeat** → Next scenario

## Test Pyramid Strategy
- **Unit Tests** (70%): Fast, isolated, numerous
- **Integration Tests** (20%): Module boundaries
- **Acceptance Tests** (10%): User scenarios

## Outside-In vs Inside-Out
- **Outside-In**: Start with user-facing test → Mock internals → Implement details
- **Inside-Out**: Start with core logic → Build outward → Integrate components

## Common Anti-patterns to Avoid
- Testing implementation details
- Fragile tests tied to internals  
- Missing assertions
- Slow, environment-dependent tests
- Ignored failing tests

## When Tests Fail
1. **Identify**: Regression, flaky test, or spec change?
2. **Isolate**: Narrow down the cause
3. **Fix**: Code bug or test bug
4. **Learn**: Add missing test cases

## Team Practices
- CI/CD integration mandatory
- No merge without tests
- Test code = Production code quality
- Pair programming for complex tests
- Regular test refactoring

## Pragmatic Exceptions
- UI/Graphics: Manual + snapshot tests
- Performance: Benchmark suites
- Exploratory: Spike then test
- Legacy: Test on change

## Remember
- Tests are living documentation
- Test behavior, not implementation
- Small steps, fast feedback
- When in doubt, write a test
# Clean Code Guidelines

You are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:

## Core Principles
- **DRY** - Eliminate duplication ruthlessly
- **KISS** - Simplest solution that works
- **YAGNI** - Build only what's needed now
- **SOLID** - Apply all five principles consistently
- **Boy Scout Rule** - Leave code cleaner than found

## Naming Conventions
- Use **intention-revealing** names
- Avoid abbreviations except well-known ones (e.g., URL, API)
- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix
- Constants: UPPER_SNAKE_CASE
- No magic numbers - use named constants

## Functions & Methods
- **Single Responsibility** - one reason to change
- Maximum 20 lines (prefer under 10)
- Maximum 3 parameters (use objects for more)
- No side effects in pure functions
- Early returns over nested conditions

## Code Structure
- **Cyclomatic complexity** < 10
- Maximum nesting depth: 3 levels
- Organize by feature, not by type
- Dependencies point inward (Clean Architecture)
- Interfaces over implementations

## Comments & Documentation
- Code should be self-documenting
- Comments explain **why**, not what
- Update comments with code changes
- Delete commented-out code immediately
- Document public APIs thoroughly

## Error Handling
- Fail fast with clear messages
- Use exceptions over error codes
- Handle errors at appropriate levels
- Never catch generic exceptions
- Log errors with context

## Testing
- **TDD** when possible
- Test behavior, not implementation
- One assertion per test
- Descriptive test names: `should_X_when_Y`
- **AAA pattern**: Arrange, Act, Assert
- Maintain test coverage > 80%

## Performance & Optimization
- Profile before optimizing
- Optimize algorithms before micro-optimizations
- Cache expensive operations
- Lazy load when appropriate
- Avoid premature optimization

## Security
- Never trust user input
- Sanitize all inputs
- Use parameterized queries
- Follow **principle of least privilege**
- Keep dependencies updated
- No secrets in code

## Version Control
- Atomic commits - one logical change
- Imperative mood commit messages
- Reference issue numbers
- Branch names: `type/description`
- Rebase feature branches before merging

## Code Reviews
- Review for correctness first
- Check edge cases
- Verify naming clarity
- Ensure consistent style
- Suggest improvements constructively

## Refactoring Triggers
- Duplicate code (Rule of Three)
- Long methods/classes
- Feature envy
- Data clumps
- Divergent change
- Shotgun surgery

## Final Checklist
Before committing, ensure:
- [ ] All tests pass
- [ ] No linting errors
- [ ] No console logs
- [ ] No commented code
- [ ] No TODOs without tickets
- [ ] Performance acceptable
- [ ] Security considered
- [ ] Documentation updated

Remember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.
## Core Directive
You are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.

## Guiding Principles
- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity
- **Expert-Level Standards**: Every output must meet professional software engineering standards
- **Concrete Results**: Provide specific, actionable details at each step

---

## Phase 1: Codebase Exploration & Analysis
**REQUIRED ACTIONS:**
1. **Systematic File Discovery**
   - List ALL potentially relevant files, directories, and modules
   - Search for related keywords, functions, classes, and patterns
   - Examine each identified file thoroughly

2. **Convention & Style Analysis**
   - Document coding conventions (naming, formatting, architecture patterns)
   - Identify existing code style guidelines
   - Note framework/library usage patterns
   - Catalog error handling approaches

**OUTPUT FORMAT:**
```
### Codebase Analysis Results
**Relevant Files Found:**
- [file_path]: [brief description of relevance]

**Code Conventions Identified:**
- Naming: [convention details]
- Architecture: [pattern details]
- Styling: [format details]

**Key Dependencies & Patterns:**
- [library/framework]: [usage pattern]
```

---

## Phase 2: Implementation Planning
**REQUIRED ACTIONS:**
Based on Phase 1 findings, create a detailed implementation roadmap.

**OUTPUT FORMAT:**
```markdown
## Implementation Plan

### Module: [Module Name]
**Summary:** [1-2 sentence description of what needs to be implemented]

**Tasks:**
- [ ] [Specific implementation task]
- [ ] [Specific implementation task]

**Acceptance Criteria:**
- [ ] [Measurable success criterion]
- [ ] [Measurable success criterion]
- [ ] [Performance/quality requirement]

### Module: [Next Module Name]
[Repeat structure above]
```

---

## Phase 3: Implementation Execution
**REQUIRED ACTIONS:**
1. Implement each module following the plan from Phase 2
2. Verify ALL acceptance criteria are met before proceeding
3. Ensure code adheres to conventions identified in Phase 1

**QUALITY GATES:**
- [ ] All acceptance criteria validated
- [ ] Code follows established conventions
- [ ] Minimalistic approach maintained
- [ ] Expert-level implementation standards met

---

## Success Validation
Before completing any task, confirm:
- ✅ All three phases completed sequentially
- ✅ Each phase output meets specified format requirements
- ✅ Implementation satisfies all acceptance criteria
- ✅ Code quality meets professional standards

## Response Structure
Always structure your response as:
1. **Phase 1 Results**: [Codebase analysis findings]
2. **Phase 2 Plan**: [Implementation roadmap]  
3. **Phase 3 Implementation**: [Actual code with validation]
</file>

<file path="CURRENT_STATUS.md">
# Excel Macro Automation - 현재 구현 상태

## 🚀 실행 방법

```bash
# 1. 가상환경 활성화
source venv/bin/activate

# 2. GUI 실행
python run_gui.py
# 또는
./start_gui.sh
```

## ✅ 구현 완료된 기능

### 1. Excel 연동 (T-002) ✓
- Excel 파일 불러오기 (.xlsx, .xls, .csv)
- 시트 선택 및 전환
- 데이터 미리보기 (처음 100행)
- 열 매핑 설정
- 상태 열 자동 추가/업데이트

### 2. 매크로 에디터 (T-003) ✓
- **드래그 앤 드롭** 방식의 직관적인 UI
- 단계 추가/삭제/순서 변경
- 각 단계별 상세 설정
- 실시간 매크로 미리보기

### 3. 지원되는 매크로 단계

#### 마우스 동작
- **마우스 클릭** 🖱️
  - 좌표 지정, 클릭 횟수, 버튼 선택
- **마우스 이동** ↗️
  - 좌표로 이동, 이동 시간 설정

#### 키보드 동작
- **텍스트 입력** ⌨️
  - 일반 텍스트 입력
  - Excel 변수 바인딩 ({{변수명}})
- **단축키** ⌘
  - Ctrl, Alt, Shift 조합키 지원

#### 대기 동작
- **시간 대기** ⏱️
  - 초 단위 대기 시간 설정
- **이미지 대기** 🖼️ (T-005) ✓
  - 화면에서 이미지가 나타날 때까지 대기
  - ROI(관심 영역) 지정 가능
  - 신뢰도 설정

#### 화면 인식 (T-005, T-006) ✓
- **이미지 검색** 🔍
  - OpenCV 기반 고급 이미지 매칭
  - DPI 스케일링 자동 처리
  - 멀티 모니터 지원
- **텍스트 검색** 🔤
  - EasyOCR 기반 한국어/영어 텍스트 인식
  - Excel 열 데이터와 연동
  - 찾은 텍스트 자동 클릭

#### 제어 구조 (T-007) 🚧
- **조건문** ❓ (개발 중)
- **반복문** 🔄 (예정)

### 4. 매크로 실행 엔진 (T-004) ✓
- Excel 행 단위 순차 실행
- 일시정지/재개 (F9)
- 강제 종료 (ESC)
- 실행 로그 기록
- 진행률 표시

### 5. 매크로 저장/불러오기 (T-008) ✓
- JSON 형식 저장
- 암호화 저장 옵션
- 자동 백업
- 템플릿 제공

## 🔧 기술 스택

- **언어**: Python 3.10
- **GUI**: PyQt5
- **자동화**: PyAutoGUI
- **이미지 처리**: OpenCV
- **OCR**: EasyOCR
- **Excel**: pandas, openpyxl

## 📁 프로젝트 구조

```
macro/
├── src/
│   ├── automation/     # 실행 엔진
│   ├── config/         # 설정 관리
│   ├── core/           # 핵심 비즈니스 로직
│   ├── excel/          # Excel 처리
│   ├── logger/         # 로깅
│   ├── ui/             # 사용자 인터페이스
│   │   ├── dialogs/    # 다이얼로그
│   │   └── widgets/    # 위젯 컴포넌트
│   ├── utils/          # 유틸리티
│   └── vision/         # 이미지/텍스트 인식
├── venv/               # 가상환경
├── demo_data.xlsx      # 테스트용 Excel 데이터
└── run_gui.py          # GUI 실행 스크립트
```

## 🎯 다음 단계 (개발 중)

- [ ] T-007: 조건문 UI 및 실행 로직
- [ ] T-009: 실행 로깅 개선
- [ ] T-010: 매크로 테스트 시뮬레이터
- [ ] T-011: 다크 모드
- [ ] T-012: 다국어 지원

## 💡 사용 팁

1. **Excel 데이터 준비**
   - 첫 번째 행은 열 제목으로 사용
   - '상태' 열은 자동으로 추가됨

2. **매크로 만들기**
   - 왼쪽 팔레트에서 단계를 드래그하여 추가
   - 각 단계를 클릭하여 상세 설정
   - {{변수명}} 형식으로 Excel 데이터 참조

3. **이미지/텍스트 검색**
   - ROI 선택 시 화면이 반투명하게 변함
   - 드래그하여 검색 영역 지정
   - 테스트 버튼으로 미리 확인 가능

## 🐛 알려진 이슈

- WSL 환경에서 tkinter 경고 (무시 가능)
- High DPI 디스플레이에서 좌표 보정 필요할 수 있음

## 📞 문의

문제가 발생하거나 기능 제안이 있으시면 이슈를 등록해주세요.
</file>

<file path="package.json">
{
  "name": "macro",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs"
}
</file>

<file path="pyproject.toml">
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "excel-macro-automation"
version = "1.0.0"
description = "Excel-based task automation macro desktop application"
readme = "README.md"
requires-python = ">=3.8"
license = {text = "MIT"}
authors = [
    {name = "Excel Macro Team", email = "contact@excelmacro.com"}
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: MIT License",
    "Operating System :: Microsoft :: Windows",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Topic :: Office/Business",
]

[project.scripts]
excel-macro = "main:main"

[tool.black]
line-length = 100
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''

[tool.pytest.ini_options]
minversion = "6.0"
addopts = "-ra -q --strict-markers"
testpaths = [
    "tests",
]
python_files = [
    "test_*.py",
    "*_test.py",
]

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true

[tool.flake8]
max-line-length = 100
exclude = [
    ".git",
    "__pycache__",
    "docs/source/conf.py",
    "old",
    "build",
    "dist",
    ".eggs",
    "*.egg",
]
</file>

<file path="README.md">
# Excel Macro Automation

Excel-based task automation macro desktop application for Windows.

## Overview

This application allows users to automate repetitive tasks by reading task lists from Excel files and executing predefined sequences of mouse, keyboard, and screen recognition actions.

## Features

- Excel file integration with sheet/column mapping
- Drag & drop macro editor
- Mouse and keyboard automation
- Image search and OCR capabilities
- Conditional logic and loops
- Execution logging
- Multi-language support (Korean/English)

## Requirements

- Windows 10/11 64-bit
- Python 3.8+
- 1280x720 minimum screen resolution

## Installation

1. Clone the repository:
```bash
git clone https://github.com/reahbi/macro.git
cd macro
```

2. Create virtual environment (requires python3-venv package):
```bash
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

## Development

Run the application:
```bash
python main.py
```

Run tests:
```bash
pytest
```

Build executable:
```bash
pyinstaller excel_macro.spec
```

## Project Structure

```
macro/
├── src/
│   ├── excel/        # Excel integration modules
│   ├── ui/           # PyQt5 GUI components
│   ├── automation/   # Automation engine
│   ├── core/         # Core business logic
│   ├── plugin/       # Plugin system
│   ├── utils/        # Utilities (encryption, etc.)
│   ├── config/       # Configuration management
│   └── logger/       # Logging system
├── tests/            # Test suites
├── resources/        # Icons, templates, locales
├── docs/             # Documentation
└── main.py           # Application entry point
```

## License

MIT License
</file>

<file path="run_from_windows_native.ps1">
# Excel Macro Automation - Windows Native Execution
# PowerShell script for running the application directly on Windows

Write-Host "=" * 50
Write-Host "Excel Macro Automation - Windows Native Setup"
Write-Host "=" * 50

# Check if running as administrator
if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Host "이 스크립트는 관리자 권한이 필요합니다." -ForegroundColor Red
    Write-Host "PowerShell을 관리자 권한으로 다시 실행해주세요." -ForegroundColor Yellow
    pause
    exit
}

# WSL path to Windows path conversion
$wslPath = "\\wsl.localhost\Ubuntu\home\nosky\macro"
$windowsPath = "C:\ExcelMacroAutomation"

Write-Host "`n1. 프로젝트 파일 복사 중..." -ForegroundColor Green

# Create directory if not exists
if (!(Test-Path $windowsPath)) {
    New-Item -ItemType Directory -Path $windowsPath | Out-Null
}

# Copy files from WSL to Windows
Write-Host "   WSL에서 Windows로 파일 복사 중..."
Copy-Item -Path "$wslPath\*" -Destination $windowsPath -Recurse -Force -ErrorAction SilentlyContinue

Write-Host "`n2. Python 확인 중..." -ForegroundColor Green

# Check Python installation
try {
    $pythonVersion = python --version 2>&1
    Write-Host "   Python 발견: $pythonVersion" -ForegroundColor Green
} catch {
    Write-Host "   Python이 설치되어 있지 않습니다." -ForegroundColor Red
    Write-Host "   Python 다운로드 페이지를 엽니다..." -ForegroundColor Yellow
    Start-Process "https://www.python.org/downloads/"
    Write-Host "   Python 설치 후 이 스크립트를 다시 실행해주세요."
    pause
    exit
}

Write-Host "`n3. 필수 패키지 설치 중..." -ForegroundColor Green

# Create virtual environment
Set-Location $windowsPath
if (!(Test-Path "venv_windows")) {
    Write-Host "   가상환경 생성 중..."
    python -m venv venv_windows
}

# Activate virtual environment and install packages
Write-Host "   패키지 설치 중 (시간이 걸릴 수 있습니다)..."
& "$windowsPath\venv_windows\Scripts\python.exe" -m pip install --upgrade pip | Out-Null
& "$windowsPath\venv_windows\Scripts\python.exe" -m pip install PyQt5 pandas openpyxl pyautogui opencv-python numpy easyocr flask

Write-Host "`n4. Windows용 실행 스크립트 생성 중..." -ForegroundColor Green

# Create run script for Windows
$runScript = @'
import sys
import os
from pathlib import Path

# Add project paths
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# Import and run main
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    
    app = QApplication(sys.argv)
    
    from ui.main_window import MainWindow
    from config.settings import Settings
    
    settings = Settings()
    window = MainWindow(settings)
    window.show()
    
    print("\nExcel Macro Automation이 실행되었습니다!")
    print("Windows 네이티브 모드로 실행 중...")
    
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"오류: {e}")
    import traceback
    traceback.print_exc()
    input("\n엔터를 눌러 종료...")
'@

$runScript | Out-File -FilePath "$windowsPath\run_windows.py" -Encoding UTF8

Write-Host "`n5. 배치 파일 생성 중..." -ForegroundColor Green

# Create batch file for easy execution
$batchFile = @"
@echo off
cd /d $windowsPath
call venv_windows\Scripts\activate
python run_windows.py
pause
"@

$batchFile | Out-File -FilePath "$windowsPath\ExcelMacroAutomation.bat" -Encoding ASCII

Write-Host "`n6. 바탕화면 바로가기 생성 중..." -ForegroundColor Green

# Create desktop shortcut
$desktopPath = [Environment]::GetFolderPath("Desktop")
$shortcut = (New-Object -ComObject WScript.Shell).CreateShortcut("$desktopPath\Excel Macro Automation.lnk")
$shortcut.TargetPath = "$windowsPath\ExcelMacroAutomation.bat"
$shortcut.WorkingDirectory = $windowsPath
$shortcut.IconLocation = "C:\Windows\System32\shell32.dll,13"
$shortcut.Save()

Write-Host "`n✅ 설치 완료!" -ForegroundColor Green
Write-Host "`n실행 옵션:" -ForegroundColor Yellow
Write-Host "1. 바탕화면의 'Excel Macro Automation' 바로가기 더블클릭"
Write-Host "2. $windowsPath\ExcelMacroAutomation.bat 실행"
Write-Host "3. 이 PowerShell에서: & '$windowsPath\ExcelMacroAutomation.bat'"

Write-Host "`n지금 실행하시겠습니까? (Y/N): " -NoNewline
$response = Read-Host

if ($response -eq 'Y' -or $response -eq 'y') {
    Write-Host "`n애플리케이션을 실행합니다..." -ForegroundColor Green
    Start-Process "$windowsPath\ExcelMacroAutomation.bat"
}

Write-Host "`n완료되었습니다. 엔터를 눌러 종료..." -ForegroundColor Green
pause
</file>

<file path="run_main_fixed.py">
#!/usr/bin/env python3
"""
Import 문제를 해결한 메인 실행 스크립트
"""

import sys
import os
from pathlib import Path

# UTF-8 인코딩 설정
import locale
if sys.platform == 'win32':
    # Windows에서 UTF-8 설정
    os.environ['PYTHONIOENCODING'] = 'utf-8'
    try:
        locale.setlocale(locale.LC_ALL, 'ko_KR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_ALL, 'Korean_Korea.949')
        except:
            pass

# 프로젝트 경로 설정
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python 경로에 추가
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# 모든 import 문제 해결
def fix_all_imports():
    """모든 파일의 import 경로를 수정"""
    print("Import 경로 수정 중...")
    
    # src 디렉토리가 없으면 생성
    src_path.mkdir(exist_ok=True)
    
    # 모든 Python 파일 찾기
    for py_file in src_path.rglob("*.py"):
        if py_file.is_file():
            try:
                content = py_file.read_text(encoding='utf-8')
                original_content = content
                
                # 상대 import를 절대 import로 변경
                import re
                
                # from ..module import 패턴 변경
                content = re.sub(r'from \.\.\.([^.\s]+)', r'from \1', content)
                content = re.sub(r'from \.\.([^.\s]+)', r'from \1', content)
                content = re.sub(r'from \.([^.\s]+)', r'from ui.\1', content)
                
                # 특정 import 수정
                content = content.replace("from dialogs.", "from ui.dialogs.")
                content = content.replace("from widgets.", "from ui.widgets.")
                
                # 잘못된 위치 수정
                content = content.replace("from ui.macro_types import", "from core.macro_types import")
                content = content.replace("from ui.macro_storage import", "from core.macro_storage import")
                content = content.replace("from ui.file_selector import", "from ui.widgets.file_selector import")
                content = content.replace("from ui.sheet_mapper import", "from ui.widgets.sheet_mapper import")
                content = content.replace("from ui.data_preview import", "from ui.widgets.data_preview import")
                content = content.replace("from ui.models import", "from excel.models import")
                content = content.replace("from ui.executor import", "from automation.executor import")
                content = content.replace("from ui.hotkey_listener import", "from automation.hotkey_listener import")
                content = content.replace("from ui.image_matcher import", "from vision.image_matcher import")
                content = content.replace("from ui.text_extractor import", "from vision.text_extractor import")
                
                # 파일이 변경되었으면 저장
                if content != original_content:
                    py_file.write_text(content, encoding='utf-8')
                    print(f"수정됨: {py_file.relative_to(src_path)}")
                    
            except Exception as e:
                print(f"파일 수정 오류 {py_file}: {e}")
    
    print("Import 경로 수정 완료")

# Import 수정 실행
fix_all_imports()

# 환경 변수 설정
if sys.platform == 'win32':
    os.environ['QT_QPA_PLATFORM'] = 'windows'
else:
    os.environ['QT_QPA_PLATFORM'] = 'xcb'

# 메인 애플리케이션 실행
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    from PyQt5.QtGui import QFont
    
    # High DPI 지원
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    
    # 애플리케이션 초기화
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # 폰트 설정
    if sys.platform == 'win32':
        font = QFont("맑은 고딕", 10)
    else:
        font = QFont("Nanum Gothic", 10)
    app.setFont(font)
    
    # 메인 윈도우 import 및 실행
    print("모듈 import 중...")
    
    try:
        from ui.main_window import MainWindow
        print("✓ MainWindow import 완료")
    except Exception as e:
        print(f"✗ MainWindow import 실패: {e}")
        raise
        
    try:
        from config.settings import Settings
        print("✓ Settings import 완료")
    except Exception as e:
        print(f"✗ Settings import 실패: {e}")
        raise
        
    try:
        from logger.app_logger import setup_logger
        print("✓ Logger import 완료")
    except Exception as e:
        print(f"✗ Logger import 실패: {e}")
        raise
    
    # 로거 설정
    try:
        logger = setup_logger()
        logger.info("Starting Excel Macro Automation Application")
        print("✓ Logger 설정 완료")
    except Exception as e:
        print(f"✗ Logger 설정 실패: {e}")
        # Logger 실패해도 계속 진행
        logger = None
    
    # 설정 초기화
    try:
        settings = Settings()
        print("✓ Settings 초기화 완료")
    except Exception as e:
        print(f"✗ Settings 초기화 실패: {e}")
        raise
    
    # 메인 윈도우 생성 및 표시
    try:
        print("✓ MainWindow 객체 생성 중...")
        window = MainWindow(settings)
        print("✓ MainWindow 객체 생성 완료")
        
        print("✓ 윈도우 타이틀 설정 중...")
        window.setWindowTitle("Excel 기반 작업 자동화 매크로")
        print("✓ 윈도우 타이틀 설정 완료")
        
        print("✓ 윈도우 표시 중...")
        window.show()
        print("✓ 윈도우 표시 완료")
        
        print("\n✓ Excel Macro Automation 애플리케이션이 실행되었습니다!")
        print("✓ 모든 GUI 컴포넌트가 로드되었습니다.")
        print("\n기능:")
        print("- Excel 탭: 파일 불러오기, 시트 선택, 데이터 미리보기")
        print("- Editor 탭: 드래그 앤 드롭 매크로 편집")
        print("- Run 탭: 매크로 실행 및 모니터링")
        print("\n창을 닫으면 종료됩니다.")
        print("\n✓ 이벤트 루프 시작 중...")
        
        # 이벤트 루프 실행
        result = app.exec_()
        print(f"\n✓ 이벤트 루프 종료됨 (코드: {result})")
        sys.exit(result)
        
    except Exception as window_error:
        print(f"\n메인 윈도우 생성 중 오류: {window_error}")
        import traceback
        traceback.print_exc()
        raise
    
except Exception as e:
    print(f"\n오류 발생: {e}")
    print("\n자세한 오류 정보:")
    import traceback
    traceback.print_exc()
    
    print("\n디버깅 정보:")
    print(f"Project root: {project_root}")
    print(f"Src path: {src_path}")
    print(f"Python path: {sys.path[:3]}")
    print(f"Platform: {sys.platform}")
    
    input("\nPress Enter to exit...")
</file>

<file path="run_simple.py">
#!/usr/bin/env python3
"""
간단한 실행 스크립트 - import 문제 해결
"""

import sys
import os
from pathlib import Path

# 프로젝트 경로 설정
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python 경로에 추가
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# 환경 변수 설정
os.environ['QT_QPA_PLATFORM'] = 'xcb'

print("Excel Macro Automation 시작...")

try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    
    # High DPI 설정
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    
    # 애플리케이션 생성
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # 설정 및 로거 초기화
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    settings = Settings()
    logger = setup_logger()
    
    # 메인 윈도우 생성
    from ui.main_window import MainWindow
    window = MainWindow(settings)
    
    # 윈도우 표시
    window.show()
    
    print("✓ GUI가 실행되었습니다!")
    print("종료하려면 창을 닫으세요.")
    
    # 이벤트 루프 실행
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"\n오류 발생: {e}")
    import traceback
    traceback.print_exc()
    input("\nEnter를 눌러 종료...")
</file>

<file path="run_windows_wsl.sh">
#!/bin/bash
# Windows + WSL2 환경 실행 스크립트

echo "Windows + WSL2 환경에서 Excel Macro Automation 실행"
echo "=================================================="

# Windows IP 주소 가져오기
WINDOWS_IP=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}')
export DISPLAY=$WINDOWS_IP:0.0
export LIBGL_ALWAYS_INDIRECT=1

echo "Windows IP: $WINDOWS_IP"
echo "DISPLAY 설정: $DISPLAY"
echo ""

# X Server 연결 테스트
echo "X Server 연결 테스트 중..."
if command -v xset &> /dev/null; then
    if xset q &>/dev/null; then
        echo "✓ X Server 연결 성공!"
    else
        echo "✗ X Server에 연결할 수 없습니다."
        echo ""
        echo "다음을 확인하세요:"
        echo "1. Windows에서 VcXsrv 또는 MobaXterm이 실행 중인가?"
        echo "2. VcXsrv 설정에서 'Disable access control'이 체크되어 있는가?"
        echo "3. Windows 방화벽이 X Server를 차단하고 있지 않은가?"
        echo ""
        echo "VcXsrv 다운로드: https://sourceforge.net/projects/vcxsrv/"
        exit 1
    fi
else
    echo "xset이 설치되지 않았습니다. X Server 테스트를 건너뜁니다."
fi

echo ""
echo "가상환경 활성화..."
source venv/bin/activate

echo "Python 경로: $(which python)"
echo "Python 버전: $(python --version)"
echo ""

# 애플리케이션 실행
echo "애플리케이션을 실행합니다..."
python run_simple.py
</file>

<file path="run_windows.ps1">
# PowerShell script to run the macro application on Windows
# This script helps run the WSL-developed app in native Windows environment

Write-Host "=== Excel Macro Automation Tool - Windows Runner ===" -ForegroundColor Cyan

# Check if Python is installed
try {
    $pythonVersion = python --version 2>&1
    Write-Host "Found Python: $pythonVersion" -ForegroundColor Green
} catch {
    Write-Host "Python is not installed or not in PATH!" -ForegroundColor Red
    Write-Host "Please install Python from python.org" -ForegroundColor Yellow
    exit 1
}

# Get the script directory
$scriptPath = $PSScriptRoot
if (-not $scriptPath) {
    $scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
}

# Handle UNC/WSL paths
if ($scriptPath -like "\\wsl*" -or $scriptPath -like "\\\\*") {
    Write-Host "Detected WSL/UNC path. Creating temporary copy..." -ForegroundColor Yellow
    
    $tempDir = Join-Path $env:TEMP "excel_macro_tool"
    if (Test-Path $tempDir) {
        Remove-Item $tempDir -Recurse -Force
    }
    
    # Create the directory first
    New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
    
    Write-Host "Copying files to: $tempDir" -ForegroundColor Yellow
    
    # Copy files and directories separately to avoid errors
    Get-ChildItem -Path $scriptPath -File | ForEach-Object {
        Copy-Item -Path $_.FullName -Destination $tempDir -Force
    }
    
    # Copy src directory
    if (Test-Path (Join-Path $scriptPath "src")) {
        Copy-Item -Path (Join-Path $scriptPath "src") -Destination $tempDir -Recurse -Force
    }
    
    # Copy other important directories if they exist
    @("resources", "captures", "docs") | ForEach-Object {
        $dirPath = Join-Path $scriptPath $_
        if (Test-Path $dirPath) {
            Copy-Item -Path $dirPath -Destination $tempDir -Recurse -Force
        }
    }
    
    $scriptPath = $tempDir
}

# Change to the script directory
Set-Location $scriptPath
Write-Host "Working directory: $(Get-Location)" -ForegroundColor Green

# Check if virtual environment exists
$venvPath = Join-Path $scriptPath "venv"
$venvActivate = Join-Path $venvPath "Scripts\Activate.ps1"

if (Test-Path $venvActivate) {
    Write-Host "Activating virtual environment..." -ForegroundColor Yellow
    & $venvActivate
} else {
    Write-Host "No virtual environment found. Creating one..." -ForegroundColor Yellow
    python -m venv venv
    & $venvActivate
}

# Install/update dependencies
Write-Host "`nChecking dependencies..." -ForegroundColor Yellow
$requirementsPath = Join-Path $scriptPath "requirements.txt"

if (Test-Path $requirementsPath) {
    Write-Host "Installing requirements..." -ForegroundColor Yellow
    pip install -r requirements.txt --quiet
} else {
    Write-Host "No requirements.txt found. Installing core packages..." -ForegroundColor Yellow
    pip install PyQt5 pandas openpyxl pyautogui pillow screeninfo cryptography --quiet
}

# Set environment variables for better Windows compatibility
$env:QT_AUTO_SCREEN_SCALE_FACTOR = "1"
$env:QT_ENABLE_HIGHDPI_SCALING = "1"

# Run the application
Write-Host "`nStarting Excel Macro Automation Tool..." -ForegroundColor Green
Write-Host "Note: Running in native Windows mode for better GUI compatibility" -ForegroundColor Cyan

try {
    python run_main_fixed.py
} catch {
    Write-Host "`nError running application: $_" -ForegroundColor Red
    Write-Host "Press any key to exit..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}
</file>

<file path="run_with_debug.py">
#!/usr/bin/env python3
"""
디버그 모드로 실행
"""

import sys
import os
from pathlib import Path

# 프로젝트 경로 설정
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# Windows IP 자동 감지
import subprocess
result = subprocess.run(['cat', '/etc/resolv.conf'], capture_output=True, text=True)
for line in result.stdout.split('\n'):
    if 'nameserver' in line:
        windows_ip = line.split()[1]
        break

# 여러 DISPLAY 설정 시도
display_options = [
    f"{windows_ip}:0.0",
    f"{windows_ip}:0",
    "localhost:0.0",
    "localhost:0",
    ":0.0",
    ":0"
]

print("=== GUI 실행 시도 ===")
print(f"Windows IP: {windows_ip}")

for display in display_options:
    print(f"\nDISPLAY={display} 시도 중...")
    os.environ['DISPLAY'] = display
    os.environ['LIBGL_ALWAYS_INDIRECT'] = '1'
    
    try:
        from PyQt5.QtWidgets import QApplication, QMessageBox
        from PyQt5.QtCore import Qt, QTimer
        
        # High DPI 설정
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        
        app = QApplication(sys.argv)
        
        # 간단한 메시지 박스 표시
        msg = QMessageBox()
        msg.setWindowTitle("연결 성공!")
        msg.setText(f"X Server 연결 성공!\nDISPLAY: {display}")
        msg.setIcon(QMessageBox.Information)
        msg.setStandardButtons(QMessageBox.Ok)
        
        # 3초 후 자동 닫기
        QTimer.singleShot(3000, msg.close)
        
        msg.show()
        
        print(f"✓ 성공! DISPLAY={display}")
        print("\n올바른 DISPLAY 설정을 찾았습니다.")
        print(f"다음 명령어로 실행하세요:")
        print(f"export DISPLAY={display}")
        print(f"source venv/bin/activate")
        print(f"python run_simple.py")
        
        app.exec_()
        break
        
    except Exception as e:
        print(f"✗ 실패: {e}")
        continue
else:
    print("\n모든 DISPLAY 설정이 실패했습니다.")
    print("\nVcXsrv 설정을 확인하세요:")
    print("1. VcXsrv가 실행 중인가?")
    print("2. 'Disable access control' 옵션이 체크되어 있는가?")
    print("3. Windows 방화벽이 차단하고 있지 않은가?")
</file>

<file path="RUNNING_GUIDE.md">
# Excel Macro Automation 실행 가이드

## 🚀 빠른 시작

### 1. 가상환경 활성화
```bash
source venv/bin/activate
```

### 2. 애플리케이션 실행
```bash
python run_simple.py
```

또는

```bash
./start_gui.sh
```

## ⚙️ 실행 환경 확인

### WSL2 GUI 지원 확인
```bash
# DISPLAY 환경 변수 확인
echo $DISPLAY
# 출력: :0 또는 :0.0

# X11 소켓 확인
ls /tmp/.X11-unix/
# 출력: X0
```

### Python 환경 확인
```bash
# 가상환경 활성화 상태 확인
which python
# 출력: /home/nosky/macro/venv/bin/python

# PyQt5 설치 확인
python -c "import PyQt5; print('PyQt5 OK')"
```

## 🔧 문제 해결

### GUI가 표시되지 않을 때

1. **WSLg 업데이트**
   ```bash
   wsl --update
   ```

2. **X11 관련 패키지 설치**
   ```bash
   sudo apt-get update
   sudo apt-get install x11-apps
   
   # 테스트
   xclock  # 시계가 표시되면 정상
   ```

3. **한글 폰트 설치** (이미 설치됨)
   ```bash
   sudo apt-get install fonts-nanum fonts-noto-cjk
   ```

### "tkinter" 경고 메시지
- PyAutoGUI의 의존성 때문에 나타나는 메시지로 무시해도 됩니다
- 우리 앱은 PyQt5를 사용하므로 tkinter가 필요하지 않습니다

### Import 오류 발생 시
```bash
# run_main.py 대신 run_simple.py 사용
python run_simple.py
```

## 📁 실행 파일 설명

- `run_main.py`: 자동 import 패치 기능이 있는 메인 실행 파일
- `run_simple.py`: 간단한 실행 파일 (import 문제 시 사용)
- `start_gui.sh`: 셸 스크립트 실행 파일

## 💡 팁

1. **첫 실행 시**
   - EasyOCR 모델을 다운로드하므로 시간이 걸릴 수 있습니다
   - 인터넷 연결이 필요합니다

2. **성능 향상**
   - ROI(관심 영역)를 지정하여 OCR/이미지 검색 속도 향상
   - 불필요한 단계는 비활성화

3. **디버깅**
   - 로그 파일 확인: `logs/` 디렉토리
   - 설정 파일: `~/.excel_macro_automation/settings.yaml`

## 🎯 다음 단계

1. Excel 파일 불러오기 (Excel 탭)
2. 매크로 단계 추가 (Editor 탭)
3. 매크로 실행 (Run 탭)

자세한 사용법은 `CURRENT_STATUS.md` 참조
</file>

<file path="setup_wsl_gui.sh">
#!/bin/bash
# WSL GUI 설정 스크립트

echo "=== WSL GUI 환경 설정 ==="

# 1. Windows IP 자동 감지
WINDOWS_IP=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2; exit;}')
echo "Windows IP: $WINDOWS_IP"

# 2. DISPLAY 환경 변수 설정
export DISPLAY=$WINDOWS_IP:0.0
export LIBGL_ALWAYS_INDIRECT=1

echo "DISPLAY 설정: $DISPLAY"

# 3. .bashrc에 영구 설정 추가 (이미 없는 경우만)
if ! grep -q "export DISPLAY=" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "# WSL GUI Support" >> ~/.bashrc
    echo "export DISPLAY=\$(cat /etc/resolv.conf | grep nameserver | awk '{print \$2; exit;}'):0.0" >> ~/.bashrc
    echo "export LIBGL_ALWAYS_INDIRECT=1" >> ~/.bashrc
    echo "✓ ~/.bashrc에 DISPLAY 설정이 추가되었습니다."
else
    echo "✓ ~/.bashrc에 이미 DISPLAY 설정이 있습니다."
fi

# 4. 필요한 패키지 확인
echo ""
echo "필요한 패키지 확인 중..."

# PyQt5 확인
if python3 -c "import PyQt5" 2>/dev/null; then
    echo "✓ PyQt5가 설치되어 있습니다."
else
    echo "✗ PyQt5가 설치되지 않았습니다."
fi

# 5. X Server 연결 테스트
echo ""
echo "X Server 연결 테스트..."
if command -v xeyes &> /dev/null; then
    timeout 2 xeyes 2>/dev/null &
    XEYES_PID=$!
    sleep 1
    if kill -0 $XEYES_PID 2>/dev/null; then
        echo "✓ X Server 연결 성공! (xeyes가 표시되어야 합니다)"
        kill $XEYES_PID 2>/dev/null
    else
        echo "✗ X Server 연결 실패"
        echo ""
        echo "다음을 확인하세요:"
        echo "1. Windows에서 VcXsrv가 실행 중인가?"
        echo "2. VcXsrv 설정에서 'Disable access control'이 체크되어 있는가?"
        echo "3. Windows 방화벽이 VcXsrv를 차단하고 있지 않은가?"
    fi
fi

echo ""
echo "설정이 완료되었습니다."
echo "새 터미널을 열거나 다음 명령을 실행하세요:"
echo "source ~/.bashrc"
</file>

<file path="start_gui.sh">
#!/bin/bash
# Excel Macro Automation 실행 스크립트

echo "Excel Macro Automation GUI 시작..."
echo "=================================="

# 가상환경 활성화
source venv/bin/activate

# 환경 변수 설정
export DISPLAY=${DISPLAY:-:0}
export QT_QPA_PLATFORM=xcb
export QT_DEBUG_PLUGINS=0

# Python 경로 출력
echo "Python 경로: $(which python)"
echo "Python 버전: $(python --version)"
echo ""

# GUI 실행
echo "GUI를 실행합니다..."
python run_main.py

echo "=================================="
echo "프로그램이 종료되었습니다."
</file>

<file path="usage_tracking2.json">
{
  "user_id": "f6904afa-4a7e-42ad-8e37-34f0262bc38a",
  "first_run": "2025-07-15T22:50:40.701999"
}
</file>

<file path="web_ui_enhanced.py">
#!/usr/bin/env python3
"""
향상된 웹 UI - 마우스 좌표 캡처 및 이미지 붙여넣기 기능 포함
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
import base64
import tempfile
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List
import io

# Flask 설치 확인
try:
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS
except ImportError:
    print("필수 패키지 설치 중...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask", "flask-cors"])
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS

# 추가 패키지 설치 확인
try:
    import pyautogui
    import pyperclip
    from PIL import Image, ImageGrab
    import keyboard
    import mouse
except ImportError:
    print("추가 패키지 설치 중...")
    subprocess.run([sys.executable, "-m", "pip", "install", "pyautogui", "pyperclip", "pillow", "keyboard", "mouse"])
    import pyautogui
    import pyperclip
    from PIL import Image, ImageGrab
    import keyboard
    import mouse

# 프로젝트 경로 설정
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# 기존 매크로 모듈 import 시도
try:
    from core.macro_types import (
        MacroStep, StepType, MouseClickStep, KeyboardTypeStep,
        WaitTimeStep, ImageSearchStep, TextSearchStep, IfConditionStep,
        ConditionType, ComparisonOperator
    )
    from automation.executor import MacroExecutor
    from excel.excel_manager import ExcelManager
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    MODULES_LOADED = True
except Exception as e:
    print(f"경고: 일부 모듈을 로드할 수 없습니다: {e}")
    MODULES_LOADED = False

app = Flask(__name__)
CORS(app)

# 전역 상태 관리
class AppState:
    def __init__(self):
        self.excel_manager = ExcelManager() if MODULES_LOADED else None
        self.macro_steps: List[Dict] = []
        self.executor = None
        self.execution_thread = None
        self.execution_log = []
        self.is_running = False
        self.settings = Settings() if MODULES_LOADED else None
        self.mouse_position = {'x': 0, 'y': 0}
        self.is_tracking_mouse = False
        self.captured_images = {}  # 이미지 임시 저장소
        
    def add_log(self, message: str, level: str = "info"):
        self.execution_log.append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': level,
            'message': message
        })

app_state = AppState()

# 마우스 위치 추적 스레드
def track_mouse_position():
    """백그라운드에서 마우스 위치를 계속 추적"""
    while True:
        if app_state.is_tracking_mouse:
            try:
                x, y = pyautogui.position()
                app_state.mouse_position = {'x': x, 'y': y}
            except:
                pass
        time.sleep(0.1)

# 마우스 추적 스레드 시작
mouse_thread = threading.Thread(target=track_mouse_position, daemon=True)
mouse_thread.start()

# HTML 템플릿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - Enhanced</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #667eea;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        .button.secondary {
            background: #757575;
        }
        .button.success {
            background: #4CAF50;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }
        .step-type-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .macro-step {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .step-config-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .form-group {
            margin: 20px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .mouse-position {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 20px;
            margin: 20px 0;
        }
        .capture-button {
            background: #FF9800;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            margin: 10px;
        }
        .image-preview {
            max-width: 100%;
            max-height: 300px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .paste-area {
            border: 2px dashed #667eea;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s;
        }
        .paste-area:hover {
            background: #f8f9ff;
            border-color: #764ba2;
        }
        .paste-area.dragover {
            background: #e8eaff;
            border-color: #4CAF50;
        }
        .coordinate-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }
        .coord-box {
            background: #f8f9ff;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .hint-text {
            color: #666;
            font-size: 14px;
            margin: 10px 0;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Excel Macro Automation - Enhanced</h1>
            <p>마우스 좌표 캡처 및 이미지 붙여넣기 기능 포함</p>
            <div class="status-badge">
                상태: <span id="status">준비됨</span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">📊 Excel</button>
            <button class="tab" onclick="showTab('editor')">✏️ Editor</button>
            <button class="tab" onclick="showTab('run')">▶️ Run</button>
            <button class="tab" onclick="showTab('tools')">🛠️ Tools</button>
        </div>
        
        <div class="content">
            <!-- Excel 탭 -->
            <div id="excel" class="panel active">
                <h2>Excel 파일 관리</h2>
                <div>
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">업로드</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor 탭 -->
            <div id="editor" class="panel">
                <h2>매크로 편집기</h2>
                <div class="step-palette">
                    <div class="step-type-card" onclick="addStep('mouse_click')">
                        <div>🖱️</div>
                        <div>마우스 클릭</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('keyboard_type')">
                        <div>⌨️</div>
                        <div>텍스트 입력</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('wait_time')">
                        <div>⏱️</div>
                        <div>대기</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('image_search')">
                        <div>🔍</div>
                        <div>이미지 검색</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('ocr_text')">
                        <div>🔤</div>
                        <div>텍스트 검색</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('if_condition')">
                        <div>❓</div>
                        <div>조건문</div>
                    </div>
                </div>
                
                <h3>현재 매크로</h3>
                <div id="macroSteps"></div>
                
                <button class="button" onclick="saveMacro()">💾 매크로 저장</button>
                <button class="button secondary" onclick="clearMacro()">🗑️ 초기화</button>
            </div>
            
            <!-- Run 탭 -->
            <div id="run" class="panel">
                <h2>매크로 실행</h2>
                <button class="button" onclick="runMacro()">▶️ 실행</button>
                <button class="button secondary" onclick="stopMacro()">⏹️ 중지</button>
                
                <h3>실행 로그</h3>
                <div id="executionLog" class="execution-log"></div>
            </div>
            
            <!-- Tools 탭 -->
            <div id="tools" class="panel">
                <h2>유용한 도구</h2>
                
                <h3>🎯 마우스 좌표 캡처</h3>
                <div class="mouse-position">
                    <div class="coordinate-display">
                        <div class="coord-box">X: <span id="mouseX">0</span></div>
                        <div class="coord-box">Y: <span id="mouseY">0</span></div>
                    </div>
                    <p class="hint-text">마우스를 움직여서 좌표를 확인하세요</p>
                    <button class="capture-button" onclick="toggleMouseTracking()">
                        <span id="trackingText">🎯 좌표 추적 시작</span>
                    </button>
                    <p class="hint-text" id="captureHint" style="display: none;">
                        F9 키를 눌러서 현재 좌표를 캡처하세요
                    </p>
                </div>
                
                <h3>📸 스크린샷 캡처</h3>
                <button class="button success" onclick="captureScreen()">
                    📷 전체 화면 캡처
                </button>
                <button class="button success" onclick="captureRegion()">
                    ✂️ 영역 선택 캡처
                </button>
                
                <h3>🖼️ 이미지 붙여넣기</h3>
                <div class="paste-area" onclick="document.getElementById('imageUpload').click()" 
                     ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <p>이미지를 여기에 드래그하거나 클릭하여 선택하세요</p>
                    <p>또는 Ctrl+V로 클립보드에서 붙여넣기</p>
                    <input type="file" id="imageUpload" accept="image/*" style="display: none;" onchange="handleFileSelect(event)">
                </div>
                <div id="imagePreview"></div>
            </div>
        </div>
    </div>
    
    <!-- 스텝 설정 모달 -->
    <div id="stepConfigModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">스텝 설정</h2>
            <div id="modalBody"></div>
            <button class="button" onclick="saveStepConfig()">저장</button>
            <button class="button secondary" onclick="closeModal()">취소</button>
        </div>
    </div>
    
    <script>
        let currentStepIndex = null;
        let isTracking = false;
        let capturedPosition = null;
        
        // 탭 전환
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        // Excel 업로드
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('파일을 선택해주세요.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('excelInfo').innerHTML = 
                    '<p>파일 업로드 완료: ' + data.filename + '</p>';
            });
        }
        
        // 매크로 스텝 추가
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
                // 즉시 설정 다이얼로그 열기
                configureStep(data.index);
            });
        }
        
        // 매크로 스텝 목록 새로고침
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => `
                    <div class="macro-step">
                        <div>
                            <strong>${i + 1}. ${step.name}</strong>
                            ${step.description ? '<br>' + step.description : ''}
                        </div>
                        <div>
                            <button class="step-config-button" onclick="configureStep(${i})">설정</button>
                            <button class="button secondary" onclick="removeStep(${i})">삭제</button>
                        </div>
                    </div>
                `).join('');
            });
        }
        
        // 스텝 설정
        function configureStep(index) {
            currentStepIndex = index;
            
            fetch('/get_step_config/' + index)
            .then(response => response.json())
            .then(data => {
                document.getElementById('modalTitle').textContent = data.title;
                document.getElementById('modalBody').innerHTML = data.html;
                document.getElementById('stepConfigModal').style.display = 'block';
                
                // 마우스 클릭 스텝인 경우 좌표 캡처 버튼 추가
                if (data.step_type === 'mouse_click') {
                    setupMouseCaptureForModal();
                }
            });
        }
        
        // 모달에 마우스 캡처 기능 설정
        function setupMouseCaptureForModal() {
            // 캡처된 좌표가 있으면 자동으로 입력
            if (capturedPosition) {
                document.querySelector('input[name="x"]').value = capturedPosition.x;
                document.querySelector('input[name="y"]').value = capturedPosition.y;
            }
        }
        
        // 스텝 설정 저장
        function saveStepConfig() {
            const formData = new FormData();
            const inputs = document.querySelectorAll('#modalBody input, #modalBody select, #modalBody textarea');
            
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    formData.append(input.name, input.checked);
                } else if (input.type === 'file' && input.files.length > 0) {
                    formData.append(input.name, input.files[0]);
                } else {
                    formData.append(input.name, input.value);
                }
            });
            
            fetch('/save_step_config/' + currentStepIndex, {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    refreshMacroSteps();
                } else {
                    alert('설정 저장 실패: ' + data.error);
                }
            });
        }
        
        // 모달 닫기
        function closeModal() {
            document.getElementById('stepConfigModal').style.display = 'none';
        }
        
        // 스텝 제거
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        // 매크로 저장
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('매크로가 저장되었습니다!');
            });
        }
        
        // 매크로 초기화
        function clearMacro() {
            if (confirm('모든 매크로 스텝을 삭제하시겠습니까?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        // 매크로 실행
        function runMacro() {
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('실행 실패: ' + data.error);
                }
            });
        }
        
        // 매크로 중지
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'});
        }
        
        // 실행 로그 업데이트
        function updateExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    '<div class="log-entry ' + entry.level + '">[' + entry.time + '] ' + entry.message + '</div>'
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        // 마우스 좌표 추적
        function toggleMouseTracking() {
            isTracking = !isTracking;
            
            fetch('/toggle_mouse_tracking', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({tracking: isTracking})
            });
            
            if (isTracking) {
                document.getElementById('trackingText').textContent = '⏹️ 좌표 추적 중지';
                document.getElementById('captureHint').style.display = 'block';
                startMousePositionUpdate();
            } else {
                document.getElementById('trackingText').textContent = '🎯 좌표 추적 시작';
                document.getElementById('captureHint').style.display = 'none';
            }
        }
        
        // 마우스 위치 업데이트
        function startMousePositionUpdate() {
            if (isTracking) {
                fetch('/get_mouse_position')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('mouseX').textContent = data.x;
                    document.getElementById('mouseY').textContent = data.y;
                    
                    if (isTracking) {
                        setTimeout(startMousePositionUpdate, 100);
                    }
                });
            }
        }
        
        // 스크린샷 캡처
        function captureScreen() {
            fetch('/capture_screen', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('스크린샷이 캡처되었습니다!');
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // 영역 캡처
        function captureRegion() {
            alert('화면에서 캡처할 영역을 마우스로 드래그하세요.');
            fetch('/capture_region', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // 이미지 미리보기
        function showImagePreview(imageUrl) {
            const previewDiv = document.getElementById('imagePreview');
            previewDiv.innerHTML = `<img src="${imageUrl}" class="image-preview">`;
        }
        
        // 드래그 앤 드롭 핸들러
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleImageFile(files[0]);
            }
        }
        
        // 파일 선택 핸들러
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        }
        
        // 이미지 파일 처리
        function handleImageFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('이미지 파일만 업로드 가능합니다.');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            
            fetch('/upload_image', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // 클립보드 붙여넣기 핸들러
        document.addEventListener('paste', function(e) {
            const items = e.clipboardData.items;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    handleImageFile(blob);
                    e.preventDefault();
                    break;
                }
            }
        });
        
        // F9 키로 좌표 캡처
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F9' && isTracking) {
                fetch('/capture_mouse_position', {method: 'POST'})
                .then(response => response.json())
                .then(data => {
                    capturedPosition = {x: data.x, y: data.y};
                    alert(`좌표가 캡처되었습니다: X=${data.x}, Y=${data.y}`);
                });
            }
        });
        
        // 초기화
        window.onload = function() {
            refreshMacroSteps();
            setInterval(updateExecutionLog, 1000);
        };
        
        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            if (event.target == document.getElementById('stepConfigModal')) {
                closeModal();
            }
        }
    </script>
</body>
</html>
'''

# API 엔드포인트들
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(tempfile.gettempdir(), file.filename)
        file.save(filepath)
        
        if MODULES_LOADED and app_state.excel_manager:
            app_state.excel_manager.load_file(filepath)
        
        return jsonify({'success': True, 'filename': file.filename})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    
    step_data = {
        'type': step_type,
        'name': get_step_name(step_type),
        'config': get_default_config(step_type)
    }
    
    app_state.macro_steps.append(step_data)
    
    return jsonify({
        'success': True,
        'index': len(app_state.macro_steps) - 1
    })

@app.route('/get_macro')
def get_macro():
    steps_info = []
    for step in app_state.macro_steps:
        step_info = {
            'type': step['type'],
            'name': step['name'],
            'description': get_step_description(step)
        }
        steps_info.append(step_info)
    
    return jsonify({'steps': steps_info})

@app.route('/get_step_config/<int:index>')
def get_step_config(index):
    if index >= len(app_state.macro_steps):
        return jsonify({'title': '오류', 'html': '<p>잘못된 인덱스</p>'})
    
    step = app_state.macro_steps[index]
    step_type = step['type']
    config = step.get('config', {})
    
    title = f"{step['name']} 설정"
    html = generate_config_html(step_type, config)
    
    return jsonify({
        'title': title,
        'html': html,
        'step_type': step_type
    })

@app.route('/save_step_config/<int:index>', methods=['POST'])
def save_step_config(index):
    try:
        if index >= len(app_state.macro_steps):
            return jsonify({'success': False, 'error': '잘못된 인덱스'})
        
        step = app_state.macro_steps[index]
        
        # 폼 데이터를 config에 저장
        for key, value in request.form.items():
            if value == 'true':
                step['config'][key] = True
            elif value == 'false':
                step['config'][key] = False
            else:
                try:
                    step['config'][key] = float(value)
                except ValueError:
                    step['config'][key] = value
        
        # 이미지 파일 처리
        if 'image' in request.files:
            image_file = request.files['image']
            if image_file.filename:
                image_id = f"step_{index}_{int(time.time())}"
                image_path = save_uploaded_image(image_file, image_id)
                step['config']['image_path'] = image_path
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state.macro_steps):
        app_state.macro_steps.pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state.macro_steps = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state.macro_steps, f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    if not app_state.macro_steps:
        return jsonify({'success': False, 'error': '실행할 매크로가 없습니다.'})
    
    app_state.add_log("매크로 실행 시작", "info")
    
    # 실제 실행 로직
    for i, step in enumerate(app_state.macro_steps):
        app_state.add_log(f"단계 {i+1}: {step['name']} 실행", "info")
        
        if step['type'] == 'mouse_click':
            x = int(step['config'].get('x', 0))
            y = int(step['config'].get('y', 0))
            pyautogui.click(x, y)
            app_state.add_log(f"마우스 클릭: ({x}, {y})", "success")
            
        elif step['type'] == 'keyboard_type':
            text = step['config'].get('text', '')
            pyautogui.typewrite(text)
            if step['config'].get('press_enter'):
                pyautogui.press('enter')
            app_state.add_log(f"텍스트 입력: {text}", "success")
            
        elif step['type'] == 'wait_time':
            seconds = float(step['config'].get('seconds', 1))
            time.sleep(seconds)
            app_state.add_log(f"{seconds}초 대기", "success")
        
    app_state.add_log("매크로 실행 완료", "success")
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state.is_running = False
    app_state.add_log("매크로 중지됨", "warning")
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state.execution_log[-50:]})

# 마우스 추적 관련 엔드포인트
@app.route('/toggle_mouse_tracking', methods=['POST'])
def toggle_mouse_tracking():
    app_state.is_tracking_mouse = request.json.get('tracking', False)
    return jsonify({'success': True})

@app.route('/get_mouse_position')
def get_mouse_position():
    return jsonify(app_state.mouse_position)

@app.route('/capture_mouse_position', methods=['POST'])
def capture_mouse_position():
    return jsonify(app_state.mouse_position)

# 스크린샷 관련 엔드포인트
@app.route('/capture_screen', methods=['POST'])
def capture_screen():
    try:
        # 전체 화면 캡처
        screenshot = ImageGrab.grab()
        
        # 이미지 저장
        image_id = f"screenshot_{int(time.time())}"
        image_path = save_screenshot(screenshot, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/capture_region', methods=['POST'])
def capture_region():
    try:
        # 간단히 구현 - 실제로는 영역 선택 UI가 필요
        app_state.add_log("영역 캡처 기능은 추가 구현이 필요합니다", "warning")
        
        # 임시로 전체 화면 캡처
        screenshot = ImageGrab.grab()
        
        image_id = f"region_{int(time.time())}"
        image_path = save_screenshot(screenshot, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/upload_image', methods=['POST'])
def upload_image():
    try:
        image_file = request.files['image']
        image_id = f"upload_{int(time.time())}"
        image_path = save_uploaded_image(image_file, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/image/<image_id>')
def get_image(image_id):
    if image_id in app_state.captured_images:
        image_data = app_state.captured_images[image_id]
        return send_file(
            io.BytesIO(image_data),
            mimetype='image/png',
            as_attachment=False
        )
    return '', 404

# 헬퍼 함수들
def get_step_name(step_type):
    names = {
        'mouse_click': '마우스 클릭',
        'keyboard_type': '텍스트 입력',
        'wait_time': '대기',
        'image_search': '이미지 검색',
        'ocr_text': '텍스트 검색',
        'if_condition': '조건문'
    }
    return names.get(step_type, '알 수 없음')

def get_default_config(step_type):
    configs = {
        'mouse_click': {'x': 0, 'y': 0, 'button': 'left', 'click_type': 'single'},
        'keyboard_type': {'text': '', 'press_enter': False},
        'wait_time': {'seconds': 1.0},
        'image_search': {'image_path': '', 'confidence': 0.8},
        'ocr_text': {'search_text': '', 'exact_match': False},
        'if_condition': {'condition_type': 'image_found', 'value': ''}
    }
    return configs.get(step_type, {})

def get_step_description(step):
    config = step.get('config', {})
    step_type = step['type']
    
    if step_type == 'mouse_click':
        return f"({config.get('x', 0)}, {config.get('y', 0)}) 클릭"
    elif step_type == 'keyboard_type':
        text = config.get('text', '')
        return f"'{text[:20]}...' 입력" if len(text) > 20 else f"'{text}' 입력"
    elif step_type == 'wait_time':
        return f"{config.get('seconds', 1)}초 대기"
    elif step_type == 'image_search':
        return "이미지 검색 후 클릭"
    elif step_type == 'ocr_text':
        return f"'{config.get('search_text', '')}' 텍스트 검색"
    elif step_type == 'if_condition':
        return f"{config.get('condition_type', '')} 조건"
    
    return ""

def generate_config_html(step_type, config):
    if step_type == 'mouse_click':
        return f'''
        <div class="form-group">
            <label>X 좌표</label>
            <input type="number" name="x" value="{config.get('x', 0)}" required>
        </div>
        <div class="form-group">
            <label>Y 좌표</label>
            <input type="number" name="y" value="{config.get('y', 0)}" required>
        </div>
        <div class="form-group" style="background: #f8f9ff; padding: 15px; border-radius: 5px;">
            <p style="text-align: center; color: #667eea; font-weight: bold;">
                💡 팁: Tools 탭에서 마우스 좌표를 쉽게 캡처할 수 있습니다!
            </p>
            <p style="text-align: center; margin-top: 10px;">
                1. Tools 탭으로 이동<br>
                2. "좌표 추적 시작" 클릭<br>
                3. 원하는 위치에서 F9 키 누르기
            </p>
        </div>
        <div class="form-group">
            <label>마우스 버튼</label>
            <select name="button">
                <option value="left" {'selected' if config.get('button') == 'left' else ''}>왼쪽</option>
                <option value="right" {'selected' if config.get('button') == 'right' else ''}>오른쪽</option>
            </select>
        </div>
        <div class="form-group">
            <label>클릭 타입</label>
            <select name="click_type">
                <option value="single" {'selected' if config.get('click_type') == 'single' else ''}>싱글 클릭</option>
                <option value="double" {'selected' if config.get('click_type') == 'double' else ''}>더블 클릭</option>
            </select>
        </div>
        '''
        
    elif step_type == 'keyboard_type':
        return f'''
        <div class="form-group">
            <label>입력할 텍스트</label>
            <textarea name="text" rows="3">{config.get('text', '')}</textarea>
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="press_enter" value="true" {'checked' if config.get('press_enter') else ''}>
                입력 후 Enter 키 누르기
            </label>
        </div>
        '''
        
    elif step_type == 'wait_time':
        return f'''
        <div class="form-group">
            <label>대기 시간 (초)</label>
            <input type="number" name="seconds" value="{config.get('seconds', 1.0)}" step="0.1" min="0.1" required>
        </div>
        '''
        
    elif step_type == 'image_search':
        return f'''
        <div class="form-group">
            <label>검색할 이미지</label>
            <input type="file" name="image" accept="image/*">
            <p style="margin-top: 10px; color: #666;">
                💡 팁: Tools 탭에서 스크린샷을 캡처하거나 클립보드에서 이미지를 붙여넣을 수 있습니다!
            </p>
        </div>
        <div class="form-group">
            <label>유사도 (0.0 ~ 1.0)</label>
            <input type="number" name="confidence" value="{config.get('confidence', 0.8)}" step="0.1" min="0" max="1" required>
        </div>
        '''
        
    elif step_type == 'ocr_text':
        return f'''
        <div class="form-group">
            <label>검색할 텍스트</label>
            <input type="text" name="search_text" value="{config.get('search_text', '')}">
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="exact_match" value="true" {'checked' if config.get('exact_match') else ''}>
                정확히 일치
            </label>
        </div>
        '''
        
    elif step_type == 'if_condition':
        return f'''
        <div class="form-group">
            <label>조건 타입</label>
            <select name="condition_type">
                <option value="image_found" {'selected' if config.get('condition_type') == 'image_found' else ''}>이미지 발견</option>
                <option value="text_found" {'selected' if config.get('condition_type') == 'text_found' else ''}>텍스트 발견</option>
                <option value="excel_value" {'selected' if config.get('condition_type') == 'excel_value' else ''}>Excel 값</option>
            </select>
        </div>
        <div class="form-group">
            <label>비교 값</label>
            <input type="text" name="value" value="{config.get('value', '')}">
        </div>
        '''
    
    return '<p>설정이 필요하지 않습니다.</p>'

def save_screenshot(image, image_id):
    # 메모리에 저장
    buffer = io.BytesIO()
    image.save(buffer, format='PNG')
    app_state.captured_images[image_id] = buffer.getvalue()
    return image_id

def save_uploaded_image(image_file, image_id):
    # 업로드된 이미지를 메모리에 저장
    image_data = image_file.read()
    app_state.captured_images[image_id] = image_data
    return image_id

# 메인 실행
if __name__ == '__main__':
    # pyautogui 안전 설정
    pyautogui.FAILSAFE = True
    pyautogui.PAUSE = 0.1
    
    print("=" * 60)
    print("Excel Macro Automation - Enhanced Version")
    print("=" * 60)
    print("\n✨ 새로운 기능:")
    print("- 🎯 실시간 마우스 좌표 추적")
    print("- 📸 스크린샷 캡처 및 저장")
    print("- 🖼️ 이미지 드래그 앤 드롭 / 클립보드 붙여넣기")
    print("- ⌨️ F9 키로 마우스 좌표 캡처")
    print("- 🖥️ 멀티 모니터 지원")
    print("\n브라우저가 자동으로 열립니다...")
    print("수동으로 열려면: http://localhost:5558")
    print("\n종료하려면 Ctrl+C를 누르세요.")
    print("=" * 60)
    
    # 브라우저 자동 열기
    def open_browser():
        time.sleep(1.5)
        webbrowser.open('http://localhost:5558')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask 앱 실행
    app.run(host='0.0.0.0', port=5558, debug=False)
</file>

<file path="web_ui_integrated_working.py">
#!/usr/bin/env python3
"""
웹 UI와 기존 매크로 기능을 통합한 실행 가능한 버전
매크로 스텝 설정 기능이 포함된 완전한 웹 인터페이스
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
import base64
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

# Flask 설치 확인
try:
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS
except ImportError:
    print("필수 패키지 설치 중...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask", "flask-cors"])
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS

# 프로젝트 경로 설정
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# 기존 매크로 모듈 import
try:
    from core.macro_types import (
        MacroStep, StepType, MouseClickStep, KeyboardTypeStep,
        WaitTimeStep, ImageSearchStep, TextSearchStep, IfConditionStep,
        ConditionType, ComparisonOperator
    )
    from automation.executor import MacroExecutor
    from excel.excel_manager import ExcelManager
    from config.settings import Settings
    from logger.app_logger import setup_logger
    from vision.image_matcher import ImageMatcher
    from vision.text_extractor import TextExtractor
    
    MODULES_LOADED = True
except Exception as e:
    print(f"경고: 일부 모듈을 로드할 수 없습니다: {e}")
    MODULES_LOADED = False

app = Flask(__name__)
CORS(app)

# 로거 설정
logger = setup_logger() if MODULES_LOADED else None

# 전역 상태 관리
class AppState:
    def __init__(self):
        self.excel_manager = ExcelManager() if MODULES_LOADED else None
        self.macro_steps: List[Dict] = []  # 단순화된 스텝 저장
        self.executor = None
        self.execution_thread = None
        self.execution_log = []
        self.is_running = False
        self.settings = Settings() if MODULES_LOADED else None
        
    def add_log(self, message: str, level: str = "info"):
        self.execution_log.append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': level,
            'message': message
        })
        if logger:
            getattr(logger, level)(message)

app_state = AppState()

# HTML 템플릿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - 통합 웹 UI</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #667eea;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        .button.secondary {
            background: #757575;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }
        .step-type-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .macro-step {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .step-config-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
        }
        .form-group {
            margin: 20px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .execution-log {
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .log-entry {
            padding: 5px 0;
        }
        .log-entry.error {
            color: #ff5252;
        }
        .log-entry.success {
            color: #69f0ae;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Excel Macro Automation</h1>
            <p>완전한 매크로 자동화 시스템 (스텝 설정 기능 포함)</p>
            <div class="status-badge">
                상태: <span id="status">준비됨</span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">📊 Excel</button>
            <button class="tab" onclick="showTab('editor')">✏️ Editor</button>
            <button class="tab" onclick="showTab('run')">▶️ Run</button>
        </div>
        
        <div class="content">
            <!-- Excel 탭 -->
            <div id="excel" class="panel active">
                <h2>Excel 파일 관리</h2>
                <div>
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">업로드</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor 탭 -->
            <div id="editor" class="panel">
                <h2>매크로 편집기</h2>
                <div class="step-palette">
                    <div class="step-type-card" onclick="addStep('mouse_click')">
                        <div>🖱️</div>
                        <div>마우스 클릭</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('keyboard_type')">
                        <div>⌨️</div>
                        <div>텍스트 입력</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('wait_time')">
                        <div>⏱️</div>
                        <div>대기</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('image_search')">
                        <div>🔍</div>
                        <div>이미지 검색</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('ocr_text')">
                        <div>🔤</div>
                        <div>텍스트 검색</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('if_condition')">
                        <div>❓</div>
                        <div>조건문</div>
                    </div>
                </div>
                
                <h3>현재 매크로</h3>
                <div id="macroSteps"></div>
                
                <button class="button" onclick="saveMacro()">💾 매크로 저장</button>
                <button class="button secondary" onclick="clearMacro()">🗑️ 초기화</button>
            </div>
            
            <!-- Run 탭 -->
            <div id="run" class="panel">
                <h2>매크로 실행</h2>
                <button class="button" onclick="runMacro()">▶️ 실행</button>
                <button class="button secondary" onclick="stopMacro()">⏹️ 중지</button>
                
                <h3>실행 로그</h3>
                <div id="executionLog" class="execution-log"></div>
            </div>
        </div>
    </div>
    
    <!-- 스텝 설정 모달 -->
    <div id="stepConfigModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">스텝 설정</h2>
            <div id="modalBody"></div>
            <button class="button" onclick="saveStepConfig()">저장</button>
            <button class="button secondary" onclick="closeModal()">취소</button>
        </div>
    </div>
    
    <script>
        let currentStepIndex = null;
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('파일을 선택해주세요.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('excelInfo').innerHTML = 
                    '<p>파일 업로드 완료: ' + data.filename + '</p>';
            });
        }
        
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
                // 즉시 설정 다이얼로그 열기
                configureStep(data.index);
            });
        }
        
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => `
                    <div class="macro-step">
                        <div>
                            <strong>${i + 1}. ${step.name}</strong>
                            ${step.description ? '<br>' + step.description : ''}
                        </div>
                        <div>
                            <button class="step-config-button" onclick="configureStep(${i})">설정</button>
                            <button class="button secondary" onclick="removeStep(${i})">삭제</button>
                        </div>
                    </div>
                `).join('');
            });
        }
        
        function configureStep(index) {
            currentStepIndex = index;
            
            fetch('/get_step_config/' + index)
            .then(response => response.json())
            .then(data => {
                document.getElementById('modalTitle').textContent = data.title;
                document.getElementById('modalBody').innerHTML = data.html;
                document.getElementById('stepConfigModal').style.display = 'block';
            });
        }
        
        function saveStepConfig() {
            const formData = new FormData();
            const inputs = document.querySelectorAll('#modalBody input, #modalBody select, #modalBody textarea');
            
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    formData.append(input.name, input.checked);
                } else {
                    formData.append(input.name, input.value);
                }
            });
            
            fetch('/save_step_config/' + currentStepIndex, {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    refreshMacroSteps();
                } else {
                    alert('설정 저장 실패: ' + data.error);
                }
            });
        }
        
        function closeModal() {
            document.getElementById('stepConfigModal').style.display = 'none';
        }
        
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('매크로가 저장되었습니다!');
            });
        }
        
        function clearMacro() {
            if (confirm('모든 매크로 스텝을 삭제하시겠습니까?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        function runMacro() {
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('실행 실패: ' + data.error);
                }
            });
        }
        
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'});
        }
        
        function updateExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    '<div class="log-entry ' + entry.level + '">[' + entry.time + '] ' + entry.message + '</div>'
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        // 초기화
        window.onload = function() {
            refreshMacroSteps();
            setInterval(updateExecutionLog, 1000);
        };
        
        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            if (event.target == document.getElementById('stepConfigModal')) {
                closeModal();
            }
        }
    </script>
</body>
</html>
'''

# API 엔드포인트들
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(tempfile.gettempdir(), file.filename)
        file.save(filepath)
        
        if MODULES_LOADED and app_state.excel_manager:
            app_state.excel_manager.load_file(filepath)
        
        return jsonify({'success': True, 'filename': file.filename})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    
    # 기본값으로 스텝 추가
    step_data = {
        'type': step_type,
        'name': get_step_name(step_type),
        'config': get_default_config(step_type)
    }
    
    app_state.macro_steps.append(step_data)
    
    return jsonify({
        'success': True,
        'index': len(app_state.macro_steps) - 1
    })

@app.route('/get_macro')
def get_macro():
    steps_info = []
    for step in app_state.macro_steps:
        step_info = {
            'type': step['type'],
            'name': step['name'],
            'description': get_step_description(step)
        }
        steps_info.append(step_info)
    
    return jsonify({'steps': steps_info})

@app.route('/get_step_config/<int:index>')
def get_step_config(index):
    if index >= len(app_state.macro_steps):
        return jsonify({'title': '오류', 'html': '<p>잘못된 인덱스</p>'})
    
    step = app_state.macro_steps[index]
    step_type = step['type']
    config = step.get('config', {})
    
    title = f"{step['name']} 설정"
    html = generate_config_html(step_type, config)
    
    return jsonify({'title': title, 'html': html})

@app.route('/save_step_config/<int:index>', methods=['POST'])
def save_step_config(index):
    try:
        if index >= len(app_state.macro_steps):
            return jsonify({'success': False, 'error': '잘못된 인덱스'})
        
        step = app_state.macro_steps[index]
        
        # 폼 데이터를 config에 저장
        for key, value in request.form.items():
            if value == 'true':
                step['config'][key] = True
            elif value == 'false':
                step['config'][key] = False
            else:
                try:
                    step['config'][key] = float(value)
                except ValueError:
                    step['config'][key] = value
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state.macro_steps):
        app_state.macro_steps.pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state.macro_steps = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state.macro_steps, f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    if not app_state.macro_steps:
        return jsonify({'success': False, 'error': '실행할 매크로가 없습니다.'})
    
    app_state.add_log("매크로 실행 시작", "info")
    
    # 실제 실행 로직은 여기에 구현
    for i, step in enumerate(app_state.macro_steps):
        app_state.add_log(f"단계 {i+1}: {step['name']} 실행", "info")
        # 실제 실행 코드...
        
    app_state.add_log("매크로 실행 완료", "success")
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state.is_running = False
    app_state.add_log("매크로 중지됨", "warning")
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state.execution_log[-50:]})

# 헬퍼 함수들
def get_step_name(step_type):
    names = {
        'mouse_click': '마우스 클릭',
        'keyboard_type': '텍스트 입력',
        'wait_time': '대기',
        'image_search': '이미지 검색',
        'ocr_text': '텍스트 검색',
        'if_condition': '조건문'
    }
    return names.get(step_type, '알 수 없음')

def get_default_config(step_type):
    configs = {
        'mouse_click': {'x': 0, 'y': 0, 'button': 'left', 'click_type': 'single'},
        'keyboard_type': {'text': '', 'press_enter': False},
        'wait_time': {'seconds': 1.0},
        'image_search': {'image_path': '', 'confidence': 0.8},
        'ocr_text': {'search_text': '', 'exact_match': False},
        'if_condition': {'condition_type': 'image_found', 'value': ''}
    }
    return configs.get(step_type, {})

def get_step_description(step):
    config = step.get('config', {})
    step_type = step['type']
    
    if step_type == 'mouse_click':
        return f"({config.get('x', 0)}, {config.get('y', 0)}) 클릭"
    elif step_type == 'keyboard_type':
        text = config.get('text', '')
        return f"'{text[:20]}...' 입력" if len(text) > 20 else f"'{text}' 입력"
    elif step_type == 'wait_time':
        return f"{config.get('seconds', 1)}초 대기"
    elif step_type == 'image_search':
        return "이미지 검색 후 클릭"
    elif step_type == 'ocr_text':
        return f"'{config.get('search_text', '')}' 텍스트 검색"
    elif step_type == 'if_condition':
        return f"{config.get('condition_type', '')} 조건"
    
    return ""

def generate_config_html(step_type, config):
    if step_type == 'mouse_click':
        return f'''
        <div class="form-group">
            <label>X 좌표</label>
            <input type="number" name="x" value="{config.get('x', 0)}" required>
        </div>
        <div class="form-group">
            <label>Y 좌표</label>
            <input type="number" name="y" value="{config.get('y', 0)}" required>
        </div>
        <div class="form-group">
            <label>마우스 버튼</label>
            <select name="button">
                <option value="left" {'selected' if config.get('button') == 'left' else ''}>왼쪽</option>
                <option value="right" {'selected' if config.get('button') == 'right' else ''}>오른쪽</option>
            </select>
        </div>
        <div class="form-group">
            <label>클릭 타입</label>
            <select name="click_type">
                <option value="single" {'selected' if config.get('click_type') == 'single' else ''}>싱글 클릭</option>
                <option value="double" {'selected' if config.get('click_type') == 'double' else ''}>더블 클릭</option>
            </select>
        </div>
        '''
        
    elif step_type == 'keyboard_type':
        return f'''
        <div class="form-group">
            <label>입력할 텍스트</label>
            <textarea name="text" rows="3">{config.get('text', '')}</textarea>
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="press_enter" value="true" {'checked' if config.get('press_enter') else ''}>
                입력 후 Enter 키 누르기
            </label>
        </div>
        '''
        
    elif step_type == 'wait_time':
        return f'''
        <div class="form-group">
            <label>대기 시간 (초)</label>
            <input type="number" name="seconds" value="{config.get('seconds', 1.0)}" step="0.1" min="0.1" required>
        </div>
        '''
        
    elif step_type == 'image_search':
        return f'''
        <div class="form-group">
            <label>이미지 경로</label>
            <input type="text" name="image_path" value="{config.get('image_path', '')}" placeholder="이미지 파일 경로">
        </div>
        <div class="form-group">
            <label>유사도 (0.0 ~ 1.0)</label>
            <input type="number" name="confidence" value="{config.get('confidence', 0.8)}" step="0.1" min="0" max="1" required>
        </div>
        '''
        
    elif step_type == 'ocr_text':
        return f'''
        <div class="form-group">
            <label>검색할 텍스트</label>
            <input type="text" name="search_text" value="{config.get('search_text', '')}">
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="exact_match" value="true" {'checked' if config.get('exact_match') else ''}>
                정확히 일치
            </label>
        </div>
        '''
        
    elif step_type == 'if_condition':
        return f'''
        <div class="form-group">
            <label>조건 타입</label>
            <select name="condition_type">
                <option value="image_found" {'selected' if config.get('condition_type') == 'image_found' else ''}>이미지 발견</option>
                <option value="text_found" {'selected' if config.get('condition_type') == 'text_found' else ''}>텍스트 발견</option>
                <option value="excel_value" {'selected' if config.get('condition_type') == 'excel_value' else ''}>Excel 값</option>
            </select>
        </div>
        <div class="form-group">
            <label>비교 값</label>
            <input type="text" name="value" value="{config.get('value', '')}">
        </div>
        '''
    
    return '<p>설정이 필요하지 않습니다.</p>'

# 메인 실행
if __name__ == '__main__':
    print("=" * 60)
    print("Excel Macro Automation - 통합 웹 UI (동작 버전)")
    print("=" * 60)
    print("\n✅ 매크로 스텝 설정 기능이 완전히 구현된 버전입니다.")
    print("\n기능:")
    print("- 각 스텝별 상세 설정 가능")
    print("- 마우스 클릭: 좌표, 버튼, 클릭 타입")
    print("- 텍스트 입력: 텍스트 내용, Enter 키")
    print("- 대기: 대기 시간")
    print("- 이미지/텍스트 검색: 검색 조건")
    print("- 조건문: 조건 타입, 비교값")
    print("\n브라우저가 자동으로 열립니다...")
    print("수동으로 열려면: http://localhost:5557")
    print("\n종료하려면 Ctrl+C를 누르세요.")
    print("=" * 60)
    
    # 브라우저 자동 열기
    def open_browser():
        import time
        time.sleep(1.5)
        webbrowser.open('http://localhost:5557')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask 앱 실행
    app.run(host='0.0.0.0', port=5557, debug=False)
</file>

<file path="web_ui_launcher.py">
#!/usr/bin/env python3
"""
WSL GUI 문제를 우회하는 웹 기반 UI 런처
브라우저를 통해 애플리케이션을 제어합니다.
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
from pathlib import Path
from datetime import datetime

# Flask 설치 확인
try:
    from flask import Flask, render_template_string, jsonify, request
except ImportError:
    print("Flask 설치 중...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask"])
    from flask import Flask, render_template_string, jsonify, request

# 프로젝트 경로 설정
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

app = Flask(__name__)

# 전역 상태 관리
app_state = {
    "status": "ready",
    "excel_file": None,
    "macro_steps": [],
    "execution_log": []
}

# HTML 템플릿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - Web UI</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .header h1 {
            color: #2196F3;
            margin-bottom: 10px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #2196F3;
            color: white;
        }
        .tab:hover {
            background: #1976D2;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 400px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #45a049;
        }
        .button.secondary {
            background: #757575;
        }
        .button.secondary:hover {
            background: #616161;
        }
        .file-input {
            margin: 20px 0;
        }
        .status-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .macro-step {
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .log-entry {
            padding: 5px 10px;
            margin: 2px 0;
            background: #f9f9f9;
            border-radius: 3px;
            font-family: monospace;
            font-size: 14px;
        }
        .log-entry.error {
            background: #ffebee;
            color: #c62828;
        }
        .log-entry.success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .step-type {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type:hover {
            background: #2196F3;
            color: white;
            transform: translateY(-2px);
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Excel Macro Automation</h1>
            <p>WSL GUI 문제를 우회하는 웹 기반 컨트롤 패널</p>
            <div class="status-box">
                상태: <span id="status">준비됨</span>
                <span id="loading" class="loading" style="display: none;"></span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">📊 Excel</button>
            <button class="tab" onclick="showTab('editor')">✏️ Editor</button>
            <button class="tab" onclick="showTab('run')">▶️ Run</button>
            <button class="tab" onclick="showTab('native')">🖥️ Native GUI</button>
        </div>
        
        <div class="content">
            <!-- Excel 탭 -->
            <div id="excel" class="panel active">
                <h2>Excel 파일 관리</h2>
                <div class="file-input">
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">업로드</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor 탭 -->
            <div id="editor" class="panel">
                <h2>매크로 편집기</h2>
                <div class="step-palette">
                    <div class="step-type" onclick="addStep('mouse_click')">🖱️ 마우스 클릭</div>
                    <div class="step-type" onclick="addStep('keyboard_type')">⌨️ 텍스트 입력</div>
                    <div class="step-type" onclick="addStep('wait_time')">⏱️ 대기</div>
                    <div class="step-type" onclick="addStep('image_search')">🔍 이미지 검색</div>
                    <div class="step-type" onclick="addStep('ocr_text')">🔤 텍스트 검색</div>
                    <div class="step-type" onclick="addStep('if_condition')">❓ 조건문</div>
                </div>
                <h3>현재 매크로</h3>
                <div id="macroSteps"></div>
                <button class="button" onclick="saveMacro()">매크로 저장</button>
                <button class="button secondary" onclick="clearMacro()">초기화</button>
            </div>
            
            <!-- Run 탭 -->
            <div id="run" class="panel">
                <h2>매크로 실행</h2>
                <button class="button" onclick="runMacro()">▶️ 실행</button>
                <button class="button secondary" onclick="stopMacro()">⏹️ 중지</button>
                <h3>실행 로그</h3>
                <div id="executionLog"></div>
            </div>
            
            <!-- Native GUI 탭 -->
            <div id="native" class="panel">
                <h2>네이티브 GUI 실행 옵션</h2>
                <p>웹 UI 대신 원래 GUI를 실행하려면 아래 옵션을 시도하세요:</p>
                
                <div style="margin: 20px 0;">
                    <h3>옵션 1: X Server 확인 후 실행</h3>
                    <button class="button" onclick="runNative('check')">X Server 체크 & 실행</button>
                    
                    <h3>옵션 2: 가상 디스플레이 (Xvfb)</h3>
                    <button class="button" onclick="runNative('xvfb')">Xvfb로 실행</button>
                    
                    <h3>옵션 3: Windows에서 직접 실행</h3>
                    <button class="button" onclick="runNative('windows')">Windows 스크립트 생성</button>
                    
                    <h3>옵션 4: 디버그 모드</h3>
                    <button class="button" onclick="runNative('debug')">디버그 정보 보기</button>
                </div>
                
                <div id="nativeOutput" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>
    
    <script>
        let currentTab = 'excel';
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            currentTab = tabName;
        }
        
        function updateStatus(status, loading = false) {
            document.getElementById('status').textContent = status;
            document.getElementById('loading').style.display = loading ? 'inline-block' : 'none';
        }
        
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('파일을 선택해주세요.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            updateStatus('Excel 파일 업로드 중...', true);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                updateStatus('Excel 파일 로드 완료');
                document.getElementById('excelInfo').innerHTML = 
                    `<p>파일명: ${data.filename}</p>
                     <p>시트: ${data.sheets.join(', ')}</p>
                     <p>행 수: ${data.rows}</p>`;
            })
            .catch(error => {
                updateStatus('오류 발생');
                alert('오류: ' + error);
            });
        }
        
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
            });
        }
        
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => 
                    `<div class="macro-step">
                        ${i + 1}. ${step.name} (${step.type})
                        <button onclick="removeStep(${i})" style="float: right;">삭제</button>
                    </div>`
                ).join('');
            });
        }
        
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('매크로 저장 완료!');
            });
        }
        
        function clearMacro() {
            if (confirm('매크로를 초기화하시겠습니까?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        function runMacro() {
            updateStatus('매크로 실행 중...', true);
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                updateStatus('매크로 실행 완료');
                refreshExecutionLog();
            });
        }
        
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'})
            .then(() => {
                updateStatus('매크로 중지됨');
            });
        }
        
        function refreshExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    `<div class="log-entry ${entry.level}">[${entry.time}] ${entry.message}</div>`
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        function runNative(mode) {
            updateStatus('네이티브 GUI 실행 시도 중...', true);
            fetch('/run_native/' + mode)
            .then(response => response.json())
            .then(data => {
                updateStatus(data.status);
                document.getElementById('nativeOutput').innerHTML = 
                    `<pre>${data.output}</pre>`;
            });
        }
        
        // 페이지 로드 시 초기화
        window.onload = function() {
            refreshMacroSteps();
            refreshExecutionLog();
        };
        
        // 주기적으로 로그 업데이트
        setInterval(refreshExecutionLog, 2000);
    </script>
</body>
</html>
'''

# API 엔드포인트들
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(project_root, 'temp_excel.xlsx')
        file.save(filepath)
        
        import pandas as pd
        xls = pd.ExcelFile(filepath)
        
        app_state['excel_file'] = filepath
        
        return jsonify({
            'success': True,
            'filename': file.filename,
            'sheets': xls.sheet_names,
            'rows': len(pd.read_excel(xls, xls.sheet_names[0]))
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    step_names = {
        'mouse_click': '마우스 클릭',
        'keyboard_type': '텍스트 입력',
        'wait_time': '대기',
        'image_search': '이미지 검색',
        'ocr_text': '텍스트 검색',
        'if_condition': '조건문'
    }
    
    app_state['macro_steps'].append({
        'type': step_type,
        'name': step_names.get(step_type, step_type)
    })
    
    return jsonify({'success': True})

@app.route('/get_macro')
def get_macro():
    return jsonify({'steps': app_state['macro_steps']})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state['macro_steps']):
        app_state['macro_steps'].pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state['macro_steps'] = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state['macro_steps'], f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    app_state['execution_log'].append({
        'time': datetime.now().strftime('%H:%M:%S'),
        'level': 'info',
        'message': '매크로 실행 시작'
    })
    
    # 실제 매크로 실행 로직은 여기에 구현
    for i, step in enumerate(app_state['macro_steps']):
        app_state['execution_log'].append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': 'success',
            'message': f'단계 {i+1}: {step["name"]} 실행 완료'
        })
    
    app_state['execution_log'].append({
        'time': datetime.now().strftime('%H:%M:%S'),
        'level': 'success',
        'message': '매크로 실행 완료'
    })
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state['status'] = 'stopped'
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state['execution_log'][-50:]})  # 최근 50개만

@app.route('/run_native/<mode>')
def run_native(mode):
    try:
        output = ""
        
        if mode == 'check':
            # X Server 체크 후 실행
            result = subprocess.run(['python3', 'run_main.py'], 
                                  capture_output=True, text=True, timeout=5)
            output = result.stdout + result.stderr
            status = "실행 시도 완료"
            
        elif mode == 'xvfb':
            # Xvfb로 실행
            subprocess.Popen(['xvfb-run', '-a', 'python3', 'run_main.py'])
            output = "Xvfb 가상 디스플레이로 실행 중..."
            status = "Xvfb 실행"
            
        elif mode == 'windows':
            # Windows 스크립트 생성
            output = "Windows에서 실행:\n"
            output += "1. PowerShell을 관리자 권한으로 실행\n"
            output += "2. cd \\\\wsl.localhost\\Ubuntu\\home\\nosky\\macro\n"
            output += "3. .\\run_from_windows.ps1"
            status = "Windows 스크립트 안내"
            
        elif mode == 'debug':
            # 디버그 정보
            output = f"DISPLAY: {os.environ.get('DISPLAY', 'Not set')}\n"
            output += f"Project Root: {project_root}\n"
            output += "Python Path: " + str(sys.path[:3])
            status = "디버그 정보"
            
    except Exception as e:
        output = str(e)
        status = "오류 발생"
    
    return jsonify({'status': status, 'output': output})

# 메인 실행
if __name__ == '__main__':
    print("=" * 50)
    print("Excel Macro Automation - Web UI")
    print("=" * 50)
    print("\nWSL GUI 문제를 우회하는 웹 기반 인터페이스를 시작합니다.")
    print("\n브라우저가 자동으로 열립니다...")
    print("수동으로 열려면: http://localhost:5555")
    print("\n종료하려면 Ctrl+C를 누르세요.")
    print("=" * 50)
    
    # 브라우저 자동 열기
    def open_browser():
        import time
        time.sleep(1.5)
        webbrowser.open('http://localhost:5555')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask 앱 실행
    app.run(host='0.0.0.0', port=5555, debug=False)
</file>

<file path="WINDOWS_GUIDE.md">
# Windows 실행 가이드

이 문서는 WSL에서 개발된 Excel 매크로 자동화 도구를 Windows 네이티브 환경에서 실행하는 방법을 설명합니다.

## 왜 Windows에서 직접 실행해야 하나요?

WSL(Windows Subsystem for Linux)에서 GUI 애플리케이션을 실행할 때 다음과 같은 제약사항이 있습니다:
- 화면 캡처 기능이 제대로 작동하지 않음
- 마우스/키보드 이벤트 캡처 문제
- 투명 오버레이 렌더링 문제
- 클립보드 접근 제한

Windows에서 직접 실행하면 이러한 문제가 해결됩니다.

## 사전 준비사항

1. **Python 설치**
   - [python.org](https://www.python.org/downloads/)에서 Python 3.8 이상 버전 다운로드
   - 설치 시 "Add Python to PATH" 옵션 체크 필수

2. **파일 접근**
   - WSL 파일은 `\\wsl$\Ubuntu\home\사용자명\macro` 경로로 접근 가능
   - 또는 Windows 폴더로 프로젝트 복사

## 실행 방법

### 방법 1: 간단한 실행기 사용 (권장)

1. Windows 탐색기에서 프로젝트 폴더 열기:
   ```
   \\wsl.localhost\Ubuntu-22.04\home\nosky\macro
   ```

2. `RUN_ON_WINDOWS.bat` 더블클릭
   - UNC 경로 문제를 자동으로 해결
   - 임시 폴더에 복사 후 실행

### 방법 2: 일반 배치 파일 사용

1. `run_windows.bat` 더블클릭
   - UNC 경로 자동 처리
   - 가상환경 지원

### 방법 3: PowerShell 사용

1. PowerShell을 관리자 권한으로 실행

2. 프로젝트 디렉토리로 이동:
   ```powershell
   cd \\wsl$\Ubuntu\home\nosky\macro
   ```

3. PowerShell 스크립트 실행:
   ```powershell
   .\run_windows.ps1
   ```

   실행 정책 오류가 발생하면:
   ```powershell
   Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
   ```

### 방법 4: 수동 실행

1. 명령 프롬프트 또는 PowerShell 열기

2. 프로젝트 디렉토리로 이동

3. 가상환경 생성 및 활성화:
   ```cmd
   python -m venv venv
   venv\Scripts\activate
   ```

4. 패키지 설치:
   ```cmd
   pip install -r requirements.txt
   ```

5. 애플리케이션 실행:
   ```cmd
   python run_main.py
   ```

## 문제 해결

### UNC 경로 오류
WSL 경로에서 직접 실행 시 발생하는 오류:
```
'\\wsl.localhost\Ubuntu-22.04\...' 위의 경로를 현재 디렉터리로 하여 CMD.EXE가 실행되었습니다.
UNC 경로는 지원되지 않습니다.
```

**해결방법**:
- `RUN_ON_WINDOWS.bat` 사용 (자동으로 로컬 폴더로 복사)
- 프로젝트를 C:\ 드라이브로 복사 후 실행

### Python을 찾을 수 없음
- Python이 PATH에 추가되었는지 확인
- `python --version` 명령으로 설치 확인

### 패키지 설치 오류
- pip 업그레이드: `python -m pip install --upgrade pip`
- 특정 패키지 수동 설치: `pip install PyQt5`

### GUI 관련 문제
- Windows 디스플레이 스케일링 설정 확인
- 그래픽 드라이버 업데이트

### 파일 경로 문제
- WSL 경로 사용 시 `\\wsl$\` 프리픽스 확인
- 경로에 공백이 있으면 따옴표로 감싸기

## 주요 차이점

| 기능 | WSL | Windows Native |
|------|-----|----------------|
| 화면 캡처 | 제한적 | 완전 지원 |
| ROI 선택 | 불안정 | 정상 작동 |
| 클립보드 | 제한적 | 완전 지원 |
| 성능 | 약간 느림 | 빠름 |

## 권장사항

1. **개발**: WSL/VSCode에서 진행
2. **테스트/실행**: Windows PowerShell에서 실행
3. **배포**: Windows 실행 파일로 패키징

## 추가 도구

Windows에서 더 나은 경험을 위해:
- **Windows Terminal**: 향상된 터미널 환경
- **PyInstaller**: 실행 파일 생성 도구

---

문제가 발생하면 프로젝트의 Issue 페이지에 보고해주세요.
</file>

<file path="WINDOWS_WSL_SETUP.md">
# Windows + VSCode + WSL2 환경에서 GUI 실행하기

## 🖥️ Windows에서 X Server 설치 및 실행

### 방법 1: VcXsrv 사용 (권장)

1. **VcXsrv 다운로드 및 설치**
   - https://sourceforge.net/projects/vcxsrv/
   - 설치 후 "XLaunch" 실행

2. **VcXsrv 설정**
   - Display settings: Multiple windows
   - Client startup: Start no client
   - Extra settings: 
     - ✅ Clipboard
     - ✅ Primary Selection
     - ✅ Native opengl
     - ✅ **Disable access control** (중요!)

3. **Windows 방화벽 허용**
   - VcXsrv가 방화벽 허용 요청하면 "허용" 클릭

### 방법 2: MobaXterm 사용

1. **MobaXterm 다운로드**
   - https://mobaxterm.mobatek.net/
   - Home Edition (무료) 사용

2. **X server 자동 시작**
   - MobaXterm 실행하면 자동으로 X server 시작됨

## 🐧 WSL2 설정

### 1. DISPLAY 환경 변수 설정

```bash
# ~/.bashrc 또는 ~/.zshrc에 추가
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
export LIBGL_ALWAYS_INDIRECT=1
```

또는 임시로 설정:

```bash
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
```

### 2. 현재 설정 확인

```bash
echo $DISPLAY
# 출력 예: 172.x.x.x:0.0
```

## 🚀 애플리케이션 실행

### 1. X Server 확인
```bash
# Windows에서 VcXsrv 또는 MobaXterm이 실행 중인지 확인
# 시스템 트레이에 X 아이콘이 있어야 함
```

### 2. 테스트
```bash
# X11 앱 테스트
sudo apt-get install x11-apps
xeyes  # 눈이 따라다니는 창이 나타나면 성공!
```

### 3. Excel Macro Automation 실행
```bash
source venv/bin/activate
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
python run_simple.py
```

## 🔧 문제 해결

### "cannot connect to X server" 오류

1. **Windows IP 확인**
   ```bash
   cat /etc/resolv.conf | grep nameserver
   # nameserver 뒤의 IP 주소 확인
   ```

2. **수동으로 DISPLAY 설정**
   ```bash
   export DISPLAY=<Windows-IP>:0.0
   # 예: export DISPLAY=172.31.32.1:0.0
   ```

3. **VcXsrv 재시작**
   - Windows에서 VcXsrv 종료 후 다시 시작
   - "Disable access control" 옵션 확인

### "Authorization required" 오류

```bash
# X 인증 비활성화 (보안상 로컬에서만 사용)
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
xhost +
```

### WSLg 사용 (Windows 11)

Windows 11 + WSL2 최신 버전에서는 WSLg가 기본 지원됩니다:

```bash
# WSL 업데이트
wsl --update

# WSL 재시작
wsl --shutdown
# Windows에서 다시 WSL 실행

# DISPLAY 확인
echo $DISPLAY
# :0 또는 :0.0이면 WSLg 사용 중
```

## 📝 실행 스크립트

`run_windows_wsl.sh` 생성:

```bash
#!/bin/bash
# Windows + WSL2 환경 실행 스크립트

echo "Windows + WSL2 환경에서 Excel Macro Automation 실행"
echo "=================================================="

# DISPLAY 설정
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
echo "DISPLAY 설정: $DISPLAY"

# 가상환경 활성화
source venv/bin/activate

# Python 실행
python run_simple.py
```

## ✅ 체크리스트

- [ ] Windows에 X Server (VcXsrv 또는 MobaXterm) 설치
- [ ] X Server 실행 중 (시스템 트레이 확인)
- [ ] VcXsrv에서 "Disable access control" 체크
- [ ] WSL에서 DISPLAY 환경변수 설정
- [ ] xeyes 또는 xclock으로 테스트 성공

모든 항목을 확인했다면 GUI가 정상적으로 표시됩니다!
</file>

<file path="WSL_GUI_GUIDE.md">
# WSL에서 Excel Macro Automation 실행 가이드

## Windows 11 (WSL2 + WSLg)

Windows 11에서는 WSLg가 기본 지원되므로 추가 설정 없이 GUI 앱을 실행할 수 있습니다.

### 1. 필요한 라이브러리 설치
```bash
# WSL 터미널에서 실행
sudo apt update
sudo apt install -y python3-pyqt5 \
    libxcb-xinerama0 libxcb-icccm4 libxcb-image0 \
    libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 \
    libxcb-xfixes0 libxcb-shape0 libgl1-mesa-glx
```

### 2. 애플리케이션 실행
```bash
cd /home/nosky/macro
python3 test_gui.py
```

## Windows 10 (WSL2 + X Server)

Windows 10에서는 X Server를 별도로 설치해야 합니다.

### 1. X Server 설치
- **VcXsrv** 다운로드: https://sourceforge.net/projects/vcxsrv/
- 또는 **X410** (Microsoft Store에서 구매)

### 2. X Server 설정 및 실행
1. VcXsrv 실행 (XLaunch)
2. 설정:
   - Display number: 0
   - "Disable access control" 체크
   - "Native opengl" 체크 해제

### 3. WSL 환경 변수 설정
```bash
# .bashrc 또는 .zshrc에 추가
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
export LIBGL_ALWAYS_INDIRECT=1
```

### 4. 애플리케이션 실행
```bash
source ~/.bashrc  # 환경변수 적용
cd /home/nosky/macro
python3 test_gui.py
```

## 문제 해결

### Qt platform plugin "xcb" 오류
```bash
# 추가 라이브러리 설치
sudo apt install -y qt5-default libqt5gui5 libqt5core5a libqt5widgets5
```

### OpenGL 관련 오류
```bash
export LIBGL_ALWAYS_SOFTWARE=1
```

### 한글 폰트 문제
```bash
sudo apt install -y fonts-nanum fonts-noto-cjk
```

## 현재 구현 상태

### ✅ 구현 완료
1. **Excel 통합** (T-002)
   - 파일 드래그 앤 드롭
   - 시트 선택 및 미리보기
   - 열 매핑 UI

2. **매크로 에디터** (T-003)
   - 드래그 앤 드롭 단계 편집
   - 시각적 단계 표시
   - 변수 치환 지원

3. **실행 엔진** (T-004)
   - 멀티스레드 실행
   - 핫키 지원
   - 진행률 표시

4. **이미지 인식** (T-005)
   - OpenCV 기반 매칭
   - ROI 선택 UI
   - DPI 스케일링 지원

### ❌ 미구현
- OCR 텍스트 인식 (T-006)
- 조건문 로직 (T-007)
- 매크로 저장/불러오기 (T-008)
- 고급 로깅 (T-009)

## 실제 애플리케이션 실행

import 문제를 해결한 후:
```bash
python3 main.py
```

또는 import 문제를 우회하여 실행:
1. 모든 상대 import를 절대 import로 변경
2. 또는 PYTHONPATH 설정:
   ```bash
   export PYTHONPATH=/home/nosky/macro/src:$PYTHONPATH
   cd /home/nosky/macro
   python3 -m main
   ```
</file>

<file path="src/core/__init__.py">
"""
Core business logic module
"""

from core.macro_types import (
    MacroStep, StepType, MouseButton, ConditionOperator,
    MouseClickStep, MouseMoveStep,
    KeyboardTypeStep, KeyboardHotkeyStep, 
    WaitTimeStep, WaitImageStep, TextSearchStep,
    IfConditionStep, LoopStep,
    Macro, StepFactory
)

from core.macro_storage import MacroStorage

__all__ = [
    # Types and Enums
    'MacroStep', 'StepType', 'MouseButton', 'ConditionOperator',
    
    # Step Classes
    'MouseClickStep', 'MouseMoveStep',
    'KeyboardTypeStep', 'KeyboardHotkeyStep',
    'WaitTimeStep', 'WaitImageStep', 'TextSearchStep',
    'IfConditionStep', 'LoopStep',
    
    # Main Classes
    'Macro', 'StepFactory', 'MacroStorage'
]
</file>

<file path="src/excel/excel_manager.py">
"""
Core Excel file management functionality
"""

import os
from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple
import pandas as pd
import openpyxl
from logger.app_logger import get_logger
from excel.models import (
    ExcelFileInfo, SheetInfo, ColumnInfo, ColumnType, 
    ExcelData, ColumnMapping
)

class ExcelManager:
    """Manages Excel file operations"""
    
    def __init__(self):
        self.logger = get_logger(__name__)
        self._current_file: Optional[str] = None
        self._current_data: Optional[ExcelData] = None
        self._column_mappings: Dict[str, ColumnMapping] = {}
        
    def load_file(self, file_path: str) -> ExcelFileInfo:
        """Load Excel file and return file information"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Excel file not found: {file_path}")
        
        if not file_path.suffix.lower() in ['.xlsx', '.xls', '.xlsm']:
            raise ValueError(f"Invalid Excel file format: {file_path.suffix}")
        
        self.logger.info(f"Loading Excel file: {file_path}")
        
        # Get file info
        file_size = file_path.stat().st_size
        
        # Load workbook to get sheet names
        workbook = openpyxl.load_workbook(file_path, read_only=True, data_only=True)
        sheet_names = workbook.sheetnames
        workbook.close()
        
        # Analyze each sheet
        sheets = []
        for sheet_name in sheet_names:
            sheet_info = self._analyze_sheet(file_path, sheet_name)
            sheets.append(sheet_info)
        
        self._current_file = str(file_path)
        
        return ExcelFileInfo(
            file_path=str(file_path),
            file_size=file_size,
            sheet_count=len(sheets),
            sheets=sheets
        )
    
    def _analyze_sheet(self, file_path: Path, sheet_name: str) -> SheetInfo:
        """Analyze a specific sheet"""
        # Read first 1000 rows for analysis
        df = pd.read_excel(file_path, sheet_name=sheet_name, nrows=1000)
        
        # Get full row count
        full_df = pd.read_excel(file_path, sheet_name=sheet_name, usecols=[0])
        row_count = len(full_df)
        
        # Analyze columns
        columns = []
        for idx, col in enumerate(df.columns):
            col_info = self._analyze_column(df[col], col, idx)
            columns.append(col_info)
        
        return SheetInfo(
            name=sheet_name,
            row_count=row_count,
            column_count=len(columns),
            columns=columns
        )
    
    def _analyze_column(self, series: pd.Series, name: str, index: int) -> ColumnInfo:
        """Analyze a single column"""
        # Get non-null values
        non_null = series.dropna()
        
        # Determine data type
        data_type = self._detect_column_type(non_null)
        
        # Get sample values
        sample_values = non_null.head(5).tolist()
        
        return ColumnInfo(
            name=str(name),
            index=index,
            data_type=data_type,
            sample_values=sample_values,
            null_count=series.isnull().sum(),
            unique_count=series.nunique()
        )
    
    def _detect_column_type(self, series: pd.Series) -> ColumnType:
        """Detect column data type"""
        if len(series) == 0:
            return ColumnType.EMPTY
        
        # Try to infer type
        try:
            pd.to_numeric(series)
            return ColumnType.NUMBER
        except:
            pass
        
        try:
            pd.to_datetime(series)
            return ColumnType.DATE
        except:
            pass
        
        # Check for boolean
        unique_values = series.unique()
        if len(unique_values) <= 2:
            bool_values = {True, False, 'True', 'False', 'true', 'false', 
                          'TRUE', 'FALSE', '예', '아니오', 'Yes', 'No'}
            if all(val in bool_values for val in unique_values):
                return ColumnType.BOOLEAN
        
        return ColumnType.TEXT
    
    def read_sheet(self, sheet_name: str, max_rows: Optional[int] = None) -> ExcelData:
        """Read data from a specific sheet"""
        if not self._current_file:
            raise ValueError("No Excel file loaded")
        
        self.logger.info(f"Reading sheet: {sheet_name}")
        
        # Read data
        df = pd.read_excel(self._current_file, sheet_name=sheet_name, nrows=max_rows)
        
        # Create ExcelData instance
        excel_data = ExcelData(df, sheet_name, self._current_file)
        
        # Check for status column
        status_columns = ['상태', 'Status', '완료여부', '처리상태', 'status', 'STATUS']
        for col in status_columns:
            if col in df.columns:
                excel_data.set_status_column(col)
                break
        
        # If no status column found, create one
        if not excel_data.get_status_column():
            excel_data.set_status_column('처리상태')
            self.logger.info("Created new status column: 처리상태")
        
        self._current_data = excel_data
        return excel_data
    
    def save_file(self, file_path: Optional[str] = None) -> str:
        """Save current data back to Excel"""
        if not self._current_data:
            raise ValueError("No data to save")
        
        save_path = file_path or self._current_file
        
        # Read all sheets to preserve
        with pd.ExcelFile(self._current_file) as xls:
            sheets = {}
            for sheet_name in xls.sheet_names:
                if sheet_name == self._current_data.sheet_name:
                    sheets[sheet_name] = self._current_data.dataframe
                else:
                    sheets[sheet_name] = pd.read_excel(xls, sheet_name)
        
        # Save all sheets
        with pd.ExcelWriter(save_path, engine='openpyxl') as writer:
            for sheet_name, df in sheets.items():
                df.to_excel(writer, sheet_name=sheet_name, index=False)
        
        self.logger.info(f"Saved Excel file: {save_path}")
        return save_path
    
    def set_column_mapping(self, excel_column: str, variable_name: str, 
                          data_type: ColumnType, is_required: bool = True):
        """Set mapping between Excel column and variable"""
        mapping = ColumnMapping(
            excel_column=excel_column,
            variable_name=variable_name,
            data_type=data_type,
            is_required=is_required
        )
        self._column_mappings[variable_name] = mapping
    
    def get_mapped_data(self, row_index: int) -> Dict[str, Any]:
        """Get row data with variable mappings applied"""
        if not self._current_data:
            raise ValueError("No data loaded")
        
        row_data = self._current_data.get_row_data(row_index)
        mapped_data = {}
        
        for var_name, mapping in self._column_mappings.items():
            if mapping.excel_column in row_data:
                mapped_data[var_name] = row_data[mapping.excel_column]
            elif mapping.default_value is not None:
                mapped_data[var_name] = mapping.default_value
            elif mapping.is_required:
                raise ValueError(f"Required column '{mapping.excel_column}' not found")
        
        return mapped_data
    
    def update_row_status(self, row_index: int, status: str, save_immediately: bool = False):
        """Update status for a specific row"""
        if not self._current_data:
            raise ValueError("No data loaded")
        
        self._current_data.update_row_status(row_index, status)
        
        if save_immediately:
            self.save_file()
    
    def get_pending_rows(self) -> List[int]:
        """Get list of row indices that need processing"""
        if not self._current_data:
            return []
        
        incomplete = self._current_data.get_incomplete_rows()
        return incomplete.index.tolist()
</file>

<file path="src/ui/dialogs/loop_step_dialog.py">
"""
Loop step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QComboBox, QSpinBox, QListWidget, QListWidgetItem,
    QAbstractItemView, QMessageBox, QTextEdit, QWidget
)
from PyQt5.QtCore import Qt
from core.macro_types import LoopStep, MacroStep
from typing import List, Optional


class LoopStepDialog(QDialog):
    """Dialog for configuring loop step"""
    
    def __init__(self, step: LoopStep, available_steps: List[MacroStep], parent=None):
        super().__init__(parent)
        self.step = step
        self.available_steps = available_steps  # All steps in the macro
        self.setWindowTitle("반복문 설정")
        self.setModal(True)
        self.setMinimumWidth(600)
        self.setMinimumHeight(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("단계 이름:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Loop type group
        type_group = QGroupBox("반복 타입")
        type_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #2196F3;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                color: #1976d2;
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        type_layout = QVBoxLayout()
        
        # Loop type selection
        type_form_layout = QFormLayout()
        self.type_combo = QComboBox()
        self.type_combo.addItems([
            "지정 횟수 반복",
            "이미지가 나타날 때까지",
            "각 엑셀 행에 대해"
        ])
        self.type_combo.currentIndexChanged.connect(self.on_type_changed)
        type_form_layout.addRow("반복 방식:", self.type_combo)
        type_layout.addLayout(type_form_layout)
        
        # Count settings (for count type)
        self.count_widget = QWidget()
        count_layout = QHBoxLayout()
        count_layout.addWidget(QLabel("반복 횟수:"))
        self.count_spin = QSpinBox()
        self.count_spin.setMinimum(1)
        self.count_spin.setMaximum(9999)
        self.count_spin.setValue(5)
        count_layout.addWidget(self.count_spin)
        count_layout.addWidget(QLabel("회"))
        count_layout.addStretch()
        self.count_widget.setLayout(count_layout)
        type_layout.addWidget(self.count_widget)
        
        # Image settings (for while_image type)
        self.image_widget = QWidget()
        image_layout = QVBoxLayout()
        image_info = QLabel(
            "이미지가 화면에 나타날 때까지 반복합니다.\n"
            "이미지 검색 단계를 반복 대상에 포함시켜야 합니다."
        )
        image_info.setWordWrap(True)
        image_info.setStyleSheet("color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        image_layout.addWidget(image_info)
        self.image_widget.setLayout(image_layout)
        self.image_widget.hide()
        type_layout.addWidget(self.image_widget)
        
        # Row settings (for for_each_row type)
        self.row_widget = QWidget()
        row_layout = QVBoxLayout()
        row_info = QLabel(
            "엑셀의 각 행에 대해 반복합니다.\n"
            "변수 치환을 사용하는 단계를 포함시켜 각 행의 데이터를 활용하세요."
        )
        row_info.setWordWrap(True)
        row_info.setStyleSheet("color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        row_layout.addWidget(row_info)
        self.row_widget.setLayout(row_layout)
        self.row_widget.hide()
        type_layout.addWidget(self.row_widget)
        
        type_group.setLayout(type_layout)
        layout.addWidget(type_group)
        
        # Steps selection group
        steps_group = QGroupBox("반복할 단계 선택")
        steps_layout = QVBoxLayout()
        
        steps_info = QLabel("반복할 단계들을 선택하세요 (Ctrl+클릭으로 다중 선택)")
        steps_info.setStyleSheet("color: #666; font-size: 12px;")
        steps_layout.addWidget(steps_info)
        
        # Available steps list
        self.steps_list = QListWidget()
        self.steps_list.setSelectionMode(QAbstractItemView.MultiSelection)
        self.steps_list.setStyleSheet("""
            QListWidget {
                background-color: white;
                border: 2px solid #2196F3;
                border-radius: 5px;
                padding: 5px;
            }
            QListWidget::item {
                padding: 8px;
                margin: 2px;
                border: 1px solid #e0e0e0;
                border-radius: 3px;
                background-color: #f5f5f5;
            }
            QListWidget::item:hover {
                background-color: #e3f2fd;
                border-color: #2196F3;
            }
            QListWidget::item:selected {
                background-color: #1976d2;
                color: white;
                border-color: #1565c0;
            }
        """)
        
        # Add available steps to list
        for step in self.available_steps:
            if step.step_id != self.step.step_id:  # Don't include self
                item = QListWidgetItem(f"{step.name} ({step.step_type.value})")
                item.setData(Qt.UserRole, step.step_id)
                self.steps_list.addItem(item)
                
        steps_layout.addWidget(self.steps_list)
        
        # Selected steps info
        self.selected_info = QLabel("선택된 단계: 0개")
        self.selected_info.setStyleSheet("font-weight: bold;")
        steps_layout.addWidget(self.selected_info)
        
        self.steps_list.itemSelectionChanged.connect(self.update_selected_info)
        
        steps_group.setLayout(steps_layout)
        layout.addWidget(steps_group)
        
        # Description
        desc_layout = QFormLayout()
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(60)
        self.description_edit.setPlaceholderText("반복문에 대한 설명 (선택사항)")
        desc_layout.addRow("설명:", self.description_edit)
        layout.addLayout(desc_layout)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        
        # Set loop type
        type_map = {
            "count": 0,
            "while_image": 1,
            "for_each_row": 2
        }
        self.type_combo.setCurrentIndex(type_map.get(self.step.loop_type, 0))
        
        # Set count
        self.count_spin.setValue(self.step.loop_count)
        
        # Select loop steps
        for i in range(self.steps_list.count()):
            item = self.steps_list.item(i)
            step_id = item.data(Qt.UserRole)
            if step_id in self.step.loop_steps:
                item.setSelected(True)
                
        # Set description
        if hasattr(self.step, 'description'):
            self.description_edit.setText(self.step.description)
            
        self.update_selected_info()
        
    def on_type_changed(self, index):
        """Handle loop type change"""
        # Show/hide appropriate widgets
        self.count_widget.setVisible(index == 0)
        self.image_widget.setVisible(index == 1)
        self.row_widget.setVisible(index == 2)
        
    def update_selected_info(self):
        """Update selected steps info"""
        selected_count = len(self.steps_list.selectedItems())
        self.selected_info.setText(f"선택된 단계: {selected_count}개")
        
    def validate_and_accept(self):
        """Validate input and accept"""
        # Check if any steps are selected
        if not self.steps_list.selectedItems():
            QMessageBox.warning(
                self, "경고",
                "반복할 단계를 최소 1개 이상 선택해주세요."
            )
            return
            
        # Check count for count type
        if self.type_combo.currentIndex() == 0 and self.count_spin.value() < 1:
            QMessageBox.warning(
                self, "경고",
                "반복 횟수는 1 이상이어야 합니다."
            )
            return
            
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        # Get loop type
        type_map = {
            0: "count",
            1: "while_image",
            2: "for_each_row"
        }
        loop_type = type_map[self.type_combo.currentIndex()]
        
        # Get selected step IDs
        loop_steps = []
        for item in self.steps_list.selectedItems():
            loop_steps.append(item.data(Qt.UserRole))
            
        return {
            'name': self.name_edit.text() or "반복문",
            'loop_type': loop_type,
            'loop_count': self.count_spin.value(),
            'loop_steps': loop_steps,
            'description': self.description_edit.toPlainText()
        }
</file>

<file path="src/ui/widgets/simple_roi_selector.py">
"""
Simple ROI selector using screenshot approach
"""

import os
import time
from typing import Optional, Tuple
from PyQt5.QtWidgets import QWidget, QLabel, QRubberBand
from PyQt5.QtCore import Qt, QRect, QPoint, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor, QCursor
import pyautogui


class SimpleROISelector(QWidget):
    """Simple ROI selector that uses screenshot approach"""
    
    selectionComplete = pyqtSignal(tuple)  # (x, y, width, height)
    selectionCancelled = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Selection state
        self.origin = QPoint()
        self.rubber_band = None
        self.screenshot_pixmap = None
        
        # Setup window
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setWindowState(Qt.WindowFullScreen)
        self.setCursor(Qt.CrossCursor)
        
        # Instructions label
        self.label = QLabel(self)
        self.label.setText("드래그하여 영역을 선택하세요. ESC: 취소")
        self.label.setStyleSheet("""
            QLabel {
                background-color: rgba(0, 0, 0, 180);
                color: white;
                padding: 10px;
                font-size: 16px;
                font-weight: bold;
            }
        """)
        self.label.adjustSize()
        self.label.move(10, 10)
        
    def start_selection(self):
        """Start ROI selection"""
        # Take screenshot first
        try:
            # Hide any windows
            QTimer.singleShot(100, self._take_screenshot)
        except Exception as e:
            print(f"Screenshot error: {e}")
            self.selectionCancelled.emit()
            self.close()
            
    def _take_screenshot(self):
        """Take screenshot and show selector"""
        try:
            # Take screenshot using pyautogui
            screenshot = pyautogui.screenshot()
            
            # Convert to QPixmap
            import io
            from PIL import Image
            
            # Save to bytes
            buffer = io.BytesIO()
            screenshot.save(buffer, format='PNG')
            buffer.seek(0)
            
            # Load as QPixmap
            self.screenshot_pixmap = QPixmap()
            self.screenshot_pixmap.loadFromData(buffer.read())
            
            # Set window size to screen size
            self.resize(self.screenshot_pixmap.size())
            
            # Show window
            self.show()
            self.raise_()
            self.activateWindow()
            
        except Exception as e:
            print(f"Screenshot error: {e}")
            self.selectionCancelled.emit()
            self.close()
            
    def paintEvent(self, event):
        """Paint screenshot as background"""
        if self.screenshot_pixmap:
            painter = QPainter(self)
            painter.drawPixmap(0, 0, self.screenshot_pixmap)
            
            # Darken the screenshot slightly (reduced from 50 to 30 for better visibility)
            painter.fillRect(self.rect(), QColor(0, 0, 0, 30))
            
    def mousePressEvent(self, event):
        """Handle mouse press"""
        if event.button() == Qt.LeftButton:
            self.origin = event.pos()
            
            if not self.rubber_band:
                self.rubber_band = QRubberBand(QRubberBand.Rectangle, self)
                self.rubber_band.setStyleSheet("""
                    QRubberBand {
                        border: 2px solid rgb(50, 150, 250);
                        background-color: rgba(50, 150, 250, 30);
                    }
                """)
                
            self.rubber_band.setGeometry(QRect(self.origin, event.pos()))
            self.rubber_band.show()
            
    def mouseMoveEvent(self, event):
        """Handle mouse move"""
        if self.rubber_band and event.buttons() == Qt.LeftButton:
            self.rubber_band.setGeometry(QRect(self.origin, event.pos()).normalized())
            
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() == Qt.LeftButton and self.rubber_band:
            rect = self.rubber_band.geometry()
            
            if rect.width() > 5 and rect.height() > 5:
                # Emit the selection - ensure all values are integers
                region = (int(rect.x()), int(rect.y()), int(rect.width()), int(rect.height()))
                self.selectionComplete.emit(region)
            
            self.close()
            
    def keyPressEvent(self, event):
        """Handle key press"""
        if event.key() == Qt.Key_Escape:
            self.selectionCancelled.emit()
            self.close()
            
    def close(self):
        """Clean up and close"""
        if self.rubber_band:
            self.rubber_band.hide()
        super().close()
</file>

<file path="src/vision/__init__.py">
"""
Vision module for image recognition and text extraction
"""

from vision.image_matcher import ImageMatcher, MatchResult
from vision.text_extractor import TextExtractor, TextResult

__all__ = ['ImageMatcher', 'MatchResult', 'TextExtractor', 'TextResult']
</file>

<file path="src/vision/text_extractor.py">
"""
Text extraction using EasyOCR for dynamic text search
"""

import os
import numpy as np
from typing import Optional, List, Tuple, Dict, Any
from dataclasses import dataclass
import cv2
from PIL import Image
import mss
from logger.app_logger import get_logger

# EasyOCR is required
import easyocr

@dataclass
class TextResult:
    """Result from text detection"""
    text: str
    confidence: float
    bbox: Tuple[int, int, int, int]  # (x, y, width, height)
    center: Tuple[int, int]  # (center_x, center_y)

class TextExtractor:
    """Extract text from screen regions using EasyOCR"""
    
    _instance = None
    _reader = None
    
    def __new__(cls):
        """Singleton pattern to avoid multiple EasyOCR reader instances"""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        """Initialize text extractor"""
        if not hasattr(self, 'initialized'):
            self.logger = get_logger(__name__)
            self.sct = mss.mss()
            self.initialized = True
            
    def _get_reader(self) -> easyocr.Reader:
        """Get or create EasyOCR reader (lazy loading)"""
        if TextExtractor._reader is None:
            self.logger.info("Initializing EasyOCR reader with Korean and English support...")
            # Initialize with Korean and English
            TextExtractor._reader = easyocr.Reader(['ko', 'en'], gpu=False)
            self.logger.info("EasyOCR reader initialized successfully")
        return TextExtractor._reader
    
    def extract_text_from_region(self, region: Optional[Tuple[int, int, int, int]] = None,
                                confidence_threshold: float = 0.5) -> List[TextResult]:
        """
        Extract text from screen region
        
        Args:
            region: (x, y, width, height) or None for full screen
            confidence_threshold: Minimum confidence for text detection
            
        Returns:
            List of TextResult objects
        """
        try:
            # Capture screen region
            if region:
                x, y, width, height = region
                monitor = {"left": x, "top": y, "width": width, "height": height}
            else:
                monitor = self.sct.monitors[1]  # Primary monitor
                
            # Capture screenshot
            screenshot = self.sct.grab(monitor)
            
            # Convert to numpy array
            img = np.array(screenshot)
            # Convert BGRA to RGB
            img_rgb = cv2.cvtColor(img, cv2.COLOR_BGRA2RGB)
            
            # Get reader
            reader = self._get_reader()
            
            # Perform OCR
            results = reader.readtext(img_rgb)
            
            # Process results
            text_results = []
            for bbox, text, confidence in results:
                if confidence >= confidence_threshold:
                    # Convert bbox format
                    # EasyOCR returns [[x1,y1], [x2,y1], [x2,y2], [x1,y2]]
                    x_coords = [point[0] for point in bbox]
                    y_coords = [point[1] for point in bbox]
                    
                    min_x = int(min(x_coords))
                    min_y = int(min(y_coords))
                    max_x = int(max(x_coords))
                    max_y = int(max(y_coords))
                    
                    width = max_x - min_x
                    height = max_y - min_y
                    
                    # Calculate center point
                    center_x = min_x + width // 2
                    center_y = min_y + height // 2
                    
                    # Adjust coordinates if region was specified
                    if region:
                        min_x += region[0]
                        min_y += region[1]
                        center_x += region[0]
                        center_y += region[1]
                    
                    result = TextResult(
                        text=text,
                        confidence=confidence,
                        bbox=(min_x, min_y, width, height),
                        center=(center_x, center_y)
                    )
                    text_results.append(result)
                    
            self.logger.info(f"Extracted {len(text_results)} text items from region")
            return text_results
            
        except Exception as e:
            self.logger.error(f"Error extracting text: {e}")
            return []
    
    def find_text(self, target_text: str, region: Optional[Tuple[int, int, int, int]] = None,
                  exact_match: bool = False, confidence_threshold: float = 0.5) -> Optional[TextResult]:
        """
        Find specific text in screen region
        
        Args:
            target_text: Text to search for
            region: (x, y, width, height) or None for full screen
            exact_match: If True, requires exact match. If False, allows partial match
            confidence_threshold: Minimum OCR confidence
            
        Returns:
            TextResult if found, None otherwise
        """
        try:
            # Extract all text from region
            text_results = self.extract_text_from_region(region, confidence_threshold)
            
            # Normalize target text for comparison
            target_lower = target_text.lower().strip()
            
            # Find matching text
            best_match = None
            best_score = 0.0
            
            for result in text_results:
                text_lower = result.text.lower().strip()
                
                if exact_match:
                    if text_lower == target_lower:
                        return result
                else:
                    # Partial match - check if target is in detected text
                    if target_lower in text_lower:
                        # Score based on how much of the detected text matches
                        score = len(target_lower) / len(text_lower)
                        if score > best_score:
                            best_match = result
                            best_score = score
                    # Also check if detected text is in target (for partial OCR results)
                    elif text_lower in target_lower and len(text_lower) > 2:
                        score = len(text_lower) / len(target_lower)
                        if score > best_score:
                            best_match = result
                            best_score = score
            
            if best_match:
                self.logger.info(f"Found text '{target_text}' at {best_match.center}")
            else:
                self.logger.info(f"Text '{target_text}' not found in region")
                
            return best_match
            
        except Exception as e:
            self.logger.error(f"Error finding text: {e}")
            return None
    
    def find_all_text(self, target_text: str, region: Optional[Tuple[int, int, int, int]] = None,
                      exact_match: bool = False, confidence_threshold: float = 0.5) -> List[TextResult]:
        """
        Find all occurrences of text in screen region
        
        Args:
            target_text: Text to search for
            region: (x, y, width, height) or None for full screen
            exact_match: If True, requires exact match. If False, allows partial match
            confidence_threshold: Minimum OCR confidence
            
        Returns:
            List of TextResult objects
        """
        try:
            # Extract all text from region
            text_results = self.extract_text_from_region(region, confidence_threshold)
            
            # Normalize target text for comparison
            target_lower = target_text.lower().strip()
            
            # Find all matching text
            matches = []
            
            for result in text_results:
                text_lower = result.text.lower().strip()
                
                if exact_match:
                    if text_lower == target_lower:
                        matches.append(result)
                else:
                    # Partial match
                    if target_lower in text_lower or text_lower in target_lower:
                        matches.append(result)
            
            self.logger.info(f"Found {len(matches)} occurrences of '{target_text}'")
            return matches
            
        except Exception as e:
            self.logger.error(f"Error finding all text: {e}")
            return []
    
    def preload_models(self):
        """Preload OCR models to avoid delay on first use"""
        try:
            self.logger.info("Preloading EasyOCR models...")
            reader = self._get_reader()
            # Do a dummy recognition to load models
            dummy_img = np.zeros((100, 100, 3), dtype=np.uint8)
            reader.readtext(dummy_img)
            self.logger.info("EasyOCR models preloaded successfully")
        except Exception as e:
            self.logger.error(f"Error preloading models: {e}")
</file>

<file path="test_results/test_drag_drop_integration_result.json">
{"created": 1752636299.6804233, "duration": 1.383589267730713, "exitcode": 0, "root": "/home/nosky/macro", "environment": {}, "summary": {"passed": 6, "total": 6, "collected": 6}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py", "type": "Module"}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "outcome": "passed", "result": []}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "type": "Function", "lineno": 42}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "type": "Function", "lineno": 72}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "type": "Function", "lineno": 102}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "type": "Function", "lineno": 130}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "type": "Function", "lineno": 157}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "type": "Function", "lineno": 177}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "type": "Class"}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "type": "Class"}]}], "tests": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "lineno": 42, "outcome": "passed", "keywords": ["test_drag_new_step_from_palette", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.008672042982652783, "outcome": "passed"}, "call": {"duration": 0.20474275600281544, "outcome": "passed"}, "teardown": {"duration": 0.0002611030067782849, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "lineno": 72, "outcome": "passed", "keywords": ["test_drag_multiple_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005240975006017834, "outcome": "passed"}, "call": {"duration": 0.42886567598907277, "outcome": "passed"}, "teardown": {"duration": 0.00034497000160627067, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "lineno": 102, "outcome": "passed", "keywords": ["test_reorder_existing_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005278473981888965, "outcome": "passed"}, "call": {"duration": 0.2657914630253799, "outcome": "passed"}, "teardown": {"duration": 0.00031732101342640817, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "lineno": 130, "outcome": "passed", "keywords": ["test_drop_at_specific_positions", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005129875004058704, "outcome": "passed"}, "call": {"duration": 0.21060508702066727, "outcome": "passed"}, "teardown": {"duration": 0.00047970798914320767, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "lineno": 157, "outcome": "passed", "keywords": ["test_drag_cancel", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005245287000434473, "outcome": "passed"}, "call": {"duration": 0.10115242601023056, "outcome": "passed"}, "teardown": {"duration": 0.00041857000906020403, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "lineno": 177, "outcome": "passed", "keywords": ["test_invalid_mime_data", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.006249186000786722, "outcome": "passed"}, "call": {"duration": 0.10108442802447826, "outcome": "passed"}, "teardown": {"duration": 0.0004092309973202646, "outcome": "passed"}}], "warnings": [{"message": "cannot collect test class 'TestScenario' because it has a __init__ constructor (from: tests/integration/test_drag_drop_integration.py)", "category": "PytestCollectionWarning", "when": "collect", "filename": "/home/nosky/macro/tests/test_helpers.py", "lineno": 227}]}
</file>

<file path="test_results/test_step_configuration_result.json">
{"created": 1752636301.615554, "duration": 1.790482521057129, "exitcode": 1, "root": "/home/nosky/macro", "environment": {}, "summary": {"failed": 6, "passed": 1, "total": 7, "collected": 7}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_step_configuration.py", "type": "Module"}]}, {"nodeid": "tests/integration/test_step_configuration.py::TestScenario", "outcome": "passed", "result": []}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_image_step_dialog_creation", "type": "Function", "lineno": 46}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_text_search_dialog_with_excel_binding", "type": "Function", "lineno": 74}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_if_condition_dialog_complex_setup", "type": "Function", "lineno": 112}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_coordinate_recording_simulation", "type": "Function", "lineno": 158}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_dialog_validation", "type": "Function", "lineno": 184}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_step_editing", "type": "Function", "lineno": 203}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_error_handling_options", "type": "Function", "lineno": 236}]}, {"nodeid": "tests/integration/test_step_configuration.py", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_step_configuration.py::TestScenario", "type": "Class"}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration", "type": "Class"}]}], "tests": [{"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_image_step_dialog_creation", "lineno": 46, "outcome": "failed", "keywords": ["test_image_step_dialog_creation", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.024844100989867002, "outcome": "passed"}, "call": {"duration": 0.1170911259832792, "outcome": "failed", "crash": {"path": "/home/nosky/macro/tests/integration/test_step_configuration.py", "lineno": 71, "message": "AssertionError: assert <StepType.WAIT_IMAGE: 'wait_image'> == 'wait_image'\n +  where 'wait_image' = <StepType.WAIT_IMAGE: 'wait_image'>.value\n +    where <StepType.WAIT_IMAGE: 'wait_image'> = StepType.WAIT_IMAGE"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 71, "message": "in test_image_step_dialog_creation"}], "longrepr": "tests/integration/test_step_configuration.py:71: in test_image_step_dialog_creation\n    assert step_dict['step_type'] == StepType.WAIT_IMAGE.value\nE   AssertionError: assert <StepType.WAIT_IMAGE: 'wait_image'> == 'wait_image'\nE    +  where 'wait_image' = <StepType.WAIT_IMAGE: 'wait_image'>.value\nE    +    where <StepType.WAIT_IMAGE: 'wait_image'> = StepType.WAIT_IMAGE\n----------------------------- Captured Qt messages -----------------------------\nQtWarningMsg: This plugin does not support propagateSizeHints()"}, "teardown": {"duration": 0.0004891989810857922, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_text_search_dialog_with_excel_binding", "lineno": 74, "outcome": "failed", "keywords": ["test_text_search_dialog_with_excel_binding", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.0001747639907989651, "outcome": "passed"}, "call": {"duration": 0.000890194991370663, "outcome": "failed", "crash": {"path": "/home/nosky/macro/src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "NameError: name 'QWidget' is not defined"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 82, "message": "in test_text_search_dialog_with_excel_binding"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 32, "message": "in __init__"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "in init_ui"}], "longrepr": "tests/integration/test_step_configuration.py:82: in test_text_search_dialog_with_excel_binding\n    dialog = TextSearchStepDialog(excel_columns=excel_columns)\nsrc/ui/dialogs/text_search_step_dialog.py:32: in __init__\n    self.init_ui()\nsrc/ui/dialogs/text_search_step_dialog.py:74: in init_ui\n    self.fixed_text_widget = QWidget()\nE   NameError: name 'QWidget' is not defined"}, "teardown": {"duration": 0.0002888650051318109, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_if_condition_dialog_complex_setup", "lineno": 112, "outcome": "failed", "keywords": ["test_if_condition_dialog_complex_setup", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00019962899386882782, "outcome": "passed"}, "call": {"duration": 0.0005808589921798557, "outcome": "failed", "crash": {"path": "/home/nosky/macro/src/ui/dialogs/if_condition_step_dialog.py", "lineno": 277, "message": "TypeError: index 0 has type 'tuple' but 'str' is expected"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 118, "message": "in test_if_condition_dialog_complex_setup"}, {"path": "src/ui/dialogs/if_condition_step_dialog.py", "lineno": 241, "message": "in __init__"}, {"path": "src/ui/dialogs/if_condition_step_dialog.py", "lineno": 277, "message": "in init_ui"}], "longrepr": "tests/integration/test_step_configuration.py:118: in test_if_condition_dialog_complex_setup\n    dialog = IfConditionStepDialog(excel_columns=excel_columns)\nsrc/ui/dialogs/if_condition_step_dialog.py:241: in __init__\n    self.init_ui()\nsrc/ui/dialogs/if_condition_step_dialog.py:277: in init_ui\n    self.condition_type_combo.addItems([\nE   TypeError: index 0 has type 'tuple' but 'str' is expected"}, "teardown": {"duration": 0.0001856969902291894, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_coordinate_recording_simulation", "lineno": 158, "outcome": "failed", "keywords": ["test_coordinate_recording_simulation", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00014237299910746515, "outcome": "passed"}, "call": {"duration": 0.00010810099774971604, "outcome": "failed", "crash": {"path": "/home/nosky/macro/tests/integration/test_step_configuration.py", "lineno": 180, "message": "assert False"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 180, "message": "in test_coordinate_recording_simulation"}], "longrepr": "tests/integration/test_step_configuration.py:180: in test_coordinate_recording_simulation\n    assert results['success']\nE   assert False"}, "teardown": {"duration": 0.00010320899309590459, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_dialog_validation", "lineno": 184, "outcome": "failed", "keywords": ["test_dialog_validation", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00013367398059926927, "outcome": "passed"}, "call": {"duration": 0.10393847801606171, "outcome": "failed", "crash": {"path": "/home/nosky/macro/tests/integration/test_step_configuration.py", "lineno": 198, "message": "AttributeError: 'WaitImageStepDialog' object has no attribute 'button_box'"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 198, "message": "in test_dialog_validation"}], "longrepr": "tests/integration/test_step_configuration.py:198: in test_dialog_validation\n    ok_button = dialog.button_box.button(dialog.button_box.Ok)\nE   AttributeError: 'WaitImageStepDialog' object has no attribute 'button_box'\n----------------------------- Captured Qt messages -----------------------------\nQtWarningMsg: This plugin does not support propagateSizeHints()"}, "teardown": {"duration": 0.0003361229901202023, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_step_editing", "lineno": 203, "outcome": "failed", "keywords": ["test_step_editing", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00016349999350495636, "outcome": "passed"}, "call": {"duration": 0.00023993299691937864, "outcome": "failed", "crash": {"path": "/home/nosky/macro/src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "NameError: name 'QWidget' is not defined"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 214, "message": "in test_step_editing"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 32, "message": "in __init__"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "in init_ui"}], "longrepr": "tests/integration/test_step_configuration.py:214: in test_step_editing\n    dialog = TextSearchStepDialog(step=initial_step)\nsrc/ui/dialogs/text_search_step_dialog.py:32: in __init__\n    self.init_ui()\nsrc/ui/dialogs/text_search_step_dialog.py:74: in init_ui\n    self.fixed_text_widget = QWidget()\nE   NameError: name 'QWidget' is not defined"}, "teardown": {"duration": 0.000176066008862108, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_error_handling_options", "lineno": 236, "outcome": "passed", "keywords": ["test_error_handling_options", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00014642099267803133, "outcome": "passed"}, "call": {"duration": 0.10420315599185415, "outcome": "passed"}, "teardown": {"duration": 0.00018910999642685056, "outcome": "passed"}}], "warnings": [{"message": "cannot collect test class 'TestScenario' because it has a __init__ constructor (from: tests/integration/test_step_configuration.py)", "category": "PytestCollectionWarning", "when": "collect", "filename": "/home/nosky/macro/tests/test_helpers.py", "lineno": 227}]}
</file>

<file path=".mcp.json">
{
  "mcpServers": {
    "vooster-ai": {
      "command": "npx",
      "args": [
        "-y",
        "--package=@vooster/mcp@latest",
        "vooster-ai",
        "--api-key=ak_arb850vwbd36cacmyp86xiah"
      ]
    },
    "playwright": {
      "command": "npx",
      "args": [
        "@playwright/mcp@latest"
      ]
    }
  }
}
</file>

<file path="prd.md">
# 제품 요구사항 문서(PRD)  
엑셀 기반 작업 자동화 매크로 데스크탑 앱  

## 1. 개요  
본 데스크탑 앱은 엑셀(Excel) 파일의 작업 목록을 기반으로 사용자가 정의한 순서대로 마우스·키보드·화면 인식 동작을 자동 수행하고 완료 여부를 표시한다. 비개발자 의료인이 반복적인 컴퓨터 작업을 코드 작성 없이 자동화하여 업무 효율을 극대화할 수 있도록 직관적 GUI를 제공한다.

## 2. 문제 정의  
- 의료 현장·사무실의 반복적 전산 업무(환자 정보 입력, 보고서 업로드 등)는 수작업 시간이 길고 오류 발생률이 높음.  
- 병원 전산팀 지원을 받지 못하는 개인·소규모 기관은 별도 자동화 솔루션 도입이 어려움.  
- 엑셀에 정리된 작업 목록을 바탕으로 자동화하려 해도 RPA·매크로 툴은 복잡한 스크립트 작성이 필요.  

## 3. 목표 및 지표  
- 1차 목표: 엑셀→GUI 구성→매크로 실행까지 30분 이내 달성(비개발자 기준).  
- 2차 목표: 수작업 대비 업무 시간 50% 이상 단축, 오류 90% 이상 감소.  
- 성공 지표  
  - Onboarding 완료 시간 ≤30분 사용자 비율 80%  
  - 월간 활성 사용자(MAU) ≥500 의료인  
  - 작업당 평균 소요 시간 50%↓  
  - 자동화 실패율 ≤5%  

## 4. 대상 사용자  
### 주요 사용자  
- 직군: 간호사·의무기록사·의사·행정원  
- 특성: 코딩 지식 없음, 엑셀 사용 능숙, 반복입력·업로드 업무 빈번  
- 니즈: 클릭·키 입력 자동화, 상태 확인, 오류 최소화  

### 부수 사용자  
- 병원 IT 담당자(배포·패키징)  
- 컨설턴트(RPA PoC)  

## 5. 사용자 스토리  
- “간호사로서 환자 100명의 검사 결과를 병원 포털에 등록하려고 엑셀 목록을 불러와 클릭·입력을 자동화하여 시간을 절약하고 싶다.”  
- “의무기록사로서 완료되지 않은 행만 재실행해 누락 없이 기록을 마감하고 싶다.”  
- “행정원으로서 특정 버튼 이미지가 나타나야 다음 단계로 진행하도록 조건부 로직을 설정하고 싶다.”  

## 6. 기능 요구사항  
### 6.1 핵심 기능  
1. 엑셀 연동  
   - 파일 선택 후 시트·열 매핑 UI 제공  
   - 지정 열의 데이터 미리보기 및 타입 검증  
   - 실행 후 상태 열 자동 업데이트(완료/실패/사용자 정의 텍스트)  
   - 수락 기준: 잘못된 경로·시트 지정 시 오류 알림, 상태 열이 없는 경우 자동 생성  

2. GUI 기반 작업 편집기  
   - Drag & Drop 방식 단계 편집 패널  
   - 지원 동작  
     ① 마우스: 이동·클릭·더블클릭·드래그  
     ② 키보드: 텍스트·특수키·단축키(조합)  
③ 화면 인식: 이미지 서치(OpenCV), OCR(EasyOCR)
④ 동적 텍스트 검색 및 클릭(Dynamic Text Search & Click)
   - 간편한 화면 영역 설정: 사용자가 '영역 지정' 버튼을 누르면, 화면이 반투명하게 변하며 마우스로 드래그하여 검색할 사각형 영역을 손쉽게 지정할 수 있음(화면 캡처 도구처럼)
   - 지정된 영역의 좌표는 작업 단계에 자동으로 저장
   - 엑셀 데이터 기반 텍스트 검색 및 클릭: 사용자는 작업 흐름에 "동적 텍스트 찾기" 단계를 추가할 수 있음
   - 이 단계에서 엑셀의 특정 열(e.g., '이름' 또는 '병력번호' 열)을 지정
   - 매크로 실행 시, 프로그램은 미리 지정된 화면 영역 안에서 현재 작업 순서에 해당하는 엑셀의 텍스트(e.g., "홍길동")를 OCR(EasyOCR)로 찾아냄
   - 해당 텍스트를 찾으면 그 좌표를 자동으로 클릭하거나, 다음 동작의 기준점으로 사용
⑤ 흐름 제어: Delay·Loop·If(조건)
   - 엑셀 변수 바인딩(예: {{이름}}) 템플릿 지원  
   - 실시간 미리보기·테스트 실행  
   - 수락 기준: 단계 추가·삭제·순서변경이 3클릭 이내, 미리보기 오류율 ≤5%  

3. 매크로 실행/제어  
   - 행 단위 순차 실행, “미완료만 실행” 옵션  
   - 일시정지·강제종료 핫키(기본 F9, Esc)  
   - 실행 로그: 행 번호, 단계, 성공/실패, 소요시간(ms) CSV 저장  
   - 수락 기준: 10,000행 처리 시 메모리 누수 없이 완료  

### 6.2 보조 기능  
- 작업 템플릿 갤러리(로그인 불필요, 로컬 저장)  
- 다국어 UI(한국어 기본, 영어 선택)  
- 자동 업데이트 체크  
- 다크모드  

### 6.3 Nice-to-Have 제안  
- 음성 명령으로 매크로 시작/정지  
- 작업 스케줄러(특정 시간에 자동 실행)  
- 클라우드 동기화로 여러 PC 설정 공유  
- 오류 발생 시 스크린샷 자동 첨부 리포트  

## 7. 비기능 요구사항  
- 성능: 1단계 실행 응답 ≤300ms, 500단계/행 처리 시 CPU 사용률 50%↓  
- 보안: 로컬 파일·스크립트 암호화 저장(AES-256), 네트워크 전송 없음 기본  
- 사용성: 온보딩 튜토리얼 5분, UI 접근성 WCAG 2.1 AA  
- 확장성: 플러그인 아키텍처로 새 동작 타입 추가 가능  
- 호환성: Windows 10/11 64bit, 해상도 1280×720 이상  

## 8. 기술 고려사항  
- 언어: Python 3.8+  
- GUI: PyQt5(권장), Fallback Tkinter  
- 자동화: PyAutoGUI  
- 이미지: OpenCV 4.x  
- OCR: EasyOCR
- 엑셀: pandas, openpyxl  
- 패키징: PyInstaller(onefile)  
- 구조: MVC 패턴, 작업 단계는 JSON 정의 저장
- 멀티/싱글 모니터 환경 자동 인식 및 주 모니터 기준 동작 보장
- 통합: 병원 사내망 제한 환경 고려, 인터넷 필요 없음  

## 9. 성공 지표  
- 기능 지표: 매크로 완료율 ≥95%, 로그 오류율 ≤2%  
- 사용자 지표: NPS≥50, 재방문률 70%  
- 비즈니스 지표: 라이선스 업셀 비율 20%  
- 기술 지표: 평균 메모리 사용량 ≤500MB, 크래시 0.1/세션↓  

## 10. 일정 및 마일스톤  
- 1단계(MVP, 3개월)  
  - 엑셀 불러오기, 마우스·키보드 동작, 순차 실행, 상태 업데이트  
- 2단계(고도화, +2개월)  
  - 이미지 서치, OCR, 조건·반복, 로그 뷰어  
- 3단계(확장, +2개월)  
  - 템플릿 갤러리, 다국어, 자동 업데이트, 다크모드  
- 4단계(NTH, +3개월)  
  - 음성 명령, 스케줄러, 클라우드 싱크  

## 11. 위험 및 완화  
- 기술: 화면 해상도 및 멀티/싱글 모니터 환경에서 이미지 매칭·마우스 위치 오류 발생 가능 → DPI 스케일 보정 알고리즘 및 멀티 모니터 탐지, 좌표 일치 로직 적용
- 비즈니스: 의료기관 보안 정책으로 실행 파일 차단 → 오프라인 설치 패키지·서명 배포  
- 사용자: 비개발자 혼란 → 인앱 가이드·툴팁·영상 제공  

## 12. 향후 고려사항  
- Mac·리눅스 버전  
- AI 기반 자동 단계 추천(사용 패턴 학습)  
- HIPAA·GDPR 등 의료 데이터 규정 준수 모듈  
- SaaS RPA 연계 API 공개  

(문서 길이: 약 4,100자)
</file>

<file path="requirements.txt">
# Core GUI Framework
PyQt5>=5.15.0

# Data Processing
pandas>=1.3.0
openpyxl>=3.0.0
numpy>=1.21.0

# Screen Automation
pyautogui>=0.9.53
pillow>=8.3.0
opencv-python>=4.5.0

# Screen Information
screeninfo>=0.8.0

# Image Processing
mss>=6.1.0

# OCR (Optical Character Recognition)
easyocr>=1.7.0

# Security
cryptography>=3.4.0

# Testing (optional)
pytest>=6.2.0
pytest-qt>=4.0.0

# Development tools (optional)
black>=21.0
flake8>=3.9.0
</file>

<file path="run_main.py">
#!/usr/bin/env python3
"""
실제 메인 애플리케이션 실행 스크립트
모든 import 문제를 해결하여 실행
"""

import sys
import os
from pathlib import Path

# 프로젝트 경로 설정
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python 경로에 추가
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# 환경 변수 설정
if sys.platform == 'win32':
    os.environ['QT_QPA_PLATFORM'] = 'windows'
else:
    os.environ['QT_QPA_PLATFORM'] = 'xcb'
os.environ['PYTHONPATH'] = f"{project_root}:{src_path}"
os.environ['PYTHONIOENCODING'] = 'utf-8'

# 상대 import를 절대 import로 변경하기 위한 monkey patching
def patch_imports():
    """모든 상대 import를 절대 import로 변경"""
    
    # settings.py의 상대 import 수정
    settings_file = src_path / "config" / "settings.py"
    content = settings_file.read_text(encoding='utf-8')
    content = content.replace("from ..utils.encryption", "from utils.encryption")
    content = content.replace("from ..logger.app_logger", "from logger.app_logger")
    settings_file.write_text(content, encoding='utf-8')
    
    # main_window.py의 상대 import 수정  
    main_window_file = src_path / "ui" / "main_window.py"
    if main_window_file.exists():
        content = main_window_file.read_text(encoding='utf-8')
        content = content.replace("from ..config.settings", "from config.settings")
        content = content.replace("from ..logger.app_logger", "from logger.app_logger")
        content = content.replace("from .widgets.excel_widget", "from ui.widgets.excel_widget")
        content = content.replace("from .widgets.macro_editor", "from ui.widgets.macro_editor")
        content = content.replace("from .widgets.execution_widget", "from ui.widgets.execution_widget")
        main_window_file.write_text(content, encoding='utf-8')
    
    # excel_widget.py의 상대 import 수정
    excel_widget_file = src_path / "ui" / "widgets" / "excel_widget.py"
    if excel_widget_file.exists():
        content = excel_widget_file.read_text(encoding='utf-8')
        content = content.replace("from ...excel.excel_manager", "from excel.excel_manager")
        content = content.replace("from ...config.settings", "from config.settings")
        content = content.replace("from ...logger.app_logger", "from logger.app_logger")
        excel_widget_file.write_text(content, encoding='utf-8')
    
    # macro_editor.py의 상대 import 수정
    macro_editor_file = src_path / "ui" / "widgets" / "macro_editor.py"
    if macro_editor_file.exists():
        content = macro_editor_file.read_text(encoding='utf-8')
        content = content.replace("from ...core", "from core")
        content = content.replace("from ..dialogs", "from ui.dialogs")
        macro_editor_file.write_text(content, encoding='utf-8')
    
    # execution_widget.py의 상대 import 수정
    execution_widget_file = src_path / "ui" / "widgets" / "execution_widget.py"
    if execution_widget_file.exists():
        content = execution_widget_file.read_text(encoding='utf-8')
        content = content.replace("from ...automation", "from automation")
        content = content.replace("from ...core", "from core")
        content = content.replace("from ...config", "from config")
        content = content.replace("from ...logger", "from logger")
        execution_widget_file.write_text(content, encoding='utf-8')
    
    # 다른 파일들도 수정
    for py_file in src_path.rglob("*.py"):
        try:
            content = py_file.read_text(encoding='utf-8')
            if "from .." in content:
                # 상대 import를 절대 import로 변경
                content = content.replace("from ...", "from ")
                content = content.replace("from ..", "from ")
                py_file.write_text(content, encoding='utf-8')
        except:
            pass

# Import 수정 적용
print("Import 경로 수정 중...")
patch_imports()
print("Import 경로 수정 완료!")

# 이제 메인 애플리케이션 실행
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    from PyQt5.QtGui import QFont
    
    # High DPI 지원 - QApplication 생성 전에 설정
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    
    # 애플리케이션 초기화
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # 한글 폰트 설정
    font = QFont("Nanum Gothic", 10)
    app.setFont(font)
    
    # 메인 윈도우 import 및 실행
    from ui.main_window import MainWindow
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    # 로거 설정
    logger = setup_logger()
    logger.info("Starting Excel Macro Automation Application")
    
    # 설정 초기화
    settings = Settings()
    
    # 메인 윈도우 생성 및 표시
    window = MainWindow(settings)
    window.setWindowTitle("Excel 기반 작업 자동화 매크로")
    window.show()
    
    print("\n✓ Excel Macro Automation 애플리케이션이 실행되었습니다!")
    print("✓ 모든 GUI 컴포넌트가 로드되었습니다.")
    print("\n기능:")
    print("- Excel 탭: 파일 불러오기, 시트 선택, 데이터 미리보기")
    print("- Editor 탭: 드래그 앤 드롭 매크로 편집")
    print("- Run 탭: 매크로 실행 및 모니터링")
    print("\n창을 닫으면 종료됩니다.")
    
    # 이벤트 루프 실행
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"\n오류 발생: {e}")
    print("\n자세한 오류 정보:")
    import traceback
    traceback.print_exc()
    
    print("\n디버깅 정보:")
    print(f"Project root: {project_root}")
    print(f"Src path: {src_path}")
    print(f"Python path: {sys.path[:3]}")
</file>

<file path="trd.md">
# Technical Requirements Document (TRD)

## 1. Executive Technical Summary
- **프로젝트 개요**  
  Python 기반 데스크탑 애플리케이션으로, 엑셀 파일의 작업 목록을 GUI로 로드·편집하고 PyAutoGUI/OpenCV/Tesseract를 이용해 마우스·키보드·화면 인식 매크로를 실행합니다. MVC 패턴을 적용해 유지 보수성과 확장성을 확보하며, 오프라인 환경에서 단일 파일 배포 방식(PyInstaller)으로 동작합니다.

- **핵심 기술 스택**  
Python 3.8+, PyQt5(Tkinter 대체), PyAutoGUI, OpenCV 4.x, EasyOCR, pandas, openpyxl, PyInstaller

- **주요 기술 목표**  
  • 1단계 실행 응답 ≤300ms  
  • 10,000행 처리 시 메모리 누수 없이 완료  
  • CPU 사용률 500단계/행 처리 시 50% 이하 유지  
  • 자동화 실패율 ≤5%  

- **중요 가정 사항**  
  • Windows 10/11 64bit 전용  
  • 인터넷 연결 없이 오프라인 실행  
  • 단일 사용자 환경(로컬 파일 저장)  
  • DPI 스케일 & 멀티 모니터 환경 자동 인식  

---

## 2. Tech Stack

| Category         | Technology / Library   | Reasoning (선택 이유)                                    |
| ---------------- | ---------------------- | ------------------------------------------------------- |
| 언어             | Python 3.8+            | 풍부한 라이브러리와 커뮤니티, 빠른 개발 속도              |
| GUI 프레임워크   | PyQt5                  | 직관적 WYSIWYG 에디터, 풍부한 위젯, 반응형 레이아웃 지원  |
| GUI 대체         | Tkinter                | PyQt5 비설치 시 기본 제공, 최소 기능 보장                |
| 자동화 엔진      | PyAutoGUI              | 마우스/키보드 제어, 크로스 플랫폼 지원                   |
| 이미지 처리      | OpenCV 4.x             | 고성능 이미지 서치 및 DPI 스케일 보정                     |
| OCR 엔진         | EasyOCR                | 한글 인식 정확도가 높고, Tesseract 대비 실패율이 낮음. 파이썬 연동도 매우 간편함. |
| 엑셀 처리        | pandas, openpyxl       | 대용량 엑셀 데이터 처리, 시트·셀 CRUD 지원               |
| 패키징           | PyInstaller (onefile)  | 단일 실행 파일 배포, 오프라인 설치 지원                 |
| 구조 패턴        | MVC                    | 역할 분리로 유지보수성·확장성 확보                        |
| 설정·정의 저장   | JSON                   | 가볍고 가독성 높은 매크로 단계 정의 파일                  |

---

## 3. System Architecture Design

### Top-Level Building Blocks
- UI Layer (PyQt5/Tkinter)  
  • 작업 편집기, 시트·열 매핑, 실시간 미리보기  
- Core Controller  
  • 사용자 인터랙션 처리, 매크로 단계 조합, 상태 관리  
- Automation Engine  
  • PyAutoGUI 기반 동작 실행, OpenCV 이미지 서치, EasyOCR 엔진 OCR  
- Data Access Layer  
  • pandas/openpyxl로 엑셀 입출력, 로그(CSV) 저장  
- Config & Plugin Manager  
  • JSON 기반 플러그인/단계 정의 로딩, 다국어 리소스  
- Packaging & Deployment  
  • PyInstaller 빌드 스크립트, AES-256 암호화 옵션  

### Top-Level Component Interaction Diagram
```mermaid
graph TD
    U[UI Layer] --> C[Core Controller]
    C --> A[Automation Engine]
    C --> D[Data Access Layer]
    A --> I[Image/OCR]
    D --> E[Excel Files]
    D --> L[Log CSV]
```

- UI Layer에서 Core Controller로 사용자 입력·명령 전달  
- Core Controller가 Automation Engine과 Data Access Layer를 조정  
- Automation Engine은 OpenCV·Tesseract로 화면 인식 후 PyAutoGUI로 동작 실행  
- Data Access Layer는 엑셀 파일 입출력 및 실행 로그(CSV) 저장  

### Code Organization & Convention

**Domain-Driven Organization Strategy**  
- Domain Separation: `excel`, `ui`, `automation`, `core`, `plugin`  
- Layer-Based Architecture: `presentation(UI)`, `application(core)`, `domain(automation)`, `infrastructure(data)`  
- Feature-Based Modules: 단계별(`mouse_actions`, `keyboard_actions`, `image_search`, `flow_control`)  
- Shared Components: 공통 유틸(`utils`), 암호화·설정(`config`), 로깅(`logger`)

**Universal File & Folder Structure**
```
/project-root
├── build/                     # PyInstaller 빌드 출력
├── config/
│   ├── settings.json         # 앱 설정(암호화)
│   └── locales/              # 다국어 리소스
├── plugin/                    # 확장 플러그인 정의(JSON)
├── src/
│   ├── core/                  # 애플리케이션 로직
│   ├── ui/                    # PyQt5/Tkinter 뷰
│   ├── automation/            # PyAutoGUI, OpenCV, OCR 모듈
│   ├── data/                  # 엑셀 및 로그 입출력
│   ├── utils/                 # 공통 유틸리티
│   └── main.py                # 엔트리 포인트
├── tests/                     # 단위/통합 테스트
└── requirements.txt           # 패키지 의존성
```

### Data Flow & Communication Patterns
- **클라이언트-컨트롤러 통신**: UI 이벤트 → Core Controller 메서드 호출  
- **데이터베이스(엑셀) 상호작용**: pandas/openpyxl 동기식 읽기·쓰기  
- **외부 서비스 연동**: 없음(오프라인 환경 기본)  
- **실시간 통신**: UI 스레드와 백그라운드 작업 스레드 간 큐/시그널  
- **데이터 동기화**: 실행 로그(CSV)에 단계별 결과 즉시 기록  

---

## 4. Performance & Optimization Strategy
- 이미지 매칭용 ROI(Region of Interest) 및 템플릿 캐싱으로 검색 속도 개선  
- 백그라운드 스레드 사용으로 UI 응답성 확보  
- OpenCV 멀티스레드 빌드 활용 및 Tesseract ROI 설정으로 OCR 속도 최적화  
- 메모리 누수 방지 위해 실행 후 리소스(이미지·객체) 명시적 해제  

---

## 5. Implementation Roadmap & Milestones

### Phase 1: Foundation (MVP Implementation)
- **Core Infrastructure**: 개발 환경 설정, CI/CD(GitHub Actions), 기본 프로젝트 구조  
- **Essential Features**: 엑셀 불러오기·매핑 UI, 마우스·키보드 순차 실행, 상태 열 업데이트  
- **Basic Security**: 설정 파일 AES-256 암호화 저장  
- **Development Setup**: 가상환경, lint(Flake8), 단위 테스트 프레임워크  
- **Timeline**: 3개월

### Phase 2: Feature Enhancement
- **Advanced Features**: 이미지 서치(OpenCV), OCR(pytesseract), Loop·If 제어  
- **Performance Optimization**: 스레드 최적화, 템플릿 캐싱 개선  
- **Enhanced Security**: 코드 서명, 설치 패키지 보안 옵션  
- **Monitoring Implementation**: 상세 실행 로그 CSV 뷰어 모듈  
- **Timeline**: 2개월

### Phase 3: Scaling & Optimization
- **Scalability Implementation**: 플러그인 아키텍처 완성, 멀티 모니터 안정화  
- **Advanced Integrations**: 자동 업데이트 체크, 다국어 UI, 다크모드  
- **Enterprise Features**: 로컬 템플릿 갤러리, 구성 동기화 옵션  
- **Compliance & Auditing**: 감사 로그, 실행 이력 리포트  
- **Timeline**: 2개월

---

## 6. Risk Assessment & Mitigation Strategies

### Technical Risk Analysis
- **기술 리스크**: 이미지 매칭 오류 → DPI 보정 알고리즘 및 멀티 모니터 좌표 동기화  
- **성능 리스크**: 대용량 데이터 처리 시 느려짐 → ROI 캐싱·백그라운드 스레드 활용  
- **보안 리스크**: 설정 파일 무단 열람 → AES-256 암호화 및 파일 권한 제한  
- **통합 리스크**: Tesseract 버전 호환성 → 사전 테스트 및 로컬 번들링  
- **Mitigation**: 사전 환경 검증 스크립트, 자동화 테스트, 주기적 보안 감사

### Project Delivery Risks
- **일정 리스크**: 기능 복잡도 과소평가 → MVP 범위 명확화 및 주기적 스코프 리뷰  
- **리소스 리스크**: Python GUI 전문 개발자 부족 → 문서화·내부 워크숍 실시  
- **품질 리스크**: 테스트 커버리지 저조 → CI 병합 전 80% 이상 커버리지 강제  
- **배포 리스크**: 병원 보안 정책 차단 → 오프라인 설치 패키지, 디지털 서명 제공  
- **비상 계획**: 주요 기능 지연 시 Nice-to-Have 후순위 조정, 페일오버 설치 지침 작성
</file>

<file path="web_macro.json">
[
  {
    "type": "mouse_click",
    "name": "마우스 클릭"
  },
  {
    "type": "keyboard_type",
    "name": "텍스트 입력"
  },
  {
    "type": "wait_time",
    "name": "대기"
  }
]
</file>

<file path="src/automation/engine.py">
"""
Main macro execution engine
"""

import time
import threading
from typing import Optional, Dict, Any, List, Callable
from enum import Enum
from PyQt5.QtCore import QThread, pyqtSignal, QObject
import pyautogui
from core.macro_types import Macro, MacroStep
from excel.excel_manager import ExcelManager
from logger.app_logger import get_logger
from config.settings import Settings
from automation.executor import StepExecutor
from automation.hotkey_listener import HotkeyListener
from logger.execution_logger import get_execution_logger

class ExecutionState(Enum):
    """Execution states"""
    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

class ExecutionResult:
    """Result of a single execution"""
    def __init__(self, row_index: int, success: bool, 
                 error: Optional[str] = None, duration_ms: float = 0):
        self.row_index = row_index
        self.success = success
        self.error = error
        self.duration_ms = duration_ms
        self.timestamp = time.time()

class ExecutionEngine(QThread):
    """Main macro execution engine"""
    
    # Signals
    stateChanged = pyqtSignal(ExecutionState)
    progressUpdated = pyqtSignal(int, int)  # current, total
    rowCompleted = pyqtSignal(ExecutionResult)
    stepExecuting = pyqtSignal(MacroStep, int)  # step, row_index
    executionFinished = pyqtSignal()
    error = pyqtSignal(str)
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.logger = get_logger(__name__)
        self.settings = settings
        
        # State management
        self._state = ExecutionState.IDLE
        self._state_lock = threading.Lock()
        self._pause_event = threading.Event()
        self._pause_event.set()  # Not paused by default
        
        # Execution components
        self.step_executor = StepExecutor(settings)
        self.hotkey_listener = HotkeyListener(settings)
        self.execution_logger = get_execution_logger()
        
        # Current execution context
        self.macro: Optional[Macro] = None
        self.excel_manager: Optional[ExcelManager] = None
        self.target_rows: List[int] = []
        self.current_row_index: Optional[int] = None
        
        # Configure PyAutoGUI
        self._configure_pyautogui()
        
        # Connect hotkey signals
        self.hotkey_listener.pausePressed.connect(self.toggle_pause)
        self.hotkey_listener.stopPressed.connect(self.stop_execution)
        
    def _configure_pyautogui(self):
        """Configure PyAutoGUI settings"""
        pyautogui.FAILSAFE = True  # Move mouse to corner to abort
        pyautogui.PAUSE = self.settings.get("execution.default_delay_ms", 100) / 1000.0
        
        # Log screen size for debugging
        screen_width, screen_height = pyautogui.size()
        self.logger.info(f"Screen size: {screen_width}x{screen_height}")
        
    @property
    def state(self) -> ExecutionState:
        """Get current execution state"""
        with self._state_lock:
            return self._state
            
    def _set_state(self, new_state: ExecutionState):
        """Set execution state"""
        with self._state_lock:
            old_state = self._state
            self._state = new_state
            
        if old_state != new_state:
            self.logger.info(f"State changed: {old_state.value} -> {new_state.value}")
            self.stateChanged.emit(new_state)
            
    def set_macro(self, macro: Macro, excel_manager: ExcelManager):
        """Set macro and Excel manager for execution"""
        if self.state != ExecutionState.IDLE:
            raise RuntimeError("Cannot set macro while execution is active")
            
        self.macro = macro
        self.excel_manager = excel_manager
        
        # Validate macro
        errors = macro.validate()
        if errors:
            raise ValueError(f"Macro validation failed: {', '.join(errors)}")
            
    def set_target_rows(self, row_indices: List[int]):
        """Set specific rows to execute"""
        self.target_rows = row_indices
        
    def run(self):
        """Main execution thread"""
        if not self.macro or not self.excel_manager:
            self.error.emit("No macro or Excel data loaded")
            return
            
        try:
            self._set_state(ExecutionState.RUNNING)
            self.hotkey_listener.start()
            
            # Start CSV logging session
            excel_file = self.excel_manager.file_path if self.excel_manager else "Unknown"
            log_file = self.execution_logger.start_session(self.macro.name, excel_file)
            self.logger.info(f"Execution log started: {log_file}")
            
            # Get rows to process
            if not self.target_rows:
                # Process all incomplete rows
                self.target_rows = self.excel_manager.get_pending_rows()
                
            total_rows = len(self.target_rows)
            self.logger.info(f"Starting execution for {total_rows} rows")
            
            # Track statistics
            successful_rows = 0
            failed_rows = 0
            
            # Execute each row
            for i, row_index in enumerate(self.target_rows):
                # Check if stopping
                if self.state == ExecutionState.STOPPING:
                    break
                    
                # Handle pause
                self._pause_event.wait()
                
                # Update progress
                self.progressUpdated.emit(i + 1, total_rows)
                self.current_row_index = row_index
                
                # Execute macro for this row
                result = self._execute_row(row_index)
                
                # Update statistics
                if result.success:
                    successful_rows += 1
                else:
                    failed_rows += 1
                
                # Update Excel status
                status = "완료" if result.success else f"실패: {result.error}"
                self.excel_manager.update_row_status(row_index, status)
                
                # Emit result
                self.rowCompleted.emit(result)
                
                # Small delay between rows
                time.sleep(0.1)
                
            # Save Excel file after all rows
            self.excel_manager.save_file()
            
            # Log session summary
            self.execution_logger.log_session_end(
                total_rows=len(self.target_rows),
                successful_rows=successful_rows,
                failed_rows=failed_rows
            )
            
            self._set_state(ExecutionState.IDLE)
            self.executionFinished.emit()
            
        except Exception as e:
            self.logger.error(f"Execution error: {e}", exc_info=True)
            self.execution_logger.log_error("EXECUTION_ERROR", str(e), details=str(e))
            self.error.emit(str(e))
            self._set_state(ExecutionState.ERROR)
            
        finally:
            self.hotkey_listener.stop()
            self.current_row_index = None
            self.execution_logger.close()
            
    def _execute_row(self, row_index: int) -> ExecutionResult:
        """Execute macro for a single row"""
        start_time = time.time()
        
        try:
            # Get row data with mappings
            row_data = self.excel_manager.get_mapped_data(row_index)
            
            # Log row start
            self.execution_logger.log_row_start(row_index, row_data)
            
            # Set variables in executor context
            self.step_executor.set_variables(row_data)
            
            # Execute each step
            for step_index, step in enumerate(self.macro.steps):
                # Check if stopping
                if self.state == ExecutionState.STOPPING:
                    return ExecutionResult(row_index, False, "Execution stopped")
                    
                # Handle pause
                self._pause_event.wait()
                
                # Skip disabled steps
                if not step.enabled:
                    continue
                    
                # Emit step executing signal
                self.stepExecuting.emit(step, row_index)
                
                # Execute step
                step_start_time = time.time()
                step_success = False
                step_error = ""
                
                try:
                    self.step_executor.execute_step(step)
                    step_success = True
                except Exception as e:
                    error_msg = f"Step '{step.name}' failed: {str(e)}"
                    self.logger.error(error_msg)
                    step_error = str(e)
                    
                    # Emit detailed error for UI
                    if step.error_handling.value == "stop":
                        self.error.emit(error_msg)
                    
                    # Handle error based on step configuration
                    if step.error_handling.value == "stop":
                        # Log failed step
                        step_duration = (time.time() - step_start_time) * 1000
                        self.execution_logger.log_step_execution(
                            row_index, step_index, step.name, step.step_type.value,
                            False, step_duration, step_error
                        )
                        return ExecutionResult(row_index, False, error_msg)
                    elif step.error_handling.value == "retry":
                        # Retry logic
                        for retry in range(step.retry_count):
                            try:
                                time.sleep(1)  # Wait before retry
                                self.step_executor.execute_step(step)
                                step_success = True
                                step_error = ""
                                break
                            except:
                                if retry == step.retry_count - 1:
                                    # Log failed step after all retries
                                    step_duration = (time.time() - step_start_time) * 1000
                                    self.execution_logger.log_step_execution(
                                        row_index, step_index, step.name, step.step_type.value,
                                        False, step_duration, step_error
                                    )
                                    return ExecutionResult(row_index, False, error_msg)
                    # For "continue", just log and proceed
                
                # Log step execution result
                step_duration = (time.time() - step_start_time) * 1000
                self.execution_logger.log_step_execution(
                    row_index, step_index, step.name, step.step_type.value,
                    step_success, step_duration, step_error
                )
                    
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(row_index, True, duration_ms)
            return ExecutionResult(row_index, True, None, duration_ms)
            
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(row_index, False, duration_ms, str(e))
            return ExecutionResult(row_index, False, str(e), duration_ms)
            
    def toggle_pause(self):
        """Toggle pause state"""
        if self.state == ExecutionState.RUNNING:
            self._set_state(ExecutionState.PAUSED)
            self._pause_event.clear()
            self.logger.info("Execution paused")
        elif self.state == ExecutionState.PAUSED:
            self._set_state(ExecutionState.RUNNING)
            self._pause_event.set()
            self.logger.info("Execution resumed")
            
    def stop_execution(self):
        """Stop execution"""
        if self.state in [ExecutionState.RUNNING, ExecutionState.PAUSED]:
            self._set_state(ExecutionState.STOPPING)
            self._pause_event.set()  # Resume if paused
            self.logger.info("Stopping execution...")
            
    def is_running(self) -> bool:
        """Check if execution is active"""
        return self.state in [ExecutionState.RUNNING, ExecutionState.PAUSED]
</file>

<file path="src/config/settings.py">
"""
Application settings management with encryption support
"""

import json
import os
from pathlib import Path
from typing import Any, Dict, Optional
from utils.encryption import EncryptionManager

class Settings:
    """Manages application settings with encryption support"""
    
    DEFAULT_SETTINGS = {
        "version": "1.0.0",
        "language": "ko",
        "theme": "light",
        "hotkeys": {
            "pause": "F9",
            "stop": "Escape"
        },
        "execution": {
            "default_delay_ms": 100,
            "screenshot_quality": 95,
            "ocr_confidence_threshold": 0.7
        },
        "ui": {
            "window_size": [1280, 720],
            "show_tooltips": True,
            "confirm_exit": True,
            "compact_mode": False
        }
    }
    
    def __init__(self, config_dir: Optional[Path] = None):
        """Initialize settings manager"""
        self.config_dir = config_dir or Path.home() / ".excel_macro_automation"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        self.settings_file = self.config_dir / "settings.json"
        self.encrypted_settings_file = self.config_dir / "settings.enc"
        
        self.encryption_manager = EncryptionManager()
        self.settings = self._load_settings()
    
    def _load_settings(self) -> Dict[str, Any]:
        """Load settings from file or create defaults"""
        # Try loading encrypted settings first
        if self.encrypted_settings_file.exists():
            try:
                encrypted_data = self.encrypted_settings_file.read_bytes()
                decrypted_data = self.encryption_manager.decrypt(encrypted_data)
                return json.loads(decrypted_data.decode('utf-8'))
            except Exception as e:
                print(f"Failed to load encrypted settings: {e}")
        
        # Try loading plain JSON settings
        if self.settings_file.exists():
            try:
                return json.loads(self.settings_file.read_text(encoding='utf-8'))
            except Exception as e:
                print(f"Failed to load settings: {e}")
        
        # Return default settings
        return self.DEFAULT_SETTINGS.copy()
    
    def save(self, encrypted: bool = True) -> None:
        """Save settings to file"""
        settings_json = json.dumps(self.settings, indent=2, ensure_ascii=False)
        
        if encrypted:
            encrypted_data = self.encryption_manager.encrypt(settings_json.encode('utf-8'))
            self.encrypted_settings_file.write_bytes(encrypted_data)
            # Remove plain text version if it exists
            if self.settings_file.exists():
                self.settings_file.unlink()
        else:
            self.settings_file.write_text(settings_json, encoding='utf-8')
            # Remove encrypted version if it exists
            if self.encrypted_settings_file.exists():
                self.encrypted_settings_file.unlink()
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get setting value by key (supports dot notation)"""
        keys = key.split('.')
        value = self.settings
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def set(self, key: str, value: Any) -> None:
        """Set setting value by key (supports dot notation)"""
        keys = key.split('.')
        target = self.settings
        
        for k in keys[:-1]:
            if k not in target:
                target[k] = {}
            target = target[k]
        
        target[keys[-1]] = value
    
    def reset_to_defaults(self) -> None:
        """Reset all settings to defaults"""
        self.settings = self.DEFAULT_SETTINGS.copy()
        self.save()
</file>

<file path="src/core/macro_storage.py">
"""
Macro storage and JSON serialization
"""

import json
import os
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
import shutil
from enum import Enum
from utils.encryption import EncryptionManager
from logger.app_logger import get_logger
from core.macro_types import Macro


class MacroFormat(Enum):
    """Supported macro file formats"""
    JSON = "json"
    ENCRYPTED = "encrypted"

class MacroStorage:
    """Handles macro storage, loading, and saving"""
    
    SCHEMA_VERSION = "1.0.0"
    
    def __init__(self, storage_dir: Optional[Path] = None):
        """Initialize macro storage"""
        self.logger = get_logger(__name__)
        self.storage_dir = storage_dir or Path.home() / ".excel_macro_automation" / "macros"
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        self.encryption_manager = EncryptionManager()
        
    def save_macro(self, macro: Macro, file_path: Optional[str] = None, 
                   format_type: MacroFormat = MacroFormat.JSON, create_backup: bool = True) -> bool:
        """Save macro to file"""
        if not file_path:
            file_name = f"{macro.name.replace(' ', '_')}_{macro.macro_id[:8]}.json"
            file_path = self.storage_dir / file_name
        else:
            file_path = Path(file_path)
            
        # Create backup if requested and file exists
        if create_backup and file_path.exists():
            self._create_backup(file_path)
            
        # Prepare data
        data = {
            "schema_version": self.SCHEMA_VERSION,
            "macro": macro.to_dict()
        }
        
        # Convert to JSON
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        
        # Save file
        try:
            if format_type == MacroFormat.ENCRYPTED:
                encrypted_data = self.encryption_manager.encrypt(json_str.encode('utf-8'))
                file_path = file_path.with_suffix('.emf')
                file_path.write_bytes(encrypted_data)
                self.logger.info(f"Saved encrypted macro: {file_path}")
            else:
                file_path.write_text(json_str, encoding='utf-8')
                self.logger.info(f"Saved macro: {file_path}")
                
            return True
        except Exception as e:
            self.logger.error(f"Failed to save macro: {e}")
            return False
        
    def load_macro(self, file_path: str) -> Macro:
        """Load macro from file"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Macro file not found: {file_path}")
            
        # Check if encrypted
        if file_path.suffix in ['.emacro', '.emf']:
            encrypted_data = file_path.read_bytes()
            json_data = self.encryption_manager.decrypt(encrypted_data).decode('utf-8')
            data = json.loads(json_data)
        else:
            data = json.loads(file_path.read_text(encoding='utf-8'))
            
        # Check schema version
        schema_version = data.get("schema_version", "0.0.0")
        if schema_version != self.SCHEMA_VERSION:
            self.logger.warning(f"Schema version mismatch: {schema_version} != {self.SCHEMA_VERSION}")
            # In future, handle migration here
            
        # Load macro
        macro_data = data.get("macro", {})
        macro = Macro.from_dict(macro_data)
        
        self.logger.info(f"Loaded macro: {macro.name} from {file_path}")
        return macro
        
    def list_macros(self, include_encrypted: bool = True) -> List[Dict[str, Any]]:
        """List all saved macros"""
        macros = []
        
        # Search for macro files
        patterns = ['*.json']
        if include_encrypted:
            patterns.append('*.emacro')
            
        for pattern in patterns:
            for file_path in self.storage_dir.glob(pattern):
                try:
                    # Get basic info without fully loading
                    if file_path.suffix == '.emacro':
                        # For encrypted files, we need to decrypt to get info
                        macro = self.load_macro(str(file_path))
                        info = {
                            "file_path": str(file_path),
                            "file_name": file_path.name,
                            "macro_id": macro.macro_id,
                            "name": macro.name,
                            "description": macro.description,
                            "created_at": macro.created_at.isoformat(),
                            "updated_at": macro.updated_at.isoformat(),
                            "encrypted": True
                        }
                    else:
                        # For JSON files, we can peek without full parsing
                        data = json.loads(file_path.read_text(encoding='utf-8'))
                        macro_data = data.get("macro", {})
                        info = {
                            "file_path": str(file_path),
                            "file_name": file_path.name,
                            "macro_id": macro_data.get("macro_id", ""),
                            "name": macro_data.get("name", ""),
                            "description": macro_data.get("description", ""),
                            "created_at": macro_data.get("created_at", ""),
                            "updated_at": macro_data.get("updated_at", ""),
                            "encrypted": False
                        }
                    macros.append(info)
                except Exception as e:
                    self.logger.error(f"Failed to read macro file {file_path}: {e}")
                    
        # Sort by updated date
        macros.sort(key=lambda x: x["updated_at"], reverse=True)
        return macros
        
    def delete_macro(self, file_path: str, create_backup: bool = True) -> bool:
        """Delete a macro file"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            return False
            
        if create_backup:
            self._create_backup(file_path)
            
        file_path.unlink()
        self.logger.info(f"Deleted macro: {file_path}")
        return True
        
    def export_macro(self, macro: Macro, export_path: str) -> str:
        """Export macro for sharing"""
        export_path = Path(export_path)
        
        # Always export as unencrypted JSON for sharing
        data = {
            "schema_version": self.SCHEMA_VERSION,
            "macro": macro.to_dict(),
            "export_info": {
                "exported_at": datetime.now().isoformat(),
                "export_version": "1.0.0"
            }
        }
        
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        export_path.write_text(json_str, encoding='utf-8')
        
        self.logger.info(f"Exported macro: {export_path}")
        return str(export_path)
        
    def import_macro(self, import_path: str, save_to_storage: bool = True) -> Macro:
        """Import macro from external file"""
        import_path = Path(import_path)
        
        if not import_path.exists():
            raise FileNotFoundError(f"Import file not found: {import_path}")
            
        # Load the macro
        data = json.loads(import_path.read_text(encoding='utf-8'))
        
        # Check if it's an export file
        if "export_info" in data:
            self.logger.info(f"Importing from export: {data['export_info']}")
            
        macro_data = data.get("macro", {})
        macro = Macro.from_dict(macro_data)
        
        # Generate new ID to avoid conflicts
        import uuid
        macro.macro_id = str(uuid.uuid4())
        macro.updated_at = datetime.now()
        
        # Save to storage if requested
        if save_to_storage:
            self.save_macro(macro)
            
        self.logger.info(f"Imported macro: {macro.name}")
        return macro
        
    def _create_backup(self, file_path: Path):
        """Create backup of file"""
        backup_dir = self.storage_dir / "backups"
        backup_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{file_path.stem}_backup_{timestamp}{file_path.suffix}"
        backup_path = backup_dir / backup_name
        
        shutil.copy2(file_path, backup_path)
        self.logger.info(f"Created backup: {backup_path}")
        
        # Clean old backups (keep last 10)
        self._clean_old_backups(file_path.stem)
        
    def _clean_old_backups(self, file_stem: str, keep_count: int = 10):
        """Clean old backup files"""
        backup_dir = self.storage_dir / "backups"
        if not backup_dir.exists():
            return
            
        # Find all backups for this file
        backups = list(backup_dir.glob(f"{file_stem}_backup_*"))
        backups.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        # Delete old backups
        for backup in backups[keep_count:]:
            backup.unlink()
            self.logger.info(f"Deleted old backup: {backup}")
            
    def get_templates(self) -> List[Dict[str, Any]]:
        """Get available macro templates"""
        templates = [
            {
                "name": "기본 자동화",
                "description": "마우스 클릭과 텍스트 입력을 포함한 기본 템플릿",
                "macro": self._create_basic_template()
            },
            {
                "name": "웹 자동화",
                "description": "웹 브라우저 자동화를 위한 템플릿",
                "macro": self._create_web_template()
            },
            {
                "name": "엑셀 데이터 입력",
                "description": "엑셀 데이터를 다른 프로그램에 입력하는 템플릿",
                "macro": self._create_excel_input_template()
            }
        ]
        return templates
        
    def _create_basic_template(self) -> Macro:
        """Create basic automation template"""
        from core.macro_types import MouseClickStep, WaitTimeStep, KeyboardTypeStep
        
        macro = Macro(name="기본 자동화 템플릿")
        
        # Add sample steps
        click_step = MouseClickStep(
            name="프로그램 클릭",
            description="자동화할 프로그램을 클릭합니다"
        )
        macro.add_step(click_step)
        
        wait_step = WaitTimeStep(
            name="대기",
            description="프로그램이 준비될 때까지 대기",
            seconds=2.0
        )
        macro.add_step(wait_step)
        
        type_step = KeyboardTypeStep(
            name="텍스트 입력",
            description="입력할 텍스트",
            text="{{이름}}"
        )
        macro.add_step(type_step)
        
        return macro
        
    def _create_web_template(self) -> Macro:
        """Create web automation template"""
        from core.macro_types import WaitTimeStep, KeyboardHotkeyStep, KeyboardTypeStep
        
        macro = Macro(name="웹 자동화 템플릿")
        
        # Open browser
        hotkey_step = KeyboardHotkeyStep(
            name="브라우저 열기",
            description="웹 브라우저를 엽니다",
            keys=["win", "r"]
        )
        macro.add_step(hotkey_step)
        
        wait_step = WaitTimeStep(seconds=1.0)
        macro.add_step(wait_step)
        
        type_step = KeyboardTypeStep(
            name="브라우저 실행",
            text="chrome"
        )
        macro.add_step(type_step)
        
        return macro
        
    def _create_excel_input_template(self) -> Macro:
        """Create Excel input template"""
        from core.macro_types import LoopStep, KeyboardTypeStep, KeyboardHotkeyStep
        
        macro = Macro(name="엑셀 데이터 입력 템플릿")
        
        # This is a placeholder - would need proper implementation
        # with Excel row iteration
        
        return macro
</file>

<file path="src/ui/dialogs/if_condition_step_dialog.py">
"""
If condition step configuration dialog
"""

from typing import Optional, Dict, Any, List
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox,
    QPushButton, QLabel, QGroupBox, QListWidget,
    QListWidgetItem, QTextEdit, QWidget, QSplitter,
    QMessageBox, QCompleter, QCheckBox, QFileDialog,
    QMenu
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QIcon
from core.macro_types import IfConditionStep, MacroStep, StepType
from ui.widgets.roi_selector import ROISelectorWidget

class DraggableStepButton(QPushButton):
    """Draggable button for step types"""
    
    def __init__(self, step_type: StepType, text: str):
        super().__init__(text)
        self.step_type = step_type
        self.setStyleSheet("""
            QPushButton {
                padding: 8px 12px;
                border: 2px solid #2196F3;
                border-radius: 4px;
                background-color: white;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #e3f2fd;
                cursor: move;
            }
        """)
        
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drag_start_position = event.pos()
            
    def mouseMoveEvent(self, event):
        if not (event.buttons() & Qt.LeftButton):
            return
            
        if (event.pos() - self.drag_start_position).manhattanLength() < 10:
            return
            
        # Start drag
        from PyQt5.QtGui import QDrag
        from PyQt5.QtCore import QMimeData, QByteArray, QDataStream, QIODevice
        
        drag = QDrag(self)
        mime_data = QMimeData()
        
        # Store step type in MIME data
        # Use setText instead of binary encoding to avoid Qt version issues
        mime_data.setData("application/x-steptype", self.step_type.value.encode())
        mime_data.setText(self.text())
        drag.setMimeData(mime_data)
        
        drag.exec_(Qt.CopyAction)

class ConditionTypeWidget(QWidget):
    """Widget for configuring condition parameters based on type"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)
        
    def set_condition_type(self, condition_type: str, excel_columns: List[str] = None):
        """Update UI based on condition type"""
        # Clear existing widgets
        while self.layout.count():
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
                
        if condition_type == "image_exists":
            self._setup_image_condition()
        elif condition_type == "text_exists":
            self._setup_text_condition()
        elif condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            self._setup_variable_condition(excel_columns)
            
    def _setup_image_condition(self):
        """Setup UI for image exists condition"""
        form_layout = QFormLayout()
        
        # Image path
        self.image_path_edit = QLineEdit()
        self.image_browse_btn = QPushButton("찾아보기...")
        self.image_browse_btn.clicked.connect(self._browse_image)
        image_layout = QHBoxLayout()
        image_layout.addWidget(self.image_path_edit)
        image_layout.addWidget(self.image_browse_btn)
        form_layout.addRow("이미지 파일:", image_layout)
        
        # Confidence
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setRange(0.1, 1.0)
        self.confidence_spin.setSingleStep(0.1)
        self.confidence_spin.setValue(0.9)
        form_layout.addRow("정확도:", self.confidence_spin)
        
        # Region selector
        self.region_selector = ROISelectorWidget()
        form_layout.addRow("검색 영역:", self.region_selector)
        
        # Test button
        self.test_btn = QPushButton("조건 테스트")
        self.test_btn.setStyleSheet("""
            QPushButton {
                background-color: #4caf50;
                color: white;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.test_btn.clicked.connect(self._test_image_condition)
        
        # Test result
        self.test_result_label = QLabel()
        self.test_result_label.setWordWrap(True)
        
        test_layout = QVBoxLayout()
        test_layout.addWidget(self.test_btn)
        test_layout.addWidget(self.test_result_label)
        form_layout.addRow("", test_layout)
        
        self.layout.addLayout(form_layout)
        
    def _browse_image(self):
        """Browse for image file"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "이미지 파일 선택",
            "",
            "Image Files (*.png *.jpg *.jpeg *.bmp *.gif);;All Files (*.*)"
        )
        if filename:
            self.image_path_edit.setText(filename)
        
    def _setup_text_condition(self):
        """Setup UI for text exists condition"""
        form_layout = QFormLayout()
        
        # Search text
        self.text_edit = QLineEdit()
        self.text_edit.setPlaceholderText("검색할 텍스트 또는 {{변수}}")
        form_layout.addRow("텍스트:", self.text_edit)
        
        # Exact match
        self.exact_match_check = QCheckBox("정확히 일치")
        form_layout.addRow("", self.exact_match_check)
        
        # Region selector
        self.region_selector = ROISelectorWidget()
        form_layout.addRow("검색 영역:", self.region_selector)
        
        self.layout.addLayout(form_layout)
        
    def _setup_variable_condition(self, excel_columns: List[str] = None):
        """Setup UI for variable comparison condition"""
        form_layout = QFormLayout()
        
        # Variable name
        self.variable_combo = QComboBox()
        self.variable_combo.setEditable(True)
        if excel_columns:
            self.variable_combo.addItems(excel_columns)
        form_layout.addRow("변수:", self.variable_combo)
        
        # Comparison value
        self.compare_value_edit = QLineEdit()
        self.compare_value_edit.setPlaceholderText("비교할 값 또는 {{변수}}")
        form_layout.addRow("비교값:", self.compare_value_edit)
        
        self.layout.addLayout(form_layout)
        
    def get_condition_value(self) -> Dict[str, Any]:
        """Get condition parameters"""
        value = {}
        
        # Image exists
        if hasattr(self, 'image_path_edit'):
            value['image_path'] = self.image_path_edit.text()
            value['confidence'] = self.confidence_spin.value()
            value['region'] = self.region_selector.get_region()
            
        # Text exists
        elif hasattr(self, 'text_edit'):
            value['text'] = self.text_edit.text()
            value['exact_match'] = self.exact_match_check.isChecked()
            value['region'] = self.region_selector.get_region()
            
        # Variable comparison
        elif hasattr(self, 'variable_combo'):
            value['variable'] = self.variable_combo.currentText()
            value['compare_value'] = self.compare_value_edit.text()
            
        return value
        
    def _test_image_condition(self):
        """Test image condition"""
        image_path = self.image_path_edit.text()
        if not image_path:
            self.test_result_label.setText("❌ 이미지 파일을 선택해주세요.")
            self.test_result_label.setStyleSheet("color: red;")
            return
            
        try:
            import pyautogui
            # Test image search
            location = pyautogui.locateOnScreen(
                image_path,
                confidence=self.confidence_spin.value(),
                region=self.region_selector.get_region()
            )
            
            if location:
                self.test_result_label.setText(f"✅ 이미지를 찾았습니다! 위치: ({location.left}, {location.top})")
                self.test_result_label.setStyleSheet("color: green; font-weight: bold;")
            else:
                self.test_result_label.setText("❌ 이미지를 찾을 수 없습니다.")
                self.test_result_label.setStyleSheet("color: red;")
                
        except Exception as e:
            self.test_result_label.setText(f"❌ 테스트 중 오류: {str(e)}")
            self.test_result_label.setStyleSheet("color: red;")
        
    def set_condition_value(self, value: Dict[str, Any]):
        """Set condition parameters"""
        # Image exists
        if hasattr(self, 'image_path_edit') and 'image_path' in value:
            self.image_path_edit.setText(value.get('image_path', ''))
            self.confidence_spin.setValue(value.get('confidence', 0.9))
            if value.get('region'):
                self.region_selector.set_region(value['region'])
                
        # Text exists
        elif hasattr(self, 'text_edit') and 'text' in value:
            self.text_edit.setText(value.get('text', ''))
            self.exact_match_check.setChecked(value.get('exact_match', False))
            if value.get('region'):
                self.region_selector.set_region(value['region'])
                
        # Variable comparison
        elif hasattr(self, 'variable_combo') and 'variable' in value:
            self.variable_combo.setCurrentText(value.get('variable', ''))
            self.compare_value_edit.setText(value.get('compare_value', ''))

class StepListWidget(QListWidget):
    """Widget for displaying and managing nested steps"""
    
    stepAdded = pyqtSignal(MacroStep)
    stepRemoved = pyqtSignal(str)  # step_id
    stepEdited = pyqtSignal(MacroStep)
    
    def __init__(self):
        super().__init__()
        self.steps: List[MacroStep] = []
        self.setAcceptDrops(True)
        self.setDragDropMode(QListWidget.InternalMove)
        self.setStyleSheet("""
            QListWidget {
                background-color: white;
                border: 1px solid #ddd;
                border-radius: 3px;
                padding: 5px;
                min-height: 100px;
            }
            QListWidget::item {
                padding: 5px;
                margin: 2px;
                border: 1px solid #e0e0e0;
                border-radius: 3px;
            }
            QListWidget::item:hover {
                background-color: #f5f5f5;
                border-color: #bdbdbd;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
                border-color: #2196F3;
            }
        """)
        
    def add_step(self, step_type: StepType):
        """Add a new step of given type"""
        from core.macro_types import StepFactory
        step = StepFactory.create_step(step_type)
        
        # Set default name
        step_names = {
            StepType.MOUSE_CLICK: "마우스 클릭",
            StepType.KEYBOARD_TYPE: "텍스트 입력",
            StepType.WAIT_TIME: "대기",
            StepType.IMAGE_SEARCH: "이미지 검색",
            StepType.OCR_TEXT: "텍스트 검색"
        }
        step.name = step_names.get(step_type, step_type.value)
        
        self.steps.append(step)
        self._refresh_list()
        self.stepAdded.emit(step)
        
    def remove_selected(self):
        """Remove selected step"""
        current_row = self.currentRow()
        if 0 <= current_row < len(self.steps):
            removed_step = self.steps.pop(current_row)
            self._refresh_list()
            self.stepRemoved.emit(removed_step.step_id)
            
    def get_steps(self) -> List[MacroStep]:
        """Get all steps"""
        return self.steps
        
    def set_steps(self, steps: List[MacroStep]):
        """Set steps"""
        self.steps = steps.copy()
        self._refresh_list()
        
    def _refresh_list(self):
        """Refresh list display"""
        self.clear()
        
        for step in self.steps:
            icon = self._get_step_icon(step.step_type)
            text = f"{icon} {step.name}"
            if hasattr(step, 'description') and step.description:
                text += f" - {step.description}"
                
            item = QListWidgetItem(text)
            self.addItem(item)
            
    def _get_step_icon(self, step_type: StepType) -> str:
        """Get icon for step type"""
        icons = {
            StepType.MOUSE_CLICK: "🖱️",
            StepType.KEYBOARD_TYPE: "⌨️",
            StepType.WAIT_TIME: "⏱️",
            StepType.IMAGE_SEARCH: "🔍",
            StepType.OCR_TEXT: "🔤"
        }
        return icons.get(step_type, "")
        
    def dragEnterEvent(self, event):
        """Handle drag enter event"""
        if event.mimeData().hasFormat("application/x-steptype"):
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)
            
    def dragMoveEvent(self, event):
        """Handle drag move event"""
        if event.mimeData().hasFormat("application/x-steptype"):
            event.acceptProposedAction()
        else:
            super().dragMoveEvent(event)
            
    def dropEvent(self, event):
        """Handle drop event"""
        if event.mimeData().hasFormat("application/x-steptype"):
            # Extract step type from mime data
            # Use simpler byte decoding to avoid Qt version issues
            byte_array = event.mimeData().data("application/x-steptype")
            step_type_str = bytes(byte_array).decode('utf-8')
            
            # Create new step
            step_type = StepType(step_type_str)
            self.add_step(step_type)
            
            event.acceptProposedAction()
        else:
            super().dropEvent(event)

class IfConditionStepDialog(QDialog):
    """Dialog for configuring if condition step"""
    
    def __init__(self, step: Optional[IfConditionStep] = None, 
                 excel_columns: List[str] = None, parent=None):
        super().__init__(parent)
        self.step = step or IfConditionStep()
        self.excel_columns = excel_columns or []
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("조건문 설정")
        self.setModal(True)
        self.resize(800, 600)
        
        layout = QVBoxLayout()
        
        # Basic info
        info_group = QGroupBox("기본 정보")
        info_layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        self.name_edit.setText(self.step.name or "조건문")
        info_layout.addRow("이름:", self.name_edit)
        
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(60)
        self.description_edit.setText(self.step.description)
        info_layout.addRow("설명:", self.description_edit)
        
        info_group.setLayout(info_layout)
        layout.addWidget(info_group)
        
        # Condition configuration
        condition_group = QGroupBox("조건 설정")
        condition_layout = QVBoxLayout()
        
        # Condition type
        type_layout = QHBoxLayout()
        type_layout.addWidget(QLabel("조건 유형:"))
        
        self.condition_type_combo = QComboBox()
        self.condition_type_combo.addItems([
            ("이미지가 존재하면", "image_exists"),
            ("텍스트가 존재하면", "text_exists"),
            ("변수가 같으면", "variable_equals"),
            ("변수가 포함하면", "variable_contains"),
            ("변수가 크면", "variable_greater"),
            ("변수가 작으면", "variable_less")
        ])
        
        # Set display text
        for i in range(self.condition_type_combo.count()):
            self.condition_type_combo.setItemData(i, self.condition_type_combo.itemText(i).split(",")[1].strip(), Qt.UserRole)
            self.condition_type_combo.setItemText(i, self.condition_type_combo.itemText(i).split(",")[0])
            
        self.condition_type_combo.currentIndexChanged.connect(self._on_condition_type_changed)
        type_layout.addWidget(self.condition_type_combo)
        type_layout.addStretch()
        condition_layout.addLayout(type_layout)
        
        # Condition parameters
        self.condition_widget = ConditionTypeWidget()
        condition_layout.addWidget(self.condition_widget)
        
        condition_group.setLayout(condition_layout)
        layout.addWidget(condition_group)
        
        # Branch steps
        branches_group = QGroupBox("분기 동작")
        branches_layout = QVBoxLayout()
        
        # Add help text
        help_text = QLabel("💡 팁: 아래 단계 유형을 드래그하여 조건 분기에 추가하거나, '단계 추가' 버튼을 사용하세요.")
        help_text.setWordWrap(True)
        help_text.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        branches_layout.addWidget(help_text)
        
        # Add mini palette
        palette_layout = QHBoxLayout()
        palette_label = QLabel("단계 유형:")
        palette_label.setStyleSheet("font-weight: bold;")
        palette_layout.addWidget(palette_label)
        
        # Create draggable step type buttons
        step_types = [
            (StepType.MOUSE_CLICK, "🖱️ 클릭"),
            (StepType.KEYBOARD_TYPE, "⌨️ 입력"),
            (StepType.WAIT_TIME, "⏱️ 대기"),
            (StepType.IMAGE_SEARCH, "🔍 이미지"),
        ]
        
        for step_type, label in step_types:
            btn = DraggableStepButton(step_type, label)
            palette_layout.addWidget(btn)
            
        palette_layout.addStretch()
        branches_layout.addLayout(palette_layout)
        
        # Create splitter for true/false branches
        splitter = QSplitter(Qt.Horizontal)
        
        # True branch
        true_widget = QWidget()
        true_widget.setStyleSheet("""
            QWidget {
                background-color: #e8f5e9;
                border: 2px solid #4caf50;
                border-radius: 5px;
                padding: 5px;
            }
        """)
        true_layout = QVBoxLayout()
        true_label = QLabel("✅ 조건이 참일 때:")
        true_label.setStyleSheet("font-weight: bold; color: #2e7d32; font-size: 13px;")
        true_layout.addWidget(true_label)
        
        self.true_steps_list = StepListWidget()
        true_layout.addWidget(self.true_steps_list)
        
        # True branch buttons
        true_btn_layout = QHBoxLayout()
        
        add_true_menu = QPushButton("단계 추가")
        add_true_menu.setMenu(self._create_step_menu(self.true_steps_list))
        true_btn_layout.addWidget(add_true_menu)
        
        remove_true_btn = QPushButton("삭제")
        remove_true_btn.clicked.connect(self.true_steps_list.remove_selected)
        true_btn_layout.addWidget(remove_true_btn)
        
        true_btn_layout.addStretch()
        true_layout.addLayout(true_btn_layout)
        
        true_widget.setLayout(true_layout)
        splitter.addWidget(true_widget)
        
        # False branch
        false_widget = QWidget()
        false_widget.setStyleSheet("""
            QWidget {
                background-color: #ffebee;
                border: 2px solid #f44336;
                border-radius: 5px;
                padding: 5px;
            }
        """)
        false_layout = QVBoxLayout()
        false_label = QLabel("❌ 조건이 거짓일 때:")
        false_label.setStyleSheet("font-weight: bold; color: #c62828; font-size: 13px;")
        false_layout.addWidget(false_label)
        
        self.false_steps_list = StepListWidget()
        false_layout.addWidget(self.false_steps_list)
        
        # False branch buttons
        false_btn_layout = QHBoxLayout()
        
        add_false_menu = QPushButton("단계 추가")
        add_false_menu.setMenu(self._create_step_menu(self.false_steps_list))
        false_btn_layout.addWidget(add_false_menu)
        
        remove_false_btn = QPushButton("삭제")
        remove_false_btn.clicked.connect(self.false_steps_list.remove_selected)
        false_btn_layout.addWidget(remove_false_btn)
        
        false_btn_layout.addStretch()
        false_layout.addLayout(false_btn_layout)
        
        false_widget.setLayout(false_layout)
        splitter.addWidget(false_widget)
        
        branches_layout.addWidget(splitter)
        branches_group.setLayout(branches_layout)
        layout.addWidget(branches_group)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        ok_btn = QPushButton("확인")
        ok_btn.clicked.connect(self.accept)
        button_layout.addWidget(ok_btn)
        
        cancel_btn = QPushButton("취소")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
        # Initialize condition type
        self._on_condition_type_changed()
        
    def _create_step_menu(self, step_list: StepListWidget):
        """Create menu for adding steps"""
        menu = QMenu()
        
        # Simple steps only (no nested conditions)
        simple_steps = [
            (StepType.MOUSE_CLICK, "🖱️ 마우스 클릭"),
            (StepType.KEYBOARD_TYPE, "⌨️ 텍스트 입력"),
            (StepType.WAIT_TIME, "⏱️ 대기"),
            (StepType.IMAGE_SEARCH, "🔍 이미지 검색"),
            (StepType.OCR_TEXT, "🔤 텍스트 검색")
        ]
        
        for step_type, name in simple_steps:
            action = menu.addAction(name)
            action.triggered.connect(lambda checked, st=step_type: step_list.add_step(st))
            
        return menu
        
    def _on_condition_type_changed(self):
        """Handle condition type change"""
        # Get selected type value
        condition_type = self.condition_type_combo.currentData(Qt.UserRole)
        if not condition_type:
            condition_type = self.condition_type_combo.currentText()
            
        # Map display text to type value
        type_mapping = {
            "이미지가 존재하면": "image_exists",
            "텍스트가 존재하면": "text_exists",
            "변수가 같으면": "variable_equals",
            "변수가 포함하면": "variable_contains",
            "변수가 크면": "variable_greater",
            "변수가 작으면": "variable_less"
        }
        
        if condition_type in type_mapping:
            condition_type = type_mapping[condition_type]
            
        self.condition_widget.set_condition_type(condition_type, self.excel_columns)
        
    def load_step_data(self):
        """Load data from step"""
        if not self.step:
            return
            
        self.name_edit.setText(self.step.name)
        self.description_edit.setText(self.step.description)
        
        # Set condition type
        type_index = {
            "image_exists": 0,
            "text_exists": 1,
            "variable_equals": 2,
            "variable_contains": 3,
            "variable_greater": 4,
            "variable_less": 5
        }.get(self.step.condition_type, 0)
        
        self.condition_type_combo.setCurrentIndex(type_index)
        self.condition_widget.set_condition_value(self.step.condition_value)
        
        # Set branch steps
        self.true_steps_list.set_steps(self.step.true_steps)
        self.false_steps_list.set_steps(self.step.false_steps)
        
    def get_step_data(self) -> Dict[str, Any]:
        """Get configured step data"""
        # Get condition type
        condition_type = self.condition_type_combo.currentData(Qt.UserRole)
        if not condition_type:
            type_mapping = {
                "이미지가 존재하면": "image_exists",
                "텍스트가 존재하면": "text_exists",
                "변수가 같으면": "variable_equals",
                "변수가 포함하면": "variable_contains",
                "변수가 크면": "variable_greater",
                "변수가 작으면": "variable_less"
            }
            condition_type = type_mapping.get(self.condition_type_combo.currentText(), "image_exists")
            
        return {
            'name': self.name_edit.text(),
            'description': self.description_edit.toPlainText(),
            'condition_type': condition_type,
            'condition_value': self.condition_widget.get_condition_value(),
            'true_steps': self.true_steps_list.get_steps(),
            'false_steps': self.false_steps_list.get_steps()
        }
        
    def accept(self):
        """Validate and accept"""
        # Basic validation
        if not self.name_edit.text():
            QMessageBox.warning(self, "경고", "이름을 입력해주세요.")
            return
            
        # Validate condition parameters
        condition_value = self.condition_widget.get_condition_value()
        condition_type = self.get_step_data()['condition_type']
        
        if condition_type == "image_exists" and not condition_value.get('image_path'):
            QMessageBox.warning(self, "경고", "이미지 파일을 선택해주세요.")
            return
            
        elif condition_type == "text_exists" and not condition_value.get('text'):
            QMessageBox.warning(self, "경고", "검색할 텍스트를 입력해주세요.")
            return
            
        elif condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            if not condition_value.get('variable'):
                QMessageBox.warning(self, "경고", "변수를 선택해주세요.")
                return
            if not condition_value.get('compare_value'):
                QMessageBox.warning(self, "경고", "비교값을 입력해주세요.")
                return
                
        super().accept()
</file>

<file path="src/ui/dialogs/text_search_step_dialog.py">
"""
Dialog for configuring text search steps with Excel column binding
"""

from typing import Optional, Dict, Any, Tuple
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QPushButton, QLabel, QCheckBox, QSpinBox,
    QDoubleSpinBox, QComboBox, QGroupBox, QMessageBox,
    QDialogButtonBox, QWidget, QApplication
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor
from core.macro_types import TextSearchStep
from ui.widgets.roi_selector import ROISelectorOverlay
from vision.text_extractor import TextExtractor
import pyautogui

class TextSearchStepDialog(QDialog):
    """Dialog for configuring text search steps"""
    
    def __init__(self, step: Optional[TextSearchStep] = None, 
                 excel_columns: list = None, parent=None):
        super().__init__(parent)
        self.step = step or TextSearchStep()
        self.excel_columns = excel_columns or []
        self.region = self.step.region
        self.text_extractor = TextExtractor()
        self.setWindowTitle("텍스트 검색 단계 설정")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Basic info
        form_layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("예: 환자 이름 찾기")
        form_layout.addRow("단계 이름:", self.name_edit)
        
        layout.addLayout(form_layout)
        
        # Text search configuration
        search_group = QGroupBox("텍스트 검색 설정")
        search_layout = QVBoxLayout()
        
        # Search text type selection
        text_type_layout = QHBoxLayout()
        text_type_layout.addWidget(QLabel("검색 방법:"))
        
        self.fixed_text_radio = QCheckBox("고정 텍스트")
        self.excel_column_radio = QCheckBox("엑셀 열 데이터")
        self.fixed_text_radio.setChecked(True)
        
        # Make them mutually exclusive
        self.fixed_text_radio.toggled.connect(
            lambda checked: self.excel_column_radio.setChecked(not checked) if checked else None
        )
        self.excel_column_radio.toggled.connect(
            lambda checked: self.fixed_text_radio.setChecked(not checked) if checked else None
        )
        
        text_type_layout.addWidget(self.fixed_text_radio)
        text_type_layout.addWidget(self.excel_column_radio)
        text_type_layout.addStretch()
        search_layout.addLayout(text_type_layout)
        
        # Fixed text input
        self.fixed_text_widget = QWidget()
        fixed_text_layout = QHBoxLayout()
        fixed_text_layout.setContentsMargins(0, 0, 0, 0)
        fixed_text_layout.addWidget(QLabel("검색할 텍스트:"))
        self.search_text_edit = QLineEdit()
        self.search_text_edit.setPlaceholderText("예: 홍길동")
        fixed_text_layout.addWidget(self.search_text_edit)
        self.fixed_text_widget.setLayout(fixed_text_layout)
        search_layout.addWidget(self.fixed_text_widget)
        
        # Excel column selection
        self.excel_column_widget = QWidget()
        excel_layout = QHBoxLayout()
        excel_layout.setContentsMargins(0, 0, 0, 0)
        excel_layout.addWidget(QLabel("엑셀 열:"))
        self.excel_column_combo = QComboBox()
        self.excel_column_combo.addItems(self.excel_columns)
        excel_layout.addWidget(self.excel_column_combo)
        self.excel_column_widget.setLayout(excel_layout)
        self.excel_column_widget.setVisible(False)
        search_layout.addWidget(self.excel_column_widget)
        
        # Connect radio buttons to show/hide widgets
        self.fixed_text_radio.toggled.connect(self.fixed_text_widget.setVisible)
        self.excel_column_radio.toggled.connect(self.excel_column_widget.setVisible)
        
        search_group.setLayout(search_layout)
        layout.addWidget(search_group)
        
        # Search region configuration
        region_group = QGroupBox("검색 영역")
        region_layout = QVBoxLayout()
        
        # Region display
        self.region_label = QLabel("전체 화면")
        if self.region:
            self.region_label.setText(
                f"영역: ({self.region[0]}, {self.region[1]}) "
                f"크기: {self.region[2]}x{self.region[3]}"
            )
        region_layout.addWidget(self.region_label)
        
        # Region buttons
        region_btn_layout = QHBoxLayout()
        
        self.select_region_btn = QPushButton("영역 선택")
        self.select_region_btn.clicked.connect(self._select_region)
        region_btn_layout.addWidget(self.select_region_btn)
        
        self.clear_region_btn = QPushButton("영역 초기화")
        self.clear_region_btn.clicked.connect(self._clear_region)
        region_btn_layout.addWidget(self.clear_region_btn)
        
        self.preview_region_btn = QPushButton("영역 미리보기")
        self.preview_region_btn.clicked.connect(self._preview_region)
        region_btn_layout.addWidget(self.preview_region_btn)
        
        region_layout.addLayout(region_btn_layout)
        region_group.setLayout(region_layout)
        layout.addWidget(region_group)
        
        # Matching options
        options_group = QGroupBox("매칭 옵션")
        options_layout = QFormLayout()
        
        self.exact_match_check = QCheckBox("정확히 일치")
        self.exact_match_check.setToolTip(
            "체크 시: 검색 텍스트와 정확히 일치하는 경우만 찾음\n"
            "체크 해제 시: 부분 일치도 허용"
        )
        options_layout.addRow("매칭 방식:", self.exact_match_check)
        
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setRange(0.0, 1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.5)
        self.confidence_spin.setToolTip("OCR 인식 신뢰도 (0.0~1.0)")
        options_layout.addRow("인식 신뢰도:", self.confidence_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Click options
        click_group = QGroupBox("클릭 옵션")
        click_layout = QFormLayout()
        
        self.click_after_find_check = QCheckBox("찾은 후 클릭")
        self.click_after_find_check.setChecked(True)
        click_layout.addRow("동작:", self.click_after_find_check)
        
        # Click type selection
        click_type_widget = QWidget()
        click_type_layout = QHBoxLayout()
        click_type_layout.setContentsMargins(0, 0, 0, 0)
        click_type_layout.addWidget(QLabel("클릭 유형:"))
        self.click_type_combo = QComboBox()
        self.click_type_combo.addItems(["한번 클릭", "더블 클릭"])
        self.click_type_combo.setCurrentIndex(0)
        click_type_layout.addWidget(self.click_type_combo)
        click_type_layout.addStretch()
        click_type_widget.setLayout(click_type_layout)
        click_layout.addRow("", click_type_widget)
        
        # Enable/disable click type based on click checkbox
        self.click_after_find_check.toggled.connect(self.click_type_combo.setEnabled)
        
        # Click offset
        offset_widget = QWidget()
        offset_layout = QHBoxLayout()
        offset_layout.setContentsMargins(0, 0, 0, 0)
        
        offset_layout.addWidget(QLabel("X:"))
        self.offset_x_spin = QSpinBox()
        self.offset_x_spin.setRange(-100, 100)
        self.offset_x_spin.setValue(0)
        self.offset_x_spin.setToolTip("텍스트 중심에서 X 오프셋")
        offset_layout.addWidget(self.offset_x_spin)
        
        offset_layout.addWidget(QLabel("Y:"))
        self.offset_y_spin = QSpinBox()
        self.offset_y_spin.setRange(-100, 100)
        self.offset_y_spin.setValue(0)
        self.offset_y_spin.setToolTip("텍스트 중심에서 Y 오프셋")
        offset_layout.addWidget(self.offset_y_spin)
        
        offset_widget.setLayout(offset_layout)
        click_layout.addRow("클릭 오프셋:", offset_widget)
        
        click_group.setLayout(click_layout)
        layout.addWidget(click_group)
        
        # Test button
        self.test_btn = QPushButton("테스트")
        self.test_btn.clicked.connect(self._test_search)
        layout.addWidget(self.test_btn)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal, self
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        
        # Set search method
        if self.step.excel_column:
            self.excel_column_radio.setChecked(True)
            # Find and select the column
            index = self.excel_column_combo.findText(self.step.excel_column)
            if index >= 0:
                self.excel_column_combo.setCurrentIndex(index)
        else:
            self.fixed_text_radio.setChecked(True)
            self.search_text_edit.setText(self.step.search_text)
        
        # Set options
        self.exact_match_check.setChecked(self.step.exact_match)
        self.confidence_spin.setValue(self.step.confidence)
        self.click_after_find_check.setChecked(self.step.click_after_find)
        self.offset_x_spin.setValue(self.step.click_offset[0])
        self.offset_y_spin.setValue(self.step.click_offset[1])
        
        # Set click type
        if hasattr(self.step, 'double_click'):
            self.click_type_combo.setCurrentIndex(1 if self.step.double_click else 0)
        
    def _select_region(self):
        """Select screen region"""
        # Hide dialog temporarily
        self.hide()
        # Give time for dialog to hide before showing ROI selector
        QTimer.singleShot(200, self._show_region_selector)
        
    def _show_region_selector(self):
        """Show region selector overlay"""
        try:
            print("DEBUG: Creating ROI selector")
            # Create ROI selector as a top-level window
            self.roi_selector = ROISelectorOverlay(parent=None)
            self.roi_selector.selectionComplete.connect(self._on_region_selected)
            self.roi_selector.selectionCancelled.connect(lambda: self.show())
            print("DEBUG: Starting ROI selection")
            self.roi_selector.start_selection()
        except Exception as e:
            print(f"DEBUG: Error in _show_region_selector: {e}")
            import traceback
            traceback.print_exc()
            self.show()
            
    def _on_selection_cancelled(self):
        """Handle selection cancellation"""
        print("DEBUG: Selection cancelled")
        self.show()
        
    def _on_region_selected(self, region: Tuple[int, int, int, int]):
        """Handle region selection"""
        try:
            # Ensure region is properly formatted
            if region and len(region) == 4:
                # Convert all values to integers to avoid any type issues
                formatted_region = tuple(int(x) for x in region)
                self.region = formatted_region
                self.region_label.setText(
                    f"영역: ({formatted_region[0]}, {formatted_region[1]}) "
                    f"크기: {formatted_region[2]}x{formatted_region[3]}"
                )
            else:
                self.region = None
                self.region_label.setText("전체 화면")
            
            # Restore dialog visibility
            self.show()
            self.raise_()
            self.activateWindow()
        except Exception as e:
            print(f"DEBUG: Error in _on_region_selected: {e}")
            import traceback
            traceback.print_exc()
            # Still try to show the dialog
            self.region = None
            self.region_label.setText("전체 화면")
            self.show()
        
    def _clear_region(self):
        """Clear selected region"""
        self.region = None
        self.region_label.setText("전체 화면")
        
    def _preview_region(self):
        """Preview selected region"""
        if not self.region:
            QMessageBox.information(self, "알림", "선택된 영역이 없습니다.")
            return
            
        try:
            # Take screenshot of region
            x, y, width, height = self.region
            screenshot = pyautogui.screenshot(region=(x, y, width, height))
            
            # Convert to QPixmap
            # Save to bytes first to avoid direct conversion issues
            import io
            bytes_io = io.BytesIO()
            screenshot.save(bytes_io, format='PNG')
            bytes_io.seek(0)
            
            pixmap = QPixmap()
            pixmap.loadFromData(bytes_io.read())
            
            if pixmap.isNull():
                QMessageBox.warning(self, "경고", "영역 미리보기를 생성할 수 없습니다.")
                return
            
            # Create preview dialog
            preview_dialog = QDialog(self)
            preview_dialog.setWindowTitle("영역 미리보기")
            layout = QVBoxLayout()
            
            label = QLabel()
            # Scale pixmap if too large
            if pixmap.width() > 800 or pixmap.height() > 600:
                pixmap = pixmap.scaled(800, 600, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            label.setPixmap(pixmap)
            layout.addWidget(label)
            
            # Add region info
            info_label = QLabel(f"영역: ({x}, {y}) - 크기: {width}x{height}")
            layout.addWidget(info_label)
            
            preview_dialog.setLayout(layout)
            preview_dialog.exec_()
            
        except Exception as e:
            print(f"DEBUG: Error in preview: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(self, "오류", f"미리보기 생성 중 오류가 발생했습니다:\n{str(e)}")
        
    def _test_search(self):
        """Test text search"""
        # Get search text
        if self.fixed_text_radio.isChecked():
            search_text = self.search_text_edit.text()
            if not search_text:
                QMessageBox.warning(self, "경고", "검색할 텍스트를 입력하세요.")
                return
        else:
            if self.excel_column_combo.currentText():
                search_text = f"[{self.excel_column_combo.currentText()} 열의 데이터]"
            else:
                QMessageBox.warning(self, "경고", "엑셀 열을 선택하세요.")
                return
        
        # Perform test search
        self.hide()
        QTimer.singleShot(300, lambda: self._perform_test_search(search_text))
        
    def _perform_test_search(self, search_text: str):
        """Perform the actual test search"""
        try:
            print(f"DEBUG: Starting test search for: {search_text}")
            print(f"DEBUG: Current region: {self.region}")
            
            # For testing with Excel column, use sample text
            if self.excel_column_radio.isChecked():
                test_text = QMessageBox.getText(
                    self, "테스트 텍스트",
                    f"{self.excel_column_combo.currentText()} 열의 테스트 값을 입력하세요:",
                    text="홍길동"
                )
                if test_text[1]:
                    search_text = test_text[0]
                else:
                    self.show()
                    return
            
            print("DEBUG: Extracting text from region...")
            # Extract text from region
            results = self.text_extractor.extract_text_from_region(
                self.region, 
                self.confidence_spin.value()
            )
            print(f"DEBUG: Found {len(results)} text results")
            
            print("DEBUG: Finding matching text...")
            # Find matching text
            found_result = self.text_extractor.find_text(
                search_text,
                self.region,
                self.exact_match_check.isChecked(),
                self.confidence_spin.value()
            )
            
            if found_result:
                print(f"DEBUG: Found text at {found_result.center}")
                # Show result
                if self.click_after_find_check.isChecked():
                    # Calculate click position
                    click_x = found_result.center[0] + self.offset_x_spin.value()
                    click_y = found_result.center[1] + self.offset_y_spin.value()
                    
                    message = (
                        f"텍스트 '{search_text}'을(를) 찾았습니다!\n"
                        f"위치: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"클릭 위치: ({click_x}, {click_y})\n"
                        f"신뢰도: {found_result.confidence:.2f}"
                    )
                else:
                    message = (
                        f"텍스트 '{search_text}'을(를) 찾았습니다!\n"
                        f"위치: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"신뢰도: {found_result.confidence:.2f}"
                    )
                
                # Highlight found text briefly
                self._highlight_found_text(found_result)
                
            else:
                print("DEBUG: Text not found")
                # Show all found text for debugging
                if results:
                    all_text = "\n".join([f"- {r.text} (신뢰도: {r.confidence:.2f})" 
                                         for r in results[:10]])  # Show max 10
                else:
                    all_text = "텍스트를 찾을 수 없습니다."
                    
                message = (
                    f"텍스트 '{search_text}'을(를) 찾을 수 없습니다.\n\n"
                    f"발견된 텍스트:\n{all_text}"
                )
            
            QMessageBox.information(self, "테스트 결과", message)
            
        except Exception as e:
            print(f"DEBUG: Error in test search: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "오류", f"테스트 중 오류 발생: {str(e)}")
        finally:
            self.show()
            
    def _highlight_found_text(self, result):
        """Briefly highlight the found text on screen"""
        # This is a simplified version - in production, you might want
        # to create a temporary overlay window
        import time
        x, y = result.center
        pyautogui.moveTo(x, y, duration=0.5)
        
    def _perform_test_search_immediate(self, search_text: str):
        """Perform test search without hiding dialog (for Windows compatibility)"""
        loading_msg = None
        try:
            print(f"DEBUG: Starting immediate test search for: {search_text}")
            print(f"DEBUG: Current region: {self.region}")
            
            # Extract text from region first (before showing loading)
            results = self.text_extractor.extract_text_from_region(
                self.region, 
                self.confidence_spin.value()
            )
            print(f"DEBUG: Found {len(results)} text results")
            
            # Find matching text
            found_result = self.text_extractor.find_text(
                search_text,
                self.region,
                self.exact_match_check.isChecked(),
                self.confidence_spin.value()
            )
            
            if found_result:
                print(f"DEBUG: Found text at {found_result.center}")
                # Show result
                if self.click_after_find_check.isChecked():
                    # Calculate click position
                    click_x = found_result.center[0] + self.offset_x_spin.value()
                    click_y = found_result.center[1] + self.offset_y_spin.value()
                    
                    message = (
                        f"텍스트 '{search_text}'을(를) 찾았습니다!\n\n"
                        f"위치: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"클릭 위치: ({click_x}, {click_y})\n"
                        f"신뢰도: {found_result.confidence:.2f}"
                    )
                else:
                    message = (
                        f"텍스트 '{search_text}'을(를) 찾았습니다!\n\n"
                        f"위치: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"신뢰도: {found_result.confidence:.2f}"
                    )
                
                QMessageBox.information(self, "테스트 성공", message)
                
                # Highlight found text
                self._highlight_found_text(found_result)
                
            else:
                print("DEBUG: Text not found")
                # Show all found text for debugging
                if results:
                    all_text = "\n".join([f"• {r.text} (신뢰도: {r.confidence:.2f})" 
                                         for r in results[:10]])  # Show max 10
                else:
                    all_text = "인식된 텍스트가 없습니다."
                    
                message = (
                    f"텍스트 '{search_text}'을(를) 찾을 수 없습니다.\n\n"
                    f"검색 영역에서 발견된 텍스트:\n{all_text}"
                )
                
                QMessageBox.warning(self, "테스트 결과", message)
                
        except Exception as e:
            print(f"DEBUG: Error in immediate test search: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "오류", f"테스트 중 오류 발생:\n{str(e)}")
        
    def get_step_data(self) -> Dict[str, Any]:
        """Get step configuration data"""
        return {
            'name': self.name_edit.text() or "텍스트 검색",
            'search_text': self.search_text_edit.text() if self.fixed_text_radio.isChecked() else "",
            'excel_column': self.excel_column_combo.currentText() if self.excel_column_radio.isChecked() else None,
            'region': self.region,
            'exact_match': self.exact_match_check.isChecked(),
            'confidence': self.confidence_spin.value(),
            'click_after_find': self.click_after_find_check.isChecked(),
            'click_offset': (self.offset_x_spin.value(), self.offset_y_spin.value()),
            'double_click': self.click_type_combo.currentIndex() == 1  # True if "더블 클릭" selected
        }
</file>

<file path="src/ui/widgets/excel_widget.py">
"""
Main Excel integration widget
"""

from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QSplitter, QMessageBox,
    QProgressDialog
)
from PyQt5.QtCore import Qt, pyqtSignal, QThread
from ui.widgets.file_selector import FileSelectorWidget
from ui.widgets.sheet_mapper import SheetMapperWidget
from ui.widgets.data_preview import DataPreviewWidget
from excel.excel_manager import ExcelManager
from excel.models import ExcelFileInfo, ColumnMapping
from logger.app_logger import get_logger

class ExcelLoadThread(QThread):
    """Thread for loading Excel files"""
    
    fileLoaded = pyqtSignal(ExcelFileInfo)
    error = pyqtSignal(str)
    
    def __init__(self, excel_manager: ExcelManager, file_path: str):
        super().__init__()
        self.excel_manager = excel_manager
        self.file_path = file_path
        
    def run(self):
        """Run Excel loading in thread"""
        try:
            file_info = self.excel_manager.load_file(self.file_path)
            self.fileLoaded.emit(file_info)
        except Exception as e:
            self.error.emit(str(e))

class ExcelWidget(QWidget):
    """Main Excel integration widget"""
    
    dataReady = pyqtSignal(object)  # ExcelData
    
    def __init__(self):
        super().__init__()
        self.logger = get_logger(__name__)
        self.excel_manager = ExcelManager()
        self.current_file_info: Optional[ExcelFileInfo] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Create splitter for resizable sections
        splitter = QSplitter(Qt.Vertical)
        
        # File selector
        self.file_selector = FileSelectorWidget()
        self.file_selector.fileSelected.connect(self._on_file_selected)
        splitter.addWidget(self.file_selector)
        
        # Sheet mapper
        self.sheet_mapper = SheetMapperWidget()
        self.sheet_mapper.mappingComplete.connect(self._on_mapping_complete)
        splitter.addWidget(self.sheet_mapper)
        
        # Data preview
        self.data_preview = DataPreviewWidget()
        self.data_preview.rowSelected.connect(self._on_row_selected)
        splitter.addWidget(self.data_preview)
        
        # Set initial splitter sizes (30%, 30%, 40%)
        splitter.setSizes([300, 300, 400])
        
        layout.addWidget(splitter)
        self.setLayout(layout)
        
    def _on_file_selected(self, file_path: str):
        """Handle file selection"""
        # Show progress dialog
        progress = QProgressDialog("엑셀 파일 로딩 중...", None, 0, 0, self)
        progress.setWindowModality(Qt.WindowModal)
        progress.show()
        
        # Load file in thread
        self.load_thread = ExcelLoadThread(self.excel_manager, file_path)
        self.load_thread.fileLoaded.connect(lambda info: self._on_file_loaded(info, progress))
        self.load_thread.error.connect(lambda err: self._on_load_error(err, progress))
        self.load_thread.start()
        
    def _on_file_loaded(self, file_info: ExcelFileInfo, progress: QProgressDialog):
        """Handle successful file load"""
        progress.close()
        self.current_file_info = file_info
        self.sheet_mapper.set_file_info(file_info.sheets)
        self.logger.info(f"Loaded Excel file: {file_info.file_path}")
        
    def _on_load_error(self, error: str, progress: QProgressDialog):
        """Handle file load error"""
        progress.close()
        QMessageBox.critical(self, "파일 로드 오류", f"엑셀 파일을 불러올 수 없습니다:\n{error}")
        self.logger.error(f"Failed to load Excel file: {error}")
        
    def _on_mapping_complete(self, sheet_name: str, mappings: list):
        """Handle mapping completion"""
        try:
            # Read sheet data
            excel_data = self.excel_manager.read_sheet(sheet_name)
            
            # Apply mappings
            for mapping in mappings:
                self.excel_manager.set_column_mapping(
                    mapping.excel_column,
                    mapping.variable_name,
                    mapping.data_type,
                    mapping.is_required
                )
            
            # Load data in preview
            self.data_preview.load_excel_data(excel_data)
            
            # Emit signal that data is ready
            self.dataReady.emit(excel_data)
            
            self.logger.info(f"Loaded sheet '{sheet_name}' with {len(mappings)} mappings")
            
        except Exception as e:
            QMessageBox.critical(self, "데이터 로드 오류", f"시트 데이터를 불러올 수 없습니다:\n{str(e)}")
            self.logger.error(f"Failed to load sheet data: {e}")
            
    def _on_row_selected(self, row_index: int):
        """Handle row selection in preview"""
        self.logger.debug(f"Row {row_index} selected for execution")
        
    def get_excel_manager(self) -> ExcelManager:
        """Get Excel manager instance"""
        return self.excel_manager
        
    def save_current_file(self):
        """Save current Excel file with updates"""
        if self.excel_manager._current_data:
            try:
                save_path = self.excel_manager.save_file()
                QMessageBox.information(self, "저장 완료", f"파일이 저장되었습니다:\n{save_path}")
                self.logger.info(f"Saved Excel file: {save_path}")
            except Exception as e:
                QMessageBox.critical(self, "저장 오류", f"파일 저장 중 오류가 발생했습니다:\n{str(e)}")
                self.logger.error(f"Failed to save Excel file: {e}")
                
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the Excel widget"""
        # Find the splitter
        splitter = self.findChild(QSplitter)
        
        if is_compact:
            # Reduce splitter sizes and spacing
            if splitter:
                splitter.setSizes([200, 200, 300])
                
            # Apply compact mode to child widgets
            if hasattr(self.file_selector, 'set_compact_mode'):
                self.file_selector.set_compact_mode(is_compact)
            if hasattr(self.sheet_mapper, 'set_compact_mode'):
                self.sheet_mapper.set_compact_mode(is_compact)
            if hasattr(self.data_preview, 'set_compact_mode'):
                self.data_preview.set_compact_mode(is_compact)
                
            # Reduce layout margins
            self.layout().setContentsMargins(5, 5, 5, 5)
            self.layout().setSpacing(5)
        else:
            # Reset to normal sizes
            if splitter:
                splitter.setSizes([300, 300, 400])
                
            # Reset child widgets
            if hasattr(self.file_selector, 'set_compact_mode'):
                self.file_selector.set_compact_mode(is_compact)
            if hasattr(self.sheet_mapper, 'set_compact_mode'):
                self.sheet_mapper.set_compact_mode(is_compact)
            if hasattr(self.data_preview, 'set_compact_mode'):
                self.data_preview.set_compact_mode(is_compact)
                
            # Reset layout margins
            self.layout().setContentsMargins(9, 9, 9, 9)
            self.layout().setSpacing(6)
</file>

<file path="src/ui/widgets/roi_selector.py">
"""
Region of Interest (ROI) selector widget with transparent overlay
"""

from typing import Optional, Tuple, Callable
from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QVBoxLayout, QDialog
from PyQt5.QtCore import Qt, QRect, QPoint, pyqtSignal, QTimer
from PyQt5.QtGui import QPainter, QPen, QColor, QBrush, QPixmap, QFont, QCursor, QPalette
import sys

class ROISelectorOverlay(QDialog):
    """Transparent overlay for ROI selection"""
    
    # Signals
    selectionComplete = pyqtSignal(tuple)  # (x, y, width, height)
    selectionCancelled = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Selection state
        self.selecting = False
        self.start_point = QPoint()
        self.end_point = QPoint()
        self.selection_rect = QRect()
        
        # UI setup
        # Use flags that work well on Windows
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Dialog)
        self.setModal(True)
        
        # Make window transparent
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setWindowOpacity(1.0)
        
        # Cursor and mouse tracking
        self.setCursor(Qt.CrossCursor)
        self.setMouseTracking(True)
        self.setFocusPolicy(Qt.StrongFocus)
        
        # Cover all screens
        self._setup_multi_monitor()
        
    def _setup_multi_monitor(self):
        """Setup to cover all monitors"""
        # Get combined screen geometry
        desktop = QApplication.desktop()
        total_rect = QRect()
        
        for i in range(desktop.screenCount()):
            screen_rect = desktop.screenGeometry(i)
            total_rect = total_rect.united(screen_rect)
            
        self.setGeometry(total_rect)
        
    def start_selection(self):
        """Start ROI selection"""
        print("DEBUG: ROI start_selection called")
        
        # Ensure window covers full screen
        desktop = QApplication.desktop()
        screen_rect = desktop.screenGeometry()
        self.setGeometry(screen_rect)
        
        # Show window using show() instead of exec_() to avoid modal issues
        print(f"DEBUG: Showing ROI window at {screen_rect}")
        
        # Show as non-modal window
        self.show()
        
        # Start with a slight delay to ensure proper display
        QTimer.singleShot(100, self._prepare_selection)
        
    def _prepare_selection(self):
        """Prepare for selection after dialog is shown"""
        print("DEBUG: _prepare_selection called")
        self.raise_()
        self.activateWindow()
        self.grabMouse()
        self.grabKeyboard()
        self.update()
        
    def _grab_input(self):
        """Grab mouse and keyboard input after delay"""
        print("DEBUG: _grab_input called")
        try:
            self.grabMouse()
            self.grabKeyboard()
            self.setFocus()
            print("DEBUG: Input grabbed successfully")
        except Exception as e:
            print(f"DEBUG: Error grabbing input: {e}")
        
    def mousePressEvent(self, event):
        """Handle mouse press"""
        if event.button() == Qt.LeftButton:
            self.selecting = True
            self.start_point = event.globalPos()
            self.end_point = self.start_point
            self.update()
            
    def mouseMoveEvent(self, event):
        """Handle mouse move"""
        if self.selecting:
            self.end_point = event.globalPos()
            self.update()
            
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() == Qt.LeftButton and self.selecting:
            self.selecting = False
            self.end_point = event.globalPos()
            
            # Calculate selection rectangle
            x = min(self.start_point.x(), self.end_point.x())
            y = min(self.start_point.y(), self.end_point.y())
            w = abs(self.end_point.x() - self.start_point.x())
            h = abs(self.end_point.y() - self.start_point.y())
            
            # Emit result if selection is valid
            if w > 5 and h > 5:
                region = (int(x), int(y), int(w), int(h))
                self.selectionComplete.emit(region)
            
            self.close()
            
    def keyPressEvent(self, event):
        """Handle key press"""
        if event.key() == Qt.Key_Escape:
            self.selecting = False
            self.selectionCancelled.emit()
            self.close()
            
    def paintEvent(self, event):
        """Paint overlay and selection"""
        print("DEBUG: paintEvent called")
        painter = QPainter(self)
        
        # Fill with semi-transparent color (reduced opacity for better visibility)
        painter.fillRect(self.rect(), QColor(0, 0, 0, 80))
        
        # If selecting, clear the selection area for better visibility
        if self.selecting or (self.start_point and self.end_point):
            # Calculate selection rectangle
            x = min(self.start_point.x(), self.end_point.x())
            y = min(self.start_point.y(), self.end_point.y())
            w = abs(self.end_point.x() - self.start_point.x())
            h = abs(self.end_point.y() - self.start_point.y())
            
            # Adjust to widget coordinates
            selection = QRect(x - self.x(), y - self.y(), w, h)
            
            # Clear the selection area (make it transparent)
            painter.setCompositionMode(QPainter.CompositionMode_Clear)
            painter.fillRect(selection, Qt.transparent)
            painter.setCompositionMode(QPainter.CompositionMode_SourceOver)
            
            # Draw selection border
            painter.setPen(QPen(QColor(50, 150, 250), 3, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(selection)
        
        # Draw visible text
        painter.setPen(QColor(255, 255, 255))
        font = QFont()
        font.setPointSize(24)
        font.setBold(True)
        painter.setFont(font)
        
        instructions = "마우스를 드래그하여 영역을 선택하세요. ESC로 취소"
        rect = self.rect()
        rect.setTop(50)
        painter.drawText(rect, Qt.AlignTop | Qt.AlignHCenter, instructions)
        
        if self.selecting or (self.start_point and self.end_point):
            
            # Draw dimensions text
            if w > 50 and h > 30:
                painter.setPen(QColor(255, 255, 255))
                font = QFont()
                font.setPointSize(12)
                font.setBold(True)
                painter.setFont(font)
                
                text = f"{w} × {h}"
                text_rect = selection.adjusted(5, 5, -5, -5)
                painter.drawText(text_rect, Qt.AlignTop | Qt.AlignLeft, text)
                
            # Draw corner handles
            self._draw_handles(painter, selection)
            
    def _draw_handles(self, painter: QPainter, rect: QRect):
        """Draw resize handles at corners"""
        handle_size = 8
        painter.setBrush(QBrush(QColor(50, 150, 250)))
        painter.setPen(Qt.NoPen)
        
        # Top-left
        painter.drawRect(rect.x() - handle_size//2, 
                        rect.y() - handle_size//2,
                        handle_size, handle_size)
        
        # Top-right
        painter.drawRect(rect.x() + rect.width() - handle_size//2,
                        rect.y() - handle_size//2,
                        handle_size, handle_size)
        
        # Bottom-left
        painter.drawRect(rect.x() - handle_size//2,
                        rect.y() + rect.height() - handle_size//2,
                        handle_size, handle_size)
        
        # Bottom-right
        painter.drawRect(rect.x() + rect.width() - handle_size//2,
                        rect.y() + rect.height() - handle_size//2,
                        handle_size, handle_size)
                        
    def close(self):
        """Clean up and close"""
        print("DEBUG: ROI close() called")
        self.releaseMouse()
        self.releaseKeyboard()
        super().close()  # Close the window properly

class ROISelectorWidget(QWidget):
    """Widget for ROI selection with preview"""
    
    regionSelected = pyqtSignal(tuple)  # (x, y, width, height)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_region: Optional[Tuple[int, int, int, int]] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Preview label
        self.preview_label = QLabel()
        self.preview_label.setMinimumSize(200, 150)
        self.preview_label.setMaximumSize(400, 300)
        self.preview_label.setScaledContents(True)
        self.preview_label.setStyleSheet("""
            QLabel {
                border: 2px solid #ccc;
                background-color: #f0f0f0;
            }
        """)
        self.preview_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.preview_label)
        
        # Info label
        self.info_label = QLabel("선택된 영역 없음")
        self.info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.info_label)
        
        self.setLayout(layout)
        
    def start_selection(self):
        """Start ROI selection"""
        self.selector = ROISelectorOverlay()
        self.selector.selectionComplete.connect(self._on_selection_complete)
        self.selector.selectionCancelled.connect(self._on_selection_cancelled)
        self.selector.start_selection()
        
    def _on_selection_complete(self, region: Tuple[int, int, int, int]):
        """Handle selection completion"""
        self.current_region = region
        self.info_label.setText(f"영역: {region[0]}, {region[1]} - {region[2]}×{region[3]}")
        self.regionSelected.emit(region)
        
        # Capture and show preview
        self._update_preview()
        
    def _on_selection_cancelled(self):
        """Handle selection cancellation"""
        self.info_label.setText("선택 취소됨")
        
    def _update_preview(self):
        """Update preview of selected region"""
        if not self.current_region:
            return
            
        try:
            # Capture the selected region
            import mss
            import numpy as np
            from PIL import Image
            
            with mss.mss() as sct:
                monitor = {
                    "left": self.current_region[0],
                    "top": self.current_region[1],
                    "width": self.current_region[2],
                    "height": self.current_region[3]
                }
                
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.bgra, "raw", "BGRX")
                
                # Convert to QPixmap
                qpixmap = QPixmap.fromImage(self._pil_to_qimage(img))
                self.preview_label.setPixmap(qpixmap)
                
        except Exception as e:
            self.info_label.setText(f"Preview error: {str(e)}")
            
    def _pil_to_qimage(self, pil_image):
        """Convert PIL image to QImage"""
        from PyQt5.QtGui import QImage
        
        if pil_image.mode == "RGB":
            r, g, b = pil_image.split()
            pil_image = Image.merge("RGB", (b, g, r))
        elif pil_image.mode == "RGBA":
            r, g, b, a = pil_image.split()
            pil_image = Image.merge("RGBA", (b, g, r, a))
            
        width, height = pil_image.size
        data = pil_image.tobytes("raw", pil_image.mode)
        
        if pil_image.mode == "RGB":
            qimage = QImage(data, width, height, QImage.Format_RGB888)
        elif pil_image.mode == "RGBA":
            qimage = QImage(data, width, height, QImage.Format_RGBA8888)
            
        return qimage
        
    def set_region(self, region: Optional[Tuple[int, int, int, int]]):
        """Set region programmatically"""
        self.current_region = region
        if region:
            self.info_label.setText(f"영역: {region[0]}, {region[1]} - {region[2]}×{region[3]}")
            self._update_preview()
        else:
            self.info_label.setText("선택된 영역 없음")
            self.preview_label.clear()
        
    def get_region(self) -> Optional[Tuple[int, int, int, int]]:
        """Get current region"""
        return self.current_region
</file>

<file path="RUN_ON_WINDOWS.bat">
@echo off
chcp 65001 >nul 2>&1
REM === Simplest Windows Runner for WSL Files ===

cls
echo ===============================
echo Excel Macro Automation Tool
echo ===============================
echo.

REM Enable error handling
setlocal enabledelayedexpansion

REM Create and use C:\macro as working directory
set WORK_DIR=C:\macro
echo Target directory: %WORK_DIR%
echo.

REM Clean existing directory
if exist "%WORK_DIR%" (
    echo Removing old files...
    rmdir /s /q "%WORK_DIR%" 2>nul
    timeout /t 2 /nobreak >nul
)

REM Create fresh directory
mkdir "%WORK_DIR%" 2>nul
if errorlevel 1 (
    echo [ERROR] Cannot create directory %WORK_DIR%
    echo Please check permissions or run as administrator
    echo.
    pause
    exit /b 1
)

REM Detect source path
set "SOURCE_PATH=%~dp0"
echo Source path: %SOURCE_PATH%

REM Check if running from WSL path
echo %SOURCE_PATH% | find "\\wsl" >nul
if %errorlevel%==0 (
    echo Running from WSL path detected
    set "WSL_PATH=\\wsl.localhost\Ubuntu-22.04\home\nosky\macro"
) else (
    echo Running from local path
    set "WSL_PATH=%SOURCE_PATH%"
)

REM Use PowerShell to copy files (handles WSL paths better)
echo.
echo Copying application files...
echo Please wait...
echo.

REM Create a PowerShell script for better error handling
echo $ErrorActionPreference = 'Stop' > "%TEMP%\copy_files.ps1"
echo try { >> "%TEMP%\copy_files.ps1"
echo     $source = '%WSL_PATH%' >> "%TEMP%\copy_files.ps1"
echo     $dest = '%WORK_DIR%' >> "%TEMP%\copy_files.ps1"
echo     Write-Host 'Source: ' $source >> "%TEMP%\copy_files.ps1"
echo     Write-Host 'Destination: ' $dest >> "%TEMP%\copy_files.ps1"
echo     Write-Host '' >> "%TEMP%\copy_files.ps1"
echo     if (-not (Test-Path $source)) { >> "%TEMP%\copy_files.ps1"
echo         throw "Source path not found: $source" >> "%TEMP%\copy_files.ps1"
echo     } >> "%TEMP%\copy_files.ps1"
echo     Write-Host 'Copying Python files...' >> "%TEMP%\copy_files.ps1"
echo     Get-ChildItem -Path "$source\*.py" -ErrorAction SilentlyContinue ^| Copy-Item -Destination $dest -Force >> "%TEMP%\copy_files.ps1"
echo     Get-ChildItem -Path "$source\*.txt" -ErrorAction SilentlyContinue ^| Copy-Item -Destination $dest -Force >> "%TEMP%\copy_files.ps1"
echo     Write-Host 'Copying source code directory...' >> "%TEMP%\copy_files.ps1"
echo     if (Test-Path "$source\src") { >> "%TEMP%\copy_files.ps1"
echo         Copy-Item -Path "$source\src" -Destination $dest -Recurse -Force >> "%TEMP%\copy_files.ps1"
echo     } >> "%TEMP%\copy_files.ps1"
echo     Write-Host 'Copying resources directory...' >> "%TEMP%\copy_files.ps1"
echo     if (Test-Path "$source\resources") { >> "%TEMP%\copy_files.ps1"
echo         Copy-Item -Path "$source\resources" -Destination $dest -Recurse -Force >> "%TEMP%\copy_files.ps1"
echo     } >> "%TEMP%\copy_files.ps1"
echo     Write-Host 'Copy complete!' >> "%TEMP%\copy_files.ps1"
echo } catch { >> "%TEMP%\copy_files.ps1"
echo     Write-Host "ERROR: $_" -ForegroundColor Red >> "%TEMP%\copy_files.ps1"
echo     exit 1 >> "%TEMP%\copy_files.ps1"
echo } >> "%TEMP%\copy_files.ps1"

REM Execute PowerShell script
powershell -ExecutionPolicy Bypass -File "%TEMP%\copy_files.ps1"
if errorlevel 1 (
    echo.
    echo [ERROR] PowerShell copy failed!
    echo Trying alternative copy method...
    echo.
    
    REM Try direct copy as fallback
    xcopy "%SOURCE_PATH%*.py" "%WORK_DIR%\" /Y >nul 2>&1
    xcopy "%SOURCE_PATH%*.txt" "%WORK_DIR%\" /Y >nul 2>&1
    xcopy "%SOURCE_PATH%src" "%WORK_DIR%\src\" /E /I /Y >nul 2>&1
    xcopy "%SOURCE_PATH%resources" "%WORK_DIR%\resources\" /E /I /Y >nul 2>&1
)

REM Clean up temp PowerShell script
del "%TEMP%\copy_files.ps1" 2>nul

REM Move to working directory
cd /d %WORK_DIR%
echo.
echo Current directory: %CD%

REM Check if copy was successful
if not exist "run_main_fixed.py" (
    echo.
    echo [ERROR] Essential files not found!
    echo.
    echo Checking what was copied:
    dir /b
    echo.
    echo Please ensure the source directory contains:
    echo - run_main_fixed.py
    echo - src\ directory
    echo - resources\ directory
    echo.
    pause
    exit /b 1
)

REM Check Python
echo.
echo Checking Python installation...
python --version 2>nul
if errorlevel 1 (
    echo.
    echo [ERROR] Python not found!
    echo.
    echo Please install Python from https://python.org
    echo Make sure to check "Add Python to PATH" during installation
    echo.
    pause
    exit /b 1
)

python --version
echo.

REM Install packages if needed
echo Checking and installing required packages...
echo This may take a few minutes on first run...
echo.

REM Upgrade pip first
echo Upgrading pip...
python -m pip install --upgrade pip

REM Install all packages at once for simplicity
echo Installing required packages...
echo - PyQt5 (GUI framework)
echo - pandas, openpyxl (Excel processing)  
echo - pyautogui (automation)
echo - easyocr (text recognition)
echo.

pip install PyQt5 pandas openpyxl pyautogui pillow opencv-python numpy mss screeninfo easyocr cryptography

if errorlevel 1 (
    echo.
    echo [WARNING] Some packages may have failed to install
    echo Continuing anyway...
    echo.
)

REM Run the application
echo.
echo ===============================
echo Starting application...
echo ===============================
echo.

REM Check if we can import basic modules
echo Testing Python environment...
python -c "import sys; print(f'Python path: {sys.executable}')" 2>&1
if errorlevel 1 (
    echo [ERROR] Python environment issue detected
    pause
    exit /b 1
)

echo Running application...
echo.

REM Run with explicit error output
python run_main_fixed.py 2>&1

set EXIT_CODE=%errorlevel%

echo.
echo ===============================
if %EXIT_CODE%==0 (
    echo Application closed successfully
) else (
    echo Application exited with error: %EXIT_CODE%
    echo.
    echo Common issues:
    echo - Missing packages: Run 'pip install -r requirements.txt'
    echo - Import errors: Check if all source files were copied
    echo - Permission issues: Try running as administrator
)
echo ===============================

echo.
echo Press any key to exit...
pause >nul

endlocal
exit /b %EXIT_CODE%
</file>

<file path="src/automation/executor.py">
"""
Step executor for macro steps
"""

import re
import time
import os
from typing import Dict, Any, Optional, Tuple
import pyautogui
from core.macro_types import MacroStep, StepType
from config.settings import Settings
from logger.app_logger import get_logger

class StepExecutor:
    """Executes individual macro steps"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        self.variables: Dict[str, Any] = {}
        
        # Initialize image matcher
        self._image_matcher = None
        self._init_image_matcher()
        
        # Initialize text extractor
        self._text_extractor = None
        self._init_text_extractor()
        
        # Step handlers mapping
        self._handlers = {
            StepType.MOUSE_CLICK: self._execute_mouse_click,
            StepType.MOUSE_MOVE: self._execute_mouse_move,
            StepType.MOUSE_DRAG: self._execute_mouse_drag,
            StepType.MOUSE_SCROLL: self._execute_mouse_scroll,
            StepType.KEYBOARD_TYPE: self._execute_keyboard_type,
            StepType.KEYBOARD_HOTKEY: self._execute_keyboard_hotkey,
            StepType.WAIT_TIME: self._execute_wait_time,
            StepType.WAIT_IMAGE: self._execute_wait_image,
            StepType.SCREENSHOT: self._execute_screenshot,
            StepType.IMAGE_SEARCH: self._execute_image_search,
            StepType.OCR_TEXT: self._execute_text_search,
            StepType.IF_CONDITION: self._execute_if_condition,
            StepType.LOOP: self._execute_loop,
        }
        
    def _init_image_matcher(self):
        """Initialize image matcher with fallback"""
        try:
            from vision.image_matcher import ImageMatcher
            self._image_matcher = ImageMatcher(self.settings)
            self.logger.info("Using OpenCV-based image matcher")
        except ImportError:
            self.logger.warning("OpenCV not available, using pyautogui fallback")
            self._image_matcher = None
            
    def _init_text_extractor(self):
        """Initialize text extractor with fallback"""
        try:
            from vision.text_extractor import TextExtractor
            self._text_extractor = TextExtractor()
            self.logger.info("Using EasyOCR-based text extractor")
        except ImportError:
            self.logger.warning("EasyOCR not available, text search disabled")
            self._text_extractor = None
        
    def set_variables(self, variables: Dict[str, Any]):
        """Set variables for template substitution"""
        self.variables = variables
        
    def execute_step(self, step: MacroStep) -> Any:
        """Execute a single step"""
        handler = self._handlers.get(step.step_type)
        if not handler:
            raise NotImplementedError(f"No handler for step type: {step.step_type}")
            
        self.logger.debug(f"Executing step: {step.name} ({step.step_type.value})")
        
        try:
            result = handler(step)
            return result
        except Exception as e:
            self.logger.error(f"Step execution failed: {e}")
            raise
            
    def _substitute_variables(self, text: str) -> str:
        """Substitute variables in text"""
        if not text:
            return text
            
        # Find all {{variable}} patterns
        pattern = r'\{\{(\w+)\}\}'
        
        def replacer(match):
            var_name = match.group(1)
            if var_name in self.variables:
                return str(self.variables[var_name])
            return match.group(0)  # Keep original if not found
            
        return re.sub(pattern, replacer, text)
        
    def _get_absolute_position(self, x: int, y: int, relative_to: str) -> Tuple[int, int]:
        """Convert coordinates to absolute screen position"""
        if relative_to == "screen":
            return x, y
        elif relative_to == "window":
            # TODO: Implement window-relative coordinates
            # For now, treat as screen coordinates
            return x, y
        elif relative_to == "image":
            # TODO: Implement image-relative coordinates
            # For now, treat as screen coordinates
            return x, y
        else:
            return x, y
            
    # Mouse handlers
    
    def _execute_mouse_click(self, step) -> None:
        """Execute mouse click"""
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        
        pyautogui.click(
            x=x,
            y=y,
            clicks=step.clicks,
            interval=step.interval,
            button=step.button.value
        )
        
    def _execute_mouse_move(self, step) -> None:
        """Execute mouse move"""
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        
        if step.duration > 0:
            pyautogui.moveTo(x, y, duration=step.duration)
        else:
            pyautogui.moveTo(x, y)
            
    def _execute_mouse_drag(self, step) -> None:
        """Execute mouse drag"""
        # This would need to be implemented with proper drag coordinates
        # For now, using simple drag
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        pyautogui.dragTo(x, y, duration=step.duration, button=step.button.value)
        
    def _execute_mouse_scroll(self, step) -> None:
        """Execute mouse scroll"""
        pyautogui.scroll(step.clicks)
        
    # Keyboard handlers
    
    def _execute_keyboard_type(self, step) -> None:
        """Execute keyboard typing"""
        text = step.text
        
        # Substitute variables if enabled
        if step.use_variables:
            text = self._substitute_variables(text)
            
        pyautogui.typewrite(text, interval=step.interval)
        
    def _execute_keyboard_hotkey(self, step) -> None:
        """Execute keyboard hotkey"""
        if step.keys:
            pyautogui.hotkey(*step.keys)
            
    # Wait handlers
    
    def _execute_wait_time(self, step) -> None:
        """Execute time wait"""
        time.sleep(step.seconds)
        
    def _execute_wait_image(self, step) -> Optional[Tuple[int, int, int, int]]:
        """Execute wait for image"""
        if self._image_matcher:
            # Use OpenCV-based matcher
            result = self._image_matcher.wait_for_image(
                step.image_path,
                timeout=step.timeout,
                confidence=step.confidence,
                region=step.region
            )
            
            if result.found:
                self.logger.debug(f"Image found at: {result.location}")
                return result.location
            else:
                raise TimeoutError(f"Image not found within {step.timeout} seconds")
        else:
            # Fallback to pyautogui
            start_time = time.time()
            
            while time.time() - start_time < step.timeout:
                try:
                    # Try to locate image
                    location = pyautogui.locateOnScreen(
                        step.image_path,
                        confidence=step.confidence,
                        region=step.region
                    )
                    
                    if location:
                        self.logger.debug(f"Image found at: {location}")
                        return location
                        
                except Exception as e:
                    self.logger.debug(f"Image search error: {e}")
                    
                time.sleep(0.5)  # Check every 500ms
                
            raise TimeoutError(f"Image not found within {step.timeout} seconds")
        
    # Screen handlers
    
    def _execute_screenshot(self, step) -> str:
        """Execute screenshot"""
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        
        # Create screenshots directory
        screenshots_dir = os.path.join(
            os.path.dirname(__file__), 
            "../../screenshots"
        )
        os.makedirs(screenshots_dir, exist_ok=True)
        
        # Generate filename
        filename = os.path.join(
            screenshots_dir,
            f"screenshot_{timestamp}.png"
        )
        
        if self._image_matcher and hasattr(step, 'region') and step.region:
            # Capture specific region
            self._image_matcher.capture_region(step.region, filename)
        else:
            # Full screen capture
            pyautogui.screenshot(filename)
            
        self.logger.info(f"Screenshot saved: {filename}")
        return filename
        
    def _execute_image_search(self, step) -> Optional[Tuple[int, int, int, int]]:
        """Execute image search and optionally click"""
        location = None
        center = None
        
        if self._image_matcher:
            # Use OpenCV-based matcher
            result = self._image_matcher.find_image(
                step.image_path,
                confidence=step.confidence,
                region=step.region
            )
            
            if result.found:
                self.logger.debug(f"Image found at: {result.location}")
                location = result.location
                center = result.center
            else:
                self.logger.debug("Image not found with OpenCV matcher")
                return None
        else:
            # Fallback to pyautogui
            try:
                location = pyautogui.locateOnScreen(
                    step.image_path,
                    confidence=step.confidence,
                    region=step.region
                )
                if location:
                    center = pyautogui.center(location)
                else:
                    self.logger.debug("Image not found with pyautogui")
                    return None
            except Exception as e:
                self.logger.error(f"Error in image search: {e}")
                return None
        
        # If image was found and click is requested
        if location and center and step.click_after_find:
            # Apply click offset
            click_x = center[0] + step.click_offset[0]
            click_y = center[1] + step.click_offset[1]
            
            self.logger.info(f"Clicking at ({click_x}, {click_y})")
            
            # Perform click
            if step.double_click:
                pyautogui.doubleClick(click_x, click_y)
                self.logger.debug("Performed double click")
            else:
                pyautogui.click(click_x, click_y)
                self.logger.debug("Performed single click")
                
        return location
            
    def _execute_text_search(self, step) -> Optional[Tuple[int, int]]:
        """Execute text search and optionally click"""
        if not self._text_extractor:
            raise RuntimeError("Text extractor not available (EasyOCR not installed)")
            
        # Get search text
        search_text = step.search_text
        
        # If using Excel column, get value from variables
        if step.excel_column and step.excel_column in self.variables:
            search_text = str(self.variables[step.excel_column])
            
        if not search_text:
            raise ValueError("No search text specified")
            
        # Replace variables in search text
        search_text = self._substitute_variables(search_text)
        
        self.logger.info(f"Searching for text: {search_text}")
        
        # Find text on screen
        result = self._text_extractor.find_text(
            search_text,
            region=step.region,
            exact_match=step.exact_match,
            confidence_threshold=step.confidence
        )
        
        if result:
            self.logger.info(f"Text found at: {result.center}")
            
            # Click if requested
            if step.click_after_find:
                click_x = result.center[0] + step.click_offset[0]
                click_y = result.center[1] + step.click_offset[1]
                
                # Perform click
                if hasattr(step, 'double_click') and step.double_click:
                    pyautogui.doubleClick(click_x, click_y)
                    self.logger.debug(f"Double clicked at: ({click_x}, {click_y})")
                else:
                    pyautogui.click(click_x, click_y)
                    self.logger.debug(f"Clicked at: ({click_x}, {click_y})")
                
            return result.center
        else:
            self.logger.warning(f"Text not found: {search_text}")
            return None
    
    # Flow control handlers
    
    def _execute_if_condition(self, step) -> bool:
        """Execute if condition and run appropriate branch"""
        condition_result = False
        
        try:
            # Evaluate condition based on type
            if step.condition_type == "image_exists":
                # Check if image exists on screen
                image_path = step.condition_value.get('image_path', '')
                confidence = step.condition_value.get('confidence', 0.9)
                region = step.condition_value.get('region')
                
                if self._image_matcher:
                    result = self._image_matcher.find_image(
                        image_path,
                        confidence=confidence,
                        region=region
                    )
                    condition_result = result.found if result else False
                else:
                    # Fallback to pyautogui
                    try:
                        location = pyautogui.locateOnScreen(
                            image_path,
                            confidence=confidence,
                            region=region
                        )
                        condition_result = location is not None
                    except:
                        condition_result = False
                        
            elif step.condition_type == "text_exists":
                # Check if text exists on screen
                search_text = step.condition_value.get('text', '')
                exact_match = step.condition_value.get('exact_match', False)
                region = step.condition_value.get('region')
                
                # Substitute variables in search text
                search_text = self._substitute_variables(search_text)
                
                if self._text_extractor and search_text:
                    result = self._text_extractor.find_text(
                        search_text,
                        region=region,
                        exact_match=exact_match,
                        confidence_threshold=0.5
                    )
                    condition_result = result is not None
                else:
                    condition_result = False
                    
            elif step.condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
                # Variable comparison conditions
                variable_name = step.condition_value.get('variable', '')
                compare_value = step.condition_value.get('compare_value', '')
                
                # Get variable value
                variable_value = self.variables.get(variable_name, '')
                
                # Substitute variables in compare value
                compare_value = self._substitute_variables(compare_value)
                
                # Perform comparison
                if step.condition_type == "variable_equals":
                    condition_result = str(variable_value) == str(compare_value)
                elif step.condition_type == "variable_contains":
                    condition_result = str(compare_value) in str(variable_value)
                elif step.condition_type == "variable_greater":
                    try:
                        condition_result = float(variable_value) > float(compare_value)
                    except (ValueError, TypeError):
                        # If not numeric, do string comparison
                        condition_result = str(variable_value) > str(compare_value)
                elif step.condition_type == "variable_less":
                    try:
                        condition_result = float(variable_value) < float(compare_value)
                    except (ValueError, TypeError):
                        # If not numeric, do string comparison
                        condition_result = str(variable_value) < str(compare_value)
                        
            self.logger.info(f"Condition '{step.condition_type}' evaluated to: {condition_result}")
            
            # Execute appropriate branch
            if condition_result:
                # Execute true branch steps
                for nested_step in step.true_steps:
                    if nested_step.enabled:
                        self.execute_step(nested_step)
            else:
                # Execute false branch steps
                for nested_step in step.false_steps:
                    if nested_step.enabled:
                        self.execute_step(nested_step)
                        
            return condition_result
            
        except Exception as e:
            self.logger.error(f"Error evaluating condition: {e}")
            # On error, execute false branch
            for nested_step in step.false_steps:
                if nested_step.enabled:
                    self.execute_step(nested_step)
            return False
        
    def _execute_loop(self, step) -> None:
        """Execute loop"""
        # TODO: Implement loop execution
        # This would need to interact with the main engine
        pass
</file>

<file path="src/ui/widgets/execution_widget.py">
"""
Macro execution control widget
"""

from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QProgressBar, QTableWidget, QTableWidgetItem, QGroupBox,
    QTextEdit, QSplitter, QHeaderView, QCheckBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QColor, QBrush, QFont
from automation.engine import ExecutionEngine, ExecutionState, ExecutionResult
from excel.excel_manager import ExcelManager
from core.macro_types import Macro, MacroStep
from config.settings import Settings
from logger.app_logger import get_logger

class ExecutionStatusWidget(QWidget):
    """Widget showing execution status"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Status label
        self.status_label = QLabel("대기 중")
        self.status_label.setAlignment(Qt.AlignCenter)
        font = QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.status_label.setFont(font)
        layout.addWidget(self.status_label)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(True)
        layout.addWidget(self.progress_bar)
        
        # Statistics
        stats_layout = QHBoxLayout()
        
        self.total_label = QLabel("전체: 0")
        stats_layout.addWidget(self.total_label)
        
        self.completed_label = QLabel("완료: 0")
        self.completed_label.setStyleSheet("color: green;")
        stats_layout.addWidget(self.completed_label)
        
        self.failed_label = QLabel("실패: 0")
        self.failed_label.setStyleSheet("color: red;")
        stats_layout.addWidget(self.failed_label)
        
        self.time_label = QLabel("소요시간: 0:00")
        stats_layout.addWidget(self.time_label)
        
        stats_layout.addStretch()
        layout.addLayout(stats_layout)
        
        self.setLayout(layout)
        
    def update_status(self, state: ExecutionState):
        """Update status display"""
        status_map = {
            ExecutionState.IDLE: ("대기 중", "#000000"),
            ExecutionState.RUNNING: ("실행 중", "#00aa00"),
            ExecutionState.PAUSED: ("일시정지", "#ff8800"),
            ExecutionState.STOPPING: ("정지 중...", "#aa0000"),
            ExecutionState.STOPPED: ("정지됨", "#aa0000"),
            ExecutionState.ERROR: ("오류", "#ff0000")
        }
        
        text, color = status_map.get(state, ("알 수 없음", "#000000"))
        self.status_label.setText(text)
        self.status_label.setStyleSheet(f"color: {color};")
        
    def update_progress(self, current: int, total: int):
        """Update progress bar"""
        self.progress_bar.setMaximum(total)
        self.progress_bar.setValue(current)
        self.progress_bar.setFormat(f"{current}/{total} ({current/total*100:.1f}%)")
        
    def update_statistics(self, total: int, completed: int, failed: int, elapsed_seconds: float):
        """Update statistics"""
        self.total_label.setText(f"전체: {total}")
        self.completed_label.setText(f"완료: {completed}")
        self.failed_label.setText(f"실패: {failed}")
        
        minutes = int(elapsed_seconds // 60)
        seconds = int(elapsed_seconds % 60)
        self.time_label.setText(f"소요시간: {minutes}:{seconds:02d}")

class ExecutionLogWidget(QTableWidget):
    """Widget showing execution log"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Set columns
        self.setColumnCount(5)
        self.setHorizontalHeaderLabels(["시간", "행", "단계", "상태", "메시지"])
        
        # Configure table
        self.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(3, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        
        self.setColumnWidth(1, 60)  # Row
        self.setColumnWidth(3, 80)  # Status
        
        # Style
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QTableWidget.SelectRows)
        
    def add_log_entry(self, timestamp: str, row: int, step_name: str, 
                      success: bool, message: str = ""):
        """Add log entry"""
        row_count = self.rowCount()
        self.insertRow(row_count)
        
        # Time
        self.setItem(row_count, 0, QTableWidgetItem(timestamp))
        
        # Row number
        row_item = QTableWidgetItem(str(row + 1))
        row_item.setTextAlignment(Qt.AlignCenter)
        self.setItem(row_count, 1, row_item)
        
        # Step name
        self.setItem(row_count, 2, QTableWidgetItem(step_name))
        
        # Status
        status_item = QTableWidgetItem("성공" if success else "실패")
        status_item.setTextAlignment(Qt.AlignCenter)
        if success:
            status_item.setForeground(QBrush(QColor(0, 150, 0)))
        else:
            status_item.setForeground(QBrush(QColor(200, 0, 0)))
        self.setItem(row_count, 3, status_item)
        
        # Message
        self.setItem(row_count, 4, QTableWidgetItem(message))
        
        # Auto scroll to bottom
        self.scrollToBottom()

class ExecutionControlWidget(QWidget):
    """Execution control buttons"""
    
    startRequested = pyqtSignal()
    pauseRequested = pyqtSignal()
    stopRequested = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        # Start button
        self.start_btn = QPushButton("▶ 시작")
        self.start_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.start_btn.clicked.connect(self.startRequested.emit)
        layout.addWidget(self.start_btn)
        
        # Pause button
        self.pause_btn = QPushButton("⏸ 일시정지")
        self.pause_btn.setEnabled(False)
        self.pause_btn.clicked.connect(self.pauseRequested.emit)
        layout.addWidget(self.pause_btn)
        
        # Stop button
        self.stop_btn = QPushButton("⏹ 정지")
        self.stop_btn.setEnabled(False)
        self.stop_btn.setStyleSheet("""
            QPushButton:enabled {
                background-color: #f44336;
                color: white;
            }
        """)
        self.stop_btn.clicked.connect(self.stopRequested.emit)
        layout.addWidget(self.stop_btn)
        
        layout.addStretch()
        
        # Hotkey info
        hotkey_label = QLabel("단축키: F9(일시정지), ESC(정지)")
        hotkey_label.setStyleSheet("color: #666; font-style: italic;")
        layout.addWidget(hotkey_label)
        
        self.setLayout(layout)
        
    def set_running_state(self, is_running: bool, is_paused: bool = False):
        """Update button states"""
        self.start_btn.setEnabled(not is_running)
        self.pause_btn.setEnabled(is_running)
        self.stop_btn.setEnabled(is_running)
        
        if is_paused:
            self.pause_btn.setText("▶ 재개")
        else:
            self.pause_btn.setText("⏸ 일시정지")

class ExecutionWidget(QWidget):
    """Complete execution widget"""
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
        # Execution engine
        self.engine = ExecutionEngine(settings)
        self.current_macro: Optional[Macro] = None
        self.excel_manager: Optional[ExcelManager] = None
        
        # Statistics
        self.start_time = None
        self.completed_count = 0
        self.failed_count = 0
        
        # Timer for elapsed time
        self.timer = QTimer()
        self.timer.timeout.connect(self._update_elapsed_time)
        
        self.init_ui()
        self.connect_signals()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Control buttons
        self.control_widget = ExecutionControlWidget()
        layout.addWidget(self.control_widget)
        
        # Status display
        status_group = QGroupBox("실행 상태")
        status_layout = QVBoxLayout()
        self.status_widget = ExecutionStatusWidget()
        status_layout.addWidget(self.status_widget)
        status_group.setLayout(status_layout)
        layout.addWidget(status_group)
        
        # Options
        options_layout = QHBoxLayout()
        self.incomplete_only_checkbox = QCheckBox("미완료 항목만 실행")
        self.incomplete_only_checkbox.setChecked(True)
        options_layout.addWidget(self.incomplete_only_checkbox)
        options_layout.addStretch()
        layout.addLayout(options_layout)
        
        # Log display
        log_group = QGroupBox("실행 로그")
        log_layout = QVBoxLayout()
        
        # Log toolbar
        log_toolbar_layout = QHBoxLayout()
        log_toolbar_layout.addStretch()
        
        view_logs_btn = QPushButton("CSV 로그 보기")
        view_logs_btn.clicked.connect(self.show_log_viewer)
        log_toolbar_layout.addWidget(view_logs_btn)
        
        log_layout.addLayout(log_toolbar_layout)
        
        self.log_widget = ExecutionLogWidget()
        log_layout.addWidget(self.log_widget)
        log_group.setLayout(log_layout)
        layout.addWidget(log_group)
        
        self.setLayout(layout)
        
    def connect_signals(self):
        """Connect signals"""
        # Control signals
        self.control_widget.startRequested.connect(self.start_execution)
        self.control_widget.pauseRequested.connect(self.toggle_pause)
        self.control_widget.stopRequested.connect(self.stop_execution)
        
        # Engine signals
        self.engine.stateChanged.connect(self._on_state_changed)
        self.engine.progressUpdated.connect(self._on_progress_updated)
        self.engine.rowCompleted.connect(self._on_row_completed)
        self.engine.stepExecuting.connect(self._on_step_executing)
        self.engine.executionFinished.connect(self._on_execution_finished)
        self.engine.error.connect(self._on_error)
        
    def set_macro_and_excel(self, macro: Macro, excel_manager: ExcelManager):
        """Set macro and Excel manager"""
        self.current_macro = macro
        self.excel_manager = excel_manager
        
    def start_execution(self):
        """Start macro execution"""
        if not self.current_macro or not self.excel_manager:
            self.logger.warning("No macro or Excel data loaded")
            return
            
        # Reset statistics
        self.completed_count = 0
        self.failed_count = 0
        from PyQt5.QtCore import QTime
        self.start_time = QTime.currentTime()
        self.log_widget.setRowCount(0)
        
        # Configure engine
        self.engine.set_macro(self.current_macro, self.excel_manager)
        
        # Set target rows based on checkbox
        if self.incomplete_only_checkbox.isChecked():
            # Let engine use default (incomplete rows)
            self.engine.set_target_rows([])
        else:
            # Execute all rows
            total_rows = len(self.excel_manager._current_data.dataframe)
            self.engine.set_target_rows(list(range(total_rows)))
            
        # Start execution
        self.engine.start()
        self.timer.start(1000)  # Update every second
        
    def toggle_pause(self):
        """Toggle pause state"""
        self.engine.toggle_pause()
        
    def stop_execution(self):
        """Stop execution"""
        self.engine.stop_execution()
        
    def _on_state_changed(self, state: ExecutionState):
        """Handle state change"""
        self.status_widget.update_status(state)
        
        is_running = state in [ExecutionState.RUNNING, ExecutionState.PAUSED]
        is_paused = state == ExecutionState.PAUSED
        self.control_widget.set_running_state(is_running, is_paused)
        
        if not is_running:
            self.timer.stop()
            
    def _on_progress_updated(self, current: int, total: int):
        """Handle progress update"""
        self.status_widget.update_progress(current, total)
        
    def _on_row_completed(self, result: ExecutionResult):
        """Handle row completion"""
        if result.success:
            self.completed_count += 1
        else:
            self.failed_count += 1
            
        # Add to log
        import time
        timestamp = time.strftime("%H:%M:%S", time.localtime(result.timestamp))
        self.log_widget.add_log_entry(
            timestamp,
            result.row_index,
            "행 완료",
            result.success,
            result.error or f"소요시간: {result.duration_ms:.0f}ms"
        )
        
    def _on_step_executing(self, step: MacroStep, row_index: int):
        """Handle step execution"""
        # Could add detailed step logging here if needed
        pass
        
    def _on_execution_finished(self):
        """Handle execution finished"""
        self.logger.info("Execution finished")
        self.timer.stop()
        
    def _on_error(self, error_msg: str):
        """Handle execution error"""
        self.logger.error(f"Execution error: {error_msg}")
        
        # Show error dialog
        from ui.dialogs.error_report_dialog import ErrorReportDialog
        from logger.execution_logger import get_execution_logger
        
        log_file = get_execution_logger().get_current_log_file()
        ErrorReportDialog.show_error(
            "Execution Error",
            error_msg,
            log_file=log_file,
            parent=self
        )
        
    def _update_elapsed_time(self):
        """Update elapsed time display"""
        if self.start_time:
            elapsed = self.start_time.secsTo(QTimer.currentTime())
            total = self.completed_count + self.failed_count
            self.status_widget.update_statistics(
                total, self.completed_count, self.failed_count, elapsed
            )
            
    def show_log_viewer(self):
        """Show log viewer dialog"""
        from ui.dialogs.log_viewer_dialog import LogViewerDialog
        from logger.execution_logger import get_execution_logger
        
        # Open with current log file if available
        log_file = get_execution_logger().get_current_log_file()
        dialog = LogViewerDialog(log_file=log_file, parent=self)
        dialog.show()  # Non-modal
        
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the execution widget"""
        if is_compact:
            # Reduce spacing in main layout
            self.layout().setSpacing(5)
            self.layout().setContentsMargins(5, 5, 5, 5)
            
            # Adjust group boxes
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(5, 15, 5, 5)
                
            # Set compact height for log table rows
            self.log_widget.verticalHeader().setDefaultSectionSize(22)
        else:
            # Reset to normal spacing
            self.layout().setSpacing(10)
            self.layout().setContentsMargins(10, 10, 10, 10)
            
            # Reset group boxes
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(9, 20, 9, 9)
                
            # Reset log table row height
            self.log_widget.verticalHeader().setDefaultSectionSize(30)
</file>

<file path="src/ui/main_window.py">
"""
Main application window
"""

from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QMenuBar, QMenu, QAction, QStatusBar, QLabel,
    QMessageBox, QTabWidget, QFileDialog
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QIcon
from config.settings import Settings
from logger.app_logger import get_logger
from core.macro_storage import MacroStorage, MacroFormat
from core.macro_types import Macro
import os
from typing import List, Optional

class MainWindow(QMainWindow):
    """Main application window"""
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
        # Macro storage
        self.macro_storage = MacroStorage()
        self.current_macro_path: Optional[str] = None
        self.recent_macros: List[str] = self.settings.get("macro.recent_files", [])
        
        self.init_ui()
        self.load_window_state()
        
        # Apply compact mode if enabled
        if self.settings.get("ui.compact_mode", False):
            self.apply_compact_mode(True)
        
    def init_ui(self):
        """Initialize user interface"""
        self.setWindowTitle("Excel Macro Automation")
        
        # Set window size from settings
        window_size = self.settings.get("ui.window_size", [1280, 720])
        self.resize(*window_size)
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Create main layout
        layout = QVBoxLayout(central_widget)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        
        # Add Excel widget
        from ui.widgets.excel_widget import ExcelWidget
        self.excel_widget = ExcelWidget()
        self.tab_widget.addTab(self.excel_widget, "Excel")
        
        # Add Macro Editor widget
        from ui.widgets.macro_editor import MacroEditorWidget
        self.macro_editor = MacroEditorWidget()
        self.tab_widget.addTab(self.macro_editor, "Editor")
        
        # Add Execution widget
        from ui.widgets.execution_widget import ExecutionWidget
        self.execution_widget = ExecutionWidget(self.settings)
        self.tab_widget.addTab(self.execution_widget, "Run")
        
        # Connect Excel and Macro widgets to Execution
        self.excel_widget.dataReady.connect(self._on_excel_data_ready)
        self.macro_editor.macroChanged.connect(self._on_macro_changed)
        
        # Create menu bar
        self.create_menu_bar()
        
        # Create status bar
        self.create_status_bar()
        
    def create_menu_bar(self):
        """Create application menu bar"""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        new_action = QAction("New Project", self)
        new_action.setShortcut("Ctrl+N")
        file_menu.addAction(new_action)
        
        open_action = QAction("Open Project", self)
        open_action.setShortcut("Ctrl+O")
        file_menu.addAction(open_action)
        
        save_action = QAction("Save Project", self)
        save_action.setShortcut("Ctrl+Alt+S")
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        # Macro menu items
        save_macro_action = QAction("Save Macro", self)
        save_macro_action.setShortcut("Ctrl+S")
        save_macro_action.triggered.connect(self.save_macro)
        file_menu.addAction(save_macro_action)
        
        load_macro_action = QAction("Load Macro", self)
        load_macro_action.setShortcut("Ctrl+O")
        load_macro_action.triggered.connect(self.load_macro)
        file_menu.addAction(load_macro_action)
        
        export_macro_action = QAction("Export Macro", self)
        export_macro_action.setShortcut("Ctrl+E")
        export_macro_action.triggered.connect(self.export_macro)
        file_menu.addAction(export_macro_action)
        
        file_menu.addSeparator()
        
        # Recent macros submenu
        self.recent_macros_menu = QMenu("Recent Macros", self)
        file_menu.addMenu(self.recent_macros_menu)
        self.update_recent_macros_menu()
        
        file_menu.addSeparator()
        
        exit_action = QAction("Exit", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Edit menu
        edit_menu = menubar.addMenu("Edit")
        
        settings_action = QAction("Settings", self)
        settings_action.setShortcut("Ctrl+,")
        edit_menu.addAction(settings_action)
        
        # View menu
        view_menu = menubar.addMenu("View")
        
        theme_action = QAction("Toggle Theme", self)
        view_menu.addAction(theme_action)
        
        # Add compact mode toggle
        self.compact_mode_action = QAction("Compact Mode", self)
        self.compact_mode_action.setCheckable(True)
        self.compact_mode_action.setChecked(self.settings.get("ui.compact_mode", False))
        self.compact_mode_action.setShortcut("Ctrl+Shift+C")
        self.compact_mode_action.setStatusTip("Toggle compact mode to reduce UI spacing (Ctrl+Shift+C)")
        self.compact_mode_action.triggered.connect(self.toggle_compact_mode)
        view_menu.addAction(self.compact_mode_action)
        
        view_menu.addSeparator()
        
        log_viewer_action = QAction("Execution Logs", self)
        log_viewer_action.setShortcut("Ctrl+L")
        log_viewer_action.triggered.connect(self.show_log_viewer)
        view_menu.addAction(log_viewer_action)
        
        # Help menu
        help_menu = menubar.addMenu("Help")
        
        about_action = QAction("About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
        
    def create_status_bar(self):
        """Create application status bar"""
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        
        # Add permanent widgets
        self.status_label = QLabel("Ready")
        self.status_bar.addPermanentWidget(self.status_label)
        
    def show_about(self):
        """Show about dialog"""
        QMessageBox.about(
            self,
            "About Excel Macro Automation",
            "Excel-based Task Automation Macro\n\n"
            "Version: 1.0.0\n"
            "Automate repetitive tasks using Excel data"
        )
        
    def show_log_viewer(self):
        """Show log viewer dialog"""
        from ui.dialogs.log_viewer_dialog import LogViewerDialog
        dialog = LogViewerDialog(parent=self)
        dialog.show()  # Non-modal
        
    def closeEvent(self, event):
        """Handle window close event"""
        if self.settings.get("ui.confirm_exit", True):
            reply = QMessageBox.question(
                self,
                "Confirm Exit",
                "Are you sure you want to exit?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                self.save_window_state()
                event.accept()
            else:
                event.ignore()
        else:
            self.save_window_state()
            event.accept()
            
    def save_window_state(self):
        """Save window size and position"""
        self.settings.set("ui.window_size", [self.width(), self.height()])
        self.settings.save()
        
    def load_window_state(self):
        """Load window size and position"""
        # Window state loading is handled in init_ui
        pass
        
    def _on_excel_data_ready(self, excel_data):
        """Handle Excel data ready"""
        excel_manager = self.excel_widget.get_excel_manager()
        macro = self.macro_editor.get_macro()
        self.execution_widget.set_macro_and_excel(macro, excel_manager)
        
    def _on_macro_changed(self, macro):
        """Handle macro change"""
        excel_manager = self.excel_widget.get_excel_manager()
        if excel_manager._current_data:
            self.execution_widget.set_macro_and_excel(macro, excel_manager)
            
    def save_macro(self):
        """Save current macro to file"""
        try:
            macro = self.macro_editor.get_macro()
            if not macro or not macro.steps:
                QMessageBox.warning(self, "Warning", "No macro to save.")
                return
                
            # Get save path
            if self.current_macro_path:
                # Use current path
                file_path = self.current_macro_path
            else:
                # Show save dialog
                file_path, selected_filter = QFileDialog.getSaveFileName(
                    self,
                    "Save Macro",
                    os.path.expanduser("~/"),
                    "JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
                )
                
                if not file_path:
                    return
                    
            # Determine format based on extension
            if file_path.endswith('.emf'):
                format_type = MacroFormat.ENCRYPTED
            else:
                format_type = MacroFormat.JSON
                if not file_path.endswith('.json'):
                    file_path += '.json'
                    
            # Save macro
            success = self.macro_storage.save_macro(macro, file_path, format_type)
            
            if success:
                self.current_macro_path = file_path
                self.add_to_recent_macros(file_path)
                self.update_window_title()
                self.status_label.setText(f"Macro saved to {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", "Macro saved successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to save macro.")
                
        except Exception as e:
            self.logger.error(f"Error saving macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to save macro: {str(e)}")
            
    def load_macro(self):
        """Load macro from file"""
        try:
            # Show open dialog
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Load Macro",
                os.path.expanduser("~/"),
                "Macro files (*.json *.emf);;JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
            )
            
            if not file_path:
                return
                
            # Load macro
            macro = self.macro_storage.load_macro(file_path)
            
            if macro:
                self.macro_editor.set_macro(macro)
                self.current_macro_path = file_path
                self.add_to_recent_macros(file_path)
                self.update_window_title()
                self.status_label.setText(f"Macro loaded from {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", "Macro loaded successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to load macro.")
                
        except Exception as e:
            self.logger.error(f"Error loading macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load macro: {str(e)}")
            
    def export_macro(self):
        """Export selected macro steps"""
        try:
            # Get selected steps from macro editor
            selected_steps = self.macro_editor.get_selected_steps()
            
            if not selected_steps:
                QMessageBox.warning(self, "Warning", "No steps selected for export.")
                return
                
            # Create partial macro
            macro = self.macro_editor.get_macro()
            partial_macro = Macro(
                name=f"{macro.name}_partial",
                description=f"Partial export of {macro.name}",
                steps=selected_steps,
                variables=macro.variables  # Include all variables for now
            )
            
            # Show save dialog
            file_path, selected_filter = QFileDialog.getSaveFileName(
                self,
                "Export Macro Steps",
                os.path.expanduser("~/"),
                "JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
            )
            
            if not file_path:
                return
                
            # Determine format
            if file_path.endswith('.emf'):
                format_type = MacroFormat.ENCRYPTED
            else:
                format_type = MacroFormat.JSON
                if not file_path.endswith('.json'):
                    file_path += '.json'
                    
            # Save partial macro
            success = self.macro_storage.save_macro(partial_macro, file_path, format_type)
            
            if success:
                self.status_label.setText(f"Exported {len(selected_steps)} steps to {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", f"Exported {len(selected_steps)} steps successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to export macro steps.")
                
        except Exception as e:
            self.logger.error(f"Error exporting macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to export macro: {str(e)}")
            
    def add_to_recent_macros(self, file_path: str):
        """Add file to recent macros list"""
        # Remove if already exists
        if file_path in self.recent_macros:
            self.recent_macros.remove(file_path)
            
        # Add to front
        self.recent_macros.insert(0, file_path)
        
        # Keep only last 5
        self.recent_macros = self.recent_macros[:5]
        
        # Save to settings
        self.settings.set("macro.recent_files", self.recent_macros)
        self.settings.save()
        
        # Update menu
        self.update_recent_macros_menu()
        
    def update_recent_macros_menu(self):
        """Update recent macros menu"""
        self.recent_macros_menu.clear()
        
        if not self.recent_macros:
            action = QAction("(No recent macros)", self)
            action.setEnabled(False)
            self.recent_macros_menu.addAction(action)
            return
            
        for file_path in self.recent_macros:
            if os.path.exists(file_path):
                action = QAction(os.path.basename(file_path), self)
                action.setStatusTip(file_path)
                action.triggered.connect(lambda checked, path=file_path: self.load_recent_macro(path))
                self.recent_macros_menu.addAction(action)
                
    def load_recent_macro(self, file_path: str):
        """Load a recent macro"""
        try:
            macro = self.macro_storage.load_macro(file_path)
            
            if macro:
                self.macro_editor.set_macro(macro)
                self.current_macro_path = file_path
                self.update_window_title()
                self.status_label.setText(f"Macro loaded from {os.path.basename(file_path)}")
            else:
                QMessageBox.critical(self, "Error", f"Failed to load macro from {os.path.basename(file_path)}")
                self.recent_macros.remove(file_path)
                self.update_recent_macros_menu()
                
        except Exception as e:
            self.logger.error(f"Error loading recent macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load macro: {str(e)}")
            
    def update_window_title(self):
        """Update window title with current macro file"""
        title = "Excel Macro Automation"
        if self.current_macro_path:
            title += f" - {os.path.basename(self.current_macro_path)}"
        self.setWindowTitle(title)
        
    def toggle_compact_mode(self):
        """Toggle compact mode for the UI"""
        is_compact = self.compact_mode_action.isChecked()
        self.settings.set("ui.compact_mode", is_compact)
        self.settings.save()
        
        # Apply compact mode styling
        self.apply_compact_mode(is_compact)
        self.status_label.setText(f"Compact mode {'enabled' if is_compact else 'disabled'}")
        
    def apply_compact_mode(self, is_compact: bool):
        """Apply compact mode styling to the application"""
        if is_compact:
            # Compact mode stylesheet
            compact_style = """
            /* General compact styling */
            QWidget {
                font-size: 11px;
            }
            
            /* Reduce padding in tabs */
            QTabBar::tab {
                padding: 3px 8px;
                min-height: 20px;
            }
            
            /* Compact buttons */
            QPushButton {
                padding: 3px 8px;
                min-height: 22px;
            }
            
            /* Compact list items */
            QListWidget::item {
                padding: 2px;
                min-height: 20px;
            }
            
            /* Compact table rows */
            QTableWidget::item {
                padding: 2px;
            }
            
            /* Compact menu items */
            QMenu::item {
                padding: 3px 20px 3px 10px;
            }
            
            /* Compact group boxes */
            QGroupBox {
                margin-top: 1ex;
                padding-top: 10px;
            }
            
            QGroupBox::title {
                top: -7px;
                left: 10px;
            }
            
            /* Compact status bar */
            QStatusBar {
                min-height: 18px;
                font-size: 10px;
            }
            
            /* Compact splitters */
            QSplitter::handle {
                background-color: #ddd;
                height: 3px;
            }
            
            /* Compact scroll bars */
            QScrollBar:vertical {
                width: 10px;
            }
            
            QScrollBar:horizontal {
                height: 10px;
            }
            
            /* Compact line edits */
            QLineEdit, QTextEdit, QPlainTextEdit {
                padding: 2px;
            }
            
            /* Compact spin boxes */
            QSpinBox, QDoubleSpinBox {
                padding: 2px;
                min-height: 20px;
            }
            
            /* Compact combo boxes */
            QComboBox {
                padding: 2px 5px;
                min-height: 20px;
            }
            
            /* Compact tool buttons */
            QToolButton {
                padding: 2px;
                min-height: 20px;
                min-width: 20px;
            }
            
            /* Compact dialogs */
            QDialog {
                font-size: 11px;
            }
            
            /* Compact labels */
            QLabel {
                margin: 1px;
            }
            
            /* Compact progress bars */
            QProgressBar {
                min-height: 14px;
                max-height: 14px;
                font-size: 10px;
            }
            
            /* Compact checkboxes and radio buttons */
            QCheckBox, QRadioButton {
                spacing: 3px;
            }
            
            /* Compact tree widget */
            QTreeWidget::item {
                padding: 1px;
                min-height: 18px;
            }
            """
            self.setStyleSheet(compact_style)
            
            # Apply specific compact settings to widgets
            self._apply_compact_to_widgets(True)
        else:
            # Reset to normal styling
            self.setStyleSheet("")
            self._apply_compact_to_widgets(False)
            
    def _apply_compact_to_widgets(self, is_compact: bool):
        """Apply compact mode settings to specific widgets"""
        # Set tab widget spacing
        if is_compact:
            self.tab_widget.setDocumentMode(True)
            self.centralWidget().layout().setContentsMargins(5, 5, 5, 5)
            self.centralWidget().layout().setSpacing(5)
        else:
            self.tab_widget.setDocumentMode(False)
            self.centralWidget().layout().setContentsMargins(9, 9, 9, 9)
            self.centralWidget().layout().setSpacing(6)
            
        # Apply to child widgets if they have compact mode support
        for i in range(self.tab_widget.count()):
            widget = self.tab_widget.widget(i)
            if hasattr(widget, 'set_compact_mode'):
                widget.set_compact_mode(is_compact)
</file>

<file path="src/core/macro_types.py">
"""
Macro step type definitions
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Union, Tuple
from enum import Enum
import uuid
from datetime import datetime

class StepType(Enum):
    """Available macro step types"""
    # Mouse actions
    MOUSE_CLICK = "mouse_click"
    MOUSE_MOVE = "mouse_move"
    MOUSE_DRAG = "mouse_drag"
    MOUSE_SCROLL = "mouse_scroll"
    
    # Keyboard actions
    KEYBOARD_TYPE = "keyboard_type"
    KEYBOARD_HOTKEY = "keyboard_hotkey"
    
    # Wait actions
    WAIT_TIME = "wait_time"
    WAIT_IMAGE = "wait_image"
    WAIT_TEXT = "wait_text"
    
    # Screen actions
    SCREENSHOT = "screenshot"
    IMAGE_SEARCH = "image_search"
    OCR_TEXT = "ocr_text"
    
    # Flow control
    IF_CONDITION = "if_condition"
    LOOP = "loop"
    
    # Excel operations
    EXCEL_READ = "excel_read"
    EXCEL_WRITE = "excel_write"

class ErrorHandling(Enum):
    """Error handling strategies"""
    STOP = "stop"           # Stop execution on error
    CONTINUE = "continue"   # Continue to next step
    RETRY = "retry"         # Retry the step

class MouseButton(Enum):
    """Mouse button types"""
    LEFT = "left"
    RIGHT = "right"
    MIDDLE = "middle"

class ConditionOperator(Enum):
    """Condition operators for conditional steps"""
    EQUALS = "equals"
    NOT_EQUALS = "not_equals"
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    GREATER_THAN = "greater_than"
    LESS_THAN = "less_than"
    EXISTS = "exists"
    NOT_EXISTS = "not_exists"

@dataclass
class MacroStep(ABC):
    """Base class for all macro steps"""
    step_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    step_type: StepType = field(init=False)
    name: str = ""
    description: str = ""
    enabled: bool = True
    error_handling: ErrorHandling = ErrorHandling.STOP
    retry_count: int = 0
    
    @abstractmethod
    def validate(self) -> List[str]:
        """Validate step configuration"""
        pass
    
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """Convert step to dictionary"""
        base_dict = {
            "step_id": self.step_id,
            "step_type": self.step_type.value,
            "name": self.name,
            "description": self.description,
            "enabled": self.enabled,
            "error_handling": self.error_handling.value,
            "retry_count": self.retry_count
        }
        return base_dict
    
    @classmethod
    @abstractmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MacroStep':
        """Create step from dictionary"""
        pass

# Mouse Steps

@dataclass
class MouseClickStep(MacroStep):
    """Mouse click action"""
    step_type: StepType = field(default=StepType.MOUSE_CLICK, init=False)
    x: int = 0
    y: int = 0
    button: MouseButton = MouseButton.LEFT
    clicks: int = 1
    interval: float = 0.0
    relative_to: str = "screen"  # screen, window, image
    
    def validate(self) -> List[str]:
        errors = []
        if self.x < 0 or self.y < 0:
            errors.append("Coordinates must be non-negative")
        if self.clicks < 1:
            errors.append("Click count must be at least 1")
        if self.interval < 0:
            errors.append("Interval must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "x": self.x,
            "y": self.y,
            "button": self.button.value,
            "clicks": self.clicks,
            "interval": self.interval,
            "relative_to": self.relative_to
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MouseClickStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            x=data.get("x", 0),
            y=data.get("y", 0),
            button=MouseButton(data.get("button", "left")),
            clicks=data.get("clicks", 1),
            interval=data.get("interval", 0.0),
            relative_to=data.get("relative_to", "screen")
        )

@dataclass
class MouseMoveStep(MacroStep):
    """Mouse move action"""
    step_type: StepType = field(default=StepType.MOUSE_MOVE, init=False)
    x: int = 0
    y: int = 0
    duration: float = 0.0
    relative_to: str = "screen"
    
    def validate(self) -> List[str]:
        errors = []
        if self.x < 0 or self.y < 0:
            errors.append("Coordinates must be non-negative")
        if self.duration < 0:
            errors.append("Duration must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "x": self.x,
            "y": self.y,
            "duration": self.duration,
            "relative_to": self.relative_to
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MouseMoveStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            x=data.get("x", 0),
            y=data.get("y", 0),
            duration=data.get("duration", 0.0),
            relative_to=data.get("relative_to", "screen")
        )

# Keyboard Steps

@dataclass
class KeyboardTypeStep(MacroStep):
    """Keyboard typing action"""
    step_type: StepType = field(default=StepType.KEYBOARD_TYPE, init=False)
    text: str = ""
    interval: float = 0.0
    use_variables: bool = True
    
    def validate(self) -> List[str]:
        errors = []
        if not self.text:
            errors.append("Text cannot be empty")
        if self.interval < 0:
            errors.append("Interval must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "text": self.text,
            "interval": self.interval,
            "use_variables": self.use_variables
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'KeyboardTypeStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            text=data.get("text", ""),
            interval=data.get("interval", 0.0),
            use_variables=data.get("use_variables", True)
        )

@dataclass
class KeyboardHotkeyStep(MacroStep):
    """Keyboard hotkey action"""
    step_type: StepType = field(default=StepType.KEYBOARD_HOTKEY, init=False)
    keys: List[str] = field(default_factory=list)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.keys:
            errors.append("At least one key must be specified")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "keys": self.keys
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'KeyboardHotkeyStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            keys=data.get("keys", [])
        )

# Wait Steps

@dataclass
class WaitTimeStep(MacroStep):
    """Wait for specified time"""
    step_type: StepType = field(default=StepType.WAIT_TIME, init=False)
    seconds: float = 1.0
    
    def validate(self) -> List[str]:
        errors = []
        if self.seconds <= 0:
            errors.append("Wait time must be positive")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "seconds": self.seconds
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WaitTimeStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            seconds=data.get("seconds", 1.0)
        )

@dataclass
class WaitImageStep(MacroStep):
    """Wait for image to appear"""
    step_type: StepType = field(default=StepType.WAIT_IMAGE, init=False)
    image_path: str = ""
    timeout: float = 10.0
    confidence: float = 0.9
    region: Optional[tuple] = None  # (x, y, width, height)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.image_path:
            errors.append("Image path cannot be empty")
        if self.timeout <= 0:
            errors.append("Timeout must be positive")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "image_path": self.image_path,
            "timeout": self.timeout,
            "confidence": self.confidence,
            "region": list(self.region) if self.region else None
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WaitImageStep':
        region = data.get("region")
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            image_path=data.get("image_path", ""),
            timeout=data.get("timeout", 10.0),
            confidence=data.get("confidence", 0.9),
            region=tuple(region) if region else None
        )

@dataclass
class TextSearchStep(MacroStep):
    """Search for dynamic text and click"""
    step_type: StepType = field(default=StepType.OCR_TEXT, init=False)
    search_text: str = ""  # Text to search for (can include {{variables}})
    excel_column: Optional[str] = None  # Excel column to bind for dynamic text
    region: Optional[tuple] = None  # (x, y, width, height)
    exact_match: bool = False
    confidence: float = 0.5
    click_after_find: bool = True
    click_offset: Tuple[int, int] = (0, 0)  # Offset from center of found text
    double_click: bool = False  # Whether to double click
    
    def validate(self) -> List[str]:
        errors = []
        if not self.search_text and not self.excel_column:
            errors.append("Either search text or Excel column must be specified")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "search_text": self.search_text,
            "excel_column": self.excel_column,
            "region": list(self.region) if self.region else None,
            "exact_match": self.exact_match,
            "confidence": self.confidence,
            "click_after_find": self.click_after_find,
            "click_offset": list(self.click_offset),
            "double_click": self.double_click
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TextSearchStep':
        region = data.get("region")
        click_offset = data.get("click_offset", [0, 0])
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            search_text=data.get("search_text", ""),
            excel_column=data.get("excel_column"),
            region=tuple(region) if region else None,
            exact_match=data.get("exact_match", False),
            confidence=data.get("confidence", 0.5),
            click_after_find=data.get("click_after_find", True),
            click_offset=tuple(click_offset),
            double_click=data.get("double_click", False)
        )

# Flow Control Steps

@dataclass
class IfConditionStep(MacroStep):
    """Conditional execution"""
    step_type: StepType = field(default=StepType.IF_CONDITION, init=False)
    condition_type: str = "image_exists"  # image_exists, text_exists, variable_equals, variable_contains, variable_greater, variable_less
    condition_value: Dict[str, Any] = field(default_factory=dict)  # Store all condition parameters
    true_steps: List['MacroStep'] = field(default_factory=list)  # Nested steps for true branch
    false_steps: List['MacroStep'] = field(default_factory=list)  # Nested steps for false branch
    
    def validate(self) -> List[str]:
        errors = []
        if not self.condition_type:
            errors.append("Condition type must be specified")
            
        # Validate based on condition type
        if self.condition_type == "image_exists":
            if not self.condition_value.get("image_path"):
                errors.append("Image path must be specified for image_exists condition")
        elif self.condition_type == "text_exists":
            if not self.condition_value.get("text"):
                errors.append("Text must be specified for text_exists condition")
        elif self.condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            if not self.condition_value.get("variable"):
                errors.append("Variable name must be specified")
            if not self.condition_value.get("compare_value"):
                errors.append("Comparison value must be specified")
                
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "condition_type": self.condition_type,
            "condition_value": self.condition_value,
            "true_steps": [step.to_dict() for step in self.true_steps],
            "false_steps": [step.to_dict() for step in self.false_steps]
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'IfConditionStep':
        # StepFactory will be defined later in this module
        # We need to reference it dynamically to avoid forward reference issues
        import sys
        module = sys.modules[__name__]
        StepFactory = getattr(module, 'StepFactory')
        
        # Create true/false steps from data
        true_steps = []
        for step_data in data.get("true_steps", []):
            true_steps.append(StepFactory.from_dict(step_data))
            
        false_steps = []
        for step_data in data.get("false_steps", []):
            false_steps.append(StepFactory.from_dict(step_data))
            
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            condition_type=data.get("condition_type", "image_exists"),
            condition_value=data.get("condition_value", {}),
            true_steps=true_steps,
            false_steps=false_steps
        )

@dataclass
class LoopStep(MacroStep):
    """Loop execution"""
    step_type: StepType = field(default=StepType.LOOP, init=False)
    loop_type: str = "count"  # count, while_image, for_each_row
    loop_count: int = 1
    loop_steps: List[str] = field(default_factory=list)  # Step IDs to loop
    
    def validate(self) -> List[str]:
        errors = []
        if self.loop_type == "count" and self.loop_count < 1:
            errors.append("Loop count must be at least 1")
        if not self.loop_steps:
            errors.append("Loop must contain at least one step")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "loop_type": self.loop_type,
            "loop_count": self.loop_count,
            "loop_steps": self.loop_steps
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LoopStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            loop_type=data.get("loop_type", "count"),
            loop_count=data.get("loop_count", 1),
            loop_steps=data.get("loop_steps", [])
        )

# Additional Step Classes

@dataclass
class ImageSearchStep(MacroStep):
    """Image search and click action"""
    step_type: StepType = field(default=StepType.IMAGE_SEARCH, init=False)
    image_path: str = ""
    confidence: float = 0.9
    region: Optional[tuple] = None  # (x, y, width, height)
    click_after_find: bool = True
    click_offset: Tuple[int, int] = (0, 0)
    double_click: bool = False
    
    def validate(self) -> List[str]:
        errors = []
        if not self.image_path:
            errors.append("Image path cannot be empty")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "image_path": self.image_path,
            "confidence": self.confidence,
            "region": list(self.region) if self.region else None,
            "click_after_find": self.click_after_find,
            "click_offset": list(self.click_offset),
            "double_click": self.double_click
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ImageSearchStep':
        region = data.get("region")
        click_offset = data.get("click_offset", [0, 0])
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            image_path=data.get("image_path", ""),
            confidence=data.get("confidence", 0.9),
            region=tuple(region) if region else None,
            click_after_find=data.get("click_after_find", True),
            click_offset=tuple(click_offset),
            double_click=data.get("double_click", False)
        )

@dataclass
class ScreenshotStep(MacroStep):
    """Take screenshot action"""
    step_type: StepType = field(default=StepType.SCREENSHOT, init=False)
    filename_pattern: str = "screenshot_{timestamp}.png"
    save_directory: str = "./screenshots/"
    region: Optional[tuple] = None  # (x, y, width, height)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.filename_pattern:
            errors.append("Filename pattern cannot be empty")
        if not self.save_directory:
            errors.append("Save directory cannot be empty")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "filename_pattern": self.filename_pattern,
            "save_directory": self.save_directory,
            "region": list(self.region) if self.region else None
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ScreenshotStep':
        region = data.get("region")
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            filename_pattern=data.get("filename_pattern", "screenshot_{timestamp}.png"),
            save_directory=data.get("save_directory", "./screenshots/"),
            region=tuple(region) if region else None
        )

# Step Factory

class StepFactory:
    """Factory for creating macro steps"""
    
    _step_classes = {
        StepType.MOUSE_CLICK: MouseClickStep,
        StepType.MOUSE_MOVE: MouseMoveStep,
        StepType.KEYBOARD_TYPE: KeyboardTypeStep,
        StepType.KEYBOARD_HOTKEY: KeyboardHotkeyStep,
        StepType.WAIT_TIME: WaitTimeStep,
        StepType.WAIT_IMAGE: WaitImageStep,
        StepType.IMAGE_SEARCH: ImageSearchStep,
        StepType.SCREENSHOT: ScreenshotStep,
        StepType.OCR_TEXT: TextSearchStep,
        StepType.IF_CONDITION: IfConditionStep,
        StepType.LOOP: LoopStep
    }
    
    @classmethod
    def create_step(cls, step_type: StepType) -> MacroStep:
        """Create a new step of given type"""
        step_class = cls._step_classes.get(step_type)
        if not step_class:
            raise ValueError(f"Unknown step type: {step_type}")
        return step_class()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> MacroStep:
        """Create step from dictionary"""
        step_type = StepType(data.get("step_type"))
        step_class = cls._step_classes.get(step_type)
        if not step_class:
            raise ValueError(f"Unknown step type: {step_type}")
        return step_class.from_dict(data)

# Macro Definition

@dataclass
class Macro:
    """Complete macro definition"""
    macro_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = "새 매크로"
    description: str = ""
    version: str = "1.0.0"
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    steps: List[MacroStep] = field(default_factory=list)
    variables: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def add_step(self, step: MacroStep, index: Optional[int] = None):
        """Add step to macro"""
        if index is None:
            self.steps.append(step)
        else:
            self.steps.insert(index, step)
        self.updated_at = datetime.now()
    
    def remove_step(self, step_id: str):
        """Remove step by ID"""
        self.steps = [s for s in self.steps if s.step_id != step_id]
        self.updated_at = datetime.now()
    
    def move_step(self, step_id: str, new_index: int):
        """Move step to new position"""
        step = None
        for i, s in enumerate(self.steps):
            if s.step_id == step_id:
                step = self.steps.pop(i)
                break
        
        if step:
            self.steps.insert(new_index, step)
            self.updated_at = datetime.now()
    
    def validate(self) -> List[str]:
        """Validate entire macro"""
        errors = []
        if not self.name:
            errors.append("Macro name cannot be empty")
        
        # Validate each step
        for i, step in enumerate(self.steps):
            step_errors = step.validate()
            for error in step_errors:
                errors.append(f"Step {i+1} ({step.name}): {error}")
        
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert macro to dictionary"""
        return {
            "macro_id": self.macro_id,
            "name": self.name,
            "description": self.description,
            "version": self.version,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "steps": [step.to_dict() for step in self.steps],
            "variables": self.variables,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Macro':
        """Create macro from dictionary"""
        # StepFactory is defined in this module
        import sys
        module = sys.modules[__name__]
        StepFactory = getattr(module, 'StepFactory')
        
        steps = []
        for step_data in data.get("steps", []):
            steps.append(StepFactory.from_dict(step_data))
        
        return cls(
            macro_id=data.get("macro_id", str(uuid.uuid4())),
            name=data.get("name", "새 매크로"),
            description=data.get("description", ""),
            version=data.get("version", "1.0.0"),
            created_at=datetime.fromisoformat(data.get("created_at", datetime.now().isoformat())),
            updated_at=datetime.fromisoformat(data.get("updated_at", datetime.now().isoformat())),
            steps=steps,
            variables=data.get("variables", {}),
            metadata=data.get("metadata", {})
        )
</file>

<file path="src/ui/dialogs/image_step_dialog.py">
"""
Configuration dialogs for image-based macro steps
"""

import os
from typing import Optional, Dict, Any, Tuple
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QLineEdit, QSpinBox, QDoubleSpinBox, QGroupBox, QFileDialog,
    QDialogButtonBox, QMessageBox, QCheckBox, QComboBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QPixmap, QImage, QKeySequence
from PyQt5.QtWidgets import QShortcut
from core.macro_types import MacroStep, WaitImageStep, StepType
from vision.image_matcher import ImageMatcher
from config.settings import Settings
from ui.widgets.roi_selector import ROISelectorWidget, ROISelectorOverlay
from utils.clipboard_utils import save_clipboard_image

class ImageStepDialog(QDialog):
    """Base dialog for image step configuration"""
    
    def __init__(self, step: Optional[MacroStep] = None, 
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(parent)
        self.step = step
        self.settings = settings or Settings()
        self.image_matcher = ImageMatcher(self.settings)
        
        # Step data
        self.step_data: Dict[str, Any] = {}
        if step:
            self.step_data = step.to_dict()
            
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize base UI"""
        self.setModal(True)
        self.setMinimumWidth(600)
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        
        layout = QVBoxLayout()
        
        # Name input
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("단계 이름:"))
        self.name_input = QLineEdit()
        name_layout.addWidget(self.name_input)
        layout.addLayout(name_layout)
        
        # Image selection group
        image_group = QGroupBox("참조 이미지")
        image_layout = QVBoxLayout()
        
        # Image path
        path_layout = QHBoxLayout()
        path_layout.addWidget(QLabel("이미지 경로:"))
        self.image_path_input = QLineEdit()
        self.image_path_input.setReadOnly(True)
        path_layout.addWidget(self.image_path_input)
        
        # Browse button
        self.browse_btn = QPushButton("찾아보기...")
        self.browse_btn.clicked.connect(self._browse_image)
        path_layout.addWidget(self.browse_btn)
        
        # Capture button
        self.capture_btn = QPushButton("캡처")
        self.capture_btn.clicked.connect(self._capture_image)
        path_layout.addWidget(self.capture_btn)
        
        # Paste button for clipboard
        self.paste_btn = QPushButton("붙여넣기 (Ctrl+V)")
        self.paste_btn.clicked.connect(self._paste_from_clipboard)
        path_layout.addWidget(self.paste_btn)
        
        # Add Ctrl+V shortcut
        paste_shortcut = QShortcut(QKeySequence("Ctrl+V"), self)
        paste_shortcut.activated.connect(self._paste_from_clipboard)
        
        image_layout.addLayout(path_layout)
        
        # Image preview
        self.image_preview = QLabel()
        self.image_preview.setMinimumHeight(150)
        self.image_preview.setMaximumHeight(300)
        self.image_preview.setScaledContents(False)  # Don't stretch image
        self.image_preview.setAlignment(Qt.AlignCenter)
        self.image_preview.setStyleSheet("""
            QLabel {
                border: 1px solid #ccc;
                background-color: #f9f9f9;
            }
        """)
        image_layout.addWidget(self.image_preview)
        
        # Help text
        help_label = QLabel(
            "💡 팁: Shift + Win + S 로 화면을 캡처한 후 Ctrl+V 또는 '붙여넣기' 버튼으로 이미지를 추가할 수 있습니다."
        )
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px; margin-top: 5px;")
        image_layout.addWidget(help_label)
        
        image_group.setLayout(image_layout)
        layout.addWidget(image_group)
        
        # ROI selection group
        roi_group = QGroupBox("검색 영역 (선택사항)")
        roi_layout = QVBoxLayout()
        
        # ROI selector widget
        self.roi_selector = ROISelectorWidget()
        roi_layout.addWidget(self.roi_selector)
        
        # Select region button
        self.select_region_btn = QPushButton("화면 영역 선택")
        self.select_region_btn.clicked.connect(self._select_region)
        roi_layout.addWidget(self.select_region_btn)
        
        # Clear region button
        self.clear_region_btn = QPushButton("영역 초기화")
        self.clear_region_btn.clicked.connect(self._clear_region)
        roi_layout.addWidget(self.clear_region_btn)
        
        roi_group.setLayout(roi_layout)
        layout.addWidget(roi_group)
        
        # Additional controls (implemented by subclasses)
        self.add_custom_controls(layout)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
        # Update preview after dialog is shown
        from PyQt5.QtCore import QTimer
        QTimer.singleShot(100, self._update_preview)
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Override to add step-specific controls"""
        pass
        
    def _browse_image(self):
        """Browse for image file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "참조 이미지 선택",
            "",
            "이미지 파일 (*.png *.jpg *.jpeg *.bmp);;모든 파일 (*.*)"
        )
        
        if file_path:
            self.image_path_input.setText(file_path)
            self._update_preview()
            
    def _capture_image(self):
        """Capture new reference image"""
        # Show instructions for Windows screen capture
        reply = QMessageBox.question(
            self,
            "화면 캡처 안내",
            "Windows 화면 캡처 도구를 사용하시겠습니까?\n\n"
            "1. Shift + Win + S 키를 눌러 화면 캡처\n"
            "2. 캡처할 영역을 선택\n"
            "3. '붙여넣기' 버튼을 클릭하여 이미지 추가\n\n"
            "이 방법을 사용하시겠습니까?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Just show the message and let user use Windows capture
            QMessageBox.information(
                self,
                "안내",
                "지금 Shift + Win + S 를 눌러서 화면을 캡처하세요.\n"
                "캡처 후 '붙여넣기' 버튼을 클릭하세요."
            )
        else:
            # Use the same approach as text search for region selection
            self.hide()
            # Give time for dialog to hide before showing ROI selector
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(200, self._show_capture_selector)
    
    def _show_capture_selector(self):
        """Show capture selector overlay"""
        try:
            print("DEBUG: Creating capture ROI selector")
            # Create ROI selector as a top-level window (same as text search)
            self.capture_roi_overlay = ROISelectorOverlay(parent=None)
            self.capture_roi_overlay.selectionComplete.connect(self._on_capture_region_selected)
            self.capture_roi_overlay.selectionCancelled.connect(lambda: self.show())
            print("DEBUG: Starting capture ROI selection")
            self.capture_roi_overlay.start_selection()
        except Exception as e:
            print(f"DEBUG: Error in _show_capture_selector: {e}")
            import traceback
            traceback.print_exc()
            self.show()
            
    def _on_capture_region_selected(self, region: tuple):
        """Handle capture region selection"""
        try:
            if region and len(region) == 4:
                # Capture the selected region
                import time
                import pyautogui
                timestamp = time.strftime("%Y%m%d_%H%M%S")
                filename = f"capture_{timestamp}.png"
                
                # Create captures directory if needed
                captures_dir = os.path.join(os.path.dirname(__file__), "../../../captures")
                os.makedirs(captures_dir, exist_ok=True)
                
                file_path = os.path.join(captures_dir, filename)
                
                # Capture using pyautogui
                x, y, w, h = region
                screenshot = pyautogui.screenshot(region=(x, y, w, h))
                screenshot.save(file_path)
                
                # Update UI
                self.image_path_input.setText(file_path)
                # Delay preview update
                from PyQt5.QtCore import QTimer
                QTimer.singleShot(50, self._update_preview)
            
            # Restore dialog visibility
            self.show()
            self.raise_()
            self.activateWindow()
        except Exception as e:
            print(f"DEBUG: Error in _on_capture_region_selected: {e}")
            import traceback
            traceback.print_exc()
            self.show()
            QMessageBox.warning(self, "오류", f"화면 캡처 중 오류가 발생했습니다: {str(e)}")
        
    def _paste_from_clipboard(self):
        """Paste image from clipboard"""
        # Use the unified clipboard utility
        file_path = save_clipboard_image()
        
        if file_path and os.path.exists(file_path):
            # Update UI
            self.image_path_input.setText(file_path)
            # Delay preview update to ensure dialog is properly sized
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(50, self._update_preview)
            QMessageBox.information(self, "성공", "클립보드에서 이미지를 붙여넣었습니다.")
        else:
            QMessageBox.information(
                self, 
                "안내", 
                "클립보드에 이미지가 없습니다.\n\n"
                "사용 방법:\n"
                "1. Windows: Shift + Win + S 로 화면 캡처\n"
                "2. 이 버튼을 클릭하여 붙여넣기\n\n"
                "참고: WSL 환경에서는 Windows PowerShell을 통해\n"
                "클립보드에 접근합니다."
            )
    
        
    def _update_preview(self):
        """Update image preview"""
        image_path = self.image_path_input.text()
        if os.path.exists(image_path):
            pixmap = QPixmap(image_path)
            if not pixmap.isNull():
                # Get the preview label size
                label_width = self.image_preview.width() - 10  # Account for padding
                label_height = self.image_preview.height() - 10
                
                # Scale to fit preview while keeping aspect ratio
                # Use the smaller of the two dimensions to ensure it fits
                scaled = pixmap.scaled(
                    label_width,
                    label_height,
                    Qt.KeepAspectRatio,
                    Qt.SmoothTransformation
                )
                self.image_preview.setPixmap(scaled)
                
                # Show original size info
                size_text = f"원본 크기: {pixmap.width()} x {pixmap.height()}"
                self.image_preview.setToolTip(size_text)
            else:
                self.image_preview.setText("잘못된 이미지")
                self.image_preview.setToolTip("")
        else:
            self.image_preview.setText("선택된 이미지 없음")
            self.image_preview.setToolTip("")
            
    def _select_region(self):
        """Start region selection"""
        # Hide dialog temporarily
        self.hide()
        # Give time for dialog to hide before showing ROI selector
        from PyQt5.QtCore import QTimer
        QTimer.singleShot(200, self._show_region_selector)
        
    def _show_region_selector(self):
        """Show region selector overlay"""
        try:
            print("DEBUG: Creating ROI selector for image search")
            # Create ROI selector as a top-level window (same as text search)
            self.roi_overlay = ROISelectorOverlay(parent=None)
            self.roi_overlay.selectionComplete.connect(self._on_region_selected)
            self.roi_overlay.selectionCancelled.connect(lambda: self.show())
            print("DEBUG: Starting ROI selection for image search")
            self.roi_overlay.start_selection()
        except Exception as e:
            print(f"DEBUG: Error in _show_region_selector: {e}")
            import traceback
            traceback.print_exc()
            self.show()
            
    def _on_region_selected(self, region: tuple):
        """Handle region selection"""
        try:
            # Ensure region is properly formatted
            if region and len(region) == 4:
                # Convert all values to integers to avoid any type issues
                formatted_region = tuple(int(x) for x in region)
                self.roi_selector.set_region(formatted_region)
                print(f"DEBUG: set_region successful with formatted region: {formatted_region}")
            else:
                print(f"DEBUG: Invalid region format: {region}")
                self.roi_selector.set_region(None)
            
            # Restore dialog visibility
            self.show()
            self.raise_()
            self.activateWindow()
        except Exception as e:
            print(f"DEBUG: Error in _on_region_selected: {e}")
            import traceback
            traceback.print_exc()
            # Still try to show the dialog
            self.roi_selector.set_region(None)
            self.show()
        
    def _clear_region(self):
        """Clear selected region"""
        self.roi_selector.set_region(None)
        
    def load_step_data(self):
        """Load data from existing step"""
        if self.step:
            self.name_input.setText(self.step.name)
            
            # Load image path if available
            if hasattr(self.step, 'image_path'):
                self.image_path_input.setText(self.step.image_path)
                self._update_preview()
                
            # Load region if available
            if hasattr(self.step, 'region') and self.step.region:
                self.roi_selector.set_region(self.step.region)
                
    def get_step_data(self) -> Dict[str, Any]:
        """Get configured step data"""
        data = {
            'name': self.name_input.text(),
            'image_path': self.image_path_input.text(),
            'region': self.roi_selector.get_region()
        }
        
        # Add custom data from subclasses
        data.update(self.get_custom_data())
        
        return data
        
    def get_custom_data(self) -> Dict[str, Any]:
        """Override to return step-specific data"""
        return {}
        
    def accept(self):
        """Validate and accept dialog"""
        # Basic validation
        if not self.name_input.text():
            QMessageBox.warning(self, "확인 오류", "단계 이름을 입력해주세요")
            return
            
        if not self.image_path_input.text():
            QMessageBox.warning(self, "확인 오류", "참조 이미지를 선택해주세요")
            return
            
        if not os.path.exists(self.image_path_input.text()):
            QMessageBox.warning(self, "확인 오류", "선택한 이미지 파일이 존재하지 않습니다")
            return
            
        super().accept()

class WaitImageStepDialog(ImageStepDialog):
    """Dialog for configuring wait image steps"""
    
    def __init__(self, step: Optional[WaitImageStep] = None, 
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(step, settings, parent)
        self.setWindowTitle("이미지 대기 단계 설정")
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Add wait-specific controls"""
        # Matching parameters group
        params_group = QGroupBox("Matching Parameters")
        params_layout = QVBoxLayout()
        
        # Timeout
        timeout_layout = QHBoxLayout()
        timeout_layout.addWidget(QLabel("Timeout (seconds):"))
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setMinimum(1)
        self.timeout_spin.setMaximum(300)
        self.timeout_spin.setValue(30)
        timeout_layout.addWidget(self.timeout_spin)
        params_layout.addLayout(timeout_layout)
        
        # Confidence
        confidence_layout = QHBoxLayout()
        confidence_layout.addWidget(QLabel("Confidence:"))
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setMinimum(0.1)
        self.confidence_spin.setMaximum(1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.9)
        self.confidence_spin.setDecimals(2)
        confidence_layout.addWidget(self.confidence_spin)
        
        # Test button
        self.test_btn = QPushButton("Test Match")
        self.test_btn.clicked.connect(self._test_match)
        confidence_layout.addWidget(self.test_btn)
        
        params_layout.addLayout(confidence_layout)
        
        # Test result
        self.test_result_label = QLabel()
        params_layout.addWidget(self.test_result_label)
        
        params_group.setLayout(params_layout)
        layout.addWidget(params_group)
        
    def load_step_data(self):
        """Load wait image step data"""
        super().load_step_data()
        
        if isinstance(self.step, WaitImageStep):
            self.timeout_spin.setValue(int(self.step.timeout))
            self.confidence_spin.setValue(self.step.confidence)
            
    def get_custom_data(self) -> Dict[str, Any]:
        """Get wait-specific data"""
        return {
            'step_type': StepType.WAIT_IMAGE,
            'timeout': self.timeout_spin.value(),
            'confidence': self.confidence_spin.value()
        }
        
    def _test_match(self):
        """Test image matching with current settings"""
        image_path = self.image_path_input.text()
        if not image_path or not os.path.exists(image_path):
            self.test_result_label.setText("Please select a valid image first")
            return
            
        # Perform test match
        result = self.image_matcher.find_image(
            image_path,
            confidence=self.confidence_spin.value(),
            region=self.roi_selector.get_region()
        )
        
        if result.found:
            self.test_result_label.setText(
                f"✓ Match found at ({result.center[0]}, {result.center[1]}) "
                f"with confidence {result.confidence:.2f}"
            )
            self.test_result_label.setStyleSheet("color: green;")
        else:
            self.test_result_label.setText(
                f"✗ No match found (best confidence: {result.confidence:.2f})"
            )
            self.test_result_label.setStyleSheet("color: red;")

class ImageSearchStepDialog(ImageStepDialog):
    """Dialog for configuring image search steps"""
    
    def __init__(self, step: Optional[MacroStep] = None,
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(step, settings, parent)
        self.setWindowTitle("이미지 검색 단계 설정")
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Add search-specific controls"""
        # Search parameters group
        params_group = QGroupBox("검색 파라미터")
        params_layout = QVBoxLayout()
        
        # Confidence
        confidence_layout = QHBoxLayout()
        confidence_layout.addWidget(QLabel("신뢰도:"))
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setMinimum(0.1)
        self.confidence_spin.setMaximum(1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.9)
        self.confidence_spin.setDecimals(2)
        confidence_layout.addWidget(self.confidence_spin)
        params_layout.addLayout(confidence_layout)
        
        # Search all occurrences
        self.search_all_check = QCheckBox("모든 항목 찾기")
        params_layout.addWidget(self.search_all_check)
        
        # Max results (when search all is checked)
        max_results_layout = QHBoxLayout()
        max_results_layout.addWidget(QLabel("최대 결과:"))
        self.max_results_spin = QSpinBox()
        self.max_results_spin.setMinimum(1)
        self.max_results_spin.setMaximum(100)
        self.max_results_spin.setValue(10)
        self.max_results_spin.setEnabled(False)
        max_results_layout.addWidget(self.max_results_spin)
        params_layout.addLayout(max_results_layout)
        
        # Connect search all checkbox
        self.search_all_check.toggled.connect(self.max_results_spin.setEnabled)
        
        params_group.setLayout(params_layout)
        layout.addWidget(params_group)
        
        # Click action group
        click_group = QGroupBox("클릭 옵션")
        click_layout = QVBoxLayout()
        
        # Click after find checkbox
        self.click_after_find_check = QCheckBox("찾은 후 클릭")
        self.click_after_find_check.setChecked(True)
        click_layout.addWidget(self.click_after_find_check)
        
        # Click type selection
        click_type_layout = QHBoxLayout()
        click_type_layout.addWidget(QLabel("클릭 유형:"))
        self.click_type_combo = QComboBox()
        self.click_type_combo.addItems(["한번 클릭", "더블 클릭"])
        self.click_type_combo.setCurrentIndex(0)
        click_type_layout.addWidget(self.click_type_combo)
        click_type_layout.addStretch()
        click_layout.addLayout(click_type_layout)
        
        # Click offset
        offset_layout = QHBoxLayout()
        offset_layout.addWidget(QLabel("클릭 오프셋:"))
        
        offset_layout.addWidget(QLabel("X:"))
        self.offset_x_spin = QSpinBox()
        self.offset_x_spin.setMinimum(-500)
        self.offset_x_spin.setMaximum(500)
        self.offset_x_spin.setValue(0)
        offset_layout.addWidget(self.offset_x_spin)
        
        offset_layout.addWidget(QLabel("Y:"))
        self.offset_y_spin = QSpinBox()
        self.offset_y_spin.setMinimum(-500)
        self.offset_y_spin.setMaximum(500)
        self.offset_y_spin.setValue(0)
        offset_layout.addWidget(self.offset_y_spin)
        
        offset_layout.addStretch()
        click_layout.addLayout(offset_layout)
        
        # Enable/disable click options based on click checkbox
        self.click_after_find_check.toggled.connect(self.click_type_combo.setEnabled)
        self.click_after_find_check.toggled.connect(self.offset_x_spin.setEnabled)
        self.click_after_find_check.toggled.connect(self.offset_y_spin.setEnabled)
        
        click_group.setLayout(click_layout)
        layout.addWidget(click_group)
        
    def get_custom_data(self) -> Dict[str, Any]:
        """Get search-specific data"""
        return {
            'step_type': StepType.IMAGE_SEARCH,
            'confidence': self.confidence_spin.value(),
            'search_all': self.search_all_check.isChecked(),
            'max_results': self.max_results_spin.value(),
            'click_after_find': self.click_after_find_check.isChecked(),
            'click_offset': (self.offset_x_spin.value(), self.offset_y_spin.value()),
            'double_click': self.click_type_combo.currentIndex() == 1  # True if "더블 클릭" selected
        }
        
    def load_step_data(self):
        """Load image search step data"""
        super().load_step_data()
        
        if self.step and hasattr(self.step, 'confidence'):
            self.confidence_spin.setValue(self.step.confidence)
            
        if self.step and hasattr(self.step, 'click_after_find'):
            self.click_after_find_check.setChecked(self.step.click_after_find)
            
        if self.step and hasattr(self.step, 'click_offset'):
            offset = self.step.click_offset
            if offset and len(offset) >= 2:
                self.offset_x_spin.setValue(offset[0])
                self.offset_y_spin.setValue(offset[1])
                
        if self.step and hasattr(self.step, 'double_click'):
            self.click_type_combo.setCurrentIndex(1 if self.step.double_click else 0)
</file>

<file path="src/ui/widgets/macro_editor.py">
"""
Drag and drop macro editor widget
"""

from typing import Optional, List, Dict, Any
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QLabel, QScrollArea, QFrame, QMenu, QMessageBox,
    QSplitter, QGroupBox, QToolButton, QDialog
)
from PyQt5.QtCore import Qt, pyqtSignal, QMimeData, QByteArray, QDataStream, QIODevice
from PyQt5.QtGui import QDrag, QDragEnterEvent, QDropEvent, QPalette, QIcon, QCursor
from core.macro_types import (
    MacroStep, StepType, Macro, StepFactory,
    MouseClickStep, KeyboardTypeStep, WaitTimeStep
)

class StepPaletteItem(QListWidgetItem):
    """Draggable step type item"""
    
    def __init__(self, step_type: StepType, display_name: str, icon: Optional[QIcon] = None):
        super().__init__(display_name)
        self.step_type = step_type
        if icon:
            self.setIcon(icon)
        self.setToolTip(self._get_tooltip())
        
    def _get_tooltip(self) -> str:
        """Get tooltip for step type"""
        tooltips = {
            StepType.MOUSE_CLICK: "마우스 클릭 동작을 추가합니다",
            StepType.MOUSE_MOVE: "마우스 이동 동작을 추가합니다",
            StepType.KEYBOARD_TYPE: "텍스트 입력 동작을 추가합니다",
            StepType.KEYBOARD_HOTKEY: "단축키 입력 동작을 추가합니다",
            StepType.WAIT_TIME: "지정된 시간만큼 대기합니다",
            StepType.WAIT_IMAGE: "이미지가 나타날 때까지 대기합니다",
            StepType.IMAGE_SEARCH: "화면에서 이미지를 검색합니다",
            StepType.OCR_TEXT: "화면에서 텍스트를 검색하고 클릭합니다",
            StepType.SCREENSHOT: "화면을 캡처합니다",
            StepType.IF_CONDITION: "조건문을 추가합니다",
            StepType.LOOP: "반복문을 추가합니다"
        }
        return tooltips.get(self.step_type, "")

class StepPalette(QListWidget):
    """Palette of draggable step types"""
    
    def __init__(self):
        super().__init__()
        self.setDragEnabled(True)
        self.setDefaultDropAction(Qt.CopyAction)
        self.setMaximumWidth(200)
        self.init_steps()
        
    def init_steps(self):
        """Initialize available step types"""
        step_configs = [
            (StepType.MOUSE_CLICK, "마우스 클릭", "🖱️"),
            (StepType.MOUSE_MOVE, "마우스 이동", "↗️"),
            (StepType.KEYBOARD_TYPE, "텍스트 입력", "⌨️"),
            (StepType.KEYBOARD_HOTKEY, "단축키", "⌘"),
            (StepType.WAIT_TIME, "대기", "⏱️"),
            (StepType.WAIT_IMAGE, "이미지 대기", "🖼️"),
            (StepType.IMAGE_SEARCH, "이미지 검색", "🔍"),
            (StepType.OCR_TEXT, "텍스트 검색", "🔤"),
            (StepType.SCREENSHOT, "화면 캡처", "📷"),
            (StepType.IF_CONDITION, "조건문", "❓"),
            (StepType.LOOP, "반복문", "🔄"),
        ]
        
        for step_type, name, emoji in step_configs:
            item = StepPaletteItem(step_type, f"{emoji} {name}")
            self.addItem(item)
            
    def startDrag(self, supportedActions):
        """Start dragging a step type"""
        item = self.currentItem()
        if isinstance(item, StepPaletteItem):
            drag = QDrag(self)
            mime_data = QMimeData()
            
            # Store step type in MIME data
            byte_array = QByteArray()
            stream = QDataStream(byte_array, QIODevice.WriteOnly)
            stream.writeQString(item.step_type.value)
            
            mime_data.setData("application/x-steptype", byte_array)
            mime_data.setText(item.text())
            drag.setMimeData(mime_data)
            
            drag.exec_(Qt.CopyAction)

class MacroStepWidget(QFrame):
    """Widget representing a single macro step"""
    
    editRequested = pyqtSignal(MacroStep)
    deleteRequested = pyqtSignal(str)  # step_id
    moveRequested = pyqtSignal(str, int)  # step_id, new_index
    selectionChanged = pyqtSignal(str, bool)  # step_id, selected
    
    def __init__(self, step: MacroStep, index: int):
        super().__init__()
        self.step = step
        self.index = index
        self.selected = False
        self.setFrameStyle(QFrame.Box)
        self.setAcceptDrops(True)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        layout.setContentsMargins(5, 5, 5, 5)
        
        # Selection checkbox
        from PyQt5.QtWidgets import QCheckBox
        self.select_cb = QCheckBox()
        self.select_cb.toggled.connect(self._on_selection_changed)
        layout.addWidget(self.select_cb)
        
        # Drag handle
        self.handle = QLabel("≡")
        self.handle.setStyleSheet("font-size: 16px; color: #888;")
        self.handle.setCursor(Qt.OpenHandCursor)
        layout.addWidget(self.handle)
        
        # Step info
        info_layout = QVBoxLayout()
        
        # Step name and type with icon
        step_icon = self._get_step_icon()
        name_text = f"{step_icon} <b>{self.step.name or self.step.step_type.value}</b>"
        name_label = QLabel(name_text)
        info_layout.addWidget(name_label)
        
        # Step details based on type
        details_text = self._get_step_details()
        if details_text:
            details_label = QLabel(details_text)
            details_label.setWordWrap(True)
            details_label.setStyleSheet("color: #666; font-size: 11px;")
            details_label.setTextFormat(Qt.RichText)  # Enable HTML formatting
            info_layout.addWidget(details_label)
            
        # Step description
        if self.step.description:
            desc_label = QLabel(self.step.description)
            desc_label.setWordWrap(True)
            desc_label.setStyleSheet("color: #666; font-size: 11px;")
            info_layout.addWidget(desc_label)
            
        layout.addLayout(info_layout)
        layout.addStretch()
        
        # Enable/disable checkbox
        self.enable_btn = QToolButton()
        self.enable_btn.setCheckable(True)
        self.enable_btn.setChecked(self.step.enabled)
        self.enable_btn.setText("✓" if self.step.enabled else "✗")
        self.enable_btn.toggled.connect(self._on_enable_toggled)
        layout.addWidget(self.enable_btn)
        
        # Edit button
        edit_btn = QToolButton()
        edit_btn.setText("✏️")
        edit_btn.setToolTip("편집")
        edit_btn.clicked.connect(lambda: self.editRequested.emit(self.step))
        layout.addWidget(edit_btn)
        
        # Delete button
        delete_btn = QToolButton()
        delete_btn.setText("🗑️")
        delete_btn.setToolTip("삭제")
        delete_btn.clicked.connect(lambda: self.deleteRequested.emit(self.step.step_id))
        layout.addWidget(delete_btn)
        
        self.setLayout(layout)
        self._update_style()
        
    def _get_step_icon(self) -> str:
        """Get icon for step type"""
        icons = {
            StepType.MOUSE_CLICK: "🖱️",
            StepType.MOUSE_MOVE: "↗️",
            StepType.KEYBOARD_TYPE: "⌨️",
            StepType.KEYBOARD_HOTKEY: "⌘",
            StepType.WAIT_TIME: "⏱️",
            StepType.WAIT_IMAGE: "🖼️",
            StepType.IMAGE_SEARCH: "🔍",
            StepType.OCR_TEXT: "🔤",
            StepType.SCREENSHOT: "📷",
            StepType.IF_CONDITION: "❓",
            StepType.LOOP: "🔄"
        }
        return icons.get(self.step.step_type, "")
        
    def _get_step_details(self) -> str:
        """Get step details based on type"""
        details = []
        
        if self.step.step_type == StepType.WAIT_IMAGE:
            if hasattr(self.step, 'image_path') and self.step.image_path:
                import os
                filename = os.path.basename(self.step.image_path)
                details.append(f"이미지: {filename}")
            if hasattr(self.step, 'timeout'):
                details.append(f"대기시간: {self.step.timeout}초")
            if hasattr(self.step, 'confidence'):
                details.append(f"정확도: {int(self.step.confidence * 100)}%")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("✓ 영역 지정됨")
                
        elif self.step.step_type == StepType.IMAGE_SEARCH:
            if hasattr(self.step, 'image_path') and self.step.image_path:
                import os
                filename = os.path.basename(self.step.image_path)
                details.append(f"이미지: {filename}")
            if hasattr(self.step, 'confidence'):
                details.append(f"정확도: {int(self.step.confidence * 100)}%")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("✓ 영역 지정됨")
                
        elif self.step.step_type == StepType.MOUSE_CLICK:
            if hasattr(self.step, 'x') and hasattr(self.step, 'y'):
                details.append(f"위치: ({self.step.x}, {self.step.y})")
            if hasattr(self.step, 'clicks') and self.step.clicks > 1:
                details.append(f"클릭 수: {self.step.clicks}")
                
        elif self.step.step_type == StepType.KEYBOARD_TYPE:
            if hasattr(self.step, 'text') and self.step.text:
                text_preview = self.step.text[:30] + "..." if len(self.step.text) > 30 else self.step.text
                details.append(f"텍스트: {text_preview}")
                
        elif self.step.step_type == StepType.WAIT_TIME:
            if hasattr(self.step, 'seconds'):
                details.append(f"대기: {self.step.seconds}초")
                
        elif self.step.step_type == StepType.OCR_TEXT:
            if hasattr(self.step, 'excel_column') and self.step.excel_column:
                details.append(f"엑셀 열: {self.step.excel_column}")
            elif hasattr(self.step, 'search_text') and self.step.search_text:
                text_preview = self.step.search_text[:20] + "..." if len(self.step.search_text) > 20 else self.step.search_text
                details.append(f"텍스트: {text_preview}")
            if hasattr(self.step, 'exact_match') and self.step.exact_match:
                details.append("정확히 일치")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("✓ 영역 지정됨")
                
        elif self.step.step_type == StepType.IF_CONDITION:
            if hasattr(self.step, 'condition_type'):
                condition_names = {
                    "image_exists": "이미지가 존재하면",
                    "text_exists": "텍스트가 존재하면",
                    "variable_equals": "변수가 같으면",
                    "variable_contains": "변수가 포함하면",
                    "variable_greater": "변수가 크면",
                    "variable_less": "변수가 작으면"
                }
                details.append(condition_names.get(self.step.condition_type, self.step.condition_type))
            if hasattr(self.step, 'true_steps'):
                details.append(f"<span style='color: #4caf50'>✓ 참: {len(self.step.true_steps)}개</span>")
            if hasattr(self.step, 'false_steps'):
                details.append(f"<span style='color: #f44336'>✗ 거짓: {len(self.step.false_steps)}개</span>")
                
        elif self.step.step_type == StepType.SCREENSHOT:
            if hasattr(self.step, 'filename_pattern'):
                details.append(f"파일명: {self.step.filename_pattern}")
            if hasattr(self.step, 'save_directory'):
                details.append(f"저장 경로: {self.step.save_directory}")
            if hasattr(self.step, 'region') and self.step.region:
                x, y, w, h = self.step.region
                details.append(f"영역: ({x}, {y}) {w}x{h}")
            else:
                details.append("전체 화면")
                
        elif self.step.step_type == StepType.LOOP:
            if hasattr(self.step, 'loop_type'):
                loop_names = {
                    "count": "횟수 반복",
                    "while_image": "이미지 대기",
                    "for_each_row": "행별 반복"
                }
                details.append(loop_names.get(self.step.loop_type, self.step.loop_type))
            if hasattr(self.step, 'loop_count') and self.step.loop_type == "count":
                details.append(f"{self.step.loop_count}회")
            if hasattr(self.step, 'loop_steps'):
                details.append(f"{len(self.step.loop_steps)}개 단계 반복")
                
        return " | ".join(details) if details else ""
        
    def _on_enable_toggled(self, checked: bool):
        """Handle enable/disable toggle"""
        self.step.enabled = checked
        self.enable_btn.setText("✓" if checked else "✗")
        self._update_style()
        
    def _update_style(self):
        """Update widget style based on state"""
        # Special styling for IF_CONDITION and LOOP
        if self.step.step_type == StepType.IF_CONDITION:
            base_color = "#fff3e0"  # Orange tint
            border_color = "#ff9800"
        elif self.step.step_type == StepType.LOOP:
            base_color = "#f3e5f5"  # Purple tint
            border_color = "#9c27b0"
        else:
            base_color = "white"
            border_color = "#ddd"
            
        if self.selected:
            self.setStyleSheet(f"""
                MacroStepWidget {{
                    background-color: #e3f2fd;
                    border: 2px solid #2196F3;
                    border-radius: 5px;
                }}
            """)
        elif self.step.enabled:
            self.setStyleSheet(f"""
                MacroStepWidget {{
                    background-color: {base_color};
                    border: 2px solid {border_color};
                    border-radius: 5px;
                }}
                MacroStepWidget:hover {{
                    border-color: #999;
                }}
            """)
        else:
            self.setStyleSheet(f"""
                MacroStepWidget {{
                    background-color: #f5f5f5;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    opacity: 0.7;
                }}
            """)
            
    def _on_selection_changed(self, checked: bool):
        """Handle selection change"""
        self.selected = checked
        self._update_style()
        self.selectionChanged.emit(self.step.step_id, checked)
        
    def set_selected(self, selected: bool):
        """Set selection state"""
        self.select_cb.setChecked(selected)
        self.selected = selected
        self._update_style()
            
    def mousePressEvent(self, event):
        """Handle mouse press for dragging"""
        if event.button() == Qt.LeftButton:
            # Check if clicking on handle
            handle_rect = self.handle.geometry()
            if handle_rect.contains(event.pos()):
                self.drag_start_position = event.pos()
                
    def mouseMoveEvent(self, event):
        """Handle mouse move for dragging"""
        if not (event.buttons() & Qt.LeftButton):
            return
            
        if not hasattr(self, 'drag_start_position'):
            return
            
        if (event.pos() - self.drag_start_position).manhattanLength() < 10:
            return
            
        # Start drag
        drag = QDrag(self)
        mime_data = QMimeData()
        
        # Store step data
        byte_array = QByteArray()
        stream = QDataStream(byte_array, QIODevice.WriteOnly)
        stream.writeQString(self.step.step_id)
        stream.writeInt(self.index)
        
        mime_data.setData("application/x-macrostep", byte_array)
        mime_data.setText(self.step.name or self.step.step_type.value)
        drag.setMimeData(mime_data)
        
        drag.exec_(Qt.MoveAction)

class MacroFlowWidget(QWidget):
    """Widget displaying the macro flow with drag/drop support"""
    
    stepAdded = pyqtSignal(MacroStep, int)  # step, index
    stepMoved = pyqtSignal(str, int)  # step_id, new_index
    stepDeleted = pyqtSignal(str)  # step_id
    stepEdited = pyqtSignal(MacroStep)
    
    def __init__(self):
        super().__init__()
        self.macro = Macro()
        self.step_widgets: Dict[str, MacroStepWidget] = {}
        self.selected_steps: Dict[str, bool] = {}  # step_id -> selected
        self.setAcceptDrops(True)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        self.layout = QVBoxLayout()
        self.layout.setSpacing(5)
        
        # Empty state label
        self.empty_label = QLabel("단계를 여기로 드래그하세요")
        self.empty_label.setAlignment(Qt.AlignCenter)
        self.empty_label.setStyleSheet("""
            QLabel {
                color: #999;
                font-size: 14px;
                padding: 50px;
                border: 2px dashed #ddd;
                border-radius: 5px;
            }
        """)
        self.layout.addWidget(self.empty_label)
        
        self.layout.addStretch()
        self.setLayout(self.layout)
        
    def set_macro(self, macro: Macro):
        """Set the macro to display"""
        self.macro = macro
        self._rebuild_ui()
        
    def _rebuild_ui(self):
        """Rebuild UI from macro"""
        # Clear existing widgets
        for widget in self.step_widgets.values():
            widget.deleteLater()
        self.step_widgets.clear()
        
        # Remove all items from layout
        while self.layout.count() > 0:
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
                
        # Show empty label or steps
        if not self.macro.steps:
            try:
                if self.empty_label:
                    self.layout.addWidget(self.empty_label)
                    self.empty_label.show()
            except RuntimeError:
                # Empty label was deleted, recreate it
                self.empty_label = QLabel("단계를 여기로 드래그하세요")
                self.empty_label.setAlignment(Qt.AlignCenter)
                self.empty_label.setStyleSheet("""
                    QLabel {
                        color: #999;
                        font-size: 14px;
                        padding: 50px;
                        border: 2px dashed #ddd;
                        border-radius: 5px;
                    }
                """)
                self.layout.addWidget(self.empty_label)
        else:
            if self.empty_label:
                try:
                    self.empty_label.hide()
                except RuntimeError:
                    pass
            for i, step in enumerate(self.macro.steps):
                widget = self._create_step_widget(step, i)
                self.layout.insertWidget(i, widget)
                self.step_widgets[step.step_id] = widget
                
        self.layout.addStretch()
        
    def _create_step_widget(self, step: MacroStep, index: int) -> MacroStepWidget:
        """Create widget for a step"""
        widget = MacroStepWidget(step, index)
        widget.editRequested.connect(self._on_step_edit)
        widget.deleteRequested.connect(self._on_step_delete)
        widget.moveRequested.connect(self.stepMoved.emit)
        widget.selectionChanged.connect(self._on_selection_changed)
        
        # Restore selection state
        if step.step_id in self.selected_steps:
            widget.set_selected(self.selected_steps[step.step_id])
            
        return widget
        
    def _on_step_edit(self, step: MacroStep):
        """Handle step edit request"""
        if not step:
            return
            
        try:
            step_id = step.step_id  # Define step_id here
            print(f"DEBUG: _on_step_edit called for step type: {step.step_type}")
            
            # Open appropriate dialog based on step type
            if step.step_type == StepType.WAIT_IMAGE:
                from ui.dialogs.image_step_dialog import WaitImageStepDialog
                dialog = WaitImageStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.image_path = step_data['image_path']
                    step.timeout = step_data['timeout']
                    step.confidence = step_data['confidence']
                    step.region = step_data['region']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.IMAGE_SEARCH:
                from ui.dialogs.image_step_dialog import ImageSearchStepDialog
                dialog = ImageSearchStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.image_path = step_data['image_path']
                    step.confidence = step_data['confidence']
                    step.region = step_data['region']
                    step.click_after_find = step_data.get('click_after_find', True)
                    step.click_offset = step_data.get('click_offset', (0, 0))
                    step.double_click = step_data.get('double_click', False)
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.OCR_TEXT:
                from ui.dialogs.text_search_step_dialog import TextSearchStepDialog
                # Get Excel columns from parent widget
                excel_columns = []
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'excel_widget'):
                        excel_manager = parent.excel_widget.get_excel_manager()
                        if excel_manager and excel_manager._current_data is not None:
                            excel_columns = list(excel_manager._current_data.columns)
                        break
                    parent = parent.parent()
                    
                dialog = TextSearchStepDialog(step, excel_columns, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.search_text = step_data['search_text']
                    step.excel_column = step_data['excel_column']
                    step.region = step_data['region']
                    step.exact_match = step_data['exact_match']
                    step.confidence = step_data['confidence']
                    step.click_after_find = step_data['click_after_find']
                    step.click_offset = step_data['click_offset']
                    step.double_click = step_data.get('double_click', False)
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.IF_CONDITION:
                print(f"DEBUG: Opening IF_CONDITION dialog for step: {step.step_id}")
                try:
                    from ui.dialogs.if_condition_step_dialog import IfConditionStepDialog
                    print(f"DEBUG: Successfully imported IfConditionStepDialog")
                    
                    # Get Excel columns from parent widget
                    excel_columns = []
                    parent = self.parent()
                    while parent:
                        if hasattr(parent, 'excel_widget'):
                            excel_manager = parent.excel_widget.get_excel_manager()
                            if excel_manager and excel_manager._current_data is not None:
                                excel_columns = list(excel_manager._current_data.columns)
                            break
                        parent = parent.parent()
                    print(f"DEBUG: Excel columns: {excel_columns}")
                    
                    # Create and show dialog
                    print(f"DEBUG: Creating IfConditionStepDialog")
                    dialog = IfConditionStepDialog(step, excel_columns, parent=self)
                    print(f"DEBUG: Executing IfConditionStepDialog")
                    
                    if dialog.exec_() == QDialog.Accepted:
                        # Update step with new data
                        step_data = dialog.get_step_data()
                        print(f"DEBUG: Got step data: {step_data.keys()}")
                        
                        step.name = step_data['name']
                        step.description = step_data.get('description', '')
                        step.condition_type = step_data['condition_type']
                        step.condition_value = step_data['condition_value']
                        step.true_steps = step_data['true_steps']
                        step.false_steps = step_data['false_steps']
                        
                        print(f"DEBUG: Updated step, rebuilding UI")
                        self._rebuild_ui()
                        self.stepEdited.emit(step)
                    else:
                        print(f"DEBUG: Dialog was cancelled")
                        
                except Exception as e:
                    print(f"ERROR in IF_CONDITION dialog: {e}")
                    import traceback
                    traceback.print_exc()
                    QMessageBox.critical(self, "오류", f"조건문 편집 중 오류가 발생했습니다:\n{str(e)}")
                    
            elif step.step_type == StepType.MOUSE_CLICK:
                from ui.dialogs.mouse_click_step_dialog import MouseClickStepDialog
                dialog = MouseClickStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.x = step_data['x']
                    step.y = step_data['y']
                    step.button = step_data['button']
                    step.clicks = step_data['clicks']
                    step.interval = step_data['interval']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.MOUSE_MOVE:
                from ui.dialogs.mouse_move_step_dialog import MouseMoveStepDialog
                dialog = MouseMoveStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.x = step_data['x']
                    step.y = step_data['y']
                    step.duration = step_data['duration']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.KEYBOARD_TYPE:
                from ui.dialogs.keyboard_type_step_dialog import KeyboardTypeStepDialog
                # Get Excel columns from parent widget
                excel_columns = []
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'excel_widget'):
                        excel_manager = parent.excel_widget.get_excel_manager()
                        if excel_manager and excel_manager._current_data is not None:
                            excel_columns = list(excel_manager._current_data.columns)
                        break
                    parent = parent.parent()
                    
                dialog = KeyboardTypeStepDialog(step, excel_columns, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.text = step_data['text']
                    step.interval = step_data['interval']
                    step.use_variables = step_data['use_variables']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.KEYBOARD_HOTKEY:
                from ui.dialogs.keyboard_hotkey_step_dialog import KeyboardHotkeyStepDialog
                dialog = KeyboardHotkeyStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.keys = step_data['keys']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.WAIT_TIME:
                print(f"DEBUG: Importing WaitTimeStepDialog")
                from ui.dialogs.wait_time_step_dialog import WaitTimeStepDialog
                print(f"DEBUG: Creating WaitTimeStepDialog")
                dialog = WaitTimeStepDialog(step, parent=self)
                print(f"DEBUG: Executing WaitTimeStepDialog")
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.seconds = step_data['seconds']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.SCREENSHOT:
                from ui.dialogs.screenshot_step_dialog import ScreenshotStepDialog
                dialog = ScreenshotStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.filename_pattern = step_data['filename_pattern']
                    step.save_directory = step_data['save_directory']
                    step.region = step_data['region']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.LOOP:
                print(f"DEBUG: Opening LOOP dialog for step: {step.step_id}")
                try:
                    from ui.dialogs.loop_step_dialog import LoopStepDialog
                    print(f"DEBUG: Successfully imported LoopStepDialog")
                    
                    # Get all steps in macro for selection
                    all_steps = self.macro.steps
                    print(f"DEBUG: Available steps for loop: {len(all_steps)}")
                    
                    # Create and show dialog
                    print(f"DEBUG: Creating LoopStepDialog")
                    dialog = LoopStepDialog(step, all_steps, parent=self)
                    print(f"DEBUG: Executing LoopStepDialog")
                    
                    if dialog.exec_() == QDialog.Accepted:
                        step_data = dialog.get_step_data()
                        print(f"DEBUG: Got step data: {step_data}")
                        
                        step.name = step_data['name']
                        step.loop_type = step_data['loop_type']
                        step.loop_count = step_data['loop_count']
                        step.loop_steps = step_data['loop_steps']
                        if 'description' in step_data:
                            step.description = step_data['description']
                            
                        print(f"DEBUG: Updated loop step, rebuilding UI")
                        self._rebuild_ui()
                        self.stepEdited.emit(step)
                    else:
                        print(f"DEBUG: Dialog was cancelled")
                        
                except Exception as e:
                    print(f"ERROR in LOOP dialog: {e}")
                    import traceback
                    traceback.print_exc()
                    QMessageBox.critical(self, "오류", f"반복문 편집 중 오류가 발생했습니다:\n{str(e)}")
                    
            else:
                # For other step types, emit the signal as before
                self.stepEdited.emit(step)
                
        except Exception as e:
            print(f"DEBUG: Exception in _on_step_edit: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "오류", f"단계 편집 중 오류가 발생했습니다:\n{str(e)}")
        
    def _on_step_delete(self, step_id: str):
        """Handle step deletion"""
        reply = QMessageBox.question(
            self, "단계 삭제", 
            "이 단계를 삭제하시겠습니까?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.macro.remove_step(step_id)
            self._rebuild_ui()
            self.stepDeleted.emit(step_id)
            
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter"""
        if event.mimeData().hasFormat("application/x-steptype") or \
           event.mimeData().hasFormat("application/x-macrostep"):
            event.acceptProposedAction()
            
    def dragMoveEvent(self, event):
        """Handle drag move"""
        if event.mimeData().hasFormat("application/x-steptype") or \
           event.mimeData().hasFormat("application/x-macrostep"):
            event.acceptProposedAction()
            
    def dropEvent(self, event: QDropEvent):
        """Handle drop"""
        try:
            # Calculate drop index
            drop_index = self._get_drop_index(event.pos())
            
            if event.mimeData().hasFormat("application/x-steptype"):
                # New step from palette
                byte_array = event.mimeData().data("application/x-steptype")
                stream = QDataStream(byte_array, QIODevice.ReadOnly)
                step_type_str_result = stream.readQString()
                step_type_str = step_type_str_result[0] if isinstance(step_type_str_result, tuple) else step_type_str_result
                
                step_type = StepType(step_type_str)
                new_step = StepFactory.create_step(step_type)
                
                # Set default name
                step_names = {
                    StepType.MOUSE_CLICK: "마우스 클릭",
                    StepType.MOUSE_MOVE: "마우스 이동",
                    StepType.KEYBOARD_TYPE: "텍스트 입력",
                    StepType.KEYBOARD_HOTKEY: "단축키",
                    StepType.WAIT_TIME: "대기",
                    StepType.WAIT_IMAGE: "이미지 대기",
                    StepType.IMAGE_SEARCH: "이미지 검색",
                    StepType.OCR_TEXT: "텍스트 검색",
                    StepType.SCREENSHOT: "화면 캡처",
                    StepType.IF_CONDITION: "조건문",
                    StepType.LOOP: "반복문"
                }
                new_step.name = step_names.get(step_type, step_type.value)
                
                self.macro.add_step(new_step, drop_index)
                self._rebuild_ui()
                self.stepAdded.emit(new_step, drop_index)
                
                # Automatically open configuration dialog for new step
                self._on_step_edit(new_step)
                
            elif event.mimeData().hasFormat("application/x-macrostep"):
                # Moving existing step
                byte_array = event.mimeData().data("application/x-macrostep")
                stream = QDataStream(byte_array, QIODevice.ReadOnly)
                step_id_result = stream.readQString()
                step_id = step_id_result[0] if isinstance(step_id_result, tuple) else step_id_result
                old_index_result = stream.readInt()
                old_index = old_index_result[0] if isinstance(old_index_result, tuple) else old_index_result
                
                # Adjust drop index if moving down
                if old_index < drop_index:
                    drop_index -= 1
                    
                self.macro.move_step(step_id, drop_index)
                self._rebuild_ui()
                self.stepMoved.emit(step_id, drop_index)
                
            event.acceptProposedAction()
            
        except Exception as e:
            QMessageBox.critical(self, "\uc624\ub958", f"\ub4dc\ub798\uadf8 \uc568 \ub4dc\ub86d \uc911 \uc624\ub958\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4:\n{str(e)}")
            print(f"Drop event error: {e}")
            import traceback
            traceback.print_exc()
        
    def _get_drop_index(self, pos) -> int:
        """Calculate index where item should be dropped"""
        if not self.macro.steps:
            return 0
            
        # Find the widget under the cursor
        for i, step in enumerate(self.macro.steps):
            widget = self.step_widgets.get(step.step_id)
            if widget:
                widget_rect = widget.geometry()
                if pos.y() < widget_rect.center().y():
                    return i
                    
        return len(self.macro.steps)
        
    def _on_selection_changed(self, step_id: str, selected: bool):
        """Handle step selection change"""
        self.selected_steps[step_id] = selected
        
    def get_selected_steps(self) -> List[MacroStep]:
        """Get list of selected steps"""
        selected = []
        for step in self.macro.steps:
            if self.selected_steps.get(step.step_id, False):
                selected.append(step)
        return selected

class MacroEditorWidget(QWidget):
    """Complete macro editor with palette and flow"""
    
    macroChanged = pyqtSignal(Macro)
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        # Create splitter
        splitter = QSplitter(Qt.Horizontal)
        
        # Step palette
        palette_group = QGroupBox("단계 팔레트")
        palette_layout = QVBoxLayout()
        
        palette_label = QLabel("단계를 드래그하여 추가하세요")
        palette_label.setWordWrap(True)
        palette_layout.addWidget(palette_label)
        
        self.palette = StepPalette()
        palette_layout.addWidget(self.palette)
        
        palette_group.setLayout(palette_layout)
        splitter.addWidget(palette_group)
        
        # Macro flow
        flow_group = QGroupBox("매크로 흐름")
        flow_layout = QVBoxLayout()
        
        # Scroll area for flow
        scroll = QScrollArea()
        self.flow_widget = MacroFlowWidget()
        self.flow_widget.stepAdded.connect(self._on_change)
        self.flow_widget.stepMoved.connect(self._on_change)
        self.flow_widget.stepDeleted.connect(self._on_change)
        self.flow_widget.stepEdited.connect(self._on_step_edit)
        
        scroll.setWidget(self.flow_widget)
        scroll.setWidgetResizable(True)
        flow_layout.addWidget(scroll)
        
        flow_group.setLayout(flow_layout)
        splitter.addWidget(flow_group)
        
        # Set splitter sizes (20% palette, 80% flow)
        splitter.setSizes([200, 800])
        
        layout.addWidget(splitter)
        self.setLayout(layout)
        
    def set_macro(self, macro: Macro):
        """Set the macro to edit"""
        self.flow_widget.set_macro(macro)
        
    def get_macro(self) -> Macro:
        """Get the current macro"""
        return self.flow_widget.macro
        
    def get_selected_steps(self) -> List[MacroStep]:
        """Get list of selected steps"""
        return self.flow_widget.get_selected_steps()
        
    def _on_change(self):
        """Handle macro change"""
        self.macroChanged.emit(self.flow_widget.macro)
        
    def _on_step_edit(self, step: MacroStep):
        """Handle step edit request"""
        # This will be connected to step configuration dialog
        pass
        
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the macro editor"""
        if is_compact:
            # Adjust palette width
            self.palette.setMaximumWidth(150)
            
            # Find the splitter and adjust sizes
            splitter = self.findChild(QSplitter)
            if splitter:
                splitter.setSizes([150, 850])
                
            # Adjust group box margins
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(5, 15, 5, 5)
        else:
            # Reset to normal sizes
            self.palette.setMaximumWidth(200)
            
            # Reset splitter
            splitter = self.findChild(QSplitter)
            if splitter:
                splitter.setSizes([200, 800])
                
            # Reset group box margins
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(9, 20, 9, 9)
</file>

</files>
