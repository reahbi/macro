This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.vooster/
  project.json
resources/
  locales/
    en.json
    ko.json
src/
  automation/
    __init__.py
    engine.py
    executor.py
    hotkey_listener.py
  config/
    settings.py
  core/
    __init__.py
    macro_storage.py
    macro_types.py
  excel/
    excel_manager.py
    models.py
  logger/
    app_logger.py
    execution_logger.py
  ui/
    dialogs/
      __init__.py
      error_report_dialog.py
      if_condition_step_dialog.py
      image_step_dialog.py
      keyboard_hotkey_step_dialog.py
      keyboard_type_step_dialog.py
      log_viewer_dialog.py
      loop_step_dialog.py
      macro_save_dialog.py
      mouse_click_step_dialog.py
      mouse_move_step_dialog.py
      screenshot_step_dialog.py
      text_search_step_dialog.py
      wait_time_step_dialog.py
    widgets/
      __init__.py
      data_preview.py
      excel_widget.py
      execution_widget.py
      file_selector.py
      macro_editor.py
      roi_selector.py
      sheet_mapper.py
      simple_roi_selector.py
    main_window.py
  utils/
    clipboard_utils.py
    encryption.py
    monitor_utils.py
    path_utils.py
  vision/
    __init__.py
    image_matcher.py
    text_extractor.py
  __init__.py
test_results/
  drag_drop_test_report.json
  test_drag_drop_integration_result.json
  test_report_20250716_115250.html
  test_results_20250716_115250.csv
  test_step_configuration_result.json
tests/
  integration/
    test_drag_drop_integration.py
    test_excel_manager.py
    test_execution_logging.py
    test_image_capture.py
    test_logging_error_handling.py
    test_macro_execution.py
    test_macro_storage.py
    test_step_configuration.py
    test_step_executor.py
    test_text_input_variables.py
  manual_test_checklist.md
  test_helpers.py
uploads/
  XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250715_225040.json
  XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_111655.json
.gitignore
.mcp.json
APPLICATION_GUIDE.md
claude.md
CURRENT_STATUS.md
package.json
prd.md
pyproject.toml
README.md
requirements.txt
run_automated_tests.py
run_from_windows_native.ps1
run_from_windows.bat
run_main_fixed.py
run_main.py
run_simple.py
run_windows_wsl.sh
run_windows.bat
run_windows.ps1
run_with_debug.py
RUNNING_GUIDE.md
setup_wsl_gui.sh
start_gui.sh
test_compact_mode.py
test_demo_scenario.py
test_drag_drop.py
test_easyocr.py
test_if_condition.py
test_logging_system.py
test_pyqt.py
test_roi_issue.py
test_simple_if.py
trd.md
usage_tracking2.json
web_macro.json
web_ui_enhanced.py
web_ui_integrated_working.py
web_ui_launcher.py
WINDOWS_GUIDE.md
WINDOWS_RUN.bat
WINDOWS_WSL_SETUP.md
WSL_GUI_GUIDE.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(cp:*)",
      "Bash(sed:*)",
      "Bash(rm:*)",
      "Bash(mkdir:*)",
      "Bash(python3:*)",
      "Bash(pip3 install:*)",
      "Bash(QT_QPA_PLATFORM=offscreen python3 -m pytest tests/integration/test_execution_logging.py::TestExecutionLogging::test_log_statistics_calculation -v)",
      "Bash(ls:*)",
      "Bash(grep:*)",
      "Bash(pip install:*)",
      "Bash(touch:*)",
      "Bash(true)",
      "Bash(timeout:*)",
      "Bash(find:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)"
    ],
    "deny": []
  }
}
</file>

<file path=".vooster/project.json">
{
  "projectUid": "X179",
  "projectName": "ì—‘ì…€(Excel) íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ, ì‚¬ìš©ìê°€ ì„¤ì •í•œ ìˆœì„œëŒ€ë¡œ ì‘ì—…ì„ ìë™ ìˆ˜...",
  "description": "ì—‘ì…€(Excel) íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ, ì‚¬ìš©ìê°€ ì„¤ì •í•œ ìˆœì„œëŒ€ë¡œ ì‘ì—…ì„ ìë™ ìˆ˜í–‰í•˜ê³  ì™„ë£Œ ì—¬ë¶€ë¥¼ í‘œì‹œí•˜ëŠ” ë§¤í¬ë¡œ í”„ë¡œê·¸ë¨ì— ëŒ€í•œ ì œí’ˆ ìš”êµ¬ì‚¬í•­ì„ ê¸°ìˆ í•©ë‹ˆë‹¤. ì‚¬ìš©ìëŠ” ì§ê´€ì ì¸ ê·¸ë˜í”½ ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤(GUI)ë¥¼ í†µí•´ ìë™í™”í•  ì‘ì—…ì„ ë‹¨ê³„ë³„ë¡œ ì‰½ê²Œ ì…ë ¥í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ í”„ë¡œê·¸ë¨ì€ ë°˜ë³µì ì¸ ìˆ˜ì‘ì—…ì„ ìë™í™”í•˜ì—¬ ì—…ë¬´ íš¨ìœ¨ì„±ì„ ê·¹ëŒ€í™”í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.",
  "version": "1.0.0",
  "agent": "claude-code"
}
</file>

<file path="resources/locales/en.json">
{
  "app": {
    "name": "Excel Macro Automation",
    "description": "Excel-based task automation tool"
  },
  "menu": {
    "file": "File",
    "edit": "Edit",
    "view": "View",
    "help": "Help",
    "new_project": "New Project",
    "open_project": "Open Project",
    "save_project": "Save Project",
    "exit": "Exit",
    "settings": "Settings",
    "toggle_theme": "Toggle Theme",
    "about": "About"
  },
  "tabs": {
    "excel": "Excel",
    "editor": "Editor",
    "run": "Run"
  },
  "status": {
    "ready": "Ready",
    "running": "Running",
    "paused": "Paused",
    "stopped": "Stopped",
    "error": "Error"
  },
  "dialog": {
    "confirm_exit": "Are you sure you want to exit?",
    "yes": "Yes",
    "no": "No",
    "ok": "OK",
    "cancel": "Cancel"
  }
}
</file>

<file path="resources/locales/ko.json">
{
  "app": {
    "name": "ì—‘ì…€ ë§¤í¬ë¡œ ìë™í™”",
    "description": "ì—‘ì…€ ê¸°ë°˜ ì‘ì—… ìë™í™” ë„êµ¬"
  },
  "menu": {
    "file": "íŒŒì¼",
    "edit": "í¸ì§‘",
    "view": "ë³´ê¸°",
    "help": "ë„ì›€ë§",
    "new_project": "ìƒˆ í”„ë¡œì íŠ¸",
    "open_project": "í”„ë¡œì íŠ¸ ì—´ê¸°",
    "save_project": "í”„ë¡œì íŠ¸ ì €ì¥",
    "exit": "ì¢…ë£Œ",
    "settings": "ì„¤ì •",
    "toggle_theme": "í…Œë§ˆ ì „í™˜",
    "about": "ì •ë³´"
  },
  "tabs": {
    "excel": "ì—‘ì…€",
    "editor": "í¸ì§‘ê¸°",
    "run": "ì‹¤í–‰"
  },
  "status": {
    "ready": "ì¤€ë¹„",
    "running": "ì‹¤í–‰ ì¤‘",
    "paused": "ì¼ì‹œì •ì§€",
    "stopped": "ì¤‘ì§€ë¨",
    "error": "ì˜¤ë¥˜"
  },
  "dialog": {
    "confirm_exit": "ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
    "yes": "ì˜ˆ",
    "no": "ì•„ë‹ˆì˜¤",
    "ok": "í™•ì¸",
    "cancel": "ì·¨ì†Œ"
  }
}
</file>

<file path="src/automation/__init__.py">
# Automation module
</file>

<file path="src/automation/hotkey_listener.py">
"""
Global hotkey listener for execution control
"""

import threading
from typing import Optional, Dict, Callable
from PyQt5.QtCore import QObject, pyqtSignal
try:
    from pynput import keyboard
except ImportError:
    # Fallback for systems without pynput
    keyboard = None
from config.settings import Settings
from logger.app_logger import get_logger

class HotkeyListener(QObject):
    """Listens for global hotkeys"""
    
    # Signals
    pausePressed = pyqtSignal()
    stopPressed = pyqtSignal()
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        self._listener: Optional[keyboard.Listener] = None
        self._running = False
        
        # Get hotkey settings
        self.pause_key = self._parse_key(settings.get("hotkeys.pause", "F9"))
        self.stop_key = self._parse_key(settings.get("hotkeys.stop", "Escape"))
        
        # Current key states
        self._pressed_keys = set()
        
    def _parse_key(self, key_string: str):
        """Parse key string to pynput key"""
        if not keyboard:
            return None
            
        # Map common key names
        key_map = {
            "F1": keyboard.Key.f1,
            "F2": keyboard.Key.f2,
            "F3": keyboard.Key.f3,
            "F4": keyboard.Key.f4,
            "F5": keyboard.Key.f5,
            "F6": keyboard.Key.f6,
            "F7": keyboard.Key.f7,
            "F8": keyboard.Key.f8,
            "F9": keyboard.Key.f9,
            "F10": keyboard.Key.f10,
            "F11": keyboard.Key.f11,
            "F12": keyboard.Key.f12,
            "Escape": keyboard.Key.esc,
            "Space": keyboard.Key.space,
            "Enter": keyboard.Key.enter,
            "Tab": keyboard.Key.tab,
            "Backspace": keyboard.Key.backspace,
            "Delete": keyboard.Key.delete,
            "Home": keyboard.Key.home,
            "End": keyboard.Key.end,
            "PageUp": keyboard.Key.page_up,
            "PageDown": keyboard.Key.page_down,
            "Left": keyboard.Key.left,
            "Right": keyboard.Key.right,
            "Up": keyboard.Key.up,
            "Down": keyboard.Key.down,
        }
        
        return key_map.get(key_string, key_string.lower())
        
    def start(self):
        """Start listening for hotkeys"""
        if not keyboard:
            self.logger.warning("pynput not available, hotkeys disabled")
            return
            
        if self._running:
            return
            
        self._running = True
        
        try:
            self._listener = keyboard.Listener(
                on_press=self._on_press,
                on_release=self._on_release
            )
            self._listener.start()
            self.logger.info(f"Hotkey listener started (Pause: {self.pause_key}, Stop: {self.stop_key})")
        except Exception as e:
            self.logger.error(f"Failed to start hotkey listener: {e}")
            
    def stop(self):
        """Stop listening for hotkeys"""
        if not self._running:
            return
            
        self._running = False
        
        if self._listener:
            self._listener.stop()
            self._listener = None
            
        self.logger.info("Hotkey listener stopped")
        
    def _on_press(self, key):
        """Handle key press"""
        try:
            # Add to pressed keys
            self._pressed_keys.add(key)
            
            # Check for pause hotkey
            if self._check_key(key, self.pause_key):
                self.logger.debug("Pause hotkey pressed")
                self.pausePressed.emit()
                
            # Check for stop hotkey
            elif self._check_key(key, self.stop_key):
                self.logger.debug("Stop hotkey pressed")
                self.stopPressed.emit()
                
        except Exception as e:
            self.logger.error(f"Error in key press handler: {e}")
            
    def _on_release(self, key):
        """Handle key release"""
        try:
            # Remove from pressed keys
            self._pressed_keys.discard(key)
        except Exception as e:
            self.logger.error(f"Error in key release handler: {e}")
            
    def _check_key(self, key, target_key) -> bool:
        """Check if pressed key matches target"""
        if not target_key:
            return False
            
        # Direct key comparison
        if key == target_key:
            return True
            
        # String comparison for character keys
        try:
            if hasattr(key, 'char') and key.char == target_key:
                return True
        except:
            pass
            
        return False

class SimpleHotkeyListener(QObject):
    """Simple hotkey listener using QShortcut (fallback)"""
    
    pausePressed = pyqtSignal()
    stopPressed = pyqtSignal()
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
    def start(self):
        """Start listening (no-op for simple listener)"""
        self.logger.info("Using simple hotkey listener (widget must have focus)")
        
    def stop(self):
        """Stop listening (no-op for simple listener)"""
        pass
</file>

<file path="src/excel/models.py">
"""
Excel data models and types
"""

from dataclasses import dataclass
from typing import List, Dict, Any, Optional
from enum import Enum
import pandas as pd

class ColumnType(Enum):
    """Excel column data types"""
    TEXT = "text"
    NUMBER = "number"
    DATE = "date"
    BOOLEAN = "boolean"
    MIXED = "mixed"
    EMPTY = "empty"

@dataclass
class ColumnInfo:
    """Information about an Excel column"""
    name: str
    index: int
    data_type: ColumnType
    sample_values: List[Any]
    null_count: int
    unique_count: int

@dataclass
class SheetInfo:
    """Information about an Excel sheet"""
    name: str
    row_count: int
    column_count: int
    columns: List[ColumnInfo]

@dataclass
class ExcelFileInfo:
    """Information about an Excel file"""
    file_path: str
    file_size: int
    sheet_count: int
    sheets: List[SheetInfo]
    
@dataclass
class ColumnMapping:
    """Maps Excel columns to macro variables"""
    excel_column: str
    variable_name: str
    data_type: ColumnType
    is_required: bool = True
    default_value: Any = None

class ExcelData:
    """Container for Excel data with metadata"""
    
    def __init__(self, dataframe: pd.DataFrame, sheet_name: str, file_path: str):
        self.dataframe = dataframe
        self.sheet_name = sheet_name
        self.file_path = file_path
        self._status_column = None
        
    @property
    def row_count(self) -> int:
        return len(self.dataframe)
    
    @property
    def column_count(self) -> int:
        return len(self.dataframe.columns)
    
    @property
    def columns(self) -> List[str]:
        return self.dataframe.columns.tolist()
    
    def get_status_column(self) -> Optional[str]:
        """Get the status column name"""
        return self._status_column
    
    def set_status_column(self, column_name: str):
        """Set the status column"""
        if column_name not in self.columns:
            self.dataframe[column_name] = ""
        self._status_column = column_name
    
    def update_row_status(self, row_index: int, status: str):
        """Update status for a specific row"""
        if self._status_column:
            self.dataframe.at[row_index, self._status_column] = status
    
    def get_incomplete_rows(self) -> pd.DataFrame:
        """Get rows that haven't been completed"""
        if not self._status_column:
            return self.dataframe
        
        return self.dataframe[
            (self.dataframe[self._status_column] != "ì™„ë£Œ") & 
            (self.dataframe[self._status_column] != "Completed")
        ]
    
    def get_row_data(self, row_index: int) -> Dict[str, Any]:
        """Get data for a specific row as dictionary"""
        return self.dataframe.iloc[row_index].to_dict()
</file>

<file path="src/logger/app_logger.py">
"""
Application logging configuration
"""

import logging
import sys
from pathlib import Path
from datetime import datetime
from logging.handlers import RotatingFileHandler
from typing import Optional

def setup_logger(log_dir: Optional[Path] = None, level: int = logging.INFO) -> logging.Logger:
    """Setup application logger with file and console handlers"""
    # Create logs directory
    if log_dir is None:
        log_dir = Path.home() / ".excel_macro_automation" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    
    # Create logger
    logger = logging.getLogger("excel_macro")
    logger.setLevel(level)
    
    # Clear existing handlers
    logger.handlers.clear()
    
    # Create formatters
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_formatter = logging.Formatter(
        '%(levelname)s: %(message)s'
    )
    
    # File handler with rotation
    log_file = log_dir / f"app_{datetime.now().strftime('%Y%m%d')}.log"
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=10 * 1024 * 1024,  # 10MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)
    
    return logger

def get_logger(name: str) -> logging.Logger:
    """Get a logger instance for a specific module"""
    return logging.getLogger(f"excel_macro.{name}")
</file>

<file path="src/logger/execution_logger.py">
"""
CSV execution logger for macro runs
"""

import csv
import os
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any
import threading
from queue import Queue
import atexit

class ExecutionLogger:
    """Logs macro execution details to CSV files"""
    
    def __init__(self, log_dir: Optional[Path] = None):
        """Initialize execution logger
        
        Args:
            log_dir: Directory to save log files. Defaults to user logs directory.
        """
        # Set log directory
        if log_dir is None:
            self.log_dir = Path.home() / ".excel_macro_automation" / "execution_logs"
        else:
            self.log_dir = Path(log_dir)
            
        # Create directory if not exists
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Current log file
        self.current_file: Optional[Path] = None
        self.csv_writer: Optional[csv.DictWriter] = None
        self.file_handle = None
        
        # Buffering for performance
        self.write_queue = Queue()
        self.writer_thread = None
        self.running = False
        
        # Register cleanup on exit
        atexit.register(self.close)
        
    def start_session(self, macro_name: str, excel_file: str) -> Path:
        """Start a new logging session
        
        Args:
            macro_name: Name of the macro being executed
            excel_file: Path to the Excel file being processed
            
        Returns:
            Path to the created log file
        """
        # Close previous session if any
        self.close()
        
        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_macro_name = "".join(c for c in macro_name if c.isalnum() or c in "._- ")[:50]
        filename = f"execution_{safe_macro_name}_{timestamp}.csv"
        self.current_file = self.log_dir / filename
        
        # Open file and create CSV writer
        self.file_handle = open(self.current_file, 'w', newline='', encoding='utf-8')
        
        # Define CSV fields
        self.fieldnames = [
            'timestamp',
            'elapsed_ms',
            'row_index',
            'row_data',
            'step_index',
            'step_name',
            'step_type',
            'status',
            'error_message',
            'duration_ms',
            'details'
        ]
        
        self.csv_writer = csv.DictWriter(self.file_handle, fieldnames=self.fieldnames)
        self.csv_writer.writeheader()
        
        # Write session info
        self.csv_writer.writerow({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': 0,
            'row_index': -1,
            'row_data': f"Session Start - Macro: {macro_name}",
            'step_index': -1,
            'step_name': "SESSION_START",
            'step_type': "INFO",
            'status': "INFO",
            'error_message': "",
            'duration_ms': 0,
            'details': f"Excel: {excel_file}"
        })
        
        # Start writer thread
        self.running = True
        self.writer_thread = threading.Thread(target=self._writer_loop, daemon=True)
        self.writer_thread.start()
        
        self.session_start_time = datetime.now()
        
        return self.current_file
        
    def log_row_start(self, row_index: int, row_data: Dict[str, Any]):
        """Log the start of processing a row"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': str(row_data),
            'step_index': -1,
            'step_name': "ROW_START",
            'step_type': "INFO",
            'status': "START",
            'error_message': "",
            'duration_ms': 0,
            'details': f"Processing row {row_index + 1}"
        })
        
    def log_step_execution(self, row_index: int, step_index: int, step_name: str, 
                          step_type: str, success: bool, duration_ms: float,
                          error_message: str = "", details: str = ""):
        """Log execution of a single step"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': "",
            'step_index': step_index,
            'step_name': step_name,
            'step_type': step_type,
            'status': "SUCCESS" if success else "FAILED",
            'error_message': error_message,
            'duration_ms': round(duration_ms, 2),
            'details': details
        })
        
    def log_row_complete(self, row_index: int, success: bool, total_duration_ms: float,
                        error_message: str = ""):
        """Log completion of a row"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': row_index,
            'row_data': "",
            'step_index': -1,
            'step_name': "ROW_COMPLETE",
            'step_type': "INFO",
            'status': "SUCCESS" if success else "FAILED",
            'error_message': error_message,
            'duration_ms': round(total_duration_ms, 2),
            'details': f"Row {row_index + 1} completed"
        })
        
    def log_session_end(self, total_rows: int, successful_rows: int, failed_rows: int):
        """Log end of session with summary"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': -1,
            'row_data': f"Session End - Total: {total_rows}, Success: {successful_rows}, Failed: {failed_rows}",
            'step_index': -1,
            'step_name': "SESSION_END",
            'step_type': "INFO",
            'status': "INFO",
            'error_message': "",
            'duration_ms': self._get_elapsed_ms(),
            'details': f"Success rate: {(successful_rows/total_rows*100) if total_rows > 0 else 0:.1f}%"
        })
        
    def log_error(self, error_type: str, error_message: str, details: str = ""):
        """Log a general error"""
        self._enqueue_log({
            'timestamp': datetime.now().isoformat(),
            'elapsed_ms': self._get_elapsed_ms(),
            'row_index': -1,
            'row_data': "",
            'step_index': -1,
            'step_name': error_type,
            'step_type': "ERROR",
            'status': "ERROR",
            'error_message': error_message,
            'duration_ms': 0,
            'details': details
        })
        
    def flush(self):
        """Force flush any pending logs"""
        if self.file_handle:
            # Wait for queue to empty
            self.write_queue.join()
            self.file_handle.flush()
            
    def close(self):
        """Close the current logging session"""
        if self.running:
            # Signal thread to stop
            self.running = False
            self._enqueue_log(None)  # Sentinel value
            
            # Wait for thread to finish
            if self.writer_thread and self.writer_thread.is_alive():
                self.writer_thread.join(timeout=5.0)
                
        # Close file
        if self.file_handle:
            self.file_handle.close()
            self.file_handle = None
            self.csv_writer = None
            
    def get_current_log_file(self) -> Optional[Path]:
        """Get path to current log file"""
        return self.current_file
        
    def _enqueue_log(self, log_entry: Optional[Dict[str, Any]]):
        """Add log entry to write queue"""
        self.write_queue.put(log_entry)
        
    def _writer_loop(self):
        """Background thread for writing logs"""
        while self.running:
            try:
                # Get log entry from queue
                log_entry = self.write_queue.get(timeout=0.1)
                
                # Check for sentinel
                if log_entry is None:
                    break
                    
                # Write to CSV
                if self.csv_writer:
                    self.csv_writer.writerow(log_entry)
                    
                # Mark task done
                self.write_queue.task_done()
                
            except:
                # Timeout or error, continue
                pass
                
    def _get_elapsed_ms(self) -> float:
        """Get elapsed time since session start"""
        if hasattr(self, 'session_start_time'):
            elapsed = datetime.now() - self.session_start_time
            return elapsed.total_seconds() * 1000
        return 0

# Global instance
_execution_logger = None

def get_execution_logger() -> ExecutionLogger:
    """Get the global execution logger instance"""
    global _execution_logger
    if _execution_logger is None:
        _execution_logger = ExecutionLogger()
    return _execution_logger
</file>

<file path="src/ui/dialogs/__init__.py">
# UI dialogs module
</file>

<file path="src/ui/dialogs/error_report_dialog.py">
"""
Error reporting dialog with detailed information and solutions
"""

import traceback
import os
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTextEdit,
    QPushButton, QLabel, QGroupBox, QTabWidget,
    QWidget, QCheckBox, QMessageBox
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont, QIcon
import pyautogui

class ErrorReportDialog(QDialog):
    """Dialog for displaying detailed error information"""
    
    # Error solutions database
    ERROR_SOLUTIONS = {
        "Image not found": {
            "ì›ì¸": [
                "í™”ë©´ í•´ìƒë„ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ëŒ€ìƒ í”„ë¡œê·¸ë¨ì˜ UIê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ì´ë¯¸ì§€ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤",
                "í™”ë©´ ë°°ìœ¨(DPI) ì„¤ì •ì´ ë‹¤ë¦…ë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ìº¡ì²˜í•˜ì„¸ìš”",
                "í™”ë©´ í•´ìƒë„ë¥¼ ì›ë˜ëŒ€ë¡œ ë³µì›í•˜ì„¸ìš”",
                "Windows ë””ìŠ¤í”Œë ˆì´ ì„¤ì •ì—ì„œ ë°°ìœ¨ì„ 100%ë¡œ ì„¤ì •í•˜ì„¸ìš”",
                "ëŒ€ìƒ í”„ë¡œê·¸ë¨ì„ ìµœëŒ€í™”í•˜ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”"
            ]
        },
        "Text not found": {
            "ì›ì¸": [
                "í…ìŠ¤íŠ¸ê°€ í™”ë©´ì— í‘œì‹œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤",
                "OCR ì¸ì‹ ì‹¤íŒ¨",
                "í°íŠ¸ë‚˜ í…ìŠ¤íŠ¸ í¬ê¸°ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ê²€ìƒ‰ ì˜ì—­ì´ ì˜ëª» ì§€ì •ë˜ì—ˆìŠµë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ê°€ í™”ë©´ì— í‘œì‹œë˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”",
                "ê²€ìƒ‰ ì˜ì—­ì„ ë‹¤ì‹œ ì§€ì •í•˜ì„¸ìš”",
                "ì •í™•í•œ í…ìŠ¤íŠ¸ ëŒ€ì‹  ë¶€ë¶„ ì¼ì¹˜ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”",
                "ëŒ€ê¸° ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”"
            ]
        },
        "Permission denied": {
            "ì›ì¸": [
                "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤",
                "íŒŒì¼ì´ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤",
                "í´ë”ì— ì“°ê¸° ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "í”„ë¡œê·¸ë¨ì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰í•˜ì„¸ìš”",
                "ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ íŒŒì¼ì„ ë‹«ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”",
                "ë‹¤ë¥¸ ìœ„ì¹˜ì— ì €ì¥í•´ë³´ì„¸ìš”"
            ]
        },
        "Excel": {
            "ì›ì¸": [
                "Excel íŒŒì¼ì´ ì—´ë ¤ìˆìŠµë‹ˆë‹¤",
                "ì‹œíŠ¸ ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤",
                "ì—´ ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤"
            ],
            "í•´ê²° ë°©ë²•": [
                "Excel íŒŒì¼ì„ ë‹«ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”",
                "ì‹œíŠ¸ ë§¤í•‘ì„ ë‹¤ì‹œ ì„¤ì •í•˜ì„¸ìš”",
                "ì—´ ë§¤í•‘ì„ í™•ì¸í•˜ì„¸ìš”"
            ]
        }
    }
    
    def __init__(self, error_type: str, error_message: str, 
                 error_details: Optional[str] = None,
                 log_file: Optional[Path] = None,
                 parent=None):
        super().__init__(parent)
        self.error_type = error_type
        self.error_message = error_message
        self.error_details = error_details or traceback.format_exc()
        self.log_file = log_file
        self.screenshot_path = None
        
        self.init_ui()
        self.load_error_info()
        
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("ì˜¤ë¥˜ ë³´ê³ ì„œ")
        self.setModal(True)
        self.resize(700, 500)
        
        layout = QVBoxLayout()
        
        # Error summary
        error_group = QGroupBox("ì˜¤ë¥˜ ìš”ì•½")
        error_layout = QVBoxLayout()
        
        # Error icon and message
        message_layout = QHBoxLayout()
        
        # Error type label with red color
        type_label = QLabel(f"âŒ {self.error_type}")
        type_label.setStyleSheet("color: red; font-size: 14px; font-weight: bold;")
        error_layout.addWidget(type_label)
        
        # Error message
        message_label = QLabel(self.error_message)
        message_label.setWordWrap(True)
        message_label.setStyleSheet("font-size: 12px; margin: 10px 0;")
        error_layout.addWidget(message_label)
        
        error_group.setLayout(error_layout)
        layout.addWidget(error_group)
        
        # Tab widget for details
        self.tabs = QTabWidget()
        
        # Solutions tab
        self.solutions_widget = self.create_solutions_tab()
        self.tabs.addTab(self.solutions_widget, "í•´ê²° ë°©ë²•")
        
        # Details tab
        self.details_widget = self.create_details_tab()
        self.tabs.addTab(self.details_widget, "ìƒì„¸ ì •ë³´")
        
        # Log tab
        if self.log_file:
            self.log_widget = self.create_log_tab()
            self.tabs.addTab(self.log_widget, "ì‹¤í–‰ ë¡œê·¸")
            
        layout.addWidget(self.tabs)
        
        # Actions
        action_layout = QHBoxLayout()
        
        # Screenshot checkbox
        self.screenshot_check = QCheckBox("ì˜¤ë¥˜ í™”ë©´ ìº¡ì²˜ í¬í•¨")
        self.screenshot_check.setChecked(True)
        action_layout.addWidget(self.screenshot_check)
        
        action_layout.addStretch()
        
        # Copy button
        copy_btn = QPushButton("ì˜¤ë¥˜ ì •ë³´ ë³µì‚¬")
        copy_btn.clicked.connect(self.copy_error_info)
        action_layout.addWidget(copy_btn)
        
        # Save button
        save_btn = QPushButton("ë³´ê³ ì„œ ì €ì¥")
        save_btn.clicked.connect(self.save_report)
        action_layout.addWidget(save_btn)
        
        layout.addLayout(action_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        # Open log folder button
        if self.log_file:
            log_folder_btn = QPushButton("ë¡œê·¸ í´ë” ì—´ê¸°")
            log_folder_btn.clicked.connect(self.open_log_folder)
            button_layout.addWidget(log_folder_btn)
        
        # OK button
        ok_btn = QPushButton("í™•ì¸")
        ok_btn.setDefault(True)
        ok_btn.clicked.connect(self.accept)
        button_layout.addWidget(ok_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def create_solutions_tab(self) -> QWidget:
        """Create solutions tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Find matching error type
        matching_solution = None
        for key, solution in self.ERROR_SOLUTIONS.items():
            if key.lower() in self.error_message.lower():
                matching_solution = solution
                break
                
        if matching_solution:
            # Possible causes
            causes_group = QGroupBox("ê°€ëŠ¥í•œ ì›ì¸")
            causes_layout = QVBoxLayout()
            
            for cause in matching_solution["ì›ì¸"]:
                cause_label = QLabel(f"â€¢ {cause}")
                cause_label.setWordWrap(True)
                causes_layout.addWidget(cause_label)
                
            causes_group.setLayout(causes_layout)
            layout.addWidget(causes_group)
            
            # Solutions
            solutions_group = QGroupBox("í•´ê²° ë°©ë²•")
            solutions_layout = QVBoxLayout()
            
            for i, solution in enumerate(matching_solution["í•´ê²° ë°©ë²•"], 1):
                solution_label = QLabel(f"{i}. {solution}")
                solution_label.setWordWrap(True)
                solution_label.setStyleSheet("margin: 5px 0;")
                solutions_layout.addWidget(solution_label)
                
            solutions_group.setLayout(solutions_layout)
            layout.addWidget(solutions_group)
        else:
            # Generic solutions
            generic_label = QLabel(
                "ì¼ë°˜ì ì¸ í•´ê²° ë°©ë²•:\n\n"
                "1. í”„ë¡œê·¸ë¨ì„ ë‹¤ì‹œ ì‹œì‘í•´ë³´ì„¸ìš”\n"
                "2. ëŒ€ìƒ í”„ë¡œê·¸ë¨ì´ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”\n"
                "3. í™”ë©´ í•´ìƒë„ë‚˜ ë°°ìœ¨ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”\n"
                "4. ë§¤í¬ë¡œ ë‹¨ê³„ë¥¼ ë‹¤ì‹œ ì„¤ì •í•´ë³´ì„¸ìš”\n"
                "5. ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ë¡œê·¸ íŒŒì¼ê³¼ í•¨ê»˜ ë¬¸ì˜í•˜ì„¸ìš”"
            )
            generic_label.setWordWrap(True)
            layout.addWidget(generic_label)
            
        layout.addStretch()
        widget.setLayout(layout)
        return widget
        
    def create_details_tab(self) -> QWidget:
        """Create error details tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Error details text
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        self.details_text.setFont(QFont("Consolas", 9))
        self.details_text.setPlainText(self.error_details)
        
        layout.addWidget(self.details_text)
        widget.setLayout(layout)
        return widget
        
    def create_log_tab(self) -> QWidget:
        """Create log file tab"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Log file path
        path_label = QLabel(f"ë¡œê·¸ íŒŒì¼: {self.log_file}")
        path_label.setWordWrap(True)
        layout.addWidget(path_label)
        
        # Log preview (last 50 lines)
        log_text = QTextEdit()
        log_text.setReadOnly(True)
        log_text.setFont(QFont("Consolas", 9))
        
        try:
            with open(self.log_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                # Show last 50 lines
                last_lines = lines[-50:] if len(lines) > 50 else lines
                log_text.setPlainText(''.join(last_lines))
        except Exception as e:
            log_text.setPlainText(f"ë¡œê·¸ íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
            
        layout.addWidget(log_text)
        widget.setLayout(layout)
        return widget
        
    def load_error_info(self):
        """Load additional error information"""
        # Could load more context here
        pass
        
    def copy_error_info(self):
        """Copy error information to clipboard"""
        from PyQt5.QtWidgets import QApplication
        
        info = f"""ì˜¤ë¥˜ íƒ€ì…: {self.error_type}
ì˜¤ë¥˜ ë©”ì‹œì§€: {self.error_message}
ë°œìƒ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

ìƒì„¸ ì •ë³´:
{self.error_details}
"""
        
        if self.log_file:
            info += f"\në¡œê·¸ íŒŒì¼: {self.log_file}"
            
        QApplication.clipboard().setText(info)
        QMessageBox.information(self, "ë³µì‚¬ ì™„ë£Œ", "ì˜¤ë¥˜ ì •ë³´ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.")
        
    def save_report(self):
        """Save error report to file"""
        from PyQt5.QtWidgets import QFileDialog
        
        # Take screenshot if requested
        if self.screenshot_check.isChecked():
            self.capture_screenshot()
            
        # Get save location
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_name = f"error_report_{timestamp}.txt"
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "ì˜¤ë¥˜ ë³´ê³ ì„œ ì €ì¥",
            default_name,
            "Text Files (*.txt);;All Files (*.*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(f"ì˜¤ë¥˜ ë³´ê³ ì„œ\n")
                    f.write(f"=" * 50 + "\n\n")
                    f.write(f"ë°œìƒ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"ì˜¤ë¥˜ íƒ€ì…: {self.error_type}\n")
                    f.write(f"ì˜¤ë¥˜ ë©”ì‹œì§€: {self.error_message}\n\n")
                    
                    # Add solutions if available
                    for key, solution in self.ERROR_SOLUTIONS.items():
                        if key.lower() in self.error_message.lower():
                            f.write("\nê°€ëŠ¥í•œ ì›ì¸:\n")
                            for cause in solution["ì›ì¸"]:
                                f.write(f"  â€¢ {cause}\n")
                            f.write("\ní•´ê²° ë°©ë²•:\n")
                            for i, sol in enumerate(solution["í•´ê²° ë°©ë²•"], 1):
                                f.write(f"  {i}. {sol}\n")
                            break
                            
                    f.write(f"\nìƒì„¸ ì •ë³´:\n")
                    f.write(f"{self.error_details}\n")
                    
                    if self.log_file:
                        f.write(f"\në¡œê·¸ íŒŒì¼: {self.log_file}\n")
                        
                    if self.screenshot_path:
                        f.write(f"\nìŠ¤í¬ë¦°ìƒ·: {self.screenshot_path}\n")
                        
                QMessageBox.information(self, "ì €ì¥ ì™„ë£Œ", f"ì˜¤ë¥˜ ë³´ê³ ì„œê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:\n{file_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "ì €ì¥ ì‹¤íŒ¨", f"ë³´ê³ ì„œ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
                
    def capture_screenshot(self):
        """Capture screenshot of current screen"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            screenshot_dir = Path.home() / ".excel_macro_automation" / "error_screenshots"
            screenshot_dir.mkdir(parents=True, exist_ok=True)
            
            self.screenshot_path = screenshot_dir / f"error_{timestamp}.png"
            pyautogui.screenshot(str(self.screenshot_path))
            
        except Exception as e:
            self.screenshot_path = None
            
    def open_log_folder(self):
        """Open log folder in file explorer"""
        if self.log_file:
            log_dir = os.path.dirname(self.log_file)
            os.startfile(log_dir)  # Windows only
            
    @staticmethod
    def show_error(error_type: str, error_message: str, 
                   error_details: Optional[str] = None,
                   log_file: Optional[Path] = None,
                   parent=None):
        """Static method to show error dialog"""
        dialog = ErrorReportDialog(error_type, error_message, error_details, log_file, parent)
        dialog.exec_()
        return dialog
</file>

<file path="src/ui/dialogs/if_condition_step_dialog.py">
"""
If condition step configuration dialog
"""

from typing import Optional, Dict, Any, List
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox,
    QPushButton, QLabel, QGroupBox, QListWidget,
    QListWidgetItem, QTextEdit, QWidget, QSplitter,
    QMessageBox, QCompleter, QCheckBox, QFileDialog
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QIcon
from core.macro_types import IfConditionStep, MacroStep, StepFactory, StepType
from ui.widgets.roi_selector import ROISelectorWidget

class ConditionTypeWidget(QWidget):
    """Widget for configuring condition parameters based on type"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)
        
    def set_condition_type(self, condition_type: str, excel_columns: List[str] = None):
        """Update UI based on condition type"""
        # Clear existing widgets
        while self.layout.count():
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
                
        if condition_type == "image_exists":
            self._setup_image_condition()
        elif condition_type == "text_exists":
            self._setup_text_condition()
        elif condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            self._setup_variable_condition(excel_columns)
            
    def _setup_image_condition(self):
        """Setup UI for image exists condition"""
        form_layout = QFormLayout()
        
        # Image path
        self.image_path_edit = QLineEdit()
        self.image_browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°...")
        self.image_browse_btn.clicked.connect(self._browse_image)
        image_layout = QHBoxLayout()
        image_layout.addWidget(self.image_path_edit)
        image_layout.addWidget(self.image_browse_btn)
        form_layout.addRow("ì´ë¯¸ì§€ íŒŒì¼:", image_layout)
        
        # Confidence
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setRange(0.1, 1.0)
        self.confidence_spin.setSingleStep(0.1)
        self.confidence_spin.setValue(0.9)
        form_layout.addRow("ì •í™•ë„:", self.confidence_spin)
        
        # Region selector
        self.region_selector = ROISelectorWidget()
        form_layout.addRow("ê²€ìƒ‰ ì˜ì—­:", self.region_selector)
        
        self.layout.addLayout(form_layout)
        
    def _browse_image(self):
        """Browse for image file"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ",
            "",
            "Image Files (*.png *.jpg *.jpeg *.bmp *.gif);;All Files (*.*)"
        )
        if filename:
            self.image_path_edit.setText(filename)
        
    def _setup_text_condition(self):
        """Setup UI for text exists condition"""
        form_layout = QFormLayout()
        
        # Search text
        self.text_edit = QLineEdit()
        self.text_edit.setPlaceholderText("ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ ë˜ëŠ” {{ë³€ìˆ˜}}")
        form_layout.addRow("í…ìŠ¤íŠ¸:", self.text_edit)
        
        # Exact match
        self.exact_match_check = QCheckBox("ì •í™•íˆ ì¼ì¹˜")
        form_layout.addRow("", self.exact_match_check)
        
        # Region selector
        self.region_selector = ROISelectorWidget()
        form_layout.addRow("ê²€ìƒ‰ ì˜ì—­:", self.region_selector)
        
        self.layout.addLayout(form_layout)
        
    def _setup_variable_condition(self, excel_columns: List[str] = None):
        """Setup UI for variable comparison condition"""
        form_layout = QFormLayout()
        
        # Variable name
        self.variable_combo = QComboBox()
        self.variable_combo.setEditable(True)
        if excel_columns:
            self.variable_combo.addItems(excel_columns)
        form_layout.addRow("ë³€ìˆ˜:", self.variable_combo)
        
        # Comparison value
        self.compare_value_edit = QLineEdit()
        self.compare_value_edit.setPlaceholderText("ë¹„êµí•  ê°’ ë˜ëŠ” {{ë³€ìˆ˜}}")
        form_layout.addRow("ë¹„êµê°’:", self.compare_value_edit)
        
        self.layout.addLayout(form_layout)
        
    def get_condition_value(self) -> Dict[str, Any]:
        """Get condition parameters"""
        value = {}
        
        # Image exists
        if hasattr(self, 'image_path_edit'):
            value['image_path'] = self.image_path_edit.text()
            value['confidence'] = self.confidence_spin.value()
            value['region'] = self.region_selector.get_region()
            
        # Text exists
        elif hasattr(self, 'text_edit'):
            value['text'] = self.text_edit.text()
            value['exact_match'] = self.exact_match_check.isChecked()
            value['region'] = self.region_selector.get_region()
            
        # Variable comparison
        elif hasattr(self, 'variable_combo'):
            value['variable'] = self.variable_combo.currentText()
            value['compare_value'] = self.compare_value_edit.text()
            
        return value
        
    def set_condition_value(self, value: Dict[str, Any]):
        """Set condition parameters"""
        # Image exists
        if hasattr(self, 'image_path_edit') and 'image_path' in value:
            self.image_path_edit.setText(value.get('image_path', ''))
            self.confidence_spin.setValue(value.get('confidence', 0.9))
            if value.get('region'):
                self.region_selector.set_region(value['region'])
                
        # Text exists
        elif hasattr(self, 'text_edit') and 'text' in value:
            self.text_edit.setText(value.get('text', ''))
            self.exact_match_check.setChecked(value.get('exact_match', False))
            if value.get('region'):
                self.region_selector.set_region(value['region'])
                
        # Variable comparison
        elif hasattr(self, 'variable_combo') and 'variable' in value:
            self.variable_combo.setCurrentText(value.get('variable', ''))
            self.compare_value_edit.setText(value.get('compare_value', ''))

class StepListWidget(QListWidget):
    """Widget for displaying and managing nested steps"""
    
    stepAdded = pyqtSignal(MacroStep)
    stepRemoved = pyqtSignal(str)  # step_id
    stepEdited = pyqtSignal(MacroStep)
    
    def __init__(self):
        super().__init__()
        self.steps: List[MacroStep] = []
        self.setAcceptDrops(True)
        
    def add_step(self, step_type: StepType):
        """Add a new step of given type"""
        step = StepFactory.create_step(step_type)
        
        # Set default name
        step_names = {
            StepType.MOUSE_CLICK: "ë§ˆìš°ìŠ¤ í´ë¦­",
            StepType.KEYBOARD_TYPE: "í…ìŠ¤íŠ¸ ì…ë ¥",
            StepType.WAIT_TIME: "ëŒ€ê¸°",
            StepType.IMAGE_SEARCH: "ì´ë¯¸ì§€ ê²€ìƒ‰",
            StepType.OCR_TEXT: "í…ìŠ¤íŠ¸ ê²€ìƒ‰"
        }
        step.name = step_names.get(step_type, step_type.value)
        
        self.steps.append(step)
        self._refresh_list()
        self.stepAdded.emit(step)
        
    def remove_selected(self):
        """Remove selected step"""
        current_row = self.currentRow()
        if 0 <= current_row < len(self.steps):
            removed_step = self.steps.pop(current_row)
            self._refresh_list()
            self.stepRemoved.emit(removed_step.step_id)
            
    def get_steps(self) -> List[MacroStep]:
        """Get all steps"""
        return self.steps
        
    def set_steps(self, steps: List[MacroStep]):
        """Set steps"""
        self.steps = steps.copy()
        self._refresh_list()
        
    def _refresh_list(self):
        """Refresh list display"""
        self.clear()
        
        for step in self.steps:
            icon = self._get_step_icon(step.step_type)
            text = f"{icon} {step.name}"
            if hasattr(step, 'description') and step.description:
                text += f" - {step.description}"
                
            item = QListWidgetItem(text)
            self.addItem(item)
            
    def _get_step_icon(self, step_type: StepType) -> str:
        """Get icon for step type"""
        icons = {
            StepType.MOUSE_CLICK: "ğŸ–±ï¸",
            StepType.KEYBOARD_TYPE: "âŒ¨ï¸",
            StepType.WAIT_TIME: "â±ï¸",
            StepType.IMAGE_SEARCH: "ğŸ”",
            StepType.OCR_TEXT: "ğŸ”¤"
        }
        return icons.get(step_type, "")

class IfConditionStepDialog(QDialog):
    """Dialog for configuring if condition step"""
    
    def __init__(self, step: Optional[IfConditionStep] = None, 
                 excel_columns: List[str] = None, parent=None):
        super().__init__(parent)
        self.step = step or IfConditionStep()
        self.excel_columns = excel_columns or []
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("ì¡°ê±´ë¬¸ ì„¤ì •")
        self.setModal(True)
        self.resize(800, 600)
        
        layout = QVBoxLayout()
        
        # Basic info
        info_group = QGroupBox("ê¸°ë³¸ ì •ë³´")
        info_layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        self.name_edit.setText(self.step.name or "ì¡°ê±´ë¬¸")
        info_layout.addRow("ì´ë¦„:", self.name_edit)
        
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(60)
        self.description_edit.setText(self.step.description)
        info_layout.addRow("ì„¤ëª…:", self.description_edit)
        
        info_group.setLayout(info_layout)
        layout.addWidget(info_group)
        
        # Condition configuration
        condition_group = QGroupBox("ì¡°ê±´ ì„¤ì •")
        condition_layout = QVBoxLayout()
        
        # Condition type
        type_layout = QHBoxLayout()
        type_layout.addWidget(QLabel("ì¡°ê±´ ìœ í˜•:"))
        
        self.condition_type_combo = QComboBox()
        self.condition_type_combo.addItems([
            ("ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´", "image_exists"),
            ("í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´", "text_exists"),
            ("ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´", "variable_equals"),
            ("ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´", "variable_contains"),
            ("ë³€ìˆ˜ê°€ í¬ë©´", "variable_greater"),
            ("ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´", "variable_less")
        ])
        
        # Set display text
        for i in range(self.condition_type_combo.count()):
            self.condition_type_combo.setItemData(i, self.condition_type_combo.itemText(i).split(",")[1].strip(), Qt.UserRole)
            self.condition_type_combo.setItemText(i, self.condition_type_combo.itemText(i).split(",")[0])
            
        self.condition_type_combo.currentIndexChanged.connect(self._on_condition_type_changed)
        type_layout.addWidget(self.condition_type_combo)
        type_layout.addStretch()
        condition_layout.addLayout(type_layout)
        
        # Condition parameters
        self.condition_widget = ConditionTypeWidget()
        condition_layout.addWidget(self.condition_widget)
        
        condition_group.setLayout(condition_layout)
        layout.addWidget(condition_group)
        
        # Branch steps
        branches_group = QGroupBox("ë¶„ê¸° ë™ì‘")
        branches_layout = QVBoxLayout()
        
        # Create splitter for true/false branches
        splitter = QSplitter(Qt.Horizontal)
        
        # True branch
        true_widget = QWidget()
        true_layout = QVBoxLayout()
        true_layout.addWidget(QLabel("âœ… ì¡°ê±´ì´ ì°¸ì¼ ë•Œ:"))
        
        self.true_steps_list = StepListWidget()
        true_layout.addWidget(self.true_steps_list)
        
        # True branch buttons
        true_btn_layout = QHBoxLayout()
        
        add_true_menu = QPushButton("ë‹¨ê³„ ì¶”ê°€")
        add_true_menu.setMenu(self._create_step_menu(self.true_steps_list))
        true_btn_layout.addWidget(add_true_menu)
        
        remove_true_btn = QPushButton("ì‚­ì œ")
        remove_true_btn.clicked.connect(self.true_steps_list.remove_selected)
        true_btn_layout.addWidget(remove_true_btn)
        
        true_btn_layout.addStretch()
        true_layout.addLayout(true_btn_layout)
        
        true_widget.setLayout(true_layout)
        splitter.addWidget(true_widget)
        
        # False branch
        false_widget = QWidget()
        false_layout = QVBoxLayout()
        false_layout.addWidget(QLabel("âŒ ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œ:"))
        
        self.false_steps_list = StepListWidget()
        false_layout.addWidget(self.false_steps_list)
        
        # False branch buttons
        false_btn_layout = QHBoxLayout()
        
        add_false_menu = QPushButton("ë‹¨ê³„ ì¶”ê°€")
        add_false_menu.setMenu(self._create_step_menu(self.false_steps_list))
        false_btn_layout.addWidget(add_false_menu)
        
        remove_false_btn = QPushButton("ì‚­ì œ")
        remove_false_btn.clicked.connect(self.false_steps_list.remove_selected)
        false_btn_layout.addWidget(remove_false_btn)
        
        false_btn_layout.addStretch()
        false_layout.addLayout(false_btn_layout)
        
        false_widget.setLayout(false_layout)
        splitter.addWidget(false_widget)
        
        branches_layout.addWidget(splitter)
        branches_group.setLayout(branches_layout)
        layout.addWidget(branches_group)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        ok_btn = QPushButton("í™•ì¸")
        ok_btn.clicked.connect(self.accept)
        button_layout.addWidget(ok_btn)
        
        cancel_btn = QPushButton("ì·¨ì†Œ")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
        # Initialize condition type
        self._on_condition_type_changed()
        
    def _create_step_menu(self, step_list: StepListWidget):
        """Create menu for adding steps"""
        from PyQt5.QtWidgets import QMenu
        
        menu = QMenu()
        
        # Simple steps only (no nested conditions)
        simple_steps = [
            (StepType.MOUSE_CLICK, "ğŸ–±ï¸ ë§ˆìš°ìŠ¤ í´ë¦­"),
            (StepType.KEYBOARD_TYPE, "âŒ¨ï¸ í…ìŠ¤íŠ¸ ì…ë ¥"),
            (StepType.WAIT_TIME, "â±ï¸ ëŒ€ê¸°"),
            (StepType.IMAGE_SEARCH, "ğŸ” ì´ë¯¸ì§€ ê²€ìƒ‰"),
            (StepType.OCR_TEXT, "ğŸ”¤ í…ìŠ¤íŠ¸ ê²€ìƒ‰")
        ]
        
        for step_type, name in simple_steps:
            action = menu.addAction(name)
            action.triggered.connect(lambda checked, st=step_type: step_list.add_step(st))
            
        return menu
        
    def _on_condition_type_changed(self):
        """Handle condition type change"""
        # Get selected type value
        condition_type = self.condition_type_combo.currentData(Qt.UserRole)
        if not condition_type:
            condition_type = self.condition_type_combo.currentText()
            
        # Map display text to type value
        type_mapping = {
            "ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´": "image_exists",
            "í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´": "text_exists",
            "ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´": "variable_equals",
            "ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´": "variable_contains",
            "ë³€ìˆ˜ê°€ í¬ë©´": "variable_greater",
            "ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´": "variable_less"
        }
        
        if condition_type in type_mapping:
            condition_type = type_mapping[condition_type]
            
        self.condition_widget.set_condition_type(condition_type, self.excel_columns)
        
    def load_step_data(self):
        """Load data from step"""
        if not self.step:
            return
            
        self.name_edit.setText(self.step.name)
        self.description_edit.setText(self.step.description)
        
        # Set condition type
        type_index = {
            "image_exists": 0,
            "text_exists": 1,
            "variable_equals": 2,
            "variable_contains": 3,
            "variable_greater": 4,
            "variable_less": 5
        }.get(self.step.condition_type, 0)
        
        self.condition_type_combo.setCurrentIndex(type_index)
        self.condition_widget.set_condition_value(self.step.condition_value)
        
        # Set branch steps
        self.true_steps_list.set_steps(self.step.true_steps)
        self.false_steps_list.set_steps(self.step.false_steps)
        
    def get_step_data(self) -> Dict[str, Any]:
        """Get configured step data"""
        # Get condition type
        condition_type = self.condition_type_combo.currentData(Qt.UserRole)
        if not condition_type:
            type_mapping = {
                "ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´": "image_exists",
                "í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´": "text_exists",
                "ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´": "variable_equals",
                "ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´": "variable_contains",
                "ë³€ìˆ˜ê°€ í¬ë©´": "variable_greater",
                "ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´": "variable_less"
            }
            condition_type = type_mapping.get(self.condition_type_combo.currentText(), "image_exists")
            
        return {
            'name': self.name_edit.text(),
            'description': self.description_edit.toPlainText(),
            'condition_type': condition_type,
            'condition_value': self.condition_widget.get_condition_value(),
            'true_steps': self.true_steps_list.get_steps(),
            'false_steps': self.false_steps_list.get_steps()
        }
        
    def accept(self):
        """Validate and accept"""
        # Basic validation
        if not self.name_edit.text():
            QMessageBox.warning(self, "ê²½ê³ ", "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
            return
            
        # Validate condition parameters
        condition_value = self.condition_widget.get_condition_value()
        condition_type = self.get_step_data()['condition_type']
        
        if condition_type == "image_exists" and not condition_value.get('image_path'):
            QMessageBox.warning(self, "ê²½ê³ ", "ì´ë¯¸ì§€ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return
            
        elif condition_type == "text_exists" and not condition_value.get('text'):
            QMessageBox.warning(self, "ê²½ê³ ", "ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
            return
            
        elif condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            if not condition_value.get('variable'):
                QMessageBox.warning(self, "ê²½ê³ ", "ë³€ìˆ˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.")
                return
            if not condition_value.get('compare_value'):
                QMessageBox.warning(self, "ê²½ê³ ", "ë¹„êµê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                return
                
        super().accept()
</file>

<file path="src/ui/dialogs/keyboard_hotkey_step_dialog.py">
"""
Keyboard hotkey step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QListWidget, QListWidgetItem, QMessageBox
)
from PyQt5.QtCore import Qt, QEvent
from PyQt5.QtGui import QKeySequence
from core.macro_types import KeyboardHotkeyStep


class KeyCaptureButton(QPushButton):
    """Button that captures key combinations"""
    
    def __init__(self, text="í´ë¦­í•˜ê³  í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”"):
        super().__init__(text)
        self.keys = []
        self.recording = False
        self.default_text = text
        
    def mousePressEvent(self, event):
        """Start recording on click"""
        super().mousePressEvent(event)
        if event.button() == Qt.LeftButton:
            self.recording = True
            self.keys = []
            self.setText("í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”...")
            self.setFocus()
            
    def keyPressEvent(self, event):
        """Capture key press"""
        if not self.recording:
            return
            
        key = event.key()
        key_name = QKeySequence(key).toString()
        
        # Handle modifiers
        modifiers = event.modifiers()
        if modifiers & Qt.ControlModifier and 'ctrl' not in self.keys:
            self.keys.append('ctrl')
        if modifiers & Qt.AltModifier and 'alt' not in self.keys:
            self.keys.append('alt')
        if modifiers & Qt.ShiftModifier and 'shift' not in self.keys:
            self.keys.append('shift')
        if modifiers & Qt.MetaModifier and 'win' not in self.keys:
            self.keys.append('win')
            
        # Add regular key if not a modifier
        if key not in [Qt.Key_Control, Qt.Key_Alt, Qt.Key_Shift, Qt.Key_Meta] and key_name:
            self.keys.append(key_name.lower())
            
        self.update_display()
        
    def keyReleaseEvent(self, event):
        """Stop recording on key release"""
        if self.recording and self.keys:
            self.recording = False
            
    def focusOutEvent(self, event):
        """Stop recording when focus lost"""
        super().focusOutEvent(event)
        self.recording = False
        
    def update_display(self):
        """Update button text with captured keys"""
        if self.keys:
            self.setText(" + ".join(self.keys))
        else:
            self.setText(self.default_text)
            
    def get_keys(self):
        """Get captured keys"""
        return self.keys
        
    def set_keys(self, keys):
        """Set keys programmatically"""
        self.keys = keys
        self.update_display()


class KeyboardHotkeyStepDialog(QDialog):
    """Dialog for configuring keyboard hotkey step"""
    
    def __init__(self, step: KeyboardHotkeyStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ë‹¨ì¶•í‚¤ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Hotkey capture
        hotkey_group = QGroupBox("ë‹¨ì¶•í‚¤")
        hotkey_layout = QVBoxLayout()
        
        # Capture button
        self.capture_button = KeyCaptureButton()
        hotkey_layout.addWidget(self.capture_button)
        
        # Common hotkeys
        common_label = QLabel("ì¼ë°˜ì ì¸ ë‹¨ì¶•í‚¤:")
        common_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        hotkey_layout.addWidget(common_label)
        
        # Hotkey list
        self.hotkey_list = QListWidget()
        self.hotkey_list.setMaximumHeight(150)
        
        common_hotkeys = [
            ("ë³µì‚¬", ["ctrl", "c"]),
            ("ë¶™ì—¬ë„£ê¸°", ["ctrl", "v"]),
            ("ì˜ë¼ë‚´ê¸°", ["ctrl", "x"]),
            ("ì‹¤í–‰ ì·¨ì†Œ", ["ctrl", "z"]),
            ("ë‹¤ì‹œ ì‹¤í–‰", ["ctrl", "y"]),
            ("ëª¨ë‘ ì„ íƒ", ["ctrl", "a"]),
            ("ì €ì¥", ["ctrl", "s"]),
            ("ìƒˆë¡œ ë§Œë“¤ê¸°", ["ctrl", "n"]),
            ("ì—´ê¸°", ["ctrl", "o"]),
            ("ì¸ì‡„", ["ctrl", "p"]),
            ("ì°¾ê¸°", ["ctrl", "f"]),
            ("íƒ­ ì „í™˜", ["alt", "tab"]),
            ("ì°½ ë‹«ê¸°", ["alt", "f4"]),
        ]
        
        for name, keys in common_hotkeys:
            item = QListWidgetItem(f"{name}: {' + '.join(keys)}")
            item.setData(Qt.UserRole, keys)
            self.hotkey_list.addItem(item)
            
        self.hotkey_list.itemDoubleClicked.connect(self.use_common_hotkey)
        hotkey_layout.addWidget(self.hotkey_list)
        
        hotkey_group.setLayout(hotkey_layout)
        layout.addWidget(hotkey_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        if self.step.keys:
            self.capture_button.set_keys(self.step.keys)
            
    def use_common_hotkey(self, item):
        """Use a common hotkey"""
        keys = item.data(Qt.UserRole)
        self.capture_button.set_keys(keys)
        
    def validate_and_accept(self):
        """Validate input and accept"""
        if not self.capture_button.get_keys():
            QMessageBox.warning(
                self, "ê²½ê³ ",
                "ë‹¨ì¶•í‚¤ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”."
            )
            return
            
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'keys': self.capture_button.get_keys()
        }
</file>

<file path="src/ui/dialogs/keyboard_type_step_dialog.py">
"""
Keyboard type step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QDialogButtonBox, QTextEdit,
    QFormLayout, QGroupBox, QCheckBox, QListWidget
)
from PyQt5.QtCore import Qt
from core.macro_types import KeyboardTypeStep


class KeyboardTypeStepDialog(QDialog):
    """Dialog for configuring keyboard type step"""
    
    def __init__(self, step: KeyboardTypeStep, excel_columns=None, parent=None):
        super().__init__(parent)
        self.step = step
        self.excel_columns = excel_columns or []
        self.setWindowTitle("í…ìŠ¤íŠ¸ ì…ë ¥ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Text input
        text_group = QGroupBox("ì…ë ¥í•  í…ìŠ¤íŠ¸")
        text_layout = QVBoxLayout()
        
        # Text edit
        self.text_edit = QTextEdit()
        self.text_edit.setPlaceholderText("ì…ë ¥í•  í…ìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ì„¸ìš”.\në³€ìˆ˜ëŠ” {{ë³€ìˆ˜ëª…}} í˜•ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        text_layout.addWidget(self.text_edit)
        
        # Variable help
        if self.excel_columns:
            help_layout = QHBoxLayout()
            help_layout.addWidget(QLabel("ì‚¬ìš© ê°€ëŠ¥í•œ Excel ì—´:"))
            
            # Variable list
            self.var_list = QListWidget()
            self.var_list.setMaximumHeight(100)
            for col in self.excel_columns:
                self.var_list.addItem(f"{{{{{col}}}}}")
            self.var_list.itemDoubleClicked.connect(self.insert_variable)
            help_layout.addWidget(self.var_list)
            
            text_layout.addLayout(help_layout)
        
        text_group.setLayout(text_layout)
        layout.addWidget(text_group)
        
        # Typing options
        options_group = QGroupBox("ì…ë ¥ ì˜µì…˜")
        options_layout = QFormLayout()
        
        # Typing interval
        self.interval_spin = QSpinBox()
        self.interval_spin.setRange(0, 1000)
        self.interval_spin.setSuffix(" ms")
        self.interval_spin.setValue(0)
        options_layout.addRow("í‚¤ ì…ë ¥ ê°„ê²©:", self.interval_spin)
        
        # Use variables checkbox
        self.use_variables_check = QCheckBox("ë³€ìˆ˜ ì¹˜í™˜ ì‚¬ìš©")
        self.use_variables_check.setChecked(True)
        options_layout.addRow("", self.use_variables_check)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.text_edit.setPlainText(self.step.text)
        self.interval_spin.setValue(int(self.step.interval * 1000))
        self.use_variables_check.setChecked(self.step.use_variables)
        
    def insert_variable(self, item):
        """Insert variable at cursor position"""
        cursor = self.text_edit.textCursor()
        cursor.insertText(item.text())
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'text': self.text_edit.toPlainText(),
            'interval': self.interval_spin.value() / 1000.0,
            'use_variables': self.use_variables_check.isChecked()
        }
</file>

<file path="src/ui/dialogs/log_viewer_dialog.py">
"""
CSV log viewer dialog for analyzing execution logs
"""

import csv
import os
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QGroupBox, QComboBox, QLineEdit,
    QWidget, QSplitter, QTextEdit, QFileDialog, QMessageBox,
    QHeaderView, QProgressBar
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QColor, QFont
try:
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
    from matplotlib.figure import Figure
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False

class LogStatisticsWidget(QWidget):
    """Widget showing log statistics and charts"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Summary statistics
        self.stats_group = QGroupBox("ì‹¤í–‰ í†µê³„")
        stats_layout = QVBoxLayout()
        
        self.total_rows_label = QLabel("ì „ì²´ í–‰: 0")
        self.success_rows_label = QLabel("ì„±ê³µ: 0 (0.0%)")
        self.failed_rows_label = QLabel("ì‹¤íŒ¨: 0 (0.0%)")
        self.total_time_label = QLabel("ì´ ì‹¤í–‰ ì‹œê°„: 0ë¶„ 0ì´ˆ")
        self.avg_time_label = QLabel("í‰ê·  í–‰ ì²˜ë¦¬ ì‹œê°„: 0.0ì´ˆ")
        
        stats_layout.addWidget(self.total_rows_label)
        stats_layout.addWidget(self.success_rows_label)
        stats_layout.addWidget(self.failed_rows_label)
        stats_layout.addWidget(self.total_time_label)
        stats_layout.addWidget(self.avg_time_label)
        
        self.stats_group.setLayout(stats_layout)
        layout.addWidget(self.stats_group)
        
        # Chart (if matplotlib available)
        if HAS_MATPLOTLIB:
            self.figure = Figure(figsize=(5, 3))
            self.canvas = FigureCanvas(self.figure)
            layout.addWidget(self.canvas)
        else:
            no_chart_label = QLabel("ì°¨íŠ¸ë¥¼ í‘œì‹œí•˜ë ¤ë©´ matplotlibë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”")
            no_chart_label.setStyleSheet("color: #666; padding: 20px;")
            no_chart_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(no_chart_label)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def update_statistics(self, log_data: List[Dict[str, Any]]):
        """Update statistics from log data"""
        if not log_data:
            return
            
        # Calculate statistics
        total_rows = 0
        successful_rows = 0
        failed_rows = 0
        total_elapsed_ms = 0
        row_times = []
        
        # Process log entries
        processed_rows = set()
        for entry in log_data:
            if entry['row_index'] and entry['row_index'] != '-1':
                row_idx = int(entry['row_index'])
                
                if entry['step_name'] == 'ROW_COMPLETE' and row_idx not in processed_rows:
                    processed_rows.add(row_idx)
                    total_rows += 1
                    
                    if entry['status'] == 'SUCCESS':
                        successful_rows += 1
                    else:
                        failed_rows += 1
                        
                    if entry['duration_ms']:
                        row_times.append(float(entry['duration_ms']))
                        
            # Get total elapsed time from session end
            if entry['step_name'] == 'SESSION_END' and entry['elapsed_ms']:
                total_elapsed_ms = float(entry['elapsed_ms'])
                
        # Update labels
        self.total_rows_label.setText(f"ì „ì²´ í–‰: {total_rows}")
        
        if total_rows > 0:
            success_rate = (successful_rows / total_rows) * 100
            self.success_rows_label.setText(f"ì„±ê³µ: {successful_rows} ({success_rate:.1f}%)")
            self.failed_rows_label.setText(f"ì‹¤íŒ¨: {failed_rows} ({100-success_rate:.1f}%)")
        else:
            self.success_rows_label.setText("ì„±ê³µ: 0 (0.0%)")
            self.failed_rows_label.setText("ì‹¤íŒ¨: 0 (0.0%)")
            
        # Time statistics
        if total_elapsed_ms > 0:
            total_seconds = total_elapsed_ms / 1000
            minutes = int(total_seconds // 60)
            seconds = int(total_seconds % 60)
            self.total_time_label.setText(f"ì´ ì‹¤í–‰ ì‹œê°„: {minutes}ë¶„ {seconds}ì´ˆ")
            
        if row_times:
            avg_time = sum(row_times) / len(row_times) / 1000  # Convert to seconds
            self.avg_time_label.setText(f"í‰ê·  í–‰ ì²˜ë¦¬ ì‹œê°„: {avg_time:.1f}ì´ˆ")
            
        # Update chart
        self.update_chart(successful_rows, failed_rows)
        
    def update_chart(self, success: int, failed: int):
        """Update pie chart"""
        if not HAS_MATPLOTLIB:
            return
            
        self.figure.clear()
        
        if success == 0 and failed == 0:
            return
            
        ax = self.figure.add_subplot(111)
        
        # Data
        sizes = [success, failed]
        labels = ['ì„±ê³µ', 'ì‹¤íŒ¨']
        colors = ['#4CAF50', '#F44336']
        
        # Create pie chart
        wedges, texts, autotexts = ax.pie(
            sizes, labels=labels, colors=colors, autopct='%1.1f%%',
            shadow=True, startangle=90
        )
        
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax.axis('equal')
        ax.set_title('ì‹¤í–‰ ê²°ê³¼ ë¶„í¬')
        
        self.canvas.draw()

class LogViewerDialog(QDialog):
    """Dialog for viewing and analyzing CSV execution logs"""
    
    def __init__(self, log_file: Optional[Path] = None, parent=None):
        super().__init__(parent)
        self.log_data: List[Dict[str, Any]] = []
        self.filtered_data: List[Dict[str, Any]] = []
        
        self.init_ui()
        
        if log_file:
            self.load_log_file(log_file)
            
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("ì‹¤í–‰ ë¡œê·¸ ë·°ì–´")
        self.setModal(False)  # Non-modal to allow interaction with main window
        self.resize(1200, 700)
        
        layout = QVBoxLayout()
        
        # Toolbar
        toolbar_layout = QHBoxLayout()
        
        # Open file button
        open_btn = QPushButton("ë¡œê·¸ íŒŒì¼ ì—´ê¸°...")
        open_btn.clicked.connect(self.open_log_file)
        toolbar_layout.addWidget(open_btn)
        
        # Refresh button
        self.refresh_btn = QPushButton("ìƒˆë¡œê³ ì¹¨")
        self.refresh_btn.clicked.connect(self.refresh_current_file)
        self.refresh_btn.setEnabled(False)
        toolbar_layout.addWidget(self.refresh_btn)
        
        toolbar_layout.addWidget(QLabel("í•„í„°:"))
        
        # Status filter
        self.status_filter = QComboBox()
        self.status_filter.addItems(["ì „ì²´", "ì„±ê³µ", "ì‹¤íŒ¨", "ì˜¤ë¥˜"])
        self.status_filter.currentTextChanged.connect(self.apply_filters)
        toolbar_layout.addWidget(self.status_filter)
        
        # Search
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("ê²€ìƒ‰...")
        self.search_edit.textChanged.connect(self.apply_filters)
        toolbar_layout.addWidget(self.search_edit)
        
        # Export button
        export_btn = QPushButton("ë‚´ë³´ë‚´ê¸°...")
        export_btn.clicked.connect(self.export_filtered_data)
        toolbar_layout.addWidget(export_btn)
        
        toolbar_layout.addStretch()
        layout.addLayout(toolbar_layout)
        
        # Current file label
        self.file_label = QLabel("ë¡œê·¸ íŒŒì¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        self.file_label.setStyleSheet("color: #666; padding: 5px;")
        layout.addWidget(self.file_label)
        
        # Main content splitter
        splitter = QSplitter(Qt.Horizontal)
        
        # Statistics widget
        self.stats_widget = LogStatisticsWidget()
        splitter.addWidget(self.stats_widget)
        
        # Log table
        self.log_table = QTableWidget()
        self.setup_table()
        splitter.addWidget(self.log_table)
        
        # Set splitter sizes (30% stats, 70% table)
        splitter.setSizes([300, 700])
        
        layout.addWidget(splitter)
        
        # Status bar
        self.status_label = QLabel("ì¤€ë¹„")
        layout.addWidget(self.status_label)
        
        self.setLayout(layout)
        
        # Auto-refresh timer
        self.auto_refresh_timer = QTimer()
        self.auto_refresh_timer.timeout.connect(self.refresh_current_file)
        
    def setup_table(self):
        """Setup log table"""
        headers = [
            "ì‹œê°„", "ê²½ê³¼(ì´ˆ)", "í–‰", "ë‹¨ê³„", "íƒ€ì…", 
            "ìƒíƒœ", "ì†Œìš”ì‹œê°„(ms)", "ì˜¤ë¥˜ ë©”ì‹œì§€", "ìƒì„¸"
        ]
        
        self.log_table.setColumnCount(len(headers))
        self.log_table.setHorizontalHeaderLabels(headers)
        
        # Set column widths
        header = self.log_table.horizontalHeader()
        header.setStretchLastSection(True)
        self.log_table.setColumnWidth(0, 150)  # Time
        self.log_table.setColumnWidth(1, 80)   # Elapsed
        self.log_table.setColumnWidth(2, 60)   # Row
        self.log_table.setColumnWidth(3, 150)  # Step
        self.log_table.setColumnWidth(4, 100)  # Type
        self.log_table.setColumnWidth(5, 80)   # Status
        self.log_table.setColumnWidth(6, 100)  # Duration
        self.log_table.setColumnWidth(7, 200)  # Error
        
        # Enable sorting
        self.log_table.setSortingEnabled(True)
        
        # Row selection
        self.log_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.log_table.itemSelectionChanged.connect(self.on_selection_changed)
        
    def open_log_file(self):
        """Open a log file"""
        log_dir = Path.home() / ".excel_macro_automation" / "execution_logs"
        log_dir.mkdir(parents=True, exist_ok=True)
        
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "ì‹¤í–‰ ë¡œê·¸ íŒŒì¼ ì„ íƒ",
            str(log_dir),
            "CSV Files (*.csv);;All Files (*.*)"
        )
        
        if file_path:
            self.load_log_file(Path(file_path))
            
    def load_log_file(self, file_path: Path):
        """Load CSV log file"""
        self.current_file = file_path
        self.file_label.setText(f"ë¡œê·¸ íŒŒì¼: {file_path.name}")
        self.refresh_btn.setEnabled(True)
        
        try:
            self.log_data = []
            
            with open(file_path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    self.log_data.append(row)
                    
            self.apply_filters()
            self.status_label.setText(f"{len(self.log_data)}ê°œ í•­ëª© ë¡œë“œë¨")
            
            # Update statistics
            self.stats_widget.update_statistics(self.log_data)
            
            # Enable auto-refresh for current session
            if self.is_current_session():
                self.auto_refresh_timer.start(2000)  # Refresh every 2 seconds
            else:
                self.auto_refresh_timer.stop()
                
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ë¡œê·¸ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨:\n{str(e)}")
            
    def is_current_session(self) -> bool:
        """Check if loaded file is from current session"""
        if not hasattr(self, 'current_file'):
            return False
            
        # Check if file was modified recently (within last minute)
        try:
            mtime = os.path.getmtime(self.current_file)
            age = datetime.now().timestamp() - mtime
            return age < 60  # Less than 1 minute old
        except:
            return False
            
    def refresh_current_file(self):
        """Refresh current log file"""
        if hasattr(self, 'current_file'):
            self.load_log_file(self.current_file)
            
    def apply_filters(self):
        """Apply filters to log data"""
        # Get filter criteria
        status_filter = self.status_filter.currentText()
        search_text = self.search_edit.text().lower()
        
        # Filter data
        self.filtered_data = []
        
        for entry in self.log_data:
            # Status filter
            if status_filter != "ì „ì²´":
                if status_filter == "ì„±ê³µ" and entry['status'] != 'SUCCESS':
                    continue
                elif status_filter == "ì‹¤íŒ¨" and entry['status'] != 'FAILED':
                    continue
                elif status_filter == "ì˜¤ë¥˜" and entry['status'] != 'ERROR':
                    continue
                    
            # Search filter
            if search_text:
                found = False
                for value in entry.values():
                    if search_text in str(value).lower():
                        found = True
                        break
                if not found:
                    continue
                    
            self.filtered_data.append(entry)
            
        # Update table
        self.update_table()
        
    def update_table(self):
        """Update table with filtered data"""
        self.log_table.setRowCount(len(self.filtered_data))
        
        for i, entry in enumerate(self.filtered_data):
            # Timestamp
            timestamp = entry.get('timestamp', '')
            if timestamp:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    timestamp = dt.strftime('%Y-%m-%d %H:%M:%S')
                except:
                    pass
            self.log_table.setItem(i, 0, QTableWidgetItem(timestamp))
            
            # Elapsed time in seconds
            elapsed_ms = entry.get('elapsed_ms', '')
            if elapsed_ms:
                try:
                    elapsed_sec = float(elapsed_ms) / 1000
                    elapsed_str = f"{elapsed_sec:.1f}"
                except:
                    elapsed_str = elapsed_ms
            else:
                elapsed_str = ""
            self.log_table.setItem(i, 1, QTableWidgetItem(elapsed_str))
            
            # Row index (1-based for display)
            row_idx = entry.get('row_index', '')
            if row_idx and row_idx != '-1':
                try:
                    row_display = str(int(row_idx) + 1)
                except:
                    row_display = row_idx
            else:
                row_display = ""
            self.log_table.setItem(i, 2, QTableWidgetItem(row_display))
            
            # Step name
            self.log_table.setItem(i, 3, QTableWidgetItem(entry.get('step_name', '')))
            
            # Step type
            self.log_table.setItem(i, 4, QTableWidgetItem(entry.get('step_type', '')))
            
            # Status with color
            status = entry.get('status', '')
            status_item = QTableWidgetItem(status)
            if status == 'SUCCESS':
                status_item.setForeground(QColor(0, 128, 0))
            elif status in ['FAILED', 'ERROR']:
                status_item.setForeground(QColor(255, 0, 0))
            self.log_table.setItem(i, 5, status_item)
            
            # Duration
            self.log_table.setItem(i, 6, QTableWidgetItem(entry.get('duration_ms', '')))
            
            # Error message
            self.log_table.setItem(i, 7, QTableWidgetItem(entry.get('error_message', '')))
            
            # Details
            self.log_table.setItem(i, 8, QTableWidgetItem(entry.get('details', '')))
            
        self.status_label.setText(f"{len(self.filtered_data)}ê°œ í•­ëª© í‘œì‹œ ì¤‘")
        
    def on_selection_changed(self):
        """Handle row selection"""
        # Could show more details in a separate panel
        pass
        
    def export_filtered_data(self):
        """Export filtered data to CSV"""
        if not self.filtered_data:
            QMessageBox.information(self, "ë‚´ë³´ë‚´ê¸°", "ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return
            
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "ë¡œê·¸ ë‚´ë³´ë‚´ê¸°",
            f"filtered_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            "CSV Files (*.csv);;All Files (*.*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', newline='', encoding='utf-8') as f:
                    if self.filtered_data:
                        writer = csv.DictWriter(f, fieldnames=self.filtered_data[0].keys())
                        writer.writeheader()
                        writer.writerows(self.filtered_data)
                        
                QMessageBox.information(self, "ë‚´ë³´ë‚´ê¸° ì™„ë£Œ", f"ë¡œê·¸ê°€ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤:\n{file_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨", f"ë¡œê·¸ ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜:\n{str(e)}")
                
    def closeEvent(self, event):
        """Handle dialog close"""
        self.auto_refresh_timer.stop()
        super().closeEvent(event)
</file>

<file path="src/ui/dialogs/loop_step_dialog.py">
"""
Loop step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QComboBox, QSpinBox, QListWidget, QListWidgetItem,
    QAbstractItemView, QMessageBox, QTextEdit
)
from PyQt5.QtCore import Qt
from core.macro_types import LoopStep, MacroStep
from typing import List, Optional


class LoopStepDialog(QDialog):
    """Dialog for configuring loop step"""
    
    def __init__(self, step: LoopStep, available_steps: List[MacroStep], parent=None):
        super().__init__(parent)
        self.step = step
        self.available_steps = available_steps  # All steps in the macro
        self.setWindowTitle("ë°˜ë³µë¬¸ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(600)
        self.setMinimumHeight(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Loop type group
        type_group = QGroupBox("ë°˜ë³µ íƒ€ì…")
        type_layout = QVBoxLayout()
        
        # Loop type selection
        type_form_layout = QFormLayout()
        self.type_combo = QComboBox()
        self.type_combo.addItems([
            "ì§€ì • íšŸìˆ˜ ë°˜ë³µ",
            "ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€",
            "ê° ì—‘ì…€ í–‰ì— ëŒ€í•´"
        ])
        self.type_combo.currentIndexChanged.connect(self.on_type_changed)
        type_form_layout.addRow("ë°˜ë³µ ë°©ì‹:", self.type_combo)
        type_layout.addLayout(type_form_layout)
        
        # Count settings (for count type)
        self.count_widget = QWidget()
        count_layout = QHBoxLayout()
        count_layout.addWidget(QLabel("ë°˜ë³µ íšŸìˆ˜:"))
        self.count_spin = QSpinBox()
        self.count_spin.setMinimum(1)
        self.count_spin.setMaximum(9999)
        self.count_spin.setValue(5)
        count_layout.addWidget(self.count_spin)
        count_layout.addWidget(QLabel("íšŒ"))
        count_layout.addStretch()
        self.count_widget.setLayout(count_layout)
        type_layout.addWidget(self.count_widget)
        
        # Image settings (for while_image type)
        self.image_widget = QWidget()
        image_layout = QVBoxLayout()
        image_info = QLabel(
            "ì´ë¯¸ì§€ê°€ í™”ë©´ì— ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ ë°˜ë³µí•©ë‹ˆë‹¤.\n"
            "ì´ë¯¸ì§€ ê²€ìƒ‰ ë‹¨ê³„ë¥¼ ë°˜ë³µ ëŒ€ìƒì— í¬í•¨ì‹œì¼œì•¼ í•©ë‹ˆë‹¤."
        )
        image_info.setWordWrap(True)
        image_info.setStyleSheet("color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        image_layout.addWidget(image_info)
        self.image_widget.setLayout(image_layout)
        self.image_widget.hide()
        type_layout.addWidget(self.image_widget)
        
        # Row settings (for for_each_row type)
        self.row_widget = QWidget()
        row_layout = QVBoxLayout()
        row_info = QLabel(
            "ì—‘ì…€ì˜ ê° í–‰ì— ëŒ€í•´ ë°˜ë³µí•©ë‹ˆë‹¤.\n"
            "ë³€ìˆ˜ ì¹˜í™˜ì„ ì‚¬ìš©í•˜ëŠ” ë‹¨ê³„ë¥¼ í¬í•¨ì‹œì¼œ ê° í–‰ì˜ ë°ì´í„°ë¥¼ í™œìš©í•˜ì„¸ìš”."
        )
        row_info.setWordWrap(True)
        row_info.setStyleSheet("color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        row_layout.addWidget(row_info)
        self.row_widget.setLayout(row_layout)
        self.row_widget.hide()
        type_layout.addWidget(self.row_widget)
        
        type_group.setLayout(type_layout)
        layout.addWidget(type_group)
        
        # Steps selection group
        steps_group = QGroupBox("ë°˜ë³µí•  ë‹¨ê³„ ì„ íƒ")
        steps_layout = QVBoxLayout()
        
        steps_info = QLabel("ë°˜ë³µí•  ë‹¨ê³„ë“¤ì„ ì„ íƒí•˜ì„¸ìš” (Ctrl+í´ë¦­ìœ¼ë¡œ ë‹¤ì¤‘ ì„ íƒ)")
        steps_info.setStyleSheet("color: #666; font-size: 12px;")
        steps_layout.addWidget(steps_info)
        
        # Available steps list
        self.steps_list = QListWidget()
        self.steps_list.setSelectionMode(QAbstractItemView.MultiSelection)
        
        # Add available steps to list
        for step in self.available_steps:
            if step.step_id != self.step.step_id:  # Don't include self
                item = QListWidgetItem(f"{step.name} ({step.step_type.value})")
                item.setData(Qt.UserRole, step.step_id)
                self.steps_list.addItem(item)
                
        steps_layout.addWidget(self.steps_list)
        
        # Selected steps info
        self.selected_info = QLabel("ì„ íƒëœ ë‹¨ê³„: 0ê°œ")
        self.selected_info.setStyleSheet("font-weight: bold;")
        steps_layout.addWidget(self.selected_info)
        
        self.steps_list.itemSelectionChanged.connect(self.update_selected_info)
        
        steps_group.setLayout(steps_layout)
        layout.addWidget(steps_group)
        
        # Description
        desc_layout = QFormLayout()
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(60)
        self.description_edit.setPlaceholderText("ë°˜ë³µë¬¸ì— ëŒ€í•œ ì„¤ëª… (ì„ íƒì‚¬í•­)")
        desc_layout.addRow("ì„¤ëª…:", self.description_edit)
        layout.addLayout(desc_layout)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        
        # Set loop type
        type_map = {
            "count": 0,
            "while_image": 1,
            "for_each_row": 2
        }
        self.type_combo.setCurrentIndex(type_map.get(self.step.loop_type, 0))
        
        # Set count
        self.count_spin.setValue(self.step.loop_count)
        
        # Select loop steps
        for i in range(self.steps_list.count()):
            item = self.steps_list.item(i)
            step_id = item.data(Qt.UserRole)
            if step_id in self.step.loop_steps:
                item.setSelected(True)
                
        # Set description
        if hasattr(self.step, 'description'):
            self.description_edit.setText(self.step.description)
            
        self.update_selected_info()
        
    def on_type_changed(self, index):
        """Handle loop type change"""
        # Show/hide appropriate widgets
        self.count_widget.setVisible(index == 0)
        self.image_widget.setVisible(index == 1)
        self.row_widget.setVisible(index == 2)
        
    def update_selected_info(self):
        """Update selected steps info"""
        selected_count = len(self.steps_list.selectedItems())
        self.selected_info.setText(f"ì„ íƒëœ ë‹¨ê³„: {selected_count}ê°œ")
        
    def validate_and_accept(self):
        """Validate input and accept"""
        # Check if any steps are selected
        if not self.steps_list.selectedItems():
            QMessageBox.warning(
                self, "ê²½ê³ ",
                "ë°˜ë³µí•  ë‹¨ê³„ë¥¼ ìµœì†Œ 1ê°œ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”."
            )
            return
            
        # Check count for count type
        if self.type_combo.currentIndex() == 0 and self.count_spin.value() < 1:
            QMessageBox.warning(
                self, "ê²½ê³ ",
                "ë°˜ë³µ íšŸìˆ˜ëŠ” 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤."
            )
            return
            
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        # Get loop type
        type_map = {
            0: "count",
            1: "while_image",
            2: "for_each_row"
        }
        loop_type = type_map[self.type_combo.currentIndex()]
        
        # Get selected step IDs
        loop_steps = []
        for item in self.steps_list.selectedItems():
            loop_steps.append(item.data(Qt.UserRole))
            
        return {
            'name': self.name_edit.text() or "ë°˜ë³µë¬¸",
            'loop_type': loop_type,
            'loop_count': self.count_spin.value(),
            'loop_steps': loop_steps,
            'description': self.description_edit.toPlainText()
        }
</file>

<file path="src/ui/dialogs/macro_save_dialog.py">
"""
Macro save and load dialogs
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QTextEdit, QRadioButton, QButtonGroup, QPushButton,
    QCheckBox, QSpinBox, QGroupBox, QProgressBar,
    QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from core.macro_types import Macro, MacroStep
from typing import List, Optional


class MacroSaveDialog(QDialog):
    """Dialog for saving macro with options"""
    
    def __init__(self, macro: Macro, parent=None):
        super().__init__(parent)
        self.macro = macro
        self.setWindowTitle("Save Macro")
        self.setModal(True)
        self.resize(400, 300)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Macro name
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("Name:"))
        self.name_edit = QLineEdit(self.macro.name)
        name_layout.addWidget(self.name_edit)
        layout.addLayout(name_layout)
        
        # Description
        layout.addWidget(QLabel("Description:"))
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.macro.description)
        self.desc_edit.setMaximumHeight(80)
        layout.addWidget(self.desc_edit)
        
        # Format selection
        format_group = QGroupBox("File Format")
        format_layout = QVBoxLayout()
        
        self.format_group = QButtonGroup()
        self.json_radio = QRadioButton("JSON (Human readable)")
        self.json_radio.setChecked(True)
        self.encrypted_radio = QRadioButton("Encrypted (Secure)")
        
        self.format_group.addButton(self.json_radio, 0)
        self.format_group.addButton(self.encrypted_radio, 1)
        
        format_layout.addWidget(self.json_radio)
        format_layout.addWidget(self.encrypted_radio)
        format_group.setLayout(format_layout)
        layout.addWidget(format_group)
        
        # Options
        options_group = QGroupBox("Options")
        options_layout = QVBoxLayout()
        
        self.include_vars_cb = QCheckBox("Include variables")
        self.include_vars_cb.setChecked(True)
        options_layout.addWidget(self.include_vars_cb)
        
        self.compress_cb = QCheckBox("Compress file")
        self.compress_cb.setChecked(False)
        options_layout.addWidget(self.compress_cb)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        save_btn.setDefault(True)
        btn_layout.addWidget(save_btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        
    def get_options(self) -> dict:
        """Get save options"""
        return {
            'name': self.name_edit.text(),
            'description': self.desc_edit.toPlainText(),
            'format': 'encrypted' if self.encrypted_radio.isChecked() else 'json',
            'include_variables': self.include_vars_cb.isChecked(),
            'compress': self.compress_cb.isChecked()
        }


class PartialMacroExportDialog(QDialog):
    """Dialog for exporting selected macro steps"""
    
    def __init__(self, selected_steps: List[MacroStep], all_variables: dict, parent=None):
        super().__init__(parent)
        self.selected_steps = selected_steps
        self.all_variables = all_variables
        self.setWindowTitle("Export Macro Steps")
        self.setModal(True)
        self.resize(450, 400)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Info
        info_label = QLabel(f"Exporting {len(self.selected_steps)} selected steps")
        info_label.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(info_label)
        
        # Name
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("Export Name:"))
        self.name_edit = QLineEdit("Partial Macro Export")
        name_layout.addWidget(self.name_edit)
        layout.addLayout(name_layout)
        
        # Description
        layout.addWidget(QLabel("Description:"))
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText("Exported macro steps")
        self.desc_edit.setMaximumHeight(60)
        layout.addWidget(self.desc_edit)
        
        # Variable dependencies
        var_group = QGroupBox("Variable Dependencies")
        var_layout = QVBoxLayout()
        
        # Check which variables are used
        used_vars = self._check_variable_usage()
        
        if used_vars:
            var_label = QLabel(f"The following variables are used in selected steps:")
            var_layout.addWidget(var_label)
            
            for var_name in used_vars:
                cb = QCheckBox(f"Include '{var_name}'")
                cb.setChecked(True)
                cb.setObjectName(var_name)
                var_layout.addWidget(cb)
        else:
            var_label = QLabel("No variables are used in selected steps")
            var_layout.addWidget(var_label)
            
        var_group.setLayout(var_layout)
        layout.addWidget(var_group)
        
        # Format
        format_group = QGroupBox("Export Format")
        format_layout = QVBoxLayout()
        
        self.format_group = QButtonGroup()
        self.json_radio = QRadioButton("JSON (Human readable)")
        self.json_radio.setChecked(True)
        self.encrypted_radio = QRadioButton("Encrypted (Secure)")
        
        self.format_group.addButton(self.json_radio, 0)
        self.format_group.addButton(self.encrypted_radio, 1)
        
        format_layout.addWidget(self.json_radio)
        format_layout.addWidget(self.encrypted_radio)
        format_group.setLayout(format_layout)
        layout.addWidget(format_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        export_btn = QPushButton("Export")
        export_btn.clicked.connect(self.accept)
        export_btn.setDefault(True)
        btn_layout.addWidget(export_btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        
    def _check_variable_usage(self) -> List[str]:
        """Check which variables are used in selected steps"""
        used_vars = set()
        
        for step in self.selected_steps:
            # Check various step properties for variable usage
            step_dict = step.to_dict()
            self._find_variables_in_dict(step_dict, used_vars)
            
        return sorted(list(used_vars))
        
    def _find_variables_in_dict(self, d: dict, used_vars: set):
        """Recursively find variable references in dictionary"""
        for key, value in d.items():
            if isinstance(value, str) and value.startswith('${') and value.endswith('}'):
                var_name = value[2:-1]
                if var_name in self.all_variables:
                    used_vars.add(var_name)
            elif isinstance(value, dict):
                self._find_variables_in_dict(value, used_vars)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, dict):
                        self._find_variables_in_dict(item, used_vars)
                        
    def get_export_data(self) -> dict:
        """Get export data"""
        # Collect selected variables
        selected_vars = {}
        var_group = self.findChild(QGroupBox, "Variable Dependencies")
        if var_group:
            for cb in var_group.findChildren(QCheckBox):
                if cb.isChecked():
                    var_name = cb.objectName()
                    if var_name in self.all_variables:
                        selected_vars[var_name] = self.all_variables[var_name]
                        
        return {
            'name': self.name_edit.text(),
            'description': self.desc_edit.toPlainText(),
            'format': 'encrypted' if self.encrypted_radio.isChecked() else 'json',
            'steps': self.selected_steps,
            'variables': selected_vars
        }


class MacroLoadProgressDialog(QDialog):
    """Progress dialog for loading macros"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Loading Macro")
        self.setModal(True)
        self.setFixedSize(300, 100)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        self.label = QLabel("Loading macro file...")
        layout.addWidget(self.label)
        
        self.progress = QProgressBar()
        self.progress.setRange(0, 0)  # Indeterminate
        layout.addWidget(self.progress)
        
        self.setLayout(layout)
        
    def set_message(self, message: str):
        """Set progress message"""
        self.label.setText(message)
</file>

<file path="src/ui/dialogs/mouse_click_step_dialog.py">
"""
Mouse click step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QComboBox, QDialogButtonBox,
    QFormLayout, QGroupBox, QCheckBox, QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QCursor
import pyautogui
from core.macro_types import MouseClickStep, MouseButton
from ui.widgets.roi_selector import ROISelectorWidget
from utils.monitor_utils import get_monitor_name_for_position, get_monitor_info


class MouseClickStepDialog(QDialog):
    """Dialog for configuring mouse click step"""
    
    def __init__(self, step: MouseClickStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ë§ˆìš°ìŠ¤ í´ë¦­ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Position group
        position_group = QGroupBox("í´ë¦­ ìœ„ì¹˜")
        position_layout = QVBoxLayout()
        
        # Position inputs
        coord_layout = QHBoxLayout()
        coord_layout.addWidget(QLabel("X:"))
        self.x_spin = QSpinBox()
        self.x_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.x_spin)
        
        coord_layout.addWidget(QLabel("Y:"))
        self.y_spin = QSpinBox()
        self.y_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.y_spin)
        
        coord_layout.addStretch()
        position_layout.addLayout(coord_layout)
        
        # Capture button
        self.capture_button = QPushButton("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)")
        self.capture_button.clicked.connect(self.capture_position)
        position_layout.addWidget(self.capture_button)
        
        # Set up F3 shortcut
        from PyQt5.QtWidgets import QShortcut
        from PyQt5.QtGui import QKeySequence
        self.capture_shortcut = QShortcut(QKeySequence("F3"), self)
        self.capture_shortcut.activated.connect(self.capture_position)
        
        # Select area button
        self.select_area_button = QPushButton("í™”ë©´ì—ì„œ ì„ íƒ...")
        self.select_area_button.clicked.connect(self.select_from_screen)
        position_layout.addWidget(self.select_area_button)
        
        position_group.setLayout(position_layout)
        layout.addWidget(position_group)
        
        # Help text for F3
        help_label = QLabel("ğŸ’¡ íŒ: F3 í‚¤ë¥¼ ëˆ„ë¥´ë©´ í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì¦‰ì‹œ ìº¡ì²˜í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        layout.addWidget(help_label)
        
        # Monitor info
        self.add_monitor_info(layout)
        
        # Click options
        options_group = QGroupBox("í´ë¦­ ì˜µì…˜")
        options_layout = QFormLayout()
        
        # Button selection
        self.button_combo = QComboBox()
        self.button_combo.addItems(["ì™¼ìª½ ë²„íŠ¼", "ì˜¤ë¥¸ìª½ ë²„íŠ¼", "ê°€ìš´ë° ë²„íŠ¼"])
        options_layout.addRow("ë§ˆìš°ìŠ¤ ë²„íŠ¼:", self.button_combo)
        
        # Click count
        self.clicks_spin = QSpinBox()
        self.clicks_spin.setRange(1, 10)
        self.clicks_spin.setValue(1)
        options_layout.addRow("í´ë¦­ íšŸìˆ˜:", self.clicks_spin)
        
        # Interval
        self.interval_spin = QSpinBox()
        self.interval_spin.setRange(0, 5000)
        self.interval_spin.setSuffix(" ms")
        self.interval_spin.setValue(0)
        options_layout.addRow("í´ë¦­ ê°„ê²©:", self.interval_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def add_monitor_info(self, parent_layout):
        """Add monitor information display"""
        monitors = get_monitor_info()
        
        if len(monitors) > 1:
            monitor_group = QGroupBox("ëª¨ë‹ˆí„° ì •ë³´")
            monitor_layout = QVBoxLayout()
            
            info_text = f"ê°ì§€ëœ ëª¨ë‹ˆí„°: {len(monitors)}ê°œ\n"
            for i, monitor in enumerate(monitors):
                name = "ì£¼ ëª¨ë‹ˆí„°" if monitor['is_primary'] else f"ëª¨ë‹ˆí„° {i+1}"
                info_text += f"â€¢ {name}: {monitor['width']}x{monitor['height']} (ìœ„ì¹˜: {monitor['x']}, {monitor['y']})\n"
            
            monitor_label = QLabel(info_text.strip())
            monitor_label.setStyleSheet("color: #666; font-size: 11px;")
            monitor_layout.addWidget(monitor_label)
            
            monitor_group.setLayout(monitor_layout)
            parent_layout.addWidget(monitor_group)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.x_spin.setValue(self.step.x)
        self.y_spin.setValue(self.step.y)
        
        # Set button
        button_map = {
            MouseButton.LEFT: 0,
            MouseButton.RIGHT: 1,
            MouseButton.MIDDLE: 2
        }
        self.button_combo.setCurrentIndex(button_map.get(self.step.button, 0))
        
        self.clicks_spin.setValue(self.step.clicks)
        self.interval_spin.setValue(int(self.step.interval * 1000))
        
    def capture_position(self):
        """Capture current mouse position"""
        # Capture immediately when F3 is pressed
        x, y = pyautogui.position()
        self.x_spin.setValue(x)
        self.y_spin.setValue(y)
        
        # Get monitor name for the position
        monitor_name = get_monitor_name_for_position(x, y)
        
        # Flash the button to indicate capture with monitor info
        self.capture_button.setText(f"ìº¡ì²˜ë¨! ({monitor_name}: {x}, {y})")
        QTimer.singleShot(1500, lambda: self.capture_button.setText("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)"))
        
        
    def select_from_screen(self):
        """Select position from screen"""
        self.hide()
        
        selector = ROISelectorWidget()
        # For now, just use capture position
        # TODO: Implement proper screen selection
        self.capture_position()
        return
        
        self.show()
        
        if result:
            x, y = result
            self.x_spin.setValue(x)
            self.y_spin.setValue(y)
            
    def get_step_data(self):
        """Get configured step data"""
        # Map combo index to button
        button_map = {
            0: MouseButton.LEFT,
            1: MouseButton.RIGHT,
            2: MouseButton.MIDDLE
        }
        
        return {
            'name': self.name_edit.text(),
            'x': self.x_spin.value(),
            'y': self.y_spin.value(),
            'button': button_map[self.button_combo.currentIndex()],
            'clicks': self.clicks_spin.value(),
            'interval': self.interval_spin.value() / 1000.0
        }
</file>

<file path="src/ui/dialogs/mouse_move_step_dialog.py">
"""
Mouse move step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QSpinBox, QDoubleSpinBox, QDialogButtonBox,
    QFormLayout, QGroupBox, QMessageBox
)
from PyQt5.QtCore import Qt, QTimer
import pyautogui
from core.macro_types import MouseMoveStep
from ui.widgets.roi_selector import ROISelectorWidget
from utils.monitor_utils import get_monitor_name_for_position, get_monitor_info


class MouseMoveStepDialog(QDialog):
    """Dialog for configuring mouse move step"""
    
    def __init__(self, step: MouseMoveStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ë§ˆìš°ìŠ¤ ì´ë™ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(400)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # Position group
        position_group = QGroupBox("ì´ë™ ìœ„ì¹˜")
        position_layout = QVBoxLayout()
        
        # Position inputs
        coord_layout = QHBoxLayout()
        coord_layout.addWidget(QLabel("X:"))
        self.x_spin = QSpinBox()
        self.x_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.x_spin)
        
        coord_layout.addWidget(QLabel("Y:"))
        self.y_spin = QSpinBox()
        self.y_spin.setRange(-9999, 9999)  # ìŒìˆ˜ ì¢Œí‘œ í—ˆìš© (ë“€ì–¼ ëª¨ë‹ˆí„°)
        coord_layout.addWidget(self.y_spin)
        
        coord_layout.addStretch()
        position_layout.addLayout(coord_layout)
        
        # Capture button
        self.capture_button = QPushButton("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)")
        self.capture_button.clicked.connect(self.capture_position)
        position_layout.addWidget(self.capture_button)
        
        # Set up F3 shortcut
        from PyQt5.QtWidgets import QShortcut
        from PyQt5.QtGui import QKeySequence
        self.capture_shortcut = QShortcut(QKeySequence("F3"), self)
        self.capture_shortcut.activated.connect(self.capture_position)
        
        # Select area button
        self.select_area_button = QPushButton("í™”ë©´ì—ì„œ ì„ íƒ...")
        self.select_area_button.clicked.connect(self.select_from_screen)
        position_layout.addWidget(self.select_area_button)
        
        position_group.setLayout(position_layout)
        layout.addWidget(position_group)
        
        # Help text for F3
        help_label = QLabel("ğŸ’¡ íŒ: F3 í‚¤ë¥¼ ëˆ„ë¥´ë©´ í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì¦‰ì‹œ ìº¡ì²˜í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px;")
        layout.addWidget(help_label)
        
        # Monitor info
        self.add_monitor_info(layout)
        
        # Move options
        options_group = QGroupBox("ì´ë™ ì˜µì…˜")
        options_layout = QFormLayout()
        
        # Duration
        self.duration_spin = QDoubleSpinBox()
        self.duration_spin.setRange(0, 10.0)
        self.duration_spin.setSingleStep(0.1)
        self.duration_spin.setDecimals(1)
        self.duration_spin.setSuffix(" ì´ˆ")
        self.duration_spin.setValue(0.0)
        options_layout.addRow("ì´ë™ ì‹œê°„:", self.duration_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Help text
        help_label = QLabel("ì´ë™ ì‹œê°„ì„ 0ìœ¼ë¡œ ì„¤ì •í•˜ë©´ ì¦‰ì‹œ ì´ë™í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-size: 12px;")
        layout.addWidget(help_label)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def add_monitor_info(self, parent_layout):
        """Add monitor information display"""
        monitors = get_monitor_info()
        
        if len(monitors) > 1:
            monitor_group = QGroupBox("ëª¨ë‹ˆí„° ì •ë³´")
            monitor_layout = QVBoxLayout()
            
            info_text = f"ê°ì§€ëœ ëª¨ë‹ˆí„°: {len(monitors)}ê°œ\n"
            for i, monitor in enumerate(monitors):
                name = "ì£¼ ëª¨ë‹ˆí„°" if monitor['is_primary'] else f"ëª¨ë‹ˆí„° {i+1}"
                info_text += f"â€¢ {name}: {monitor['width']}x{monitor['height']} (ìœ„ì¹˜: {monitor['x']}, {monitor['y']})\n"
            
            monitor_label = QLabel(info_text.strip())
            monitor_label.setStyleSheet("color: #666; font-size: 11px;")
            monitor_layout.addWidget(monitor_label)
            
            monitor_group.setLayout(monitor_layout)
            parent_layout.addWidget(monitor_group)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.x_spin.setValue(self.step.x)
        self.y_spin.setValue(self.step.y)
        self.duration_spin.setValue(self.step.duration)
        
    def capture_position(self):
        """Capture current mouse position"""
        # Capture immediately when F3 is pressed
        x, y = pyautogui.position()
        self.x_spin.setValue(x)
        self.y_spin.setValue(y)
        
        # Get monitor name for the position
        monitor_name = get_monitor_name_for_position(x, y)
        
        # Flash the button to indicate capture with monitor info
        self.capture_button.setText(f"ìº¡ì²˜ë¨! ({monitor_name}: {x}, {y})")
        QTimer.singleShot(1500, lambda: self.capture_button.setText("í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìº¡ì²˜ (F3)"))
        
        
    def select_from_screen(self):
        """Select position from screen"""
        self.hide()
        
        selector = ROISelectorWidget()
        # For now, just use capture position
        # TODO: Implement proper screen selection
        self.capture_position()
        return
        
        self.show()
        
        if result:
            x, y = result
            self.x_spin.setValue(x)
            self.y_spin.setValue(y)
            
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'x': self.x_spin.value(),
            'y': self.y_spin.value(),
            'duration': self.duration_spin.value()
        }
</file>

<file path="src/ui/dialogs/screenshot_step_dialog.py">
"""
Screenshot step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
    QPushButton, QDialogButtonBox, QFormLayout, QGroupBox,
    QComboBox, QCheckBox, QFileDialog, QMessageBox
)
from PyQt5.QtCore import Qt
from core.macro_types import ScreenshotStep
import os
from datetime import datetime


class ScreenshotStepDialog(QDialog):
    """Dialog for configuring screenshot step"""
    
    def __init__(self, step: ScreenshotStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("í™”ë©´ ìº¡ì²˜ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Step name
        name_layout = QFormLayout()
        self.name_edit = QLineEdit()
        name_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        layout.addLayout(name_layout)
        
        # File settings group
        file_group = QGroupBox("íŒŒì¼ ì„¤ì •")
        file_layout = QVBoxLayout()
        
        # Filename pattern
        pattern_layout = QHBoxLayout()
        pattern_layout.addWidget(QLabel("íŒŒì¼ëª… íŒ¨í„´:"))
        self.filename_edit = QLineEdit()
        self.filename_edit.setPlaceholderText("ì˜ˆ: screenshot_{timestamp}.png")
        pattern_layout.addWidget(self.filename_edit)
        file_layout.addLayout(pattern_layout)
        
        # Help text for filename patterns
        help_text = QLabel(
            "ì‚¬ìš© ê°€ëŠ¥í•œ ë³€ìˆ˜:\n"
            "â€¢ {timestamp} - í˜„ì¬ ì‹œê°„ (YYYYMMDD_HHMMSS)\n"
            "â€¢ {date} - í˜„ì¬ ë‚ ì§œ (YYYYMMDD)\n"
            "â€¢ {time} - í˜„ì¬ ì‹œê°„ (HHMMSS)\n"
            "â€¢ {index} - ìˆœë²ˆ (ìë™ ì¦ê°€)"
        )
        help_text.setWordWrap(True)
        help_text.setStyleSheet("color: #666; font-size: 11px; background-color: #f0f0f0; padding: 10px; border-radius: 5px;")
        file_layout.addWidget(help_text)
        
        # Save directory
        dir_layout = QHBoxLayout()
        dir_layout.addWidget(QLabel("ì €ì¥ ê²½ë¡œ:"))
        self.directory_edit = QLineEdit()
        self.directory_edit.setPlaceholderText("ê¸°ë³¸: ./screenshots/")
        dir_layout.addWidget(self.directory_edit)
        
        self.browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°...")
        self.browse_btn.clicked.connect(self.browse_directory)
        dir_layout.addWidget(self.browse_btn)
        file_layout.addLayout(dir_layout)
        
        file_group.setLayout(file_layout)
        layout.addWidget(file_group)
        
        # Capture options group
        options_group = QGroupBox("ìº¡ì²˜ ì˜µì…˜")
        options_layout = QVBoxLayout()
        
        # Full screen or region
        self.full_screen_checkbox = QCheckBox("ì „ì²´ í™”ë©´ ìº¡ì²˜")
        self.full_screen_checkbox.setChecked(True)
        self.full_screen_checkbox.toggled.connect(self.on_full_screen_toggled)
        options_layout.addWidget(self.full_screen_checkbox)
        
        # Region settings (disabled by default)
        region_layout = QHBoxLayout()
        region_layout.addWidget(QLabel("ì˜ì—­:"))
        
        self.x_edit = QLineEdit("0")
        self.x_edit.setMaximumWidth(80)
        self.x_edit.setEnabled(False)
        region_layout.addWidget(QLabel("X:"))
        region_layout.addWidget(self.x_edit)
        
        self.y_edit = QLineEdit("0")
        self.y_edit.setMaximumWidth(80)
        self.y_edit.setEnabled(False)
        region_layout.addWidget(QLabel("Y:"))
        region_layout.addWidget(self.y_edit)
        
        self.width_edit = QLineEdit("0")
        self.width_edit.setMaximumWidth(80)
        self.width_edit.setEnabled(False)
        region_layout.addWidget(QLabel("ë„ˆë¹„:"))
        region_layout.addWidget(self.width_edit)
        
        self.height_edit = QLineEdit("0")
        self.height_edit.setMaximumWidth(80)
        self.height_edit.setEnabled(False)
        region_layout.addWidget(QLabel("ë†’ì´:"))
        region_layout.addWidget(self.height_edit)
        
        region_layout.addStretch()
        options_layout.addLayout(region_layout)
        
        # Select region button
        self.select_region_btn = QPushButton("í™”ë©´ì—ì„œ ì˜ì—­ ì„ íƒ...")
        self.select_region_btn.setEnabled(False)
        self.select_region_btn.clicked.connect(self.select_region)
        options_layout.addWidget(self.select_region_btn)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.filename_edit.setText(self.step.filename_pattern)
        self.directory_edit.setText(self.step.save_directory)
        
        if self.step.region:
            self.full_screen_checkbox.setChecked(False)
            x, y, width, height = self.step.region
            self.x_edit.setText(str(x))
            self.y_edit.setText(str(y))
            self.width_edit.setText(str(width))
            self.height_edit.setText(str(height))
        else:
            self.full_screen_checkbox.setChecked(True)
            
    def on_full_screen_toggled(self, checked):
        """Handle full screen checkbox toggle"""
        self.x_edit.setEnabled(not checked)
        self.y_edit.setEnabled(not checked)
        self.width_edit.setEnabled(not checked)
        self.height_edit.setEnabled(not checked)
        self.select_region_btn.setEnabled(not checked)
        
    def browse_directory(self):
        """Browse for save directory"""
        directory = QFileDialog.getExistingDirectory(
            self,
            "ì €ì¥ ê²½ë¡œ ì„ íƒ",
            self.directory_edit.text() or "./screenshots/"
        )
        if directory:
            self.directory_edit.setText(directory)
            
    def select_region(self):
        """Select region from screen"""
        # TODO: Implement screen region selection
        # For now, just show a message
        QMessageBox.information(
            self,
            "ê¸°ëŠ¥ êµ¬í˜„ ì˜ˆì •",
            "í™”ë©´ ì˜ì—­ ì„ íƒ ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.\nìˆ˜ë™ìœ¼ë¡œ ì¢Œí‘œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."
        )
        
    def validate_and_accept(self):
        """Validate input and accept"""
        # Default filename if empty
        if not self.filename_edit.text():
            self.filename_edit.setText("screenshot_{timestamp}.png")
            
        # Default directory if empty
        if not self.directory_edit.text():
            self.directory_edit.setText("./screenshots/")
            
        # Validate region if not full screen
        if not self.full_screen_checkbox.isChecked():
            try:
                x = int(self.x_edit.text())
                y = int(self.y_edit.text())
                width = int(self.width_edit.text())
                height = int(self.height_edit.text())
                
                if width <= 0 or height <= 0:
                    raise ValueError("ë„ˆë¹„ì™€ ë†’ì´ëŠ” 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤")
                    
            except ValueError as e:
                QMessageBox.warning(
                    self, "ê²½ê³ ",
                    f"ì˜ëª»ëœ ì˜ì—­ ì„¤ì •: {str(e)}"
                )
                return
                
        self.accept()
        
    def get_step_data(self):
        """Get configured step data"""
        region = None
        if not self.full_screen_checkbox.isChecked():
            region = (
                int(self.x_edit.text()),
                int(self.y_edit.text()),
                int(self.width_edit.text()),
                int(self.height_edit.text())
            )
            
        return {
            'name': self.name_edit.text() or "í™”ë©´ ìº¡ì²˜",
            'filename_pattern': self.filename_edit.text() or "screenshot_{timestamp}.png",
            'save_directory': self.directory_edit.text() or "./screenshots/",
            'region': region
        }
</file>

<file path="src/ui/dialogs/wait_time_step_dialog.py">
"""
Wait time step configuration dialog
"""

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, 
    QDoubleSpinBox, QDialogButtonBox, QFormLayout
)
from PyQt5.QtCore import Qt
from core.macro_types import WaitTimeStep


class WaitTimeStepDialog(QDialog):
    """Dialog for configuring wait time step"""
    
    def __init__(self, step: WaitTimeStep, parent=None):
        super().__init__(parent)
        self.step = step
        self.setWindowTitle("ëŒ€ê¸° ì‹œê°„ ì„¤ì •")
        self.setModal(True)
        self.setFixedWidth(300)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Form layout
        form_layout = QFormLayout()
        
        # Step name
        self.name_edit = QLineEdit()
        form_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        
        # Wait time
        self.seconds_spin = QDoubleSpinBox()
        self.seconds_spin.setRange(0.1, 3600.0)
        self.seconds_spin.setSingleStep(0.5)
        self.seconds_spin.setDecimals(1)
        self.seconds_spin.setSuffix(" ì´ˆ")
        self.seconds_spin.setValue(1.0)
        form_layout.addRow("ëŒ€ê¸° ì‹œê°„:", self.seconds_spin)
        
        layout.addLayout(form_layout)
        
        # Help text
        help_label = QLabel("ì§€ì •ëœ ì‹œê°„ ë™ì•ˆ ì‹¤í–‰ì„ ì¼ì‹œ ì •ì§€í•©ë‹ˆë‹¤.")
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-size: 12px;")
        layout.addWidget(help_label)
        
        layout.addStretch()
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        self.seconds_spin.setValue(self.step.seconds)
        
    def get_step_data(self):
        """Get configured step data"""
        return {
            'name': self.name_edit.text(),
            'seconds': self.seconds_spin.value()
        }
</file>

<file path="src/ui/widgets/__init__.py">
# UI Widgets
</file>

<file path="src/ui/widgets/data_preview.py">
"""
Excel data preview widget with pagination
"""

from typing import Optional, List
import pandas as pd
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, 
    QTableWidgetItem, QPushButton, QLabel, QSpinBox,
    QComboBox, QLineEdit, QCheckBox, QHeaderView,
    QGroupBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QColor, QBrush
from excel.models import ExcelData, ColumnType

class DataPreviewTable(QTableWidget):
    """Table widget for previewing Excel data"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Configure table appearance
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QTableWidget.SelectRows)
        self.horizontalHeader().setStretchLastSection(True)
        self.verticalHeader().setDefaultSectionSize(24)
        
    def load_data(self, dataframe: pd.DataFrame, start_row: int = 0, 
                  rows_per_page: int = 100, highlight_status: bool = True):
        """Load data into table"""
        # Clear existing data
        self.clear()
        
        # Set columns
        columns = dataframe.columns.tolist()
        self.setColumnCount(len(columns))
        self.setHorizontalHeaderLabels(columns)
        
        # Determine rows to display
        end_row = min(start_row + rows_per_page, len(dataframe))
        display_rows = end_row - start_row
        self.setRowCount(display_rows)
        
        # Find status column
        status_col_idx = None
        if highlight_status:
            status_columns = ['ìƒíƒœ', 'Status', 'ì™„ë£Œì—¬ë¶€', 'ì²˜ë¦¬ìƒíƒœ', 'status', 'STATUS']
            for idx, col in enumerate(columns):
                if col in status_columns:
                    status_col_idx = idx
                    break
        
        # Populate data
        for row in range(display_rows):
            df_row = start_row + row
            
            # Set row header to show actual row number
            self.setVerticalHeaderItem(row, QTableWidgetItem(str(df_row + 1)))
            
            for col in range(len(columns)):
                value = dataframe.iloc[df_row, col]
                
                # Handle different data types
                if pd.isna(value):
                    item_text = ""
                elif isinstance(value, float):
                    item_text = f"{value:.2f}" if value % 1 else str(int(value))
                else:
                    item_text = str(value)
                
                item = QTableWidgetItem(item_text)
                
                # Apply status highlighting
                if col == status_col_idx and highlight_status:
                    if value in ['ì™„ë£Œ', 'Completed', 'Complete', 'Done']:
                        item.setBackground(QBrush(QColor(200, 255, 200)))
                    elif value in ['ì‹¤íŒ¨', 'Failed', 'Error']:
                        item.setBackground(QBrush(QColor(255, 200, 200)))
                    elif value in ['ì§„í–‰ì¤‘', 'Processing', 'In Progress']:
                        item.setBackground(QBrush(QColor(255, 255, 200)))
                
                self.setItem(row, col, item)
        
        # Resize columns to content
        self.resizeColumnsToContents()

class DataPreviewWidget(QWidget):
    """Complete data preview widget with controls"""
    
    rowSelected = pyqtSignal(int)  # Emit actual dataframe row index
    
    def __init__(self):
        super().__init__()
        self.excel_data: Optional[ExcelData] = None
        self.current_page = 0
        self.rows_per_page = 100
        self.filtered_indices: Optional[List[int]] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Filter controls
        filter_group = QGroupBox("í•„í„° ì˜µì…˜")
        filter_layout = QHBoxLayout()
        
        # Status filter
        self.incomplete_only = QCheckBox("ë¯¸ì™„ë£Œ í•­ëª©ë§Œ í‘œì‹œ")
        self.incomplete_only.stateChanged.connect(self._apply_filter)
        filter_layout.addWidget(self.incomplete_only)
        
        # Search
        filter_layout.addWidget(QLabel("ê²€ìƒ‰:"))
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("ê²€ìƒ‰ì–´ ì…ë ¥...")
        self.search_input.textChanged.connect(self._apply_filter)
        filter_layout.addWidget(self.search_input)
        
        filter_layout.addStretch()
        filter_group.setLayout(filter_layout)
        layout.addWidget(filter_group)
        
        # Data table
        self.data_table = DataPreviewTable()
        self.data_table.cellDoubleClicked.connect(self._on_cell_double_clicked)
        layout.addWidget(self.data_table)
        
        # Pagination controls
        pagination_layout = QHBoxLayout()
        
        # Page size
        pagination_layout.addWidget(QLabel("í–‰/í˜ì´ì§€:"))
        self.page_size_spin = QSpinBox()
        self.page_size_spin.setRange(10, 1000)
        self.page_size_spin.setSingleStep(50)
        self.page_size_spin.setValue(self.rows_per_page)
        self.page_size_spin.valueChanged.connect(self._on_page_size_changed)
        pagination_layout.addWidget(self.page_size_spin)
        
        pagination_layout.addStretch()
        
        # Page navigation
        self.prev_btn = QPushButton("â—€ ì´ì „")
        self.prev_btn.clicked.connect(self._prev_page)
        pagination_layout.addWidget(self.prev_btn)
        
        self.page_label = QLabel("1 / 1")
        pagination_layout.addWidget(self.page_label)
        
        self.next_btn = QPushButton("ë‹¤ìŒ â–¶")
        self.next_btn.clicked.connect(self._next_page)
        pagination_layout.addWidget(self.next_btn)
        
        pagination_layout.addStretch()
        
        # Row count info
        self.row_info_label = QLabel()
        pagination_layout.addWidget(self.row_info_label)
        
        layout.addLayout(pagination_layout)
        self.setLayout(layout)
        
    def load_excel_data(self, excel_data: ExcelData):
        """Load Excel data for preview"""
        self.excel_data = excel_data
        self.current_page = 0
        self.filtered_indices = None
        self._apply_filter()
        
    def _apply_filter(self):
        """Apply current filter settings"""
        if not self.excel_data:
            return
            
        df = self.excel_data.dataframe
        
        # Start with all rows
        mask = pd.Series([True] * len(df))
        
        # Apply incomplete filter
        if self.incomplete_only.isChecked():
            status_col = self.excel_data.get_status_column()
            if status_col:
                mask &= ~df[status_col].isin(['ì™„ë£Œ', 'Completed', 'Complete', 'Done'])
        
        # Apply search filter
        search_text = self.search_input.text().strip()
        if search_text:
            search_mask = pd.Series([False] * len(df))
            for col in df.columns:
                if df[col].dtype == 'object':  # String columns only
                    search_mask |= df[col].astype(str).str.contains(
                        search_text, case=False, na=False
                    )
            mask &= search_mask
        
        # Get filtered indices
        self.filtered_indices = df[mask].index.tolist()
        
        # Reset to first page
        self.current_page = 0
        self._update_display()
        
    def _update_display(self):
        """Update table display"""
        if not self.excel_data:
            return
            
        df = self.excel_data.dataframe
        
        # Use filtered data if available
        if self.filtered_indices is not None:
            if not self.filtered_indices:
                self.data_table.setRowCount(0)
                self._update_pagination_controls()
                return
            display_df = df.loc[self.filtered_indices]
        else:
            display_df = df
        
        # Calculate page boundaries
        start_idx = self.current_page * self.rows_per_page
        
        # Load data into table
        self.data_table.load_data(
            display_df,
            start_row=start_idx,
            rows_per_page=self.rows_per_page
        )
        
        self._update_pagination_controls()
        
    def _update_pagination_controls(self):
        """Update pagination control states"""
        if not self.excel_data:
            return
            
        # Calculate total pages
        if self.filtered_indices is not None:
            total_rows = len(self.filtered_indices)
        else:
            total_rows = len(self.excel_data.dataframe)
            
        total_pages = max(1, (total_rows + self.rows_per_page - 1) // self.rows_per_page)
        
        # Update label
        self.page_label.setText(f"{self.current_page + 1} / {total_pages}")
        
        # Update button states
        self.prev_btn.setEnabled(self.current_page > 0)
        self.next_btn.setEnabled(self.current_page < total_pages - 1)
        
        # Update row info
        if self.filtered_indices is not None:
            self.row_info_label.setText(
                f"í‘œì‹œ: {len(self.filtered_indices)} / ì „ì²´: {len(self.excel_data.dataframe)} í–‰"
            )
        else:
            self.row_info_label.setText(f"ì „ì²´: {total_rows} í–‰")
        
    def _on_page_size_changed(self, value: int):
        """Handle page size change"""
        self.rows_per_page = value
        self.current_page = 0
        self._update_display()
        
    def _prev_page(self):
        """Go to previous page"""
        if self.current_page > 0:
            self.current_page -= 1
            self._update_display()
            
    def _next_page(self):
        """Go to next page"""
        self.current_page += 1
        self._update_display()
        
    def _on_cell_double_clicked(self, row: int, column: int):
        """Handle cell double click"""
        # Calculate actual dataframe row index
        actual_row = self.current_page * self.rows_per_page + row
        
        if self.filtered_indices is not None:
            if actual_row < len(self.filtered_indices):
                df_row_index = self.filtered_indices[actual_row]
                self.rowSelected.emit(df_row_index)
        else:
            self.rowSelected.emit(actual_row)
</file>

<file path="src/ui/widgets/file_selector.py">
"""
Excel file selection widget with drag-drop support
"""

import os
from pathlib import Path
from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
    QLabel, QListWidget, QListWidgetItem, QFileDialog,
    QGroupBox, QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QMimeData
from PyQt5.QtGui import QDragEnterEvent, QDropEvent, QIcon

class FileDropArea(QLabel):
    """Drag and drop area for Excel files"""
    
    fileDropped = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setAcceptDrops(True)
        self.setAlignment(Qt.AlignCenter)
        self.setStyleSheet("""
            QLabel {
                border: 2px dashed #aaa;
                border-radius: 5px;
                padding: 20px;
                background-color: #f5f5f5;
                min-height: 100px;
            }
            QLabel:hover {
                border-color: #555;
                background-color: #e8e8e8;
            }
        """)
        self.setText("ì—‘ì…€ íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ê±°ë‚˜\nì•„ë˜ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”")
        
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event"""
        if event.mimeData().hasUrls():
            # Check if any file is Excel
            for url in event.mimeData().urls():
                if url.isLocalFile():
                    path = url.toLocalFile()
                    if path.lower().endswith(('.xlsx', '.xls', '.xlsm')):
                        event.acceptProposedAction()
                        self.setStyleSheet("""
                            QLabel {
                                border: 2px solid #4CAF50;
                                border-radius: 5px;
                                padding: 20px;
                                background-color: #e8f5e9;
                                min-height: 100px;
                            }
                        """)
                        return
        event.ignore()
        
    def dragLeaveEvent(self, event):
        """Handle drag leave event"""
        self.setStyleSheet("""
            QLabel {
                border: 2px dashed #aaa;
                border-radius: 5px;
                padding: 20px;
                background-color: #f5f5f5;
                min-height: 100px;
            }
        """)
        
    def dropEvent(self, event: QDropEvent):
        """Handle drop event"""
        for url in event.mimeData().urls():
            if url.isLocalFile():
                path = url.toLocalFile()
                if path.lower().endswith(('.xlsx', '.xls', '.xlsm')):
                    self.fileDropped.emit(path)
                    event.acceptProposedAction()
                    self.dragLeaveEvent(None)
                    return

class RecentFilesList(QListWidget):
    """List of recently opened Excel files"""
    
    fileSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setMaximumHeight(150)
        self.itemDoubleClicked.connect(self._on_item_double_clicked)
        
    def add_recent_file(self, file_path: str):
        """Add file to recent files list"""
        # Check if already exists
        for i in range(self.count()):
            if self.item(i).data(Qt.UserRole) == file_path:
                # Move to top
                item = self.takeItem(i)
                self.insertItem(0, item)
                return
        
        # Add new item
        file_name = os.path.basename(file_path)
        item = QListWidgetItem(file_name)
        item.setData(Qt.UserRole, file_path)
        item.setToolTip(file_path)
        self.insertItem(0, item)
        
        # Keep only 10 recent files
        while self.count() > 10:
            self.takeItem(self.count() - 1)
            
    def _on_item_double_clicked(self, item: QListWidgetItem):
        """Handle double click on item"""
        file_path = item.data(Qt.UserRole)
        if file_path and os.path.exists(file_path):
            self.fileSelected.emit(file_path)

class FileSelectorWidget(QWidget):
    """Excel file selection widget"""
    
    fileSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.current_file: Optional[str] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Current file info
        self.file_info_label = QLabel("ì„ íƒëœ íŒŒì¼: ì—†ìŒ")
        self.file_info_label.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(self.file_info_label)
        
        # Drop area
        self.drop_area = FileDropArea()
        self.drop_area.fileDropped.connect(self._on_file_selected)
        layout.addWidget(self.drop_area)
        
        # Browse button
        browse_button = QPushButton("íŒŒì¼ ì°¾ì•„ë³´ê¸°...")
        browse_button.clicked.connect(self._browse_file)
        layout.addWidget(browse_button)
        
        # Recent files
        recent_group = QGroupBox("ìµœê·¼ íŒŒì¼")
        recent_layout = QVBoxLayout()
        self.recent_files = RecentFilesList()
        self.recent_files.fileSelected.connect(self._on_file_selected)
        recent_layout.addWidget(self.recent_files)
        recent_group.setLayout(recent_layout)
        layout.addWidget(recent_group)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def _browse_file(self):
        """Open file dialog to select Excel file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "ì—‘ì…€ íŒŒì¼ ì„ íƒ",
            "",
            "Excel Files (*.xlsx *.xls *.xlsm);;All Files (*.*)"
        )
        
        if file_path:
            self._on_file_selected(file_path)
            
    def _on_file_selected(self, file_path: str):
        """Handle file selection"""
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "íŒŒì¼ ì˜¤ë¥˜", f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n{file_path}")
            return
            
        self.current_file = file_path
        self.file_info_label.setText(f"ì„ íƒëœ íŒŒì¼: {os.path.basename(file_path)}")
        self.recent_files.add_recent_file(file_path)
        self.fileSelected.emit(file_path)
        
    def get_recent_files(self) -> list:
        """Get list of recent files"""
        files = []
        for i in range(self.recent_files.count()):
            item = self.recent_files.item(i)
            files.append(item.data(Qt.UserRole))
        return files
        
    def set_recent_files(self, files: list):
        """Set recent files list"""
        self.recent_files.clear()
        for file_path in files:
            if os.path.exists(file_path):
                self.recent_files.add_recent_file(file_path)
</file>

<file path="src/ui/widgets/sheet_mapper.py">
"""
Sheet and column mapping UI widget
"""

from typing import Dict, List, Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QComboBox, 
    QTableWidget, QTableWidgetItem, QPushButton,
    QLabel, QGroupBox, QHeaderView, QCheckBox,
    QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from excel.models import SheetInfo, ColumnInfo, ColumnMapping, ColumnType

class SheetSelectorWidget(QWidget):
    """Widget for selecting Excel sheet"""
    
    sheetSelected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.sheets: List[SheetInfo] = []
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        layout.addWidget(QLabel("ì‹œíŠ¸ ì„ íƒ:"))
        
        self.sheet_combo = QComboBox()
        self.sheet_combo.setMinimumWidth(200)
        self.sheet_combo.currentTextChanged.connect(self.sheetSelected.emit)
        layout.addWidget(self.sheet_combo)
        
        self.info_label = QLabel()
        layout.addWidget(self.info_label)
        
        layout.addStretch()
        self.setLayout(layout)
        
    def set_sheets(self, sheets: List[SheetInfo]):
        """Set available sheets"""
        self.sheets = sheets
        self.sheet_combo.clear()
        
        for sheet in sheets:
            display_text = f"{sheet.name} ({sheet.row_count}í–‰ Ã— {sheet.column_count}ì—´)"
            self.sheet_combo.addItem(display_text, sheet.name)
            
        if sheets:
            self.sheetSelected.emit(sheets[0].name)
            
    def get_selected_sheet(self) -> Optional[str]:
        """Get currently selected sheet name"""
        if self.sheet_combo.currentData():
            return self.sheet_combo.currentData()
        return None

class ColumnMappingTable(QTableWidget):
    """Table widget for column mapping"""
    
    mappingChanged = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        self.columns: List[ColumnInfo] = []
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Set headers
        self.setColumnCount(6)
        self.setHorizontalHeaderLabels([
            "ì‚¬ìš©", "ì—‘ì…€ ì—´", "ë³€ìˆ˜ëª…", "ë°ì´í„° íƒ€ì…", "ìƒ˜í”Œ ë°ì´í„°", "í•„ìˆ˜"
        ])
        
        # Configure table
        self.horizontalHeader().setStretchLastSection(False)
        self.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(5, QHeaderView.Fixed)
        
        self.setColumnWidth(0, 50)  # ì‚¬ìš©
        self.setColumnWidth(5, 50)  # í•„ìˆ˜
        
        # Enable sorting
        self.setSortingEnabled(True)
        
    def set_columns(self, columns: List[ColumnInfo]):
        """Set columns for mapping"""
        self.columns = columns
        self.setRowCount(len(columns))
        
        for row, col_info in enumerate(columns):
            # Use checkbox
            use_checkbox = QCheckBox()
            use_checkbox.setChecked(True)
            use_checkbox.stateChanged.connect(self.mappingChanged.emit)
            self.setCellWidget(row, 0, use_checkbox)
            
            # Excel column name
            col_item = QTableWidgetItem(col_info.name)
            col_item.setFlags(col_item.flags() & ~Qt.ItemIsEditable)
            self.setItem(row, 1, col_item)
            
            # Variable name (editable)
            var_name = self._generate_variable_name(col_info.name)
            var_item = QTableWidgetItem(var_name)
            self.setItem(row, 2, var_item)
            
            # Data type
            type_combo = QComboBox()
            type_combo.addItems([t.value for t in ColumnType])
            type_combo.setCurrentText(col_info.data_type.value)
            self.setCellWidget(row, 3, type_combo)
            
            # Sample data
            sample_text = ", ".join(str(v) for v in col_info.sample_values[:3])
            if len(col_info.sample_values) > 3:
                sample_text += "..."
            sample_item = QTableWidgetItem(sample_text)
            sample_item.setFlags(sample_item.flags() & ~Qt.ItemIsEditable)
            sample_item.setToolTip("\n".join(str(v) for v in col_info.sample_values))
            self.setItem(row, 4, sample_item)
            
            # Required checkbox
            required_checkbox = QCheckBox()
            required_checkbox.setChecked(False)
            self.setCellWidget(row, 5, required_checkbox)
            
    def _generate_variable_name(self, column_name: str) -> str:
        """Generate variable name from column name"""
        # Remove special characters and convert to snake_case
        import re
        var_name = re.sub(r'[^\w\s]', '', column_name)
        var_name = var_name.strip().lower().replace(' ', '_')
        
        # Ensure it starts with letter
        if var_name and not var_name[0].isalpha():
            var_name = 'col_' + var_name
            
        return var_name or 'column'
        
    def get_mappings(self) -> List[ColumnMapping]:
        """Get current column mappings"""
        mappings = []
        
        for row in range(self.rowCount()):
            use_checkbox = self.cellWidget(row, 0)
            if not use_checkbox.isChecked():
                continue
                
            excel_col = self.item(row, 1).text()
            var_name = self.item(row, 2).text()
            type_combo = self.cellWidget(row, 3)
            required_checkbox = self.cellWidget(row, 5)
            
            if var_name.strip():  # Only add if variable name is not empty
                mapping = ColumnMapping(
                    excel_column=excel_col,
                    variable_name=var_name.strip(),
                    data_type=ColumnType(type_combo.currentText()),
                    is_required=required_checkbox.isChecked()
                )
                mappings.append(mapping)
                
        return mappings

class SheetMapperWidget(QWidget):
    """Complete sheet and column mapping widget"""
    
    mappingComplete = pyqtSignal(str, list)  # sheet_name, mappings
    
    def __init__(self):
        super().__init__()
        self.current_sheet: Optional[SheetInfo] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Sheet selector
        self.sheet_selector = SheetSelectorWidget()
        self.sheet_selector.sheetSelected.connect(self._on_sheet_selected)
        layout.addWidget(self.sheet_selector)
        
        # Column mapping
        mapping_group = QGroupBox("ì—´ ë§¤í•‘ ì„¤ì •")
        mapping_layout = QVBoxLayout()
        
        # Mapping table
        self.mapping_table = ColumnMappingTable()
        mapping_layout.addWidget(self.mapping_table)
        
        # Auto-detect status column
        auto_layout = QHBoxLayout()
        self.auto_detect_btn = QPushButton("ìƒíƒœ ì—´ ìë™ ê°ì§€")
        self.auto_detect_btn.clicked.connect(self._auto_detect_status)
        auto_layout.addWidget(self.auto_detect_btn)
        
        self.status_label = QLabel()
        auto_layout.addWidget(self.status_label)
        auto_layout.addStretch()
        
        mapping_layout.addLayout(auto_layout)
        mapping_group.setLayout(mapping_layout)
        layout.addWidget(mapping_group)
        
        # Apply button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        self.apply_btn = QPushButton("ë§¤í•‘ ì ìš©")
        self.apply_btn.clicked.connect(self._apply_mapping)
        button_layout.addWidget(self.apply_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def set_file_info(self, sheets: List[SheetInfo]):
        """Set file information"""
        self.sheet_selector.set_sheets(sheets)
        
    def _on_sheet_selected(self, sheet_name: str):
        """Handle sheet selection"""
        # Find sheet info
        for sheet in self.sheet_selector.sheets:
            if sheet.name == sheet_name:
                self.current_sheet = sheet
                self.mapping_table.set_columns(sheet.columns)
                self._auto_detect_status()
                break
                
    def _auto_detect_status(self):
        """Auto-detect status column"""
        if not self.current_sheet:
            return
            
        status_keywords = ['ìƒíƒœ', 'Status', 'ì™„ë£Œ', 'ì²˜ë¦¬', 'status', 'STATUS']
        
        for row in range(self.mapping_table.rowCount()):
            col_name = self.mapping_table.item(row, 1).text()
            
            # Check if column name contains status keywords
            for keyword in status_keywords:
                if keyword in col_name:
                    # Set as status column
                    self.mapping_table.item(row, 2).setText('status')
                    required_checkbox = self.mapping_table.cellWidget(row, 5)
                    required_checkbox.setChecked(True)
                    self.status_label.setText(f"ìƒíƒœ ì—´ ê°ì§€ë¨: {col_name}")
                    return
                    
        self.status_label.setText("ìƒíƒœ ì—´ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ (ìë™ ìƒì„±ë¨)")
        
    def _apply_mapping(self):
        """Apply current mapping"""
        if not self.sheet_selector.get_selected_sheet():
            QMessageBox.warning(self, "ê²½ê³ ", "ì‹œíŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return
            
        mappings = self.mapping_table.get_mappings()
        if not mappings:
            QMessageBox.warning(self, "ê²½ê³ ", "ìµœì†Œ í•˜ë‚˜ ì´ìƒì˜ ì—´ì„ ë§¤í•‘í•´ì£¼ì„¸ìš”.")
            return
            
        # Check for duplicate variable names
        var_names = [m.variable_name for m in mappings]
        if len(var_names) != len(set(var_names)):
            QMessageBox.warning(self, "ê²½ê³ ", "ë³€ìˆ˜ëª…ì´ ì¤‘ë³µë˜ì—ˆìŠµë‹ˆë‹¤.")
            return
            
        self.mappingComplete.emit(
            self.sheet_selector.get_selected_sheet(),
            mappings
        )
</file>

<file path="src/ui/widgets/simple_roi_selector.py">
"""
Simple ROI selector using screenshot approach
"""

import os
import time
from typing import Optional, Tuple
from PyQt5.QtWidgets import QWidget, QLabel, QRubberBand
from PyQt5.QtCore import Qt, QRect, QPoint, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor, QCursor
import pyautogui


class SimpleROISelector(QWidget):
    """Simple ROI selector that uses screenshot approach"""
    
    selectionComplete = pyqtSignal(tuple)  # (x, y, width, height)
    selectionCancelled = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Selection state
        self.origin = QPoint()
        self.rubber_band = None
        self.screenshot_pixmap = None
        
        # Setup window
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setWindowState(Qt.WindowFullScreen)
        self.setCursor(Qt.CrossCursor)
        
        # Instructions label
        self.label = QLabel(self)
        self.label.setText("ë“œë˜ê·¸í•˜ì—¬ ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”. ESC: ì·¨ì†Œ")
        self.label.setStyleSheet("""
            QLabel {
                background-color: rgba(0, 0, 0, 180);
                color: white;
                padding: 10px;
                font-size: 16px;
                font-weight: bold;
            }
        """)
        self.label.adjustSize()
        self.label.move(10, 10)
        
    def start_selection(self):
        """Start ROI selection"""
        # Take screenshot first
        try:
            # Hide any windows
            QTimer.singleShot(100, self._take_screenshot)
        except Exception as e:
            print(f"Screenshot error: {e}")
            self.selectionCancelled.emit()
            self.close()
            
    def _take_screenshot(self):
        """Take screenshot and show selector"""
        try:
            # Take screenshot using pyautogui
            screenshot = pyautogui.screenshot()
            
            # Convert to QPixmap
            import io
            from PIL import Image
            
            # Save to bytes
            buffer = io.BytesIO()
            screenshot.save(buffer, format='PNG')
            buffer.seek(0)
            
            # Load as QPixmap
            self.screenshot_pixmap = QPixmap()
            self.screenshot_pixmap.loadFromData(buffer.read())
            
            # Set window size to screen size
            self.resize(self.screenshot_pixmap.size())
            
            # Show window
            self.show()
            self.raise_()
            self.activateWindow()
            
        except Exception as e:
            print(f"Screenshot error: {e}")
            self.selectionCancelled.emit()
            self.close()
            
    def paintEvent(self, event):
        """Paint screenshot as background"""
        if self.screenshot_pixmap:
            painter = QPainter(self)
            painter.drawPixmap(0, 0, self.screenshot_pixmap)
            
            # Darken the screenshot slightly
            painter.fillRect(self.rect(), QColor(0, 0, 0, 50))
            
    def mousePressEvent(self, event):
        """Handle mouse press"""
        if event.button() == Qt.LeftButton:
            self.origin = event.pos()
            
            if not self.rubber_band:
                self.rubber_band = QRubberBand(QRubberBand.Rectangle, self)
                self.rubber_band.setStyleSheet("""
                    QRubberBand {
                        border: 2px solid rgb(50, 150, 250);
                        background-color: rgba(50, 150, 250, 30);
                    }
                """)
                
            self.rubber_band.setGeometry(QRect(self.origin, event.pos()))
            self.rubber_band.show()
            
    def mouseMoveEvent(self, event):
        """Handle mouse move"""
        if self.rubber_band and event.buttons() == Qt.LeftButton:
            self.rubber_band.setGeometry(QRect(self.origin, event.pos()).normalized())
            
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() == Qt.LeftButton and self.rubber_band:
            rect = self.rubber_band.geometry()
            
            if rect.width() > 5 and rect.height() > 5:
                # Emit the selection - ensure all values are integers
                region = (int(rect.x()), int(rect.y()), int(rect.width()), int(rect.height()))
                self.selectionComplete.emit(region)
            
            self.close()
            
    def keyPressEvent(self, event):
        """Handle key press"""
        if event.key() == Qt.Key_Escape:
            self.selectionCancelled.emit()
            self.close()
            
    def close(self):
        """Clean up and close"""
        if self.rubber_band:
            self.rubber_band.hide()
        super().close()
</file>

<file path="src/utils/clipboard_utils.py">
"""
Clipboard utilities for cross-platform image handling
"""

import os
import sys
import time
import subprocess
from typing import Optional
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtWidgets import QApplication
from utils.path_utils import get_captures_dir, is_wsl


def save_clipboard_image() -> Optional[str]:
    """
    Try multiple methods to save clipboard image to file
    Returns the saved file path or None if no image found
    """
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    filename = f"clipboard_{timestamp}.png"
    
    # Create captures directory using path utility
    captures_dir = get_captures_dir()
    file_path = os.path.join(captures_dir, filename)
    
    # Method 1: Try Windows PowerShell if in WSL
    if is_wsl():
        if save_from_windows_clipboard(file_path):
            return file_path
    
    # Method 2: Try Qt clipboard
    if save_from_qt_clipboard(file_path):
        return file_path
    
    # Method 3: Try PIL
    if save_from_pil_clipboard(file_path):
        return file_path
    
    return None


def save_from_windows_clipboard(file_path: str) -> bool:
    """
    Use PowerShell to save clipboard image (WSL specific)
    """
    try:
        # Convert WSL path to Windows path
        win_path = subprocess.check_output(['wslpath', '-w', file_path]).decode().strip()
        
        # PowerShell script to save clipboard image
        ps_script = f'''
        Add-Type -Assembly System.Windows.Forms
        $clipboard = [System.Windows.Forms.Clipboard]::GetImage()
        if ($clipboard -ne $null) {{
            $clipboard.Save("{win_path}", [System.Drawing.Imaging.ImageFormat]::Png)
            Write-Host "SUCCESS"
        }} else {{
            Write-Host "NO_IMAGE"
        }}
        '''
        
        # Run PowerShell command
        result = subprocess.run(
            ['powershell.exe', '-Command', ps_script],
            capture_output=True,
            text=True
        )
        
        if "SUCCESS" in result.stdout:
            print("Successfully saved image from Windows clipboard")
            return True
        elif "NO_IMAGE" in result.stdout:
            print("No image in Windows clipboard")
        else:
            print(f"PowerShell error: {result.stderr}")
            
    except Exception as e:
        print(f"Windows clipboard error: {e}")
    
    return False


def save_from_qt_clipboard(file_path: str) -> bool:
    """
    Save image from Qt clipboard
    """
    try:
        clipboard = QApplication.clipboard()
        
        # Try image first
        if clipboard.mimeData().hasImage():
            image = clipboard.image()
            if not image.isNull():
                if image.save(file_path, "PNG"):
                    print("Successfully saved image from Qt clipboard")
                    return True
        
        # Try pixmap
        pixmap = clipboard.pixmap()
        if not pixmap.isNull():
            if pixmap.save(file_path, "PNG"):
                print("Successfully saved pixmap from Qt clipboard")
                return True
                
    except Exception as e:
        print(f"Qt clipboard error: {e}")
    
    return False


def save_from_pil_clipboard(file_path: str) -> bool:
    """
    Save image from PIL clipboard
    """
    try:
        from PIL import ImageGrab
        
        # Try multiple times with delay
        for attempt in range(3):
            if attempt > 0:
                time.sleep(0.1)
                
            img = ImageGrab.grabclipboard()
            if img:
                img.save(file_path)
                print("Successfully saved image from PIL clipboard")
                return True
                
    except Exception as e:
        print(f"PIL clipboard error: {e}")
    
    return False
</file>

<file path="src/utils/encryption.py">
"""
AES-256 encryption utilities for secure storage
"""

import os
from pathlib import Path
from typing import Optional
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
import base64

class EncryptionManager:
    """Handles AES-256 encryption/decryption for configuration and macro files"""
    
    def __init__(self, key_file: Optional[Path] = None):
        """Initialize encryption manager with key"""
        self.key_file = key_file or Path.home() / ".excel_macro_automation" / ".key"
        self.key = self._load_or_generate_key()
    
    def _load_or_generate_key(self) -> bytes:
        """Load existing key or generate new one"""
        if self.key_file.exists():
            return base64.b64decode(self.key_file.read_bytes())
        else:
            # Generate new key
            key = os.urandom(32)  # 256 bits
            self.key_file.parent.mkdir(parents=True, exist_ok=True)
            self.key_file.write_bytes(base64.b64encode(key))
            # Set restrictive permissions (Unix-like systems)
            if hasattr(os, 'chmod'):
                os.chmod(self.key_file, 0o600)
            return key
    
    def derive_key(self, password: str, salt: bytes) -> bytes:
        """Derive key from password using PBKDF2"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        return kdf.derive(password.encode())
    
    def encrypt(self, data: bytes, password: Optional[str] = None) -> bytes:
        """Encrypt data using AES-256-CBC"""
        # Use password-derived key if provided, otherwise use stored key
        if password:
            salt = os.urandom(16)
            key = self.derive_key(password, salt)
        else:
            salt = b''
            key = self.key
        
        # Generate IV
        iv = os.urandom(16)
        
        # Pad data to block size
        padder = padding.PKCS7(128).padder()
        padded_data = padder.update(data) + padder.finalize()
        
        # Encrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        
        # Return salt + iv + encrypted data
        return salt + iv + encrypted_data
    
    def decrypt(self, encrypted_data: bytes, password: Optional[str] = None) -> bytes:
        """Decrypt data using AES-256-CBC"""
        # Extract components
        if password:
            salt = encrypted_data[:16]
            iv = encrypted_data[16:32]
            ciphertext = encrypted_data[32:]
            key = self.derive_key(password, salt)
        else:
            iv = encrypted_data[:16]
            ciphertext = encrypted_data[16:]
            key = self.key
        
        # Decrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(ciphertext) + decryptor.finalize()
        
        # Remove padding
        unpadder = padding.PKCS7(128).unpadder()
        data = unpadder.update(padded_data) + unpadder.finalize()
        
        return data
    
    def encrypt_file(self, input_path: Path, output_path: Path, password: Optional[str] = None) -> None:
        """Encrypt a file"""
        data = input_path.read_bytes()
        encrypted_data = self.encrypt(data, password)
        output_path.write_bytes(encrypted_data)
    
    def decrypt_file(self, input_path: Path, output_path: Path, password: Optional[str] = None) -> None:
        """Decrypt a file"""
        encrypted_data = input_path.read_bytes()
        data = self.decrypt(encrypted_data, password)
        output_path.write_bytes(data)


# Global encryption manager instance
_encryption_manager = None


def get_encryption_manager() -> EncryptionManager:
    """Get global encryption manager instance"""
    global _encryption_manager
    if _encryption_manager is None:
        _encryption_manager = EncryptionManager()
    return _encryption_manager


def encrypt_data(data: str, password: str) -> bytes:
    """Encrypt string data with password"""
    manager = get_encryption_manager()
    return manager.encrypt(data.encode('utf-8'), password)


def decrypt_data(encrypted_data: bytes, password: str) -> str:
    """Decrypt data with password and return as string"""
    manager = get_encryption_manager()
    decrypted_bytes = manager.decrypt(encrypted_data, password)
    return decrypted_bytes.decode('utf-8')
</file>

<file path="src/utils/monitor_utils.py">
"""
Monitor detection and coordinate utilities
"""

from typing import Dict, List, Tuple, Optional
import logging

logger = logging.getLogger(__name__)


def get_monitor_info() -> List[Dict]:
    """
    Get information about all connected monitors
    Returns list of monitor dictionaries with x, y, width, height, is_primary
    """
    monitors = []
    
    try:
        # Try using screeninfo library if available
        from screeninfo import get_monitors
        
        for m in get_monitors():
            monitors.append({
                'name': m.name,
                'x': m.x,
                'y': m.y,
                'width': m.width,
                'height': m.height,
                'is_primary': m.is_primary if hasattr(m, 'is_primary') else (m.x == 0 and m.y == 0)
            })
            
    except ImportError:
        logger.warning("screeninfo not installed, using fallback method")
        # Fallback to tkinter method
        try:
            import tkinter as tk
            root = tk.Tk()
            root.withdraw()  # Hide the window
            
            # Get primary monitor info
            primary_width = root.winfo_screenwidth()
            primary_height = root.winfo_screenheight()
            
            # Get virtual screen size (all monitors)
            virtual_width = root.winfo_vrootwidth()
            virtual_height = root.winfo_vrootheight()
            
            monitors.append({
                'name': 'Primary',
                'x': 0,
                'y': 0,
                'width': primary_width,
                'height': primary_height,
                'is_primary': True
            })
            
            # If virtual size is larger, we have multiple monitors
            if virtual_width > primary_width:
                # Assume second monitor is to the right
                monitors.append({
                    'name': 'Secondary',
                    'x': primary_width,
                    'y': 0,
                    'width': virtual_width - primary_width,
                    'height': primary_height,
                    'is_primary': False
                })
            elif virtual_width < 0:
                # Monitor might be to the left
                monitors.insert(0, {
                    'name': 'Secondary',
                    'x': virtual_width,
                    'y': 0,
                    'width': -virtual_width,
                    'height': primary_height,
                    'is_primary': False
                })
                
            root.destroy()
            
        except Exception as e:
            logger.error(f"Failed to get monitor info: {e}")
            # Return at least one monitor
            monitors.append({
                'name': 'Default',
                'x': 0,
                'y': 0,
                'width': 1920,
                'height': 1080,
                'is_primary': True
            })
    
    return monitors


def get_monitor_at_position(x: int, y: int) -> Optional[Dict]:
    """
    Get monitor information for the monitor containing the given position
    """
    monitors = get_monitor_info()
    
    for monitor in monitors:
        if (monitor['x'] <= x < monitor['x'] + monitor['width'] and
            monitor['y'] <= y < monitor['y'] + monitor['height']):
            return monitor
            
    # If no monitor found, return the primary monitor
    for monitor in monitors:
        if monitor['is_primary']:
            return monitor
            
    return monitors[0] if monitors else None


def get_monitor_name_for_position(x: int, y: int) -> str:
    """
    Get a friendly name for the monitor at the given position
    """
    monitor = get_monitor_at_position(x, y)
    
    if not monitor:
        return "ì•Œ ìˆ˜ ì—†ëŠ” ëª¨ë‹ˆí„°"
        
    # Create a friendly name based on position
    if monitor['is_primary']:
        return "ì£¼ ëª¨ë‹ˆí„°"
    elif monitor['x'] < 0:
        return "ì™¼ìª½ ëª¨ë‹ˆí„°"
    elif monitor['x'] > 0:
        return "ì˜¤ë¥¸ìª½ ëª¨ë‹ˆí„°"
    elif monitor['y'] < 0:
        return "ìœ„ìª½ ëª¨ë‹ˆí„°"
    elif monitor['y'] > 0:
        return "ì•„ë˜ìª½ ëª¨ë‹ˆí„°"
    else:
        return monitor.get('name', 'ë³´ì¡° ëª¨ë‹ˆí„°')


def get_total_screen_bounds() -> Tuple[int, int, int, int]:
    """
    Get the total bounds of all monitors combined
    Returns: (min_x, min_y, max_x, max_y)
    """
    monitors = get_monitor_info()
    
    if not monitors:
        return (0, 0, 1920, 1080)
        
    min_x = min(m['x'] for m in monitors)
    min_y = min(m['y'] for m in monitors)
    max_x = max(m['x'] + m['width'] for m in monitors)
    max_y = max(m['y'] + m['height'] for m in monitors)
    
    return (min_x, min_y, max_x, max_y)


def is_position_valid(x: int, y: int) -> bool:
    """
    Check if a position is within any monitor bounds
    """
    return get_monitor_at_position(x, y) is not None
</file>

<file path="src/utils/path_utils.py">
"""
Cross-platform path utilities for Windows/WSL compatibility
"""

import os
import sys
import platform


def normalize_path(path: str) -> str:
    """
    Normalize path for the current platform
    Handles both Windows and WSL/Linux paths
    """
    if not path:
        return path
    
    # Convert to absolute path if relative
    if not os.path.isabs(path):
        path = os.path.abspath(path)
    
    # Normalize separators
    path = os.path.normpath(path)
    
    return path


def get_project_root() -> str:
    """
    Get the project root directory in a platform-independent way
    """
    # Get the directory of this file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Go up two levels (utils -> src -> project_root)
    project_root = os.path.dirname(os.path.dirname(current_dir))
    
    return normalize_path(project_root)


def get_captures_dir() -> str:
    """
    Get the captures directory, creating it if necessary
    """
    captures_dir = os.path.join(get_project_root(), "captures")
    os.makedirs(captures_dir, exist_ok=True)
    return captures_dir


def get_logs_dir() -> str:
    """
    Get the logs directory, creating it if necessary
    """
    logs_dir = os.path.join(get_project_root(), "logs")
    os.makedirs(logs_dir, exist_ok=True)
    return logs_dir


def is_wsl() -> bool:
    """
    Check if running in WSL environment
    """
    return 'microsoft' in platform.uname().release.lower()


def is_windows_native() -> bool:
    """
    Check if running in native Windows (not WSL)
    """
    return sys.platform == 'win32' and not is_wsl()


def convert_wsl_to_windows_path(wsl_path: str) -> str:
    """
    Convert WSL path to Windows path
    Example: /home/user/file -> \\\\wsl$\\Ubuntu\\home\\user\\file
    """
    if not wsl_path.startswith('/'):
        return wsl_path
    
    # Get WSL distribution name (default to Ubuntu)
    import subprocess
    try:
        result = subprocess.run(['wslpath', '-w', wsl_path], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass
    
    # Fallback conversion
    windows_path = wsl_path.replace('/', '\\')
    return f"\\\\wsl$\\Ubuntu{windows_path}"


def convert_windows_to_wsl_path(windows_path: str) -> str:
    """
    Convert Windows path to WSL path
    Example: C:\\Users\\file -> /mnt/c/Users/file
    """
    if ':' not in windows_path:
        return windows_path
    
    # Use wslpath if available
    import subprocess
    try:
        result = subprocess.run(['wslpath', '-u', windows_path], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass
    
    # Fallback conversion
    drive = windows_path[0].lower()
    path = windows_path[2:].replace('\\', '/')
    return f"/mnt/{drive}{path}"
</file>

<file path="src/vision/image_matcher.py">
"""
OpenCV-based image matching engine with DPI scaling and multi-monitor support
"""

import time
from typing import Optional, Tuple, List, Dict, Any
from dataclasses import dataclass
import numpy as np
import cv2
import pyautogui
from PIL import Image
import mss
from config.settings import Settings
from logger.app_logger import get_logger

@dataclass
class MatchResult:
    """Result of image matching operation"""
    found: bool
    confidence: float
    location: Optional[Tuple[int, int, int, int]] = None  # x, y, width, height
    center: Optional[Tuple[int, int]] = None  # center x, y
    
@dataclass 
class MonitorInfo:
    """Monitor information"""
    index: int
    left: int
    top: int
    width: int
    height: int
    scale: float = 1.0

class ImageMatcher:
    """Advanced image matching with OpenCV"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        self._template_cache: Dict[str, np.ndarray] = {}
        self._sct = mss.mss()
        self._monitors = self._detect_monitors()
        
    def _detect_monitors(self) -> List[MonitorInfo]:
        """Detect all monitors and their properties"""
        monitors = []
        
        for i, monitor in enumerate(self._sct.monitors[1:], 1):  # Skip combined monitor
            info = MonitorInfo(
                index=i,
                left=monitor["left"],
                top=monitor["top"],
                width=monitor["width"],
                height=monitor["height"]
            )
            
            # Detect DPI scaling (simplified - may need platform-specific code)
            try:
                # Get actual screen size vs reported size
                actual_size = pyautogui.size()
                if i == 1:  # Primary monitor
                    scale_x = actual_size.width / monitor["width"]
                    scale_y = actual_size.height / monitor["height"]
                    info.scale = max(scale_x, scale_y)
            except:
                info.scale = 1.0
                
            monitors.append(info)
            self.logger.debug(f"Detected monitor {i}: {info}")
            
        return monitors
        
    def _load_template(self, image_path: str, scale: float = 1.0) -> np.ndarray:
        """Load and cache template image with scaling"""
        cache_key = f"{image_path}_{scale}"
        
        if cache_key in self._template_cache:
            return self._template_cache[cache_key]
            
        try:
            # Load template
            template = cv2.imread(image_path)
            if template is None:
                raise ValueError(f"Failed to load image: {image_path}")
                
            # Apply DPI scaling if needed
            if scale != 1.0:
                width = int(template.shape[1] * scale)
                height = int(template.shape[0] * scale)
                template = cv2.resize(template, (width, height), interpolation=cv2.INTER_LINEAR)
                
            # Convert to grayscale for faster matching
            template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
            
            # Cache the processed template
            self._template_cache[cache_key] = template_gray
            
            return template_gray
            
        except Exception as e:
            self.logger.error(f"Error loading template {image_path}: {e}")
            raise
            
    def _capture_screen(self, region: Optional[Tuple[int, int, int, int]] = None,
                       monitor_index: Optional[int] = None) -> np.ndarray:
        """Capture screen or region"""
        try:
            if region:
                # Capture specific region
                monitor = {
                    "left": region[0],
                    "top": region[1], 
                    "width": region[2],
                    "height": region[3]
                }
            elif monitor_index is not None and 0 <= monitor_index < len(self._monitors):
                # Capture specific monitor
                mon_info = self._monitors[monitor_index]
                monitor = {
                    "left": mon_info.left,
                    "top": mon_info.top,
                    "width": mon_info.width,
                    "height": mon_info.height
                }
            else:
                # Capture all monitors
                monitor = self._sct.monitors[0]
                
            # Capture screenshot
            screenshot = self._sct.grab(monitor)
            
            # Convert to numpy array
            img = np.array(screenshot)
            
            # Convert BGRA to BGR
            img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
            
            return img
            
        except Exception as e:
            self.logger.error(f"Error capturing screen: {e}")
            raise
            
    def find_image(self, template_path: str, 
                   confidence: float = 0.9,
                   region: Optional[Tuple[int, int, int, int]] = None,
                   monitor_index: Optional[int] = None,
                   grayscale: bool = True) -> MatchResult:
        """Find image on screen using template matching"""
        
        try:
            # Determine scale factor
            scale = 1.0
            if monitor_index is not None and 0 <= monitor_index < len(self._monitors):
                scale = self._monitors[monitor_index].scale
                
            # Load template
            template = self._load_template(template_path, scale)
            
            # Capture screen
            screenshot = self._capture_screen(region, monitor_index)
            
            # Convert to grayscale if needed
            if grayscale:
                screenshot_gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
            else:
                screenshot_gray = screenshot
                
            # Perform template matching
            result = cv2.matchTemplate(screenshot_gray, template, cv2.TM_CCOEFF_NORMED)
            
            # Find best match
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
            
            if max_val >= confidence:
                # Calculate absolute coordinates
                h, w = template.shape[:2]
                x, y = max_loc
                
                # Adjust for region offset if applicable
                if region:
                    x += region[0]
                    y += region[1]
                elif monitor_index is not None:
                    mon_info = self._monitors[monitor_index]
                    x += mon_info.left
                    y += mon_info.top
                    
                location = (x, y, w, h)
                center = (x + w // 2, y + h // 2)
                
                return MatchResult(
                    found=True,
                    confidence=max_val,
                    location=location,
                    center=center
                )
            else:
                return MatchResult(found=False, confidence=max_val)
                
        except Exception as e:
            self.logger.error(f"Error in find_image: {e}")
            return MatchResult(found=False, confidence=0.0)
            
    def find_all_images(self, template_path: str,
                       confidence: float = 0.9,
                       region: Optional[Tuple[int, int, int, int]] = None,
                       limit: int = 10) -> List[MatchResult]:
        """Find all occurrences of image on screen"""
        
        results = []
        
        try:
            # Load template
            template = self._load_template(template_path)
            
            # Capture screen  
            screenshot = self._capture_screen(region)
            screenshot_gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
            
            # Perform template matching
            match_result = cv2.matchTemplate(screenshot_gray, template, cv2.TM_CCOEFF_NORMED)
            
            # Find all matches above threshold
            locations = np.where(match_result >= confidence)
            
            h, w = template.shape[:2]
            
            # Process matches
            for pt in zip(*locations[::-1]):
                if len(results) >= limit:
                    break
                    
                x, y = pt
                
                # Adjust for region offset
                if region:
                    x += region[0]
                    y += region[1]
                    
                location = (x, y, w, h)
                center = (x + w // 2, y + h // 2)
                
                # Get confidence for this match
                conf = match_result[y, x]
                
                results.append(MatchResult(
                    found=True,
                    confidence=float(conf),
                    location=location,
                    center=center
                ))
                
        except Exception as e:
            self.logger.error(f"Error in find_all_images: {e}")
            
        return results
        
    def wait_for_image(self, template_path: str,
                      timeout: float = 30.0,
                      confidence: float = 0.9,
                      region: Optional[Tuple[int, int, int, int]] = None,
                      check_interval: float = 0.5) -> MatchResult:
        """Wait for image to appear on screen"""
        
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            result = self.find_image(template_path, confidence, region)
            
            if result.found:
                return result
                
            time.sleep(check_interval)
            
        # Timeout reached
        return MatchResult(found=False, confidence=0.0)
        
    def capture_region(self, region: Tuple[int, int, int, int], 
                      save_path: Optional[str] = None) -> np.ndarray:
        """Capture a specific region of the screen"""
        
        screenshot = self._capture_screen(region)
        
        if save_path:
            cv2.imwrite(save_path, screenshot)
            self.logger.info(f"Saved screenshot to {save_path}")
            
        return screenshot
        
    def clear_cache(self):
        """Clear template cache"""
        self._template_cache.clear()
        self.logger.debug("Template cache cleared")

class ImageMatcherLegacy:
    """Legacy image matcher using pyautogui for fallback"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        
    def find_image(self, template_path: str,
                   confidence: float = 0.9,
                   region: Optional[Tuple[int, int, int, int]] = None) -> MatchResult:
        """Find image using pyautogui"""
        
        try:
            location = pyautogui.locateOnScreen(
                template_path,
                confidence=confidence,
                region=region
            )
            
            if location:
                center = pyautogui.center(location)
                return MatchResult(
                    found=True,
                    confidence=confidence,
                    location=location,
                    center=center
                )
            else:
                return MatchResult(found=False, confidence=0.0)
                
        except Exception as e:
            self.logger.error(f"Error in legacy find_image: {e}")
            return MatchResult(found=False, confidence=0.0)
</file>

<file path="src/__init__.py">
# Excel Macro Automation Package
</file>

<file path="test_results/drag_drop_test_report.json">
{"created": 1752635947.0595722, "duration": 2.1377406120300293, "exitcode": 0, "root": "/home/nosky/macro", "environment": {}, "summary": {"passed": 6, "total": 6, "collected": 6}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py", "type": "Module"}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "outcome": "passed", "result": []}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "type": "Function", "lineno": 42}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "type": "Function", "lineno": 72}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "type": "Function", "lineno": 102}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "type": "Function", "lineno": 130}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "type": "Function", "lineno": 157}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "type": "Function", "lineno": 177}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "type": "Class"}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "type": "Class"}]}], "tests": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "lineno": 42, "outcome": "passed", "keywords": ["test_drag_new_step_from_palette", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.14800998900318518, "outcome": "passed"}, "call": {"duration": 0.20660709802177735, "outcome": "passed"}, "teardown": {"duration": 0.0007801619940437376, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "lineno": 72, "outcome": "passed", "keywords": ["test_drag_multiple_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.0966931150178425, "outcome": "passed"}, "call": {"duration": 0.4246597609890159, "outcome": "passed"}, "teardown": {"duration": 0.0003640960203483701, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "lineno": 102, "outcome": "passed", "keywords": ["test_reorder_existing_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09244555799523368, "outcome": "passed"}, "call": {"duration": 0.26532694601337425, "outcome": "passed"}, "teardown": {"duration": 0.00038110199966467917, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "lineno": 130, "outcome": "passed", "keywords": ["test_drop_at_specific_positions", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09779455501120538, "outcome": "passed"}, "call": {"duration": 0.21195768300094642, "outcome": "passed"}, "teardown": {"duration": 0.0003567070234566927, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "lineno": 157, "outcome": "passed", "keywords": ["test_drag_cancel", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09215356002096087, "outcome": "passed"}, "call": {"duration": 0.10171863497816958, "outcome": "passed"}, "teardown": {"duration": 0.0003038999857380986, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "lineno": 177, "outcome": "passed", "keywords": ["test_invalid_mime_data", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.09534229998826049, "outcome": "passed"}, "call": {"duration": 0.1021027640090324, "outcome": "passed"}, "teardown": {"duration": 0.0003029129875358194, "outcome": "passed"}}], "warnings": [{"message": "cannot collect test class 'TestScenario' because it has a __init__ constructor (from: tests/integration/test_drag_drop_integration.py)", "category": "PytestCollectionWarning", "when": "collect", "filename": "/home/nosky/macro/tests/test_helpers.py", "lineno": 227}]}
</file>

<file path="test_results/test_report_20250716_115250.html">
<!DOCTYPE html>
<html>
<head>
    <title>Test Report - 2025-07-16 11:52:50</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #333;
        }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 14px;
        }
        .stat-card .value {
            font-size: 32px;
            font-weight: bold;
            color: #333;
        }
        .success { color: #28a745; }
        .failure { color: #dc3545; }
        .warning { color: #ffc107; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .test-detail {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        pre {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-fill {
            height: 100%;
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Excel Macro Automation - Test Report</h1>
        <p>Generated on: 2025-07-16 11:52:50</p>
        
        <h2>Summary</h2>
        <div class="summary">
            <div class="stat-card">
                <h3>Total Tests</h3>
                <div class="value">0</div>
            </div>
            <div class="stat-card">
                <h3>Passed</h3>
                <div class="value success">0</div>
            </div>
            <div class="stat-card">
                <h3>Failed</h3>
                <div class="value failure">0</div>
            </div>
            <div class="stat-card">
                <h3>Success Rate</h3>
                <div class="value">0.0%</div>
            </div>
            <div class="stat-card">
                <h3>Duration</h3>
                <div class="value">0.4s</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" style="width: 0%">
                0.0%
            </div>
        </div>
        
        <h2>Test Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Test File</th>
                    <th>Total</th>
                    <th>Passed</th>
                    <th>Failed</th>
                    <th>Duration</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>

                <tr>
                    <td>test_drag_drop_integration.py</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0.20s</td>
                    <td class="warning">âš ï¸ Error</td>
                </tr>

                <tr>
                    <td>test_step_configuration.py</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0.12s</td>
                    <td class="warning">âš ï¸ Error</td>
                </tr>

                <tr>
                    <td>test_execution_logging.py</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0.11s</td>
                    <td class="warning">âš ï¸ Error</td>
                </tr>

            </tbody>
        </table>
        
        <h2>Detailed Results</h2>

    </div>
</body>
</html>
</file>

<file path="test_results/test_results_20250716_115250.csv">

</file>

<file path="tests/integration/test_drag_drop_integration.py">
#!/usr/bin/env python3
"""
Integration tests for drag and drop functionality
"""

import sys
import os
from pathlib import Path
import pytest
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import QPoint, Qt

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import MockDragDropEvent, GUITestContext, TestScenario
from ui.widgets.macro_editor import MacroEditorWidget, StepPalette, MacroFlowWidget
from core.macro_types import Macro, StepType, MacroStep
from config.settings import Settings


class TestDragDropIntegration:
    """Test drag and drop functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def macro_editor(self, app):
        """Create macro editor widget"""
        editor = MacroEditorWidget()
        editor.show()
        app.processEvents()
        yield editor
        editor.close()
        
    def test_drag_new_step_from_palette(self, app, macro_editor):
        """Test dragging a new step from palette to flow"""
        with GUITestContext(app) as ctx:
            # Get palette and flow widgets
            palette = macro_editor.palette
            flow = macro_editor.flow_widget
            
            # Initial state - should be empty
            assert len(flow.macro.steps) == 0
            
            # Create drag event for Click step
            mime_data = MockDragDropEvent.create_step_mime_data("mouse_click")
            
            # Simulate drag enter
            drag_enter_event = MockDragDropEvent.create_drag_enter_event(mime_data)
            flow.dragEnterEvent(drag_enter_event)
            assert drag_enter_event.isAccepted()
            
            # Simulate drop at position
            drop_event = MockDragDropEvent.create_drop_event(mime_data, QPoint(100, 50))
            flow.dropEvent(drop_event)
            
            # Process events
            ctx.process_events(200)
            
            # Verify step was added
            assert len(flow.macro.steps) == 1
            assert flow.macro.steps[0].step_type == StepType.MOUSE_CLICK
            assert flow.macro.steps[0].name == "ë§ˆìš°ìŠ¤ í´ë¦­"
            
    def test_drag_multiple_steps(self, app, macro_editor):
        """Test dragging multiple different step types"""
        with GUITestContext(app) as ctx:
            flow = macro_editor.flow_widget
            
            # Step types to test
            step_types = [
                ("mouse_click", StepType.MOUSE_CLICK, "ë§ˆìš°ìŠ¤ í´ë¦­"),
                ("keyboard_type", StepType.KEYBOARD_TYPE, "í…ìŠ¤íŠ¸ ì…ë ¥"),
                ("wait_time", StepType.WAIT_TIME, "ëŒ€ê¸°"),
                ("if_condition", StepType.IF_CONDITION, "ì¡°ê±´ë¬¸")
            ]
            
            # Add each step type
            for i, (mime_type, expected_type, expected_name) in enumerate(step_types):
                mime_data = MockDragDropEvent.create_step_mime_data(mime_type)
                drop_event = MockDragDropEvent.create_drop_event(
                    mime_data, 
                    QPoint(100, 50 + i * 100)
                )
                flow.dropEvent(drop_event)
                ctx.process_events(100)
                
            # Verify all steps were added
            assert len(flow.macro.steps) == len(step_types)
            
            for i, (_, expected_type, expected_name) in enumerate(step_types):
                assert flow.macro.steps[i].step_type == expected_type
                assert flow.macro.steps[i].name == expected_name
                
    def test_reorder_existing_steps(self, app, macro_editor):
        """Test reordering steps by dragging"""
        with GUITestContext(app) as ctx:
            flow = macro_editor.flow_widget
            
            # Add 3 steps first
            for i in range(3):
                mime_data = MockDragDropEvent.create_step_mime_data("mouse_click")
                drop_event = MockDragDropEvent.create_drop_event(mime_data)
                flow.dropEvent(drop_event)
                ctx.process_events(50)
                
            # Get step IDs
            step_ids = [step.step_id for step in flow.macro.steps]
            
            # Move first step to last position
            mime_data = MockDragDropEvent.create_move_mime_data(step_ids[0], 0)
            drop_event = MockDragDropEvent.create_drop_event(
                mime_data,
                QPoint(100, 300)  # Drop at bottom
            )
            flow.dropEvent(drop_event)
            ctx.process_events(100)
            
            # Verify order changed
            new_step_ids = [step.step_id for step in flow.macro.steps]
            assert new_step_ids == [step_ids[1], step_ids[2], step_ids[0]]
            
    def test_drop_at_specific_positions(self, app, macro_editor):
        """Test dropping at specific positions between steps"""
        with GUITestContext(app) as ctx:
            flow = macro_editor.flow_widget
            
            # Add initial steps
            for i in range(2):
                mime_data = MockDragDropEvent.create_step_mime_data("wait_time")
                drop_event = MockDragDropEvent.create_drop_event(mime_data)
                flow.dropEvent(drop_event)
                ctx.process_events(50)
                
            # Drop new step between existing ones
            mime_data = MockDragDropEvent.create_step_mime_data("keyboard_type")
            drop_event = MockDragDropEvent.create_drop_event(
                mime_data,
                QPoint(100, 75)  # Between first and second
            )
            flow.dropEvent(drop_event)
            ctx.process_events(100)
            
            # Verify insertion position
            assert len(flow.macro.steps) == 3
            assert flow.macro.steps[0].step_type == StepType.WAIT_TIME
            assert flow.macro.steps[1].step_type == StepType.KEYBOARD_TYPE
            assert flow.macro.steps[2].step_type == StepType.WAIT_TIME
            
    def test_drag_cancel(self, app, macro_editor):
        """Test canceling a drag operation"""
        with GUITestContext(app) as ctx:
            flow = macro_editor.flow_widget
            
            # Initial count
            initial_count = len(flow.macro.steps)
            
            # Start drag but don't drop
            mime_data = MockDragDropEvent.create_step_mime_data("click")
            drag_enter_event = MockDragDropEvent.create_drag_enter_event(mime_data)
            flow.dragEnterEvent(drag_enter_event)
            
            # Simulate drag leave (cancel)
            flow.dragLeaveEvent(None)
            ctx.process_events(100)
            
            # Verify no change
            assert len(flow.macro.steps) == initial_count
            
    def test_invalid_mime_data(self, app, macro_editor):
        """Test handling invalid mime data"""
        with GUITestContext(app) as ctx:
            flow = macro_editor.flow_widget
            
            # Create invalid mime data
            from PyQt5.QtCore import QMimeData
            mime_data = QMimeData()
            mime_data.setText("invalid data")
            
            # Try to drop
            drop_event = MockDragDropEvent.create_drop_event(mime_data)
            flow.dropEvent(drop_event)
            ctx.process_events(100)
            
            # Should not crash and no steps added
            assert len(flow.macro.steps) == 0


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_excel_manager.py">
#!/usr/bin/env python3
"""
Integration tests for Excel data load and mapping functionality
"""

import sys
import os
from pathlib import Path
import pytest
import tempfile
import pandas as pd
from PyQt5.QtWidgets import QApplication

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import GUITestContext
from excel.excel_manager import ExcelManager
from excel.models import ColumnType, ColumnMapping
from config.settings import Settings


class TestExcelManager:
    """Test Excel data load and mapping functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def test_excel_file(self):
        """Create test Excel file"""
        # Create temporary Excel file
        temp_file = tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False)
        
        # Create test data with multiple sheets
        data1 = pd.DataFrame({
            'ì´ë¦„': ['í™ê¸¸ë™', 'ê¹€ì² ìˆ˜', 'ì´ì˜í¬', 'ë°•ë¯¼ìˆ˜', 'ìµœì§€í˜œ'],
            'ë‚˜ì´': [30, 25, 35, 28, 32],
            'ì´ë©”ì¼': ['hong@test.com', 'kim@test.com', 'lee@test.com', 'park@test.com', 'choi@test.com'],
            'ë¶€ì„œ': ['ê°œë°œíŒ€', 'ë§ˆì¼€íŒ…íŒ€', 'ê°œë°œíŒ€', 'ì˜ì—…íŒ€', 'ê°œë°œíŒ€'],
            'ìƒíƒœ': ['í™œì„±', 'í™œì„±', 'ë¹„í™œì„±', 'í™œì„±', 'í™œì„±'],
            'Status': ['', '', '', '', '']  # Status column for tracking
        })
        
        data2 = pd.DataFrame({
            'ì œí’ˆëª…': ['ë…¸íŠ¸ë¶', 'ë§ˆìš°ìŠ¤', 'í‚¤ë³´ë“œ', 'ëª¨ë‹ˆí„°'],
            'ê°€ê²©': [1200000, 35000, 80000, 450000],
            'ì¬ê³ ': [15, 200, 150, 25],
            'ì¹´í…Œê³ ë¦¬': ['ì „ìì œí’ˆ', 'ì•¡ì„¸ì„œë¦¬', 'ì•¡ì„¸ì„œë¦¬', 'ì „ìì œí’ˆ']
        })
        
        # Save to Excel with multiple sheets
        with pd.ExcelWriter(temp_file.name, engine='openpyxl') as writer:
            data1.to_excel(writer, sheet_name='ì§ì›ëª©ë¡', index=False)
            data2.to_excel(writer, sheet_name='ì œí’ˆëª©ë¡', index=False)
            
        temp_file.close()
        yield temp_file.name
        
        # Cleanup
        os.unlink(temp_file.name)
        
    def test_load_excel_file(self, app, test_excel_file):
        """Test loading Excel file"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            
            # Load file
            file_info = manager.load_file(test_excel_file)
            
            # Verify file info
            assert file_info.file_path == test_excel_file
            assert file_info.sheet_count == 2
            assert len(file_info.sheets) == 2
            
            # Check sheet names
            sheet_names = [sheet.name for sheet in file_info.sheets]
            assert 'ì§ì›ëª©ë¡' in sheet_names
            assert 'ì œí’ˆëª©ë¡' in sheet_names
            
    def test_analyze_sheet(self, app, test_excel_file):
        """Test sheet analysis"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            file_info = manager.load_file(test_excel_file)
            
            # Check employee sheet
            employee_sheet = next(s for s in file_info.sheets if s.name == 'ì§ì›ëª©ë¡')
            assert employee_sheet.row_count == 5
            assert employee_sheet.column_count == 6
            
            # Check column names
            column_names = [col.name for col in employee_sheet.columns]
            assert 'ì´ë¦„' in column_names
            assert 'ë‚˜ì´' in column_names
            assert 'ì´ë©”ì¼' in column_names
            
    def test_column_type_detection(self, app, test_excel_file):
        """Test column type detection"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            file_info = manager.load_file(test_excel_file)
            
            employee_sheet = next(s for s in file_info.sheets if s.name == 'ì§ì›ëª©ë¡')
            
            # Check column types
            name_col = next(c for c in employee_sheet.columns if c.name == 'ì´ë¦„')
            assert name_col.data_type == ColumnType.TEXT
            
            age_col = next(c for c in employee_sheet.columns if c.name == 'ë‚˜ì´')
            assert age_col.data_type == ColumnType.NUMBER
            
            email_col = next(c for c in employee_sheet.columns if c.name == 'ì´ë©”ì¼')
            assert email_col.data_type == ColumnType.TEXT
            
    def test_select_sheet(self, app, test_excel_file):
        """Test sheet selection"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            manager.load_file(test_excel_file)
            
            # Select sheet
            excel_data = manager.read_sheet('ì§ì›ëª©ë¡')
            
            # Verify data loaded
            assert excel_data is not None
            assert excel_data.sheet_name == 'ì§ì›ëª©ë¡'
            assert len(excel_data.dataframe) == 5
            assert list(excel_data.dataframe.columns) == ['ì´ë¦„', 'ë‚˜ì´', 'ì´ë©”ì¼', 'ë¶€ì„œ', 'ìƒíƒœ', 'Status']
            
    def test_column_mapping(self, app, test_excel_file):
        """Test column mapping functionality"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            manager.load_file(test_excel_file)
            manager.read_sheet('ì§ì›ëª©ë¡')
            
            # Set column mappings
            manager.set_column_mapping('ì´ë¦„', 'name', ColumnType.TEXT, True)
            manager.set_column_mapping('ì´ë©”ì¼', 'email', ColumnType.TEXT, True)
            manager.set_column_mapping('Status', 'status', ColumnType.TEXT, False)
            
            # Get mappings (accessing internal attribute)
            mappings = manager._column_mappings
            assert len(mappings) == 3
            assert mappings['name'].excel_column == 'ì´ë¦„'
            assert mappings['email'].excel_column == 'ì´ë©”ì¼'
            assert mappings['status'].excel_column == 'Status'
            
    def test_get_row_data(self, app, test_excel_file):
        """Test getting row data with mappings"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            manager.load_file(test_excel_file)
            manager.read_sheet('ì§ì›ëª©ë¡')
            
            # Set mappings
            manager.set_column_mapping('ì´ë¦„', 'name', ColumnType.TEXT, True)
            manager.set_column_mapping('ë‚˜ì´', 'age', ColumnType.NUMBER, True)
            manager.set_column_mapping('ì´ë©”ì¼', 'email', ColumnType.TEXT, True)
            
            # Get first row data
            row_data = manager.get_mapped_data(0)
            
            # Verify data
            assert row_data['name'] == 'í™ê¸¸ë™'
            assert row_data['age'] == 30
            assert row_data['email'] == 'hong@test.com'
            
    def test_update_status_column(self, app, test_excel_file):
        """Test updating status column"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            manager.load_file(test_excel_file)
            excel_data = manager.read_sheet('ì§ì›ëª©ë¡')
            
            # Update status using ExcelManager's update_row_status
            manager.update_row_status(0, 'Completed')
            
            # Verify update in the dataframe
            assert excel_data.dataframe.iloc[0][excel_data.get_status_column()] == 'Completed'
            
    def test_filter_incomplete_rows(self, app, test_excel_file):
        """Test filtering incomplete rows"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            manager.load_file(test_excel_file)
            manager.read_sheet('ì§ì›ëª©ë¡')
            
            # Update some rows
            manager.update_row_status(0, 'Completed')
            manager.update_row_status(2, 'Completed')
            
            # Get pending rows
            pending_indices = manager.get_pending_rows()
            
            # Should have 3 incomplete rows (1, 3, 4)
            assert len(pending_indices) == 3
            assert 1 in pending_indices
            assert 3 in pending_indices
            assert 4 in pending_indices
            
    def test_save_excel_file(self, app, test_excel_file):
        """Test saving Excel file with updates"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            manager.load_file(test_excel_file)
            excel_data = manager.read_sheet('ì§ì›ëª©ë¡')
            
            # Make updates
            manager.update_row_status(0, 'Processed')
            manager.update_row_status(1, 'Processed')
            
            # Save file (returns path, not boolean)
            saved_path = manager.save_file()
            assert saved_path == test_excel_file
            
            # Reload and verify
            manager2 = ExcelManager()
            manager2.load_file(test_excel_file)
            data2 = manager2.read_sheet('ì§ì›ëª©ë¡')
            
            # Check saved values
            status_col = data2.get_status_column()
            assert data2.dataframe.iloc[0][status_col] == 'Processed'
            assert data2.dataframe.iloc[1][status_col] == 'Processed'
            
    def test_multiple_sheet_handling(self, app, test_excel_file):
        """Test handling multiple sheets"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            file_info = manager.load_file(test_excel_file)
            
            # Load first sheet
            data1 = manager.read_sheet('ì§ì›ëª©ë¡')
            assert data1.sheet_name == 'ì§ì›ëª©ë¡'
            assert len(data1.dataframe) == 5
            
            # Switch to second sheet
            data2 = manager.read_sheet('ì œí’ˆëª©ë¡')
            assert data2.sheet_name == 'ì œí’ˆëª©ë¡'
            assert len(data2.dataframe) == 4
            
            # Column names should be different
            assert 'ì œí’ˆëª…' in data2.dataframe.columns
            assert 'ê°€ê²©' in data2.dataframe.columns
            
    def test_invalid_file_handling(self, app):
        """Test handling of invalid files"""
        with GUITestContext(app) as ctx:
            manager = ExcelManager()
            
            # Non-existent file
            with pytest.raises(FileNotFoundError):
                manager.load_file("/nonexistent/file.xlsx")
                
            # Invalid format
            temp_file = tempfile.NamedTemporaryFile(suffix='.txt', delete=False)
            temp_file.write(b"Not an Excel file")
            temp_file.close()
            
            with pytest.raises(ValueError):
                manager.load_file(temp_file.name)
                
            os.unlink(temp_file.name)
            
    def test_empty_excel_handling(self, app):
        """Test handling empty Excel files"""
        with GUITestContext(app) as ctx:
            # Create empty Excel file
            temp_file = tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False)
            empty_df = pd.DataFrame()
            empty_df.to_excel(temp_file.name, index=False)
            temp_file.close()
            
            manager = ExcelManager()
            file_info = manager.load_file(temp_file.name)
            
            # Should handle gracefully
            assert file_info.sheet_count >= 1
            
            os.unlink(temp_file.name)


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_execution_logging.py">
#!/usr/bin/env python3
"""
Integration tests for execution and logging functionality
"""

import sys
import os
from pathlib import Path
import pytest
import pandas as pd
import tempfile
import time
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import QTimer

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import LogVerifier, GUITestContext, TestScenario
from ui.widgets.execution_widget import ExecutionWidget
from ui.dialogs.log_viewer_dialog import LogViewerDialog
from ui.dialogs.error_report_dialog import ErrorReportDialog
from automation.engine import ExecutionEngine, ExecutionState
from excel.excel_manager import ExcelManager
from core.macro_types import Macro, MacroStep, StepType
from config.settings import Settings
from logger.execution_logger import get_execution_logger


class TestExecutionLogging:
    """Test execution and logging functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def test_excel_file(self):
        """Create test Excel file"""
        # Create temporary Excel file
        temp_file = tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False)
        
        # Create test data
        test_data = pd.DataFrame({
            'ì´ë¦„': ['í™ê¸¸ë™', 'ê¹€ì² ìˆ˜', 'ì´ì˜í¬'],
            'ë‚˜ì´': [30, 25, 35],
            'ìƒíƒœ': ['ëŒ€ê¸°', 'ì™„ë£Œ', 'ì§„í–‰ì¤‘'],
            'Status': ['', '', '']  # Status column for tracking
        })
        
        # Save to Excel
        test_data.to_excel(temp_file.name, index=False)
        temp_file.close()
        
        yield temp_file.name
        
        # Cleanup
        os.unlink(temp_file.name)
        
    @pytest.fixture
    def test_macro(self):
        """Create test macro"""
        macro = Macro(name="í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ")
        
        # Add some test steps
        wait_step = MacroStep(step_type=StepType.WAIT_TIME)
        wait_step.name = "1ì´ˆ ëŒ€ê¸°"
        wait_step.config = {"duration_seconds": 1}
        
        type_step = MacroStep(step_type=StepType.KEYBOARD_TYPE)
        type_step.name = "ì´ë¦„ ì…ë ¥"
        type_step.config = {"text": "{{ì´ë¦„}}", "use_variable": True}
        
        macro.add_step(wait_step)
        macro.add_step(type_step)
        
        return macro
        
    def test_execution_with_csv_logging(self, app, test_excel_file, test_macro):
        """Test macro execution with CSV logging"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            
            # Create Excel manager and load file
            excel_manager = ExcelManager()
            excel_manager.load_file(test_excel_file)
            excel_manager.select_sheet(0)
            excel_manager.set_column_mapping('ì´ë¦„', 'ì´ë¦„')
            excel_manager.set_column_mapping('Status', 'Status')
            
            # Create execution widget
            exec_widget = ExecutionWidget(settings)
            exec_widget.set_macro_and_excel(test_macro, excel_manager)
            exec_widget.show()
            ctx.process_events(100)
            
            # Get execution logger
            logger = get_execution_logger()
            
            # Start execution
            exec_widget.start_execution()
            
            # Wait for execution to start
            start_time = time.time()
            while exec_widget.engine.state != ExecutionState.RUNNING and time.time() - start_time < 5:
                ctx.process_events(100)
                
            # Let it run for a bit
            ctx.process_events(2000)
            
            # Stop execution
            exec_widget.stop_execution()
            
            # Wait for stop
            while exec_widget.engine.state != ExecutionState.IDLE and time.time() - start_time < 10:
                ctx.process_events(100)
                
            # Get log file
            log_file = logger.get_current_log_file()
            assert log_file is not None
            assert log_file.exists()
            
            # Verify log contents
            verifier = LogVerifier(log_file)
            
            # Check session started
            assert any(entry['step_name'] == 'SESSION_START' for entry in verifier.entries)
            
            # Check some steps executed
            assert verifier.verify_step_executed("1ì´ˆ ëŒ€ê¸°")
            
            # Get summary
            summary = verifier.get_execution_summary()
            assert summary['total_steps'] > 0
            
            exec_widget.close()
            
    def test_error_dialog_on_failure(self, app, test_macro):
        """Test error dialog appears on execution failure"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            
            # Create macro with failing step
            fail_step = MacroStep(step_type=StepType.WAIT_IMAGE)
            fail_step.name = "ì°¾ì„ ìˆ˜ ì—†ëŠ” ì´ë¯¸ì§€"
            fail_step.config = {
                "image_path": "/nonexistent/image.png",
                "timeout_seconds": 1
            }
            test_macro.add_step(fail_step, 0)  # Add at beginning
            
            # Mock execution that will fail
            error_shown = False
            original_show = ErrorReportDialog.show_error
            
            def mock_show_error(*args, **kwargs):
                nonlocal error_shown
                error_shown = True
                # Don't actually show dialog in test
                
            ErrorReportDialog.show_error = mock_show_error
            
            try:
                # Create minimal execution setup
                engine = ExecutionEngine(settings)
                
                # Emit error signal
                engine.error.emit("Test error: Image not found")
                ctx.process_events(100)
                
                # Verify error handling was triggered
                # In real execution, this would show the error dialog
                
            finally:
                ErrorReportDialog.show_error = original_show
                
    def test_log_viewer_real_time_update(self, app):
        """Test log viewer updates in real-time"""
        with GUITestContext(app) as ctx:
            # Create log file
            logger = get_execution_logger()
            log_file = logger.start_session("ì‹¤ì‹œê°„ í…ŒìŠ¤íŠ¸", "test.xlsx")
            
            # Create and show log viewer
            viewer = LogViewerDialog(log_file)
            viewer.show()
            ctx.process_events(100)
            
            # Initial row count
            initial_rows = viewer.log_table.rowCount()
            
            # Add some log entries
            logger.log_row_start(0, {"í…ŒìŠ¤íŠ¸": "ë°ì´í„°"})
            logger.log_step_execution(0, 0, "í…ŒìŠ¤íŠ¸ ë‹¨ê³„", "test", True, 100.5)
            logger.flush()
            
            # Wait for auto-refresh (viewer refreshes every 2 seconds for active logs)
            ctx.process_events(2500)
            
            # Check if new entries appeared
            new_rows = viewer.log_table.rowCount()
            assert new_rows > initial_rows
            
            # Close logger
            logger.close()
            viewer.close()
            
    def test_log_statistics_calculation(self, app):
        """Test log statistics calculation"""
        with GUITestContext(app) as ctx:
            # Create log with known data
            logger = get_execution_logger()
            log_file = logger.start_session("í†µê³„ í…ŒìŠ¤íŠ¸", "test.xlsx")
            
            # Log specific test data
            # Row 1 - Success
            logger.log_row_start(0, {"name": "test1"})
            logger.log_step_execution(0, 0, "Step1", "click", True, 100)
            logger.log_step_execution(0, 1, "Step2", "type", True, 200)
            logger.log_row_complete(0, True, 300)
            
            # Row 2 - Failure
            logger.log_row_start(1, {"name": "test2"})
            logger.log_step_execution(1, 0, "Step1", "click", False, 150, "Not found")
            logger.log_row_complete(1, False, 150, "Step failed")
            
            # Row 3 - Success
            logger.log_row_start(2, {"name": "test3"})
            logger.log_step_execution(2, 0, "Step1", "click", True, 120)
            logger.log_row_complete(2, True, 120)
            
            logger.flush()
            
            # Create verifier
            verifier = LogVerifier(log_file)
            summary = verifier.get_execution_summary()
            
            # Verify statistics
            assert summary['total_rows'] == 3
            assert summary['successful_rows'] == 2
            assert summary['failed_rows'] == 1
            assert summary['success_rate'] == pytest.approx(66.67, 0.1)
            
            # Check step statistics
            assert summary['total_steps'] == 4
            assert summary['successful_steps'] == 3
            assert summary['failed_steps'] == 1
            
            logger.close()
            
    def test_execution_pause_resume(self, app, test_excel_file, test_macro):
        """Test pause and resume functionality with logging"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            
            # Setup
            excel_manager = ExcelManager()
            excel_manager.load_file(test_excel_file)
            excel_manager.select_sheet(0)
            
            exec_widget = ExecutionWidget(settings)
            exec_widget.set_macro_and_excel(test_macro, excel_manager)
            
            # Start execution
            exec_widget.start_execution()
            ctx.process_events(500)
            
            # Pause
            exec_widget.toggle_pause()
            ctx.process_events(100)
            
            # Verify paused state
            assert exec_widget.engine.state == ExecutionState.PAUSED
            
            # Resume
            exec_widget.toggle_pause()
            ctx.process_events(100)
            
            # Verify resumed
            assert exec_widget.engine.state == ExecutionState.RUNNING
            
            # Stop
            exec_widget.stop_execution()
            ctx.process_events(500)
            
            exec_widget.close()
            
    def test_error_recovery_scenarios(self, app):
        """Test various error recovery scenarios"""
        scenarios = TestScenario("ì—ëŸ¬ ë³µêµ¬ ì‹œë‚˜ë¦¬ì˜¤")
        
        # Scenario 1: Retry on failure
        scenarios.add_step(
            "ì¬ì‹œë„ ì„¤ì • í…ŒìŠ¤íŠ¸",
            lambda ctx: {
                'error_handling': 'retry',
                'retry_count': 3,
                'retry_success': False  # Simulated
            }
        )
        
        # Scenario 2: Continue on error
        scenarios.add_step(
            "ê³„ì† ì§„í–‰ ì„¤ì • í…ŒìŠ¤íŠ¸",
            lambda ctx: {
                'error_handling': 'continue',
                'error_logged': True,
                'execution_continued': True
            }
        )
        
        # Scenario 3: Stop on error
        scenarios.add_step(
            "ì¤‘ì§€ ì„¤ì • í…ŒìŠ¤íŠ¸",
            lambda ctx: {
                'error_handling': 'stop',
                'execution_stopped': True,
                'error_dialog_shown': True
            }
        )
        
        # Execute scenarios
        results = scenarios.execute({})
        
        # Verify all scenarios passed
        assert results['success']
        for step in results['steps']:
            assert step['passed']


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v", "-s"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_image_capture.py">
#!/usr/bin/env python3
"""
Integration tests for image capture and search functionality
"""

import sys
import os
from pathlib import Path
import pytest
import tempfile
import numpy as np
from PIL import Image
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt, QRect, QPoint

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import GUITestContext
from vision.image_matcher import ImageMatcher
from vision.screen_capture import ScreenCapture
from core.macro_types import WaitImageStep, StepType
from config.settings import Settings


class TestImageCapture:
    """Test image capture and search functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def temp_image_dir(self):
        """Create temporary directory for test images"""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        # Cleanup
        import shutil
        shutil.rmtree(temp_dir)
        
    @pytest.fixture
    def test_image(self, temp_image_dir):
        """Create a test image"""
        # Create a simple test image
        img_array = np.zeros((100, 100, 3), dtype=np.uint8)
        # Add some distinctive features
        img_array[20:40, 20:80] = [255, 0, 0]  # Red rectangle
        img_array[60:80, 30:70] = [0, 255, 0]  # Green rectangle
        
        img = Image.fromarray(img_array)
        img_path = Path(temp_image_dir) / "test_image.png"
        img.save(img_path)
        
        return str(img_path)
        
    def test_screen_capture_region(self, app):
        """Test capturing a specific screen region"""
        with GUITestContext(app) as ctx:
            capture = ScreenCapture()
            
            # Define test region
            region = QRect(100, 100, 200, 200)
            
            # Capture region
            screenshot = capture.capture_region(region)
            
            # Verify capture
            assert screenshot is not None
            assert screenshot.shape[0] == 200  # Height
            assert screenshot.shape[1] == 200  # Width
            assert screenshot.shape[2] == 3    # RGB channels
            
    def test_image_matcher_initialization(self, app):
        """Test ImageMatcher initialization"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            matcher = ImageMatcher(settings)
            
            # Verify initialization
            assert matcher is not None
            assert hasattr(matcher, 'find_image')
            assert hasattr(matcher, 'wait_for_image')
            
    def test_find_image_in_screenshot(self, app, test_image):
        """Test finding an image within a screenshot"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            matcher = ImageMatcher(settings)
            
            # Create a larger screenshot with our test image embedded
            screenshot = np.zeros((300, 300, 3), dtype=np.uint8)
            # Load test image
            test_img = np.array(Image.open(test_image))
            # Place test image in screenshot
            screenshot[50:150, 50:150] = test_img
            
            # Find the image
            location = matcher.find_image(test_image, screenshot=screenshot)
            
            # Verify location found
            assert location is not None
            assert location[0] >= 45  # Allow small margin
            assert location[0] <= 55
            assert location[1] >= 45
            assert location[1] <= 55
            
    def test_image_not_found(self, app, test_image):
        """Test behavior when image is not found"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            matcher = ImageMatcher(settings)
            
            # Create empty screenshot
            screenshot = np.zeros((300, 300, 3), dtype=np.uint8)
            
            # Try to find image
            location = matcher.find_image(test_image, screenshot=screenshot)
            
            # Should return None
            assert location is None
            
    def test_confidence_threshold(self, app, test_image):
        """Test image matching with different confidence thresholds"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            matcher = ImageMatcher(settings)
            
            # Create screenshot with slightly modified test image
            screenshot = np.zeros((300, 300, 3), dtype=np.uint8)
            test_img = np.array(Image.open(test_image))
            # Add noise to test image
            noisy_img = test_img + np.random.randint(-20, 20, test_img.shape, dtype=np.int16)
            noisy_img = np.clip(noisy_img, 0, 255).astype(np.uint8)
            screenshot[50:150, 50:150] = noisy_img
            
            # High confidence - might not find
            location_high = matcher.find_image(test_image, screenshot=screenshot, confidence=0.95)
            
            # Low confidence - should find
            location_low = matcher.find_image(test_image, screenshot=screenshot, confidence=0.7)
            
            # Low confidence should be more likely to find the image
            assert location_low is not None
            
    def test_wait_image_step_configuration(self, app, test_image):
        """Test WaitImageStep configuration"""
        with GUITestContext(app) as ctx:
            # Create wait image step
            step = WaitImageStep()
            step.name = "ì´ë¯¸ì§€ ëŒ€ê¸° í…ŒìŠ¤íŠ¸"
            step.image_path = test_image
            step.timeout_seconds = 5
            step.confidence_threshold = 0.8
            
            # Verify configuration
            assert step.step_type == StepType.WAIT_IMAGE
            assert step.image_path == test_image
            assert step.timeout_seconds == 5
            assert step.confidence_threshold == 0.8
            
            # Test serialization
            step_dict = step.to_dict()
            assert step_dict['step_type'] == StepType.WAIT_IMAGE.value
            assert step_dict['image_path'] == test_image
            assert step_dict['timeout_seconds'] == 5
            assert step_dict['confidence_threshold'] == 0.8
            
    def test_roi_selection(self, app):
        """Test Region of Interest (ROI) selection"""
        with GUITestContext(app) as ctx:
            # Test ROI configuration
            roi = {
                'x': 100,
                'y': 200,
                'width': 300,
                'height': 400
            }
            
            # Create step with ROI
            step = WaitImageStep()
            step.region = roi
            
            # Verify ROI configuration
            assert step.region == roi
            assert step.region['x'] == 100
            assert step.region['y'] == 200
            assert step.region['width'] == 300
            assert step.region['height'] == 400
            
    def test_multiple_image_search(self, app, temp_image_dir):
        """Test searching for multiple instances of an image"""
        with GUITestContext(app) as ctx:
            settings = Settings()
            matcher = ImageMatcher(settings)
            
            # Create small pattern
            pattern = np.zeros((20, 20, 3), dtype=np.uint8)
            pattern[5:15, 5:15] = [255, 255, 0]  # Yellow square
            
            pattern_path = Path(temp_image_dir) / "pattern.png"
            Image.fromarray(pattern).save(pattern_path)
            
            # Create screenshot with multiple instances
            screenshot = np.zeros((200, 200, 3), dtype=np.uint8)
            # Place pattern in multiple locations
            screenshot[20:40, 20:40] = pattern
            screenshot[100:120, 50:70] = pattern
            screenshot[60:80, 150:170] = pattern
            
            # Find all instances (this would require extending ImageMatcher)
            # For now, just verify we can find at least one
            location = matcher.find_image(str(pattern_path), screenshot=screenshot)
            assert location is not None


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_logging_error_handling.py">
#!/usr/bin/env python3
"""
Integration tests for execution logging and error handling
"""

import sys
import os
from pathlib import Path
import pytest
import tempfile
import csv
import time
from datetime import datetime
from PyQt5.QtWidgets import QApplication

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import GUITestContext
from logger.execution_logger import ExecutionLogger, get_execution_logger
from automation.engine import ExecutionResult
from config.settings import Settings


class TestExecutionLogging:
    """Test execution logging functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def settings(self):
        """Create test settings"""
        return Settings()
        
    @pytest.fixture
    def temp_log_dir(self):
        """Create temporary log directory"""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        # Cleanup
        import shutil
        shutil.rmtree(temp_dir)
        
    @pytest.fixture
    def execution_logger(self, temp_log_dir):
        """Create execution logger with temp directory"""
        logger = ExecutionLogger(log_dir=Path(temp_log_dir))
        yield logger
        
    def test_start_session(self, app, execution_logger):
        """Test starting a logging session"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ",
                excel_file="test_data.xlsx"
            )
            
            # Verify log file created
            assert log_file is not None
            assert Path(log_file).exists()
            assert str(log_file).endswith('.csv')
            
            # Check file name format
            file_name = Path(log_file).name
            assert file_name.startswith("execution_")
            assert ".csv" in file_name
            
            # Close the session
            execution_logger.close()
            
    def test_log_row_execution(self, app, execution_logger):
        """Test logging row execution process"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ",
                excel_file="test_data.xlsx"
            )
            
            # Log row start
            execution_logger.log_row_start(
                row_index=0,
                row_data={'ì´ë¦„': 'í™ê¸¸ë™', 'ë‚˜ì´': 30}
            )
            
            # Log successful row completion
            execution_logger.log_row_complete(
                row_index=0,
                success=True,
                total_duration_ms=1500.5,
                error_message=""
            )
            
            # Log another row with failure
            execution_logger.log_row_start(
                row_index=1,
                row_data={'ì´ë¦„': 'ê¹€ì² ìˆ˜', 'ë‚˜ì´': 25}
            )
            
            execution_logger.log_row_complete(
                row_index=1,
                success=False,
                total_duration_ms=500.0,
                error_message="í´ë¦­ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ"
            )
            
            # Force close to flush
            execution_logger.close()
            
            # Verify file has content
            assert Path(log_file).stat().st_size > 0
            
    def test_log_step_execution(self, app, execution_logger):
        """Test logging individual step execution"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ",
                excel_file="test_data.xlsx"
            )
            
            # Log row start
            execution_logger.log_row_start(0, {'test': 'data'})
            
            # Log step executions
            execution_logger.log_step_execution(
                row_index=0,
                step_index=0,
                step_name="ë§ˆìš°ìŠ¤ í´ë¦­",
                step_type="mouse_click",
                success=True,
                duration_ms=100.0,
                error_message="",
                details=""
            )
            
            execution_logger.log_step_execution(
                row_index=0,
                step_index=1,
                step_name="í…ìŠ¤íŠ¸ ì…ë ¥",
                step_type="keyboard_type",
                success=False,
                duration_ms=50.0,
                error_message="íƒ€ì„ì•„ì›ƒ",
                details="ì…ë ¥ ì‹¤íŒ¨"
            )
            
            # Complete row
            execution_logger.log_row_complete(0, False, 150.0, "ì¼ë¶€ ë‹¨ê³„ ì‹¤íŒ¨")
            
            # Close session
            execution_logger.close()
            
            # Verify log file has content
            assert Path(log_file).stat().st_size > 0
            
    def test_session_end_logging(self, app, execution_logger):
        """Test session end summary logging"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ",
                excel_file="test_data.xlsx"
            )
            
            # Log some rows
            for i in range(5):
                execution_logger.log_row_start(i, {'index': i})
                execution_logger.log_row_complete(
                    row_index=i,
                    success=(i % 2 == 0),  # Alternate success/failure
                    total_duration_ms=1000.0,
                    error_message="" if i % 2 == 0 else "Test error"
                )
                
            # Log session end
            execution_logger.log_session_end(
                total_rows=5,
                successful_rows=3,
                failed_rows=2
            )
            
            # Close
            execution_logger.close()
            
            # Verify log file exists and has content
            assert Path(log_file).exists()
            assert Path(log_file).stat().st_size > 0
            
    def test_error_logging(self, app, execution_logger):
        """Test error logging functionality"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="ì—ëŸ¬ í…ŒìŠ¤íŠ¸",
                excel_file="test.xlsx"
            )
            
            # Log various errors
            execution_logger.log_error(
                error_type="ImageNotFound",
                error_message="ëŒ€ìƒ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
                details="image_path: /tmp/target.png"
            )
            
            execution_logger.log_error(
                error_type="TimeoutError",
                error_message="ì‘ì—… ì‹œê°„ ì´ˆê³¼",
                details="timeout: 30s"
            )
            
            # Close
            execution_logger.close()
            
            # Verify errors were logged
            assert Path(log_file).stat().st_size > 0
            
    def test_concurrent_logging(self, app, temp_log_dir):
        """Test multiple logger instances"""
        with GUITestContext(app) as ctx:
            # Create multiple logger instances
            logger1 = ExecutionLogger(log_dir=Path(temp_log_dir))
            logger2 = ExecutionLogger(log_dir=Path(temp_log_dir))
            
            # Start sessions
            log_file1 = logger1.start_session("ë§¤í¬ë¡œ1", "data1.xlsx")
            log_file2 = logger2.start_session("ë§¤í¬ë¡œ2", "data2.xlsx")
            
            # Log to both
            logger1.log_row_start(0, {'data': 1})
            logger1.log_row_complete(0, True, 100, "")
            
            logger2.log_row_start(0, {'data': 2})
            logger2.log_row_complete(0, True, 200, "")
            
            # Close sessions
            logger1.close()
            logger2.close()
            
            # Both files should exist
            assert Path(log_file1).exists()
            assert Path(log_file2).exists()
            assert log_file1 != log_file2
            
    def test_get_execution_logger_singleton(self, app):
        """Test singleton logger instance"""
        with GUITestContext(app) as ctx:
            # Get logger instances
            logger1 = get_execution_logger()
            logger2 = get_execution_logger()
            
            # Should be the same instance
            assert logger1 is logger2
            
    def test_long_running_session(self, app, execution_logger):
        """Test logging over extended period"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="ì¥ì‹œê°„ í…ŒìŠ¤íŠ¸",
                excel_file="test.xlsx"
            )
            
            # Log many rows with small delays
            for i in range(10):
                execution_logger.log_row_start(i, {'index': i})
                
                # Log multiple steps
                for j in range(3):
                    execution_logger.log_step_execution(
                        row_index=i,
                        step_index=j,
                        step_name=f"ë‹¨ê³„ {j}",
                        step_type="wait_time",
                        success=True,
                        duration_ms=50.0,
                        error_message="",
                        details=""
                    )
                    
                execution_logger.log_row_complete(i, True, 150.0, "")
                
                # Small delay
                time.sleep(0.01)
                
            # Close
            execution_logger.close()
            
            # Should have logged all data
            assert Path(log_file).stat().st_size > 0
            
    def test_log_directory_creation(self, app):
        """Test automatic log directory creation"""
        with GUITestContext(app) as ctx:
            # Create logger with non-existent directory
            non_existent = Path("/tmp/test_macro_logs_" + str(time.time()))
            logger = ExecutionLogger(log_dir=non_existent)
            
            # Start session should create directory
            log_file = logger.start_session("í…ŒìŠ¤íŠ¸", "data.xlsx")
            
            # Directory should be created
            assert non_existent.exists()
            assert non_existent.is_dir()
            
            # Cleanup
            logger.close()
            import shutil
            shutil.rmtree(non_existent)
            
    def test_special_characters_in_data(self, app, execution_logger):
        """Test logging data with special characters"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="íŠ¹ìˆ˜ë¬¸ì í…ŒìŠ¤íŠ¸",
                excel_file="test.xlsx"
            )
            
            # Log data with special characters
            execution_logger.log_row_start(
                row_index=0,
                row_data={
                    'name': 'í™ê¸¸ë™, "í…ŒìŠ¤í„°"',
                    'description': 'Line1\nLine2\nLine3',
                    'note': 'Tab\there',
                    'path': 'C:\\Users\\Test\\File.txt'
                }
            )
            
            execution_logger.log_row_complete(0, True, 100, "")
            
            # Close
            execution_logger.close()
            
            # Should handle special characters properly
            assert Path(log_file).exists()
            
    def test_empty_session(self, app, execution_logger):
        """Test session with no data logged"""
        with GUITestContext(app) as ctx:
            # Start session
            log_file = execution_logger.start_session(
                macro_name="ë¹ˆ ì„¸ì…˜",
                excel_file="empty.xlsx"
            )
            
            # Close immediately without logging
            execution_logger.close()
            
            # File should still exist (with headers at least)
            assert Path(log_file).exists()


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_macro_execution.py">
#!/usr/bin/env python3
"""
Integration tests for macro execution and pause/resume functionality
"""

import sys
import os
from pathlib import Path
import pytest
import tempfile
import time
from PyQt5.QtWidgets import QApplication, QMessageBox
from PyQt5.QtCore import QTimer, Qt
from PyQt5.QtTest import QTest

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import GUITestContext
from automation.engine import ExecutionEngine, ExecutionState
from excel.excel_manager import ExcelManager
from core.macro_types import (
    Macro, MacroStep, StepType, KeyboardTypeStep, 
    MouseClickStep, WaitTimeStep, IfConditionStep, MouseButton
)
from ui.widgets.execution_widget import ExecutionControlWidget
from config.settings import Settings


class TestMacroExecution:
    """Test macro execution and control functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def settings(self):
        """Create test settings"""
        return Settings()
        
    @pytest.fixture
    def simple_macro(self):
        """Create a simple test macro"""
        macro = Macro(name="í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë§¤í¬ë¡œ")
        
        # Add a few simple steps
        wait_step = WaitTimeStep()
        wait_step.name = "ì‹œì‘ ëŒ€ê¸°"
        wait_step.seconds = 0.1  # Short wait for testing
        macro.add_step(wait_step)
        
        type_step = KeyboardTypeStep()
        type_step.name = "í…ìŠ¤íŠ¸ ì…ë ¥"
        type_step.text = "Hello {{name}}"
        macro.add_step(type_step)
        
        wait_step2 = WaitTimeStep()
        wait_step2.name = "ì¢…ë£Œ ëŒ€ê¸°"
        wait_step2.seconds = 0.1
        macro.add_step(wait_step2)
        
        return macro
        
    @pytest.fixture
    def complex_macro(self):
        """Create a macro with conditional logic"""
        macro = Macro(name="ë³µì¡í•œ ë§¤í¬ë¡œ")
        
        # Conditional step
        condition_step = IfConditionStep()
        condition_step.name = "ì¡°ê±´ í™•ì¸"
        condition_step.condition_type = "variable_equals"
        condition_step.condition_value = {
            "variable": "mode",
            "compare_value": "auto"
        }
        
        # True branch
        true_type = KeyboardTypeStep()
        true_type.name = "ìë™ ëª¨ë“œ"
        true_type.text = "ìë™ ì‹¤í–‰ ì¤‘..."
        condition_step.true_steps = [true_type]
        
        # False branch
        false_type = KeyboardTypeStep()
        false_type.name = "ìˆ˜ë™ ëª¨ë“œ"
        false_type.text = "ìˆ˜ë™ ì‹¤í–‰ ì¤‘..."
        condition_step.false_steps = [false_type]
        
        macro.add_step(condition_step)
        
        return macro
        
    @pytest.fixture
    def test_excel_manager(self):
        """Create test Excel manager with dummy data"""
        # Create temporary Excel file
        temp_file = tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False)
        
        import pandas as pd
        data = pd.DataFrame({
            'ì´ë¦„': ['í…ŒìŠ¤íŠ¸1', 'í…ŒìŠ¤íŠ¸2', 'í…ŒìŠ¤íŠ¸3'],
            'ìƒíƒœ': ['', '', ''],
            'Status': ['', '', '']
        })
        
        data.to_excel(temp_file.name, index=False)
        temp_file.close()
        
        manager = ExcelManager()
        manager.load_file(temp_file.name)
        manager.read_sheet('Sheet1')
        
        yield manager
        
        # Cleanup
        os.unlink(temp_file.name)
        
    def test_basic_execution(self, app, settings, simple_macro, test_excel_manager):
        """Test basic macro execution"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            
            # Set macro and excel manager
            engine.set_macro(simple_macro, test_excel_manager)
            
            # Set variables
            engine.step_executor.set_variables({'name': 'í…ŒìŠ¤í„°'})
            
            # Track state changes
            state_changes = []
            
            def on_state_changed(state):
                state_changes.append(state)
                
            engine.stateChanged.connect(on_state_changed)
            
            # Start execution
            engine.start()
            
            # Wait for completion
            timeout = 2000
            start_time = time.time()
            while engine.state not in [ExecutionState.IDLE, ExecutionState.STOPPED]:
                if (time.time() - start_time) * 1000 > timeout:
                    engine.stop_execution()
                    break
                QTest.qWait(100)
                
            # Verify execution states
            assert ExecutionState.RUNNING in state_changes
            
    def test_pause_resume(self, app, settings, simple_macro, test_excel_manager):
        """Test pause and resume functionality"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            
            # Set longer wait steps for pause testing
            simple_macro.steps[0].seconds = 0.5
            simple_macro.steps[2].seconds = 0.5
            
            engine.set_macro(simple_macro, test_excel_manager)
            
            # Track states
            states = []
            
            def on_state_changed(state):
                states.append(state)
                
            engine.stateChanged.connect(on_state_changed)
            
            # Start execution
            engine.start()
            
            # Pause after a short delay
            QTimer.singleShot(200, engine.toggle_pause)
            
            # Resume after another delay
            QTimer.singleShot(400, engine.toggle_pause)
            
            # Wait for completion
            timeout = 3000
            start_time = time.time()
            while engine.state not in [ExecutionState.IDLE, ExecutionState.STOPPED]:
                if (time.time() - start_time) * 1000 > timeout:
                    engine.stop_execution()
                    break
                QTest.qWait(100)
                
            # Verify states changed
            assert ExecutionState.RUNNING in states
            assert ExecutionState.PAUSED in states
            
    def test_stop_execution(self, app, settings, simple_macro, test_excel_manager):
        """Test stopping execution"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            
            # Set longer wait for stop testing
            simple_macro.steps[0].seconds = 2.0
            
            engine.set_macro(simple_macro, test_excel_manager)
            
            # Track completion
            finished = False
            
            def on_finished():
                nonlocal finished
                finished = True
                
            engine.executionFinished.connect(on_finished)
            
            # Start execution
            engine.start()
            
            # Stop after a short delay
            QTimer.singleShot(200, engine.stop_execution)
            
            # Wait briefly
            QTest.qWait(500)
            
            # Verify stopped
            assert engine.state in [ExecutionState.STOPPED, ExecutionState.IDLE]
            assert finished  # Should emit finished signal
            
    def test_variable_substitution(self, app, settings, test_excel_manager):
        """Test variable substitution during execution"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            
            # Create macro with variables
            macro = Macro(name="ë³€ìˆ˜ í…ŒìŠ¤íŠ¸")
            
            type_step = KeyboardTypeStep()
            type_step.text = "ì´ë¦„: {{name}}, ë‚˜ì´: {{age}}"
            macro.add_step(type_step)
            
            engine.set_macro(macro, test_excel_manager)
            
            # Set variables
            engine.step_executor.set_variables({
                'name': 'í™ê¸¸ë™',
                'age': 25
            })
            
            # Execute
            engine.start()
            
            # Wait for completion
            timeout = 1000
            start_time = time.time()
            while engine.state not in [ExecutionState.IDLE, ExecutionState.STOPPED]:
                if (time.time() - start_time) * 1000 > timeout:
                    engine.stop_execution()
                    break
                QTest.qWait(100)
                
            # Execution should complete without errors
            
    def test_conditional_execution(self, app, settings, complex_macro, test_excel_manager):
        """Test conditional step execution"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            
            # Test true branch
            engine.set_macro(complex_macro, test_excel_manager)
            engine.step_executor.set_variables({'mode': 'auto'})
            
            # Track executed steps
            executed_steps = []
            
            def on_step_executing(step, row_index):
                executed_steps.append(step.name)
                
            engine.stepExecuting.connect(on_step_executing)
            
            # Execute
            engine.start()
            
            # Wait for completion
            while engine.state not in [ExecutionState.IDLE, ExecutionState.STOPPED]:
                QTest.qWait(100)
                
            # Should have executed conditional branch
            # The exact steps depend on how the execution engine handles nested steps
            
    def test_error_handling(self, app, settings, test_excel_manager):
        """Test error handling during execution"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            
            # Create macro with invalid step
            macro = Macro(name="ì—ëŸ¬ í…ŒìŠ¤íŠ¸")
            
            # Add a wait step (valid steps are needed for a macro)
            wait_step = WaitTimeStep()
            wait_step.seconds = 0.1
            macro.add_step(wait_step)
            
            engine.set_macro(macro, test_excel_manager)
            
            # Track errors
            errors = []
            
            def on_error(error_msg):
                errors.append(error_msg)
                
            engine.error.connect(on_error)
            
            # Execute
            engine.start()
            
            # Wait for completion
            timeout = 1000
            start_time = time.time()
            while engine.state not in [ExecutionState.IDLE, ExecutionState.STOPPED]:
                if (time.time() - start_time) * 1000 > timeout:
                    engine.stop_execution()
                    break
                QTest.qWait(100)
                
            # Should execute without major errors
            
    def test_execution_control_widget(self, app, settings, simple_macro, test_excel_manager):
        """Test execution control widget"""
        with GUITestContext(app) as ctx:
            control = ExecutionControlWidget()
            control.show()
            
            # Initialize with engine
            engine = ExecutionEngine(settings)
            engine.set_macro(simple_macro, test_excel_manager)
            control.set_engine(engine)
            
            # Verify initial state
            assert control.play_button.isEnabled()
            assert not control.pause_button.isEnabled()
            assert not control.stop_button.isEnabled()
            
            # Start execution
            control.play_button.click()
            QTest.qWait(100)
            
            # Verify running state
            assert not control.play_button.isEnabled()
            assert control.pause_button.isEnabled()
            assert control.stop_button.isEnabled()
            
            # Wait for completion or stop
            timeout = 2000
            start_time = time.time()
            while engine.state == ExecutionState.RUNNING:
                if (time.time() - start_time) * 1000 > timeout:
                    control.stop_button.click()
                    break
                QTest.qWait(100)
                
    def test_multiple_row_execution(self, app, settings, simple_macro, test_excel_manager):
        """Test executing multiple Excel rows"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            engine.set_macro(simple_macro, test_excel_manager)
            
            # Set specific rows to execute
            engine.set_target_rows([0, 1, 2])
            
            # Track progress
            progress_updates = []
            
            def on_progress(current, total):
                progress_updates.append((current, total))
                
            engine.progressUpdated.connect(on_progress)
            
            # Execute
            engine.start()
            
            # Wait for completion
            timeout = 3000
            start_time = time.time()
            while engine.state not in [ExecutionState.IDLE, ExecutionState.STOPPED]:
                if (time.time() - start_time) * 1000 > timeout:
                    engine.stop_execution()
                    break
                QTest.qWait(100)
                
            # Should have progress updates
            assert len(progress_updates) > 0
            
    def test_hotkey_control(self, app, settings, simple_macro, test_excel_manager):
        """Test hotkey pause/stop control"""
        with GUITestContext(app) as ctx:
            engine = ExecutionEngine(settings)
            
            # Set longer execution for hotkey testing
            simple_macro.steps[0].seconds = 1.0
            
            engine.set_macro(simple_macro, test_excel_manager)
            
            # Start execution
            engine.start()
            
            # The hotkey listener should be active
            # In a real test we would simulate hotkey presses
            # For now just verify the engine can be controlled
            
            QTest.qWait(200)
            engine.toggle_pause()
            assert engine.state == ExecutionState.PAUSED
            
            engine.toggle_pause()
            QTest.qWait(100)
            
            engine.stop_execution()
            QTest.qWait(500)
            
            assert engine.state in [ExecutionState.STOPPED, ExecutionState.IDLE]


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_macro_storage.py">
#!/usr/bin/env python3
"""
Integration tests for macro storage functionality
"""

import sys
import os
from pathlib import Path
import pytest
import tempfile
import json
from PyQt5.QtWidgets import QApplication

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import GUITestContext
from core.macro_types import (
    Macro, MacroStep, StepType, KeyboardTypeStep, 
    MouseClickStep, WaitTimeStep, IfConditionStep, MouseButton
)
from core.macro_storage import MacroStorage, MacroFormat
from config.settings import Settings


class TestMacroStorage:
    """Test macro storage functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def temp_storage_dir(self):
        """Create temporary storage directory"""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        # Cleanup
        import shutil
        shutil.rmtree(temp_dir)
        
    @pytest.fixture
    def test_macro(self):
        """Create a test macro with various steps"""
        macro = Macro(name="í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ")
        macro.description = "ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° í…ŒìŠ¤íŠ¸ìš©"
        
        # Add various step types
        # 1. Wait step
        wait_step = WaitTimeStep()
        wait_step.name = "ëŒ€ê¸°"
        wait_step.seconds = 2.5
        macro.add_step(wait_step)
        
        # 2. Type step with variables
        type_step = KeyboardTypeStep()
        type_step.name = "í…ìŠ¤íŠ¸ ì…ë ¥"
        type_step.text = "ì•ˆë…•í•˜ì„¸ìš” {{ì´ë¦„}}ë‹˜"
        type_step.interval = 0.05
        macro.add_step(type_step)
        
        # 3. Click step
        click_step = MouseClickStep()
        click_step.name = "ë§ˆìš°ìŠ¤ í´ë¦­"
        click_step.x = 100
        click_step.y = 200
        click_step.button = MouseButton.LEFT
        click_step.clicks = 2
        macro.add_step(click_step)
        
        # 4. Conditional step
        condition_step = IfConditionStep()
        condition_step.name = "ì¡°ê±´ í™•ì¸"
        condition_step.condition_type = "variable_equals"
        condition_step.variable_name = "ìƒíƒœ"
        condition_step.compare_value = "ì™„ë£Œ"
        
        # Add steps to branches
        true_step = KeyboardTypeStep()
        true_step.name = "ì™„ë£Œ ë©”ì‹œì§€"
        true_step.text = "ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"
        condition_step.true_steps = [true_step]
        
        false_step = KeyboardTypeStep()
        false_step.name = "ëŒ€ê¸° ë©”ì‹œì§€"
        false_step.text = "ì‘ì—… ëŒ€ê¸° ì¤‘ì…ë‹ˆë‹¤"
        condition_step.false_steps = [false_step]
        
        macro.add_step(condition_step)
        
        # Add variables
        macro.variables = {
            'ì´ë¦„': 'í™ê¸¸ë™',
            'ìƒíƒœ': 'ì™„ë£Œ'
        }
        
        return macro
        
    def test_save_macro_json(self, app, test_macro, temp_storage_dir):
        """Test saving macro in JSON format"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Save macro
            file_path = Path(temp_storage_dir) / "test_macro.json"
            result = storage.save_macro(test_macro, str(file_path), MacroFormat.JSON)
            
            # Verify save was successful
            assert result is True
            assert file_path.exists()
            
            # Check file content
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            assert 'schema_version' in data
            assert 'macro' in data
            assert data['macro']['name'] == "í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ"
            assert len(data['macro']['steps']) == 4
            
    def test_load_macro_json(self, app, test_macro, temp_storage_dir):
        """Test loading macro from JSON"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Save macro first
            file_path = Path(temp_storage_dir) / "test_macro.json"
            storage.save_macro(test_macro, str(file_path), MacroFormat.JSON)
            
            # Load macro
            loaded_macro = storage.load_macro(str(file_path))
            
            # Verify loaded macro matches original
            assert loaded_macro.name == test_macro.name
            assert loaded_macro.description == test_macro.description
            assert len(loaded_macro.steps) == len(test_macro.steps)
            assert loaded_macro.variables == test_macro.variables
            
            # Check specific steps
            assert loaded_macro.steps[0].step_type == StepType.WAIT_TIME
            assert loaded_macro.steps[0].seconds == 2.5
            
            assert loaded_macro.steps[1].step_type == StepType.KEYBOARD_TYPE
            assert loaded_macro.steps[1].text == "ì•ˆë…•í•˜ì„¸ìš” {{ì´ë¦„}}ë‹˜"
            
    def test_save_macro_encrypted(self, app, test_macro, temp_storage_dir):
        """Test saving macro in encrypted format"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Save macro as encrypted
            file_path = Path(temp_storage_dir) / "test_macro.emf"
            result = storage.save_macro(test_macro, str(file_path), MacroFormat.ENCRYPTED)
            
            # Verify save was successful
            assert result is True
            assert file_path.exists()
            
            # File should not be readable as plain text
            content = file_path.read_bytes()
            assert b'"name"' not in content  # JSON content should be encrypted
            
    def test_load_macro_encrypted(self, app, test_macro, temp_storage_dir):
        """Test loading encrypted macro"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Save as encrypted
            file_path = Path(temp_storage_dir) / "test_macro.emf"
            storage.save_macro(test_macro, str(file_path), MacroFormat.ENCRYPTED)
            
            # Load encrypted macro
            loaded_macro = storage.load_macro(str(file_path))
            
            # Verify loaded macro matches original
            assert loaded_macro.name == test_macro.name
            assert loaded_macro.description == test_macro.description
            assert len(loaded_macro.steps) == len(test_macro.steps)
            
    def test_macro_backup(self, app, test_macro, temp_storage_dir):
        """Test macro backup functionality"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Save initial macro
            file_path = Path(temp_storage_dir) / "test_macro.json"
            storage.save_macro(test_macro, str(file_path), MacroFormat.JSON)
            
            # Modify macro
            test_macro.name = "ìˆ˜ì •ëœ ë§¤í¬ë¡œ"
            test_macro.add_step(WaitTimeStep())
            
            # Save again (should create backup)
            storage.save_macro(test_macro, str(file_path), MacroFormat.JSON, create_backup=True)
            
            # Check backup exists in backups directory
            backup_dir = Path(temp_storage_dir) / "backups"
            assert backup_dir.exists()
            backup_files = list(backup_dir.glob("test_macro_backup_*.json"))
            assert len(backup_files) > 0
            
    def test_list_macros(self, app, temp_storage_dir):
        """Test listing available macros"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Create multiple macros
            for i in range(3):
                macro = Macro(name=f"ë§¤í¬ë¡œ {i+1}")
                file_path = Path(temp_storage_dir) / f"macro_{i}.json"
                storage.save_macro(macro, str(file_path))
                
            # List macros
            macros = storage.list_macros()
            
            # Verify count
            assert len(macros) >= 3
            
    def test_macro_with_complex_steps(self, app, temp_storage_dir):
        """Test saving/loading macro with complex nested steps"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Create macro with nested conditions
            macro = Macro(name="ë³µì¡í•œ ë§¤í¬ë¡œ")
            
            # Nested if condition
            outer_condition = IfConditionStep()
            outer_condition.name = "ì™¸ë¶€ ì¡°ê±´"
            outer_condition.condition_type = "variable_equals"
            outer_condition.variable_name = "mode"
            outer_condition.compare_value = "auto"
            
            # Inner condition in true branch
            inner_condition = IfConditionStep()
            inner_condition.name = "ë‚´ë¶€ ì¡°ê±´"
            inner_condition.condition_type = "variable_not_empty"
            inner_condition.variable_name = "target"
            
            inner_true_step = KeyboardTypeStep()
            inner_true_step.text = "ìë™ ì²˜ë¦¬: {{target}}"
            inner_condition.true_steps = [inner_true_step]
            
            outer_condition.true_steps = [inner_condition]
            macro.add_step(outer_condition)
            
            # Save and load
            file_path = Path(temp_storage_dir) / "complex_macro.json"
            storage.save_macro(macro, str(file_path))
            loaded_macro = storage.load_macro(str(file_path))
            
            # Verify nested structure preserved
            assert len(loaded_macro.steps) == 1
            outer = loaded_macro.steps[0]
            assert outer.step_type == StepType.IF_CONDITION
            assert len(outer.true_steps) == 1
            
            inner = outer.true_steps[0]
            assert inner.step_type == StepType.IF_CONDITION
            assert len(inner.true_steps) == 1
            assert inner.true_steps[0].text == "ìë™ ì²˜ë¦¬: {{target}}"
            
    def test_invalid_file_handling(self, app, temp_storage_dir):
        """Test handling of invalid files"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Non-existent file
            with pytest.raises(FileNotFoundError):
                storage.load_macro("/nonexistent/file.json")
                
            # Invalid JSON
            invalid_file = Path(temp_storage_dir) / "invalid.json"
            invalid_file.write_text("{ invalid json }")
            
            with pytest.raises(json.JSONDecodeError):
                storage.load_macro(str(invalid_file))
                
    def test_file_permissions(self, app, test_macro, temp_storage_dir):
        """Test saving with different file permissions"""
        with GUITestContext(app) as ctx:
            storage = MacroStorage(Path(temp_storage_dir))
            
            # Normal save
            file_path = Path(temp_storage_dir) / "test_macro.json"
            result = storage.save_macro(test_macro, str(file_path))
            assert result is True
            
            # Verify file permissions (should be readable/writable by user)
            assert os.access(file_path, os.R_OK)
            assert os.access(file_path, os.W_OK)


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_step_configuration.py">
#!/usr/bin/env python3
"""
Integration tests for step configuration dialogs
"""

import sys
import os
from pathlib import Path
import pytest
from PyQt5.QtWidgets import QApplication, QLineEdit, QSpinBox, QComboBox, QPushButton
from PyQt5.QtCore import Qt, QTimer
import tempfile
import shutil

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import DialogTester, GUITestContext, TestScenario
from ui.dialogs.image_step_dialog import ImageStepDialog, WaitImageStepDialog
from ui.dialogs.text_search_step_dialog import TextSearchStepDialog
from ui.dialogs.if_condition_step_dialog import IfConditionStepDialog
from core.macro_types import (
    WaitImageStep, TextSearchStep, IfConditionStep,
    StepType, ErrorHandling
)


class TestStepConfiguration:
    """Test step configuration dialogs"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def temp_dir(self):
        """Create temporary directory for test files"""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        shutil.rmtree(temp_dir)
        
    def test_image_step_dialog_creation(self, app):
        """Test creating and configuring image step dialog"""
        with GUITestContext(app) as ctx:
            # Create dialog
            dialog = WaitImageStepDialog()
            dialog.show()
            ctx.process_events(100)
            
            # Set step name
            name_input = dialog.findChild(QLineEdit, "name_input")
            if not name_input:
                name_input = dialog.name_input
            name_input.setText("í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ëŒ€ê¸°")
            
            # Set timeout
            timeout_spinbox = dialog.findChild(QSpinBox)
            if timeout_spinbox:
                timeout_spinbox.setValue(10)
                
            # Get step data
            step_dict = dialog.get_step_data()
            
            # Verify configuration
            assert step_dict['name'] == "í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ëŒ€ê¸°"
            assert step_dict['step_type'] == StepType.WAIT_IMAGE.value
            
            dialog.close()
            
    def test_text_search_dialog_with_excel_binding(self, app):
        """Test text search dialog with Excel column binding"""
        with GUITestContext(app) as ctx:
            # Excel columns for testing
            excel_columns = ["ì´ë¦„", "ì „í™”ë²ˆí˜¸", "ì£¼ì†Œ", "ì´ë©”ì¼"]
            
            # Create dialog
            dialog = TextSearchStepDialog(excel_columns=excel_columns)
            dialog.show()
            ctx.process_events(100)
            
            # Set name
            dialog.name_edit.setText("í™˜ì ì´ë¦„ ê²€ìƒ‰")
            
            # Test fixed text mode
            dialog.fixed_text_radio.setChecked(True)
            dialog.search_text_edit.setText("í™ê¸¸ë™")
            ctx.process_events(50)
            
            # Verify fixed text configuration
            step_dict = dialog.get_step_data()
            assert step_dict['search_text'] == "í™ê¸¸ë™"
            assert step_dict['use_excel_column'] is False
            
            # Switch to Excel column mode
            dialog.excel_column_radio.setChecked(True)
            ctx.process_events(50)
            
            # Select column
            dialog.excel_column_combo.setCurrentText("ì´ë¦„")
            
            # Verify Excel binding configuration
            step_dict = dialog.get_step_data()
            assert step_dict['excel_column'] == "ì´ë¦„"
            assert step_dict['use_excel_column'] is True
            
            dialog.close()
            
    def test_if_condition_dialog_complex_setup(self, app):
        """Test if condition dialog with complex configuration"""
        with GUITestContext(app) as ctx:
            # Create dialog
            excel_columns = ["ìƒíƒœ", "ê¸ˆì•¡", "í™•ì¸ì—¬ë¶€"]
            dialog = IfConditionStepDialog(excel_columns=excel_columns)
            dialog.show()
            ctx.process_events(100)
            
            # Set name
            dialog.name_edit.setText("ìƒíƒœ í™•ì¸ ì¡°ê±´")
            
            # Select condition type
            dialog.condition_type_combo.setCurrentText("variable_equals")
            ctx.process_events(50)
            
            # Configure variable comparison
            if hasattr(dialog, 'variable_combo'):
                dialog.variable_combo.setCurrentText("ìƒíƒœ")
                
            if hasattr(dialog, 'value_edit'):
                dialog.value_edit.setText("ì™„ë£Œ")
                
            # Add true branch step (would normally open another dialog)
            # For testing, we'll verify the UI allows it
            add_true_btn = dialog.findChild(QPushButton, "add_true_step_btn")
            if not add_true_btn:
                # Find by text
                buttons = dialog.findChildren(QPushButton)
                for btn in buttons:
                    if "True ë¶„ê¸°" in btn.text():
                        add_true_btn = btn
                        break
                        
            assert add_true_btn is not None
            
            # Get step data
            step_dict = dialog.get_step_data()
            
            # Verify configuration
            assert step_dict['name'] == "ìƒíƒœ í™•ì¸ ì¡°ê±´"
            assert step_dict['step_type'] == StepType.IF_CONDITION.value
            assert step_dict['condition_type'] == "variable_equals"
            
            dialog.close()
            
    def test_coordinate_recording_simulation(self, app):
        """Test coordinate recording functionality"""
        with GUITestContext(app) as ctx:
            # This tests the concept since actual screen capture requires user interaction
            
            # Simulate coordinate selection
            test_coordinates = [(100, 200), (300, 400), (500, 600)]
            
            scenario = TestScenario("ì¢Œí‘œ ë…¹í™” í…ŒìŠ¤íŠ¸")
            
            for i, (x, y) in enumerate(test_coordinates):
                scenario.add_step(
                    f"ì¢Œí‘œ {i+1} ê¸°ë¡: ({x}, {y})",
                    lambda coords=(x, y): coords,
                    (x, y)
                )
                
            # Execute scenario
            results = scenario.execute({})
            
            # Verify all coordinates recorded correctly
            assert results['success']
            for i, step_result in enumerate(results['steps']):
                assert step_result['passed']
                assert step_result['actual_result'] == test_coordinates[i]
                
    def test_dialog_validation(self, app):
        """Test dialog validation and error handling"""
        with GUITestContext(app) as ctx:
            # Test image dialog without image
            dialog = WaitImageStepDialog()
            dialog.show()
            ctx.process_events(100)
            
            # Try to get data without setting image
            dialog.name_input.setText("No Image Test")
            
            # This should show validation error
            # In real implementation, clicking OK would show error
            ok_button = dialog.button_box.button(dialog.button_box.Ok)
            
            # Verify validation state
            # The dialog should not close without valid image
            dialog.close()
            
    def test_step_editing(self, app):
        """Test editing existing steps"""
        with GUITestContext(app) as ctx:
            # Create a step with initial data
            initial_step = TextSearchStep()
            initial_step.name = "ì´ˆê¸° í…ìŠ¤íŠ¸ ê²€ìƒ‰"
            initial_step.search_text = "ì´ˆê¸°ê°’"
            initial_step.timeout_seconds = 5
            
            # Open dialog with existing step
            dialog = TextSearchStepDialog(step=initial_step)
            dialog.show()
            ctx.process_events(100)
            
            # Verify initial values loaded
            assert dialog.name_edit.text() == "ì´ˆê¸° í…ìŠ¤íŠ¸ ê²€ìƒ‰"
            assert dialog.search_text_edit.text() == "ì´ˆê¸°ê°’"
            
            # Modify values
            dialog.name_edit.setText("ìˆ˜ì •ëœ í…ìŠ¤íŠ¸ ê²€ìƒ‰")
            dialog.search_text_edit.setText("ìˆ˜ì •ëœê°’")
            dialog.timeout_spin.setValue(10)
            
            # Get updated data
            step_dict = dialog.get_step_data()
            
            # Verify changes
            assert step_dict['name'] == "ìˆ˜ì •ëœ í…ìŠ¤íŠ¸ ê²€ìƒ‰"
            assert step_dict['search_text'] == "ìˆ˜ì •ëœê°’"
            assert step_dict['timeout_seconds'] == 10
            
            dialog.close()
            
    def test_error_handling_options(self, app):
        """Test error handling configuration in dialogs"""
        with GUITestContext(app) as ctx:
            dialog = WaitImageStepDialog()
            dialog.show()
            ctx.process_events(100)
            
            # Find error handling combo
            error_combo = None
            combos = dialog.findChildren(QComboBox)
            for combo in combos:
                if combo.count() > 0 and "stop" in combo.itemText(0).lower():
                    error_combo = combo
                    break
                    
            if error_combo:
                # Test different error handling options
                error_options = ["stop", "continue", "retry"]
                
                for option in error_options:
                    # Find matching item
                    for i in range(error_combo.count()):
                        if option in error_combo.itemText(i).lower():
                            error_combo.setCurrentIndex(i)
                            ctx.process_events(50)
                            
                            # Verify selection
                            step_dict = dialog.get_step_data()
                            assert step_dict.get('error_handling') is not None
                            break
                            
            dialog.close()


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_step_executor.py">
#!/usr/bin/env python3
"""
Integration tests for step executor functionality
"""

import sys
import os
from pathlib import Path
import pytest
import tempfile
from PyQt5.QtWidgets import QApplication

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import GUITestContext
from automation.executor import StepExecutor
from core.macro_types import (
    MacroStep, StepType, KeyboardTypeStep, 
    MouseClickStep, WaitTimeStep, IfConditionStep, MouseButton
)
from config.settings import Settings


class TestStepExecutor:
    """Test individual step execution functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def settings(self):
        """Create test settings"""
        return Settings()
        
    @pytest.fixture
    def executor(self, settings):
        """Create step executor"""
        return StepExecutor(settings)
        
    def test_wait_time_execution(self, app, executor):
        """Test wait time step execution"""
        with GUITestContext(app) as ctx:
            # Create wait step
            step = WaitTimeStep()
            step.name = "í…ŒìŠ¤íŠ¸ ëŒ€ê¸°"
            step.seconds = 0.1
            
            # Execute
            import time
            start_time = time.time()
            executor.execute_step(step)
            elapsed = time.time() - start_time
            
            # Should have waited approximately the specified time
            assert elapsed >= 0.09  # Allow small margin
            assert elapsed < 0.2
            
    def test_variable_substitution(self, app, executor):
        """Test variable substitution in text"""
        with GUITestContext(app) as ctx:
            # Set variables
            executor.set_variables({
                'name': 'í™ê¸¸ë™',
                'age': 25,
                'city': 'ì„œìš¸'
            })
            
            # Test substitution
            text = "ì´ë¦„: {{name}}, ë‚˜ì´: {{age}}, ë„ì‹œ: {{city}}"
            result = executor._substitute_variables(text)
            
            assert result == "ì´ë¦„: í™ê¸¸ë™, ë‚˜ì´: 25, ë„ì‹œ: ì„œìš¸"
            
    def test_variable_substitution_missing(self, app, executor):
        """Test substitution with missing variables"""
        with GUITestContext(app) as ctx:
            executor.set_variables({'name': 'í…ŒìŠ¤í„°'})
            
            # Missing variable should remain unchanged
            text = "ì´ë¦„: {{name}}, ì´ë©”ì¼: {{email}}"
            result = executor._substitute_variables(text)
            
            assert result == "ì´ë¦„: í…ŒìŠ¤í„°, ì´ë©”ì¼: {{email}}"
            
    def test_keyboard_type_step(self, app, executor):
        """Test keyboard typing step"""
        with GUITestContext(app) as ctx:
            # Create type step
            step = KeyboardTypeStep()
            step.text = "Hello World"
            step.interval = 0.0
            
            # Execute (in test environment, this won't actually type)
            try:
                executor.execute_step(step)
            except Exception as e:
                # May fail without proper display, but should handle gracefully
                pass
                
    def test_conditional_step_true(self, app, executor):
        """Test conditional step with true condition"""
        with GUITestContext(app) as ctx:
            # Create conditional step
            step = IfConditionStep()
            step.condition_type = "variable_equals"
            step.condition_value = {
                "variable": "status",
                "compare_value": "active"
            }
            
            # Add true branch step
            true_step = WaitTimeStep()
            true_step.seconds = 0.05
            step.true_steps = [true_step]
            
            # Add false branch step
            false_step = WaitTimeStep()
            false_step.seconds = 0.1
            step.false_steps = [false_step]
            
            # Set variable to make condition true
            executor.set_variables({'status': 'active'})
            
            # Execute
            import time
            start_time = time.time()
            executor.execute_step(step)
            elapsed = time.time() - start_time
            
            # Should have executed true branch (shorter wait)
            assert elapsed < 0.08
            
    def test_conditional_step_false(self, app, executor):
        """Test conditional step with false condition"""
        with GUITestContext(app) as ctx:
            # Create conditional step
            step = IfConditionStep()
            step.condition_type = "variable_equals"
            step.condition_value = {
                "variable": "status",
                "compare_value": "active"
            }
            
            # Add true branch step
            true_step = WaitTimeStep()
            true_step.seconds = 0.05
            step.true_steps = [true_step]
            
            # Add false branch step
            false_step = WaitTimeStep()
            false_step.seconds = 0.15
            step.false_steps = [false_step]
            
            # Set variable to make condition false
            executor.set_variables({'status': 'inactive'})
            
            # Execute
            import time
            start_time = time.time()
            executor.execute_step(step)
            elapsed = time.time() - start_time
            
            # Should have executed false branch (longer wait)
            assert elapsed >= 0.14
            
    def test_nested_conditions(self, app, executor):
        """Test nested conditional execution"""
        with GUITestContext(app) as ctx:
            # Create outer condition
            outer = IfConditionStep()
            outer.condition_type = "variable_equals"
            outer.condition_value = {
                "variable": "mode",
                "compare_value": "auto"
            }
            
            # Create inner condition for true branch
            inner = IfConditionStep()
            inner.condition_type = "variable_not_empty"
            inner.condition_value = {
                "variable": "target"
            }
            
            # Inner true step
            inner_true = WaitTimeStep()
            inner_true.seconds = 0.05
            inner.true_steps = [inner_true]
            
            outer.true_steps = [inner]
            
            # Set variables
            executor.set_variables({
                'mode': 'auto',
                'target': 'test'
            })
            
            # Execute
            executor.execute_step(outer)
            # Should complete without errors
            
    def test_variable_contains_condition(self, app, executor):
        """Test variable contains condition"""
        with GUITestContext(app) as ctx:
            step = IfConditionStep()
            step.condition_type = "variable_contains"
            step.condition_value = {
                "variable": "message",
                "compare_value": "error"
            }
            
            # True branch
            true_step = WaitTimeStep()
            true_step.seconds = 0.05
            step.true_steps = [true_step]
            
            # Test with containing value
            executor.set_variables({'message': 'Error occurred in system'})
            executor.execute_step(step)
            
            # Test with non-containing value
            executor.set_variables({'message': 'Success'})
            executor.execute_step(step)
            
    def test_variable_greater_condition(self, app, executor):
        """Test variable greater than condition"""
        with GUITestContext(app) as ctx:
            step = IfConditionStep()
            step.condition_type = "variable_greater"
            step.condition_value = {
                "variable": "count",
                "compare_value": "10"
            }
            
            # True branch
            true_step = WaitTimeStep()
            true_step.seconds = 0.05
            step.true_steps = [true_step]
            
            # Test with greater value
            executor.set_variables({'count': 15})
            executor.execute_step(step)
            
            # Test with smaller value
            executor.set_variables({'count': 5})
            executor.execute_step(step)
            
    def test_invalid_step_type(self, app, executor):
        """Test handling of unsupported step type"""
        with GUITestContext(app) as ctx:
            # Create a mock step with unsupported type
            class UnsupportedStep(MacroStep):
                def __init__(self):
                    super().__init__()
                    self.step_type = StepType.EXCEL_READ  # Not implemented in executor
                    
                def validate(self):
                    return []
                    
                def to_dict(self):
                    return super().to_dict()
                    
                @classmethod
                def from_dict(cls, data):
                    return cls()
                    
            step = UnsupportedStep()
            
            # Should raise NotImplementedError
            with pytest.raises(NotImplementedError):
                executor.execute_step(step)
                
    def test_mouse_click_validation(self, app, executor):
        """Test mouse click step validation"""
        with GUITestContext(app) as ctx:
            # Create click step with invalid coordinates
            step = MouseClickStep()
            step.x = -10  # Invalid
            step.y = -20  # Invalid
            
            errors = step.validate()
            assert len(errors) > 0
            assert "Coordinates must be non-negative" in errors[0]
            
    def test_keyboard_type_validation(self, app, executor):
        """Test keyboard type step validation"""
        with GUITestContext(app) as ctx:
            # Create type step with empty text
            step = KeyboardTypeStep()
            step.text = ""
            
            errors = step.validate()
            assert len(errors) > 0
            assert "Text cannot be empty" in errors[0]


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/integration/test_text_input_variables.py">
#!/usr/bin/env python3
"""
Integration tests for text input and variable binding functionality
"""

import sys
import os
from pathlib import Path
import pytest
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent))

from test_helpers import GUITestContext
from core.macro_types import (
    MacroStep, StepType, KeyboardTypeStep, 
    Macro, IfConditionStep
)
from automation.executor import StepExecutor
from config.settings import Settings


class TestTextInputVariables:
    """Test text input and variable binding functionality"""
    
    @pytest.fixture
    def app(self):
        """Create QApplication for tests"""
        app = QApplication.instance()
        if app is None:
            app = QApplication(sys.argv)
        yield app
        
    @pytest.fixture
    def test_variables(self):
        """Create test variables"""
        return {
            'ì´ë¦„': 'í™ê¸¸ë™',
            'ì´ë©”ì¼': 'test@example.com',
            'ì „í™”ë²ˆí˜¸': '010-1234-5678',
            'ì£¼ì†Œ': 'ì„œìš¸ì‹œ ê°•ë‚¨êµ¬',
            'ìƒíƒœ': 'ì²˜ë¦¬ì¤‘'
        }
        
    def test_keyboard_type_step_creation(self, app):
        """Test creating keyboard type step"""
        with GUITestContext(app) as ctx:
            # Create keyboard type step
            step = KeyboardTypeStep()
            step.name = "í…ìŠ¤íŠ¸ ì…ë ¥ í…ŒìŠ¤íŠ¸"
            step.text = "Hello World"
            
            # Verify configuration
            assert step.step_type == StepType.KEYBOARD_TYPE
            assert step.text == "Hello World"
            assert step.name == "í…ìŠ¤íŠ¸ ì…ë ¥ í…ŒìŠ¤íŠ¸"
            
            # Test serialization
            step_dict = step.to_dict()
            assert step_dict['step_type'] == StepType.KEYBOARD_TYPE.value
            assert step_dict['text'] == "Hello World"
            
    def test_variable_substitution_simple(self, app, test_variables):
        """Test simple variable substitution"""
        with GUITestContext(app) as ctx:
            executor = StepExecutor(Settings())
            executor.set_variables(test_variables)
            
            # Test simple substitution
            text = "ì´ë¦„: {{ì´ë¦„}}"
            result = executor._substitute_variables(text)
            assert result == "ì´ë¦„: í™ê¸¸ë™"
            
            # Test multiple variables
            text = "{{ì´ë¦„}}ë‹˜ì˜ ì´ë©”ì¼ì€ {{ì´ë©”ì¼}}ì…ë‹ˆë‹¤"
            result = executor._substitute_variables(text)
            assert result == "í™ê¸¸ë™ë‹˜ì˜ ì´ë©”ì¼ì€ test@example.comì…ë‹ˆë‹¤"
            
    def test_variable_substitution_missing(self, app, test_variables):
        """Test behavior with missing variables"""
        with GUITestContext(app) as ctx:
            executor = StepExecutor(Settings())
            executor.set_variables(test_variables)
            
            # Missing variable should remain unchanged
            text = "{{ì—†ëŠ”ë³€ìˆ˜}} í…ŒìŠ¤íŠ¸"
            result = executor._substitute_variables(text)
            assert result == "{{ì—†ëŠ”ë³€ìˆ˜}} í…ŒìŠ¤íŠ¸"
            
    def test_variable_substitution_mixed(self, app, test_variables):
        """Test mixed text and variables"""
        with GUITestContext(app) as ctx:
            executor = StepExecutor(Settings())
            executor.set_variables(test_variables)
            
            # Complex mixed text
            text = """
            ê³ ê°ëª…: {{ì´ë¦„}}
            ì—°ë½ì²˜: {{ì „í™”ë²ˆí˜¸}}
            ì´ë©”ì¼: {{ì´ë©”ì¼}}
            ì£¼ì†Œ: {{ì£¼ì†Œ}}
            ì²˜ë¦¬ìƒíƒœ: {{ìƒíƒœ}}
            """
            
            result = executor._substitute_variables(text)
            
            assert "ê³ ê°ëª…: í™ê¸¸ë™" in result
            assert "ì—°ë½ì²˜: 010-1234-5678" in result
            assert "ì´ë©”ì¼: test@example.com" in result
            assert "ì£¼ì†Œ: ì„œìš¸ì‹œ ê°•ë‚¨êµ¬" in result
            assert "ì²˜ë¦¬ìƒíƒœ: ì²˜ë¦¬ì¤‘" in result
            
    def test_special_keys(self, app):
        """Test special key configurations"""
        with GUITestContext(app) as ctx:
            # Test Tab key
            step = KeyboardTypeStep()
            step.text = "{{ì´ë¦„}}\t{{ì´ë©”ì¼}}"
            
            # Verify tab character
            assert '\t' in step.text
            
            # Test Enter key
            step2 = KeyboardTypeStep()
            step2.text = "ì²« ì¤„\në‘ ë²ˆì§¸ ì¤„"
            
            assert '\n' in step2.text
            
    def test_keyboard_step_with_delay(self, app):
        """Test keyboard typing with delay settings"""
        with GUITestContext(app) as ctx:
            step = KeyboardTypeStep()
            step.text = "ì²œì²œíˆ ì…ë ¥"
            step.interval = 0.1  # 0.1 seconds between characters
            
            # Verify delay configuration
            assert step.interval == 0.1
            
            # Test serialization includes delay
            step_dict = step.to_dict()
            assert step_dict.get('interval') == 0.1
            
    def test_conditional_text_input(self, app, test_variables):
        """Test text input within conditional statements"""
        with GUITestContext(app) as ctx:
            # Create conditional step
            condition = IfConditionStep()
            condition.condition_type = "variable_equals"
            condition.variable_name = "ìƒíƒœ"
            condition.compare_value = "ì²˜ë¦¬ì¤‘"
            
            # Add text input to true branch
            true_step = KeyboardTypeStep()
            true_step.text = "{{ì´ë¦„}}ë‹˜ ì²˜ë¦¬ì¤‘ì…ë‹ˆë‹¤"
            condition.true_steps = [true_step]
            
            # Add text input to false branch
            false_step = KeyboardTypeStep()
            false_step.text = "{{ì´ë¦„}}ë‹˜ ëŒ€ê¸°ì¤‘ì…ë‹ˆë‹¤"
            condition.false_steps = [false_step]
            
            # Verify structure
            assert len(condition.true_steps) == 1
            assert len(condition.false_steps) == 1
            assert condition.true_steps[0].text == "{{ì´ë¦„}}ë‹˜ ì²˜ë¦¬ì¤‘ì…ë‹ˆë‹¤"
            assert condition.false_steps[0].text == "{{ì´ë¦„}}ë‹˜ ëŒ€ê¸°ì¤‘ì…ë‹ˆë‹¤"
            
    def test_variable_in_macro_context(self, app, test_variables):
        """Test variables in full macro context"""
        with GUITestContext(app) as ctx:
            # Create macro with variables
            macro = Macro(name="ë³€ìˆ˜ í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ")
            macro.variables = test_variables
            
            # Add steps with variables
            step1 = KeyboardTypeStep()
            step1.text = "ê³ ê°ëª…: {{ì´ë¦„}}"
            macro.add_step(step1)
            
            step2 = KeyboardTypeStep()
            step2.text = "ì´ë©”ì¼: {{ì´ë©”ì¼}}"
            macro.add_step(step2)
            
            # Verify macro structure
            assert len(macro.steps) == 2
            assert macro.variables['ì´ë¦„'] == 'í™ê¸¸ë™'
            assert macro.variables['ì´ë©”ì¼'] == 'test@example.com'
            
    def test_empty_and_whitespace_handling(self, app):
        """Test handling of empty and whitespace text"""
        with GUITestContext(app) as ctx:
            executor = StepExecutor(Settings())
            
            # Empty string
            executor.set_variables({})
            result = executor._substitute_variables("")
            assert result == ""
            
            # Only whitespace
            result = executor._substitute_variables("   ")
            assert result == "   "
            
            # Variable with empty value
            executor.set_variables({'empty': ''})
            result = executor._substitute_variables("Value: {{empty}}")
            assert result == "Value: "
            
    def test_nested_brackets(self, app):
        """Test handling of nested or malformed brackets"""
        with GUITestContext(app) as ctx:
            executor = StepExecutor(Settings())
            
            # Nested brackets
            executor.set_variables({'nested': 'value'})
            text = "{{{{nested}}}}"
            result = executor._substitute_variables(text)
            # Should handle gracefully
            assert "{{" in result or "value" in result
            
            # Unclosed brackets
            executor.set_variables({})
            text = "{{unclosed"
            result = executor._substitute_variables(text)
            assert result == "{{unclosed"
            
            # Extra closing brackets
            text = "extra}}"
            result = executor._substitute_variables(text)
            assert result == "extra}}"


def run_tests():
    """Run tests standalone"""
    pytest.main([__file__, "-v"])


if __name__ == "__main__":
    run_tests()
</file>

<file path="tests/manual_test_checklist.md">
# Excel Macro Automation - ìˆ˜ë™ í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

## í…ŒìŠ¤íŠ¸ í™˜ê²½ ì¤€ë¹„

- [ ] ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ (`python3 run_main.py`)
- [ ] í…ŒìŠ¤íŠ¸ìš© Excel íŒŒì¼ ì¤€ë¹„ (demo_data.xlsx)
- [ ] ë¡œê·¸ í´ë” í™•ì¸ (`~/.excel_macro_automation/execution_logs/`)

## 1. ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸

### 1.1 ìƒˆ ë‹¨ê³„ ì¶”ê°€
- [ ] **ë§ˆìš°ìŠ¤ í´ë¦­** ë‹¨ê³„ë¥¼ íŒ”ë ˆíŠ¸ì—ì„œ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€
- [ ] **í…ìŠ¤íŠ¸ ì…ë ¥** ë‹¨ê³„ë¥¼ ì¶”ê°€
- [ ] **ëŒ€ê¸°** ë‹¨ê³„ë¥¼ ì¶”ê°€
- [ ] **ì¡°ê±´ë¬¸** ë‹¨ê³„ë¥¼ ì¶”ê°€
- [ ] **ì´ë¯¸ì§€ ëŒ€ê¸°** ë‹¨ê³„ë¥¼ ì¶”ê°€
- [ ] **í…ìŠ¤íŠ¸ ê²€ìƒ‰** ë‹¨ê³„ë¥¼ ì¶”ê°€

### 1.2 ë‹¨ê³„ ì¬ì •ë ¬
- [ ] ê¸°ì¡´ ë‹¨ê³„ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ìˆœì„œ ë³€ê²½
- [ ] ì²« ë²ˆì§¸ ë‹¨ê³„ë¥¼ ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™
- [ ] ì¤‘ê°„ ë‹¨ê³„ë¥¼ ë§¨ ì•ìœ¼ë¡œ ì´ë™

### 1.3 ì˜¤ë¥˜ ì²˜ë¦¬
- [ ] ë¹ˆ ì˜ì—­ì— ë“œë¡­ ì‹œë„
- [ ] íŒ”ë ˆíŠ¸ ë°–ìœ¼ë¡œ ë“œë˜ê·¸
- [ ] ì—¬ëŸ¬ ë‹¨ê³„ë¥¼ ë™ì‹œì— ì„ íƒí•˜ì—¬ ì´ë™ ì‹œë„

## 2. ë‹¨ê³„ ì„¤ì • ë‹¤ì´ì–¼ë¡œê·¸ í…ŒìŠ¤íŠ¸

### 2.1 ì´ë¯¸ì§€ ìº¡ì²˜ ê¸°ëŠ¥
- [ ] **ìº¡ì²˜** ë²„íŠ¼ í´ë¦­í•˜ì—¬ í™”ë©´ ì˜ì—­ ì„ íƒ
- [ ] ì„ íƒí•œ ì˜ì—­ì´ ë¯¸ë¦¬ë³´ê¸°ì— í‘œì‹œë˜ëŠ”ì§€ í™•ì¸
- [ ] **ì°¾ì•„ë³´ê¸°** ë²„íŠ¼ìœ¼ë¡œ ê¸°ì¡´ ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ
- [ ] ê²€ìƒ‰ ì˜ì—­(ROI) ì„¤ì • ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] ì‹ ë¢°ë„ ì„¤ì • ë³€ê²½ (0.7 â†’ 0.9)

### 2.2 í…ìŠ¤íŠ¸ ì…ë ¥ ì„¤ì •
- [ ] ê³ ì • í…ìŠ¤íŠ¸ ì…ë ¥ ëª¨ë“œ í…ŒìŠ¤íŠ¸
- [ ] Excel ì—´ ë°ì´í„° ë°”ì¸ë”© ëª¨ë“œ í…ŒìŠ¤íŠ¸
- [ ] ë³€ìˆ˜ ì‚¬ìš© ({{ë³€ìˆ˜ëª…}} í˜•ì‹) í…ŒìŠ¤íŠ¸
- [ ] íŠ¹ìˆ˜ í‚¤ ì…ë ¥ ì„¤ì • (Enter, Tab ë“±)

### 2.3 ì¢Œí‘œ ë…¹í™” ê¸°ëŠ¥
- [ ] ë§ˆìš°ìŠ¤ í´ë¦­ ë‹¨ê³„ì—ì„œ **ì¢Œí‘œ ê¸°ë¡** ë²„íŠ¼ í´ë¦­
- [ ] í™”ë©´ì˜ íŠ¹ì • ìœ„ì¹˜ í´ë¦­í•˜ì—¬ ì¢Œí‘œ ì €ì¥
- [ ] ì €ì¥ëœ ì¢Œí‘œê°€ ì„¤ì • ì°½ì— í‘œì‹œë˜ëŠ”ì§€ í™•ì¸
- [ ] ìƒëŒ€ ì¢Œí‘œ vs ì ˆëŒ€ ì¢Œí‘œ ì˜µì…˜ í…ŒìŠ¤íŠ¸

### 2.4 ì¡°ê±´ë¬¸ ì„¤ì •
- [ ] ì´ë¯¸ì§€ ì¡´ì¬ ì—¬ë¶€ ì¡°ê±´ ì„¤ì •
- [ ] í…ìŠ¤íŠ¸ ì¡´ì¬ ì—¬ë¶€ ì¡°ê±´ ì„¤ì •
- [ ] ë³€ìˆ˜ ë¹„êµ ì¡°ê±´ ì„¤ì • (ê°™ìŒ, ë‹¤ë¦„, í¬í•¨)
- [ ] True/False ë¶„ê¸°ì— ë‹¨ê³„ ì¶”ê°€

## 3. ì‹¤í–‰ ë° ë¡œê¹… í…ŒìŠ¤íŠ¸

### 3.1 ê¸°ë³¸ ì‹¤í–‰
- [ ] **ì‹œì‘** ë²„íŠ¼ìœ¼ë¡œ ë§¤í¬ë¡œ ì‹¤í–‰
- [ ] ì‹¤í–‰ ì¤‘ ì§„í–‰ë¥  í‘œì‹œ í™•ì¸
- [ ] ê° ë‹¨ê³„ë³„ ì‹¤í–‰ ìƒíƒœ í™•ì¸
- [ ] Excel ë°ì´í„°ì˜ Status ì—´ ì—…ë°ì´íŠ¸ í™•ì¸

### 3.2 ì‹¤í–‰ ì œì–´
- [ ] **F9** í‚¤ë¡œ ì¼ì‹œì •ì§€
- [ ] ì¼ì‹œì •ì§€ í›„ **ì¬ê°œ** ë²„íŠ¼ í´ë¦­
- [ ] **ESC** í‚¤ë¡œ ì‹¤í–‰ ì¤‘ì§€
- [ ] ë¯¸ì™„ë£Œ í•­ëª©ë§Œ ì‹¤í–‰ ì˜µì…˜ í…ŒìŠ¤íŠ¸

### 3.3 ì˜¤ë¥˜ ì²˜ë¦¬
- [ ] ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì„ ë•Œ ì—ëŸ¬ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ í™•ì¸
- [ ] ì—ëŸ¬ ë‹¤ì´ì–¼ë¡œê·¸ì˜ í•´ê²° ë°©ë²• í™•ì¸
- [ ] **ì˜¤ë¥˜ ì •ë³´ ë³µì‚¬** ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] **ë³´ê³ ì„œ ì €ì¥** ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] ìŠ¤í¬ë¦°ìƒ· í¬í•¨ ì˜µì…˜ í…ŒìŠ¤íŠ¸

### 3.4 ë¡œê·¸ í™•ì¸
- [ ] ì‹¤í–‰ íƒ­ì˜ **CSV ë¡œê·¸ ë³´ê¸°** ë²„íŠ¼ í´ë¦­
- [ ] View ë©”ë‰´ â†’ **Execution Logs** (Ctrl+L) í…ŒìŠ¤íŠ¸
- [ ] ë¡œê·¸ ë·°ì–´ì˜ í•„í„° ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
  - [ ] ìƒíƒœë³„ í•„í„° (ì „ì²´/ì„±ê³µ/ì‹¤íŒ¨/ì˜¤ë¥˜)
  - [ ] í…ìŠ¤íŠ¸ ê²€ìƒ‰ ê¸°ëŠ¥
- [ ] í†µê³„ ì •ë³´ í™•ì¸
  - [ ] ì „ì²´ í–‰ ìˆ˜
  - [ ] ì„±ê³µ/ì‹¤íŒ¨ ë¹„ìœ¨
  - [ ] í‰ê·  ì²˜ë¦¬ ì‹œê°„
- [ ] ì‹¤ì‹œê°„ ë¡œê·¸ ì—…ë°ì´íŠ¸ í™•ì¸ (ì‹¤í–‰ ì¤‘)
- [ ] **ë‚´ë³´ë‚´ê¸°** ê¸°ëŠ¥ìœ¼ë¡œ í•„í„°ëœ ë¡œê·¸ ì €ì¥

## 4. ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°

### 4.1 ì €ì¥ ê¸°ëŠ¥
- [ ] File â†’ Save Macro (Ctrl+S)
- [ ] JSON í˜•ì‹ìœ¼ë¡œ ì €ì¥
- [ ] ì•”í˜¸í™”ëœ í˜•ì‹(.emf)ìœ¼ë¡œ ì €ì¥
- [ ] íŒŒì¼ëª…ì— íŠ¹ìˆ˜ë¬¸ì ì²˜ë¦¬ í™•ì¸

### 4.2 ë¶ˆëŸ¬ì˜¤ê¸° ê¸°ëŠ¥
- [ ] File â†’ Load Macro (Ctrl+O)
- [ ] ì €ì¥ëœ ë§¤í¬ë¡œ ì •ìƒ ë¡œë“œ í™•ì¸
- [ ] ëª¨ë“  ë‹¨ê³„ì™€ ì„¤ì •ì´ ë³µì›ë˜ëŠ”ì§€ í™•ì¸
- [ ] ìµœê·¼ ë§¤í¬ë¡œ ëª©ë¡ì—ì„œ ì„ íƒ

### 4.3 ë¶€ë¶„ ë‚´ë³´ë‚´ê¸°
- [ ] íŠ¹ì • ë‹¨ê³„ë§Œ ì„ íƒí•˜ì—¬ ë‚´ë³´ë‚´ê¸°
- [ ] File â†’ Export Macro
- [ ] ë‚´ë³´ë‚¸ ë‹¨ê³„ë¥¼ ë‹¤ë¥¸ ë§¤í¬ë¡œì— ê°€ì ¸ì˜¤ê¸°

## 5. í†µí•© ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

### ì‹œë‚˜ë¦¬ì˜¤ 1: ì›¹ í¼ ìë™ ì…ë ¥
1. [ ] Excel íŒŒì¼ ë¡œë“œ (ì´ë¦„, ì „í™”ë²ˆí˜¸, ì£¼ì†Œ ë°ì´í„°)
2. [ ] ë§¤í¬ë¡œ ìƒì„±:
   - [ ] ì´ë¯¸ì§€ í´ë¦­ (ì…ë ¥ í•„ë“œ ì°¾ê¸°)
   - [ ] í…ìŠ¤íŠ¸ ì…ë ¥ (Excel ë°ì´í„° ë°”ì¸ë”©)
   - [ ] Tab í‚¤ ì…ë ¥
   - [ ] ë‹¤ìŒ í•„ë“œë¡œ ì´ë™
3. [ ] ë§¤í¬ë¡œ ì‹¤í–‰ ë° ë¡œê·¸ í™•ì¸
4. [ ] ì˜¤ë¥˜ ë°œìƒ ì‹œ ì²˜ë¦¬ í™•ì¸

### ì‹œë‚˜ë¦¬ì˜¤ 2: ì¡°ê±´ë¶€ ì²˜ë¦¬
1. [ ] Excel íŒŒì¼ ë¡œë“œ (ìƒíƒœ í•„ë“œ í¬í•¨)
2. [ ] ì¡°ê±´ë¬¸ ì¶”ê°€:
   - [ ] ìƒíƒœê°€ "ëŒ€ê¸°"ì¸ ê²½ìš°ë§Œ ì²˜ë¦¬
   - [ ] ì²˜ë¦¬ ì™„ë£Œ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸
3. [ ] ì¼ë¶€ í–‰ë§Œ ì²˜ë¦¬ë˜ëŠ”ì§€ í™•ì¸
4. [ ] ë¡œê·¸ì—ì„œ ì¡°ê±´ ë¶„ê¸° í™•ì¸

## 6. ì„±ëŠ¥ ë° ì•ˆì •ì„±

### 6.1 ëŒ€ìš©ëŸ‰ ë°ì´í„°
- [ ] 100ê°œ ì´ìƒì˜ í–‰ ì²˜ë¦¬
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
- [ ] ì‹¤í–‰ ì‹œê°„ ì¸¡ì •

### 6.2 ì¥ì‹œê°„ ì‹¤í–‰
- [ ] 30ë¶„ ì´ìƒ ì—°ì† ì‹¤í–‰
- [ ] ë¡œê·¸ íŒŒì¼ í¬ê¸° í™•ì¸
- [ ] ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ í™•ì¸

### 6.3 ì˜ˆì™¸ ìƒí™©
- [ ] ì‹¤í–‰ ì¤‘ Excel íŒŒì¼ ìˆ˜ì • ì‹œë„
- [ ] ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠê¹€ ì‹œë‚˜ë¦¬ì˜¤
- [ ] ì‹œìŠ¤í…œ ì ˆì „ ëª¨ë“œ ì§„ì…/ë³µê·€

## í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê¸°ë¡

| í…ŒìŠ¤íŠ¸ í•­ëª© | ê²°ê³¼ | ë¹„ê³  |
|------------|------|------|
| ë“œë˜ê·¸ ì•¤ ë“œë¡­ | â¬œ Pass / â¬œ Fail | |
| ë‹¨ê³„ ì„¤ì • | â¬œ Pass / â¬œ Fail | |
| ì‹¤í–‰ ë° ë¡œê¹… | â¬œ Pass / â¬œ Fail | |
| ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° | â¬œ Pass / â¬œ Fail | |
| í†µí•© ì‹œë‚˜ë¦¬ì˜¤ | â¬œ Pass / â¬œ Fail | |
| ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ | â¬œ Pass / â¬œ Fail | |

## ë°œê²¬ëœ ì´ìŠˆ

1. **ì´ìŠˆ #1**
   - ì„¤ëª…:
   - ì¬í˜„ ë°©ë²•:
   - ì˜ˆìƒ ì›ì¸:

2. **ì´ìŠˆ #2**
   - ì„¤ëª…:
   - ì¬í˜„ ë°©ë²•:
   - ì˜ˆìƒ ì›ì¸:

## ê°œì„  ì œì•ˆì‚¬í•­

1. 
2. 
3. 

---

í…ŒìŠ¤íŠ¸ ìˆ˜í–‰ì: _______________  
í…ŒìŠ¤íŠ¸ ì¼ì: _______________  
í…ŒìŠ¤íŠ¸ í™˜ê²½: _______________
</file>

<file path="tests/test_helpers.py">
"""
Test helper classes for GUI automation testing
"""

import sys
import os
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
from PyQt5.QtCore import Qt, QMimeData, QPoint, QByteArray, QDataStream, QIODevice
from PyQt5.QtGui import QDragEnterEvent, QDropEvent, QDragMoveEvent
from PyQt5.QtWidgets import QWidget, QDialog, QPushButton, QApplication
import time
import csv
from datetime import datetime

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))


class MockDragDropEvent:
    """Helper class to simulate drag and drop events"""
    
    @staticmethod
    def create_drag_enter_event(mime_data: QMimeData, pos: QPoint = None) -> QDragEnterEvent:
        """Create a drag enter event"""
        if pos is None:
            pos = QPoint(50, 50)
        
        event = QDragEnterEvent(
            pos,
            Qt.CopyAction | Qt.MoveAction,
            mime_data,
            Qt.LeftButton,
            Qt.NoModifier
        )
        return event
    
    @staticmethod
    def create_drop_event(mime_data: QMimeData, pos: QPoint = None) -> QDropEvent:
        """Create a drop event"""
        if pos is None:
            pos = QPoint(50, 50)
            
        event = QDropEvent(
            pos,
            Qt.CopyAction | Qt.MoveAction,
            mime_data,
            Qt.LeftButton,
            Qt.NoModifier
        )
        return event
    
    @staticmethod
    def create_step_mime_data(step_type: str) -> QMimeData:
        """Create mime data for a new step from palette"""
        mime_data = QMimeData()
        byte_array = QByteArray()
        stream = QDataStream(byte_array, QIODevice.WriteOnly)
        stream.writeQString(step_type)
        mime_data.setData("application/x-steptype", byte_array)
        return mime_data
    
    @staticmethod
    def create_move_mime_data(step_id: str, old_index: int) -> QMimeData:
        """Create mime data for moving an existing step"""
        mime_data = QMimeData()
        byte_array = QByteArray()
        stream = QDataStream(byte_array, QIODevice.WriteOnly)
        stream.writeQString(step_id)
        stream.writeInt(old_index)
        mime_data.setData("application/x-macrostep", byte_array)
        return mime_data


class DialogTester:
    """Helper class to test dialogs automatically"""
    
    def __init__(self, app: QApplication):
        self.app = app
        self.dialog = None
        self.result = None
        
    def test_dialog(self, dialog_class, *args, **kwargs):
        """Test a dialog by creating it and interacting with it"""
        self.dialog = dialog_class(*args, **kwargs)
        self.dialog.show()
        return self
        
    def click_button(self, button_text: str):
        """Click a button by its text"""
        buttons = self.dialog.findChildren(QPushButton)
        for button in buttons:
            if button.text() == button_text:
                button.click()
                self.app.processEvents()
                break
        return self
        
    def set_field(self, field_name: str, value: Any):
        """Set a field value by its object name"""
        widget = self.dialog.findChild(QWidget, field_name)
        if widget:
            if hasattr(widget, 'setText'):
                widget.setText(str(value))
            elif hasattr(widget, 'setValue'):
                widget.setValue(value)
            elif hasattr(widget, 'setCurrentText'):
                widget.setCurrentText(str(value))
            self.app.processEvents()
        return self
        
    def accept(self):
        """Accept the dialog"""
        self.dialog.accept()
        self.result = self.dialog.result()
        self.app.processEvents()
        return self
        
    def reject(self):
        """Reject the dialog"""
        self.dialog.reject()
        self.result = self.dialog.result()
        self.app.processEvents()
        return self
        
    def get_result(self) -> Any:
        """Get the dialog result"""
        return self.result


class LogVerifier:
    """Helper class to verify execution logs"""
    
    def __init__(self, log_file: Path):
        self.log_file = log_file
        self.entries = []
        self.load_log()
        
    def load_log(self):
        """Load log entries from CSV file"""
        if not self.log_file.exists():
            return
            
        with open(self.log_file, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            self.entries = list(reader)
            
    def verify_step_executed(self, step_name: str, expected_status: str = "SUCCESS") -> bool:
        """Verify a step was executed with expected status"""
        for entry in self.entries:
            if entry.get('step_name') == step_name and entry.get('status') == expected_status:
                return True
        return False
        
    def verify_row_completed(self, row_index: int, expected_status: str = "SUCCESS") -> bool:
        """Verify a row was completed with expected status"""
        for entry in self.entries:
            if (entry.get('row_index') == str(row_index) and 
                entry.get('step_name') == 'ROW_COMPLETE' and 
                entry.get('status') == expected_status):
                return True
        return False
        
    def get_step_duration(self, step_name: str) -> Optional[float]:
        """Get duration of a step execution"""
        for entry in self.entries:
            if entry.get('step_name') == step_name and entry.get('duration_ms'):
                return float(entry['duration_ms'])
        return None
        
    def get_error_messages(self) -> List[str]:
        """Get all error messages from log"""
        errors = []
        for entry in self.entries:
            if entry.get('status') in ['FAILED', 'ERROR'] and entry.get('error_message'):
                errors.append(entry['error_message'])
        return errors
        
    def get_execution_summary(self) -> Dict[str, Any]:
        """Get execution summary statistics"""
        total_rows = 0
        successful_rows = 0
        failed_rows = 0
        total_steps = 0
        successful_steps = 0
        failed_steps = 0
        
        for entry in self.entries:
            if entry.get('step_name') == 'ROW_COMPLETE':
                total_rows += 1
                if entry.get('status') == 'SUCCESS':
                    successful_rows += 1
                else:
                    failed_rows += 1
            elif entry.get('step_type') and entry.get('status'):
                total_steps += 1
                if entry.get('status') == 'SUCCESS':
                    successful_steps += 1
                else:
                    failed_steps += 1
                    
        return {
            'total_rows': total_rows,
            'successful_rows': successful_rows,
            'failed_rows': failed_rows,
            'success_rate': (successful_rows / total_rows * 100) if total_rows > 0 else 0,
            'total_steps': total_steps,
            'successful_steps': successful_steps,
            'failed_steps': failed_steps,
            'step_success_rate': (successful_steps / total_steps * 100) if total_steps > 0 else 0
        }
        
    def wait_for_entry(self, condition_func, timeout: float = 5.0) -> bool:
        """Wait for a log entry matching condition"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            self.load_log()  # Reload log
            for entry in self.entries:
                if condition_func(entry):
                    return True
            time.sleep(0.1)
            
        return False


class TestScenario:
    """Base class for test scenarios"""
    
    def __init__(self, name: str):
        self.name = name
        self.steps = []
        self.expected_results = []
        
    def add_step(self, description: str, action: callable, expected_result: Any = None):
        """Add a test step"""
        self.steps.append({
            'description': description,
            'action': action,
            'expected_result': expected_result
        })
        return self
        
    def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the test scenario"""
        results = {
            'scenario': self.name,
            'start_time': datetime.now(),
            'steps': [],
            'success': True
        }
        
        for i, step in enumerate(self.steps):
            step_result = {
                'index': i,
                'description': step['description'],
                'start_time': datetime.now()
            }
            
            try:
                # Execute action
                actual_result = step['action'](context)
                step_result['actual_result'] = actual_result
                
                # Verify result if expected
                if step['expected_result'] is not None:
                    step_result['expected_result'] = step['expected_result']
                    step_result['passed'] = actual_result == step['expected_result']
                else:
                    step_result['passed'] = True
                    
            except Exception as e:
                step_result['error'] = str(e)
                step_result['passed'] = False
                results['success'] = False
                
            step_result['end_time'] = datetime.now()
            step_result['duration'] = (step_result['end_time'] - step_result['start_time']).total_seconds()
            
            results['steps'].append(step_result)
            
            if not step_result['passed']:
                results['success'] = False
                break  # Stop on first failure
                
        results['end_time'] = datetime.now()
        results['duration'] = (results['end_time'] - results['start_time']).total_seconds()
        
        return results


class GUITestContext:
    """Context manager for GUI tests"""
    
    def __init__(self, app: QApplication):
        self.app = app
        self.widgets = {}
        self.dialogs = []
        
    def __enter__(self):
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        # Clean up dialogs
        for dialog in self.dialogs:
            if dialog and dialog.isVisible():
                dialog.close()
                
    def register_widget(self, name: str, widget: QWidget):
        """Register a widget for later access"""
        self.widgets[name] = widget
        
    def get_widget(self, name: str) -> Optional[QWidget]:
        """Get a registered widget"""
        return self.widgets.get(name)
        
    def process_events(self, duration_ms: int = 100):
        """Process Qt events for a duration"""
        start = time.time()
        while (time.time() - start) * 1000 < duration_ms:
            self.app.processEvents()
            time.sleep(0.01)
</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250715_225040.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path="uploads/XXXNEW_pro_Europe_Warsaw_f6904afa-4a7e-42ad-8e37-34f0262bc38a_20250716_111655.json">
{
  "blocks": [
    {
      "startTime": "2025-06-19T07:00:00.000Z",
      "endTime": "2025-06-19T12:00:00.000Z",
      "actualEndTime": "2025-06-19T11:38:21.105Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 453,
            "outputTokens": 12054,
            "cacheCreationTokens": 914384,
            "cacheReadTokens": 18331383,
            "totalTokens": 12507
          },
          "costUSD": 9.110524,
          "entriesCount": 218
        }
      },
      "totalTokens": 12507,
      "totalTokensOld": 12507,
      "costUSD": 9.110524,
      "entries": 221,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-19T07:23:50.950Z",
          "content": "Claude AI usage limit reached|1750330800",
          "resetTime": "2025-06-19T11:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-06-22T11:00:00.000Z",
      "endTime": "2025-06-22T16:00:00.000Z",
      "actualEndTime": "2025-06-22T14:24:12.420Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 177,
            "outputTokens": 8629,
            "cacheCreationTokens": 183823,
            "cacheReadTokens": 3825818,
            "totalTokens": 8806
          },
          "costUSD": 9.835238,
          "entriesCount": 58
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 759,
            "outputTokens": 18548,
            "cacheCreationTokens": 1105327,
            "cacheReadTokens": 15403692,
            "totalTokens": 19307
          },
          "costUSD": 9.046581,
          "entriesCount": 179
        }
      },
      "totalTokens": 63337,
      "totalTokensOld": 28113,
      "costUSD": 18.881819,
      "entries": 239,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-22T12:42:30.039Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T02:00:00.000Z",
      "endTime": "2025-06-23T07:00:00.000Z",
      "actualEndTime": "2025-06-23T06:54:49.528Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1158,
            "outputTokens": 16519,
            "cacheCreationTokens": 1265825,
            "cacheReadTokens": 23790518,
            "totalTokens": 17677
          },
          "costUSD": 12.135258,
          "entriesCount": 288
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 50,
            "outputTokens": 402,
            "cacheCreationTokens": 140068,
            "cacheReadTokens": 659119,
            "totalTokens": 452
          },
          "costUSD": 3.645853,
          "entriesCount": 8
        }
      },
      "totalTokens": 19937,
      "totalTokensOld": 18129,
      "costUSD": 15.781111,
      "entries": 298,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T06:11:03.913Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-23T14:00:00.000Z",
      "endTime": "2025-06-23T19:00:00.000Z",
      "actualEndTime": "2025-06-23T14:58:54.378Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 98,
            "outputTokens": 19056,
            "cacheCreationTokens": 89326,
            "cacheReadTokens": 2049296,
            "totalTokens": 19154
          },
          "costUSD": 6.179476,
          "entriesCount": 60
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 104,
            "outputTokens": 7478,
            "cacheCreationTokens": 198335,
            "cacheReadTokens": 4424540,
            "totalTokens": 7582
          },
          "costUSD": 2.1836,
          "entriesCount": 47
        }
      },
      "totalTokens": 103352,
      "totalTokensOld": 26736,
      "costUSD": 8.363076,
      "entries": 107,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-23T14:45:08.643Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-24T12:00:00.000Z",
      "endTime": "2025-06-24T17:00:00.000Z",
      "actualEndTime": "2025-06-24T14:30:23.908Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 494,
            "outputTokens": 36984,
            "cacheCreationTokens": 2383949,
            "cacheReadTokens": 3323196,
            "totalTokens": 37478
          },
          "costUSD": 10.49301,
          "entriesCount": 123
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 77,
            "outputTokens": 1623,
            "cacheCreationTokens": 133374,
            "cacheReadTokens": 442678,
            "totalTokens": 1700
          },
          "costUSD": 3.287659,
          "entriesCount": 18
        }
      },
      "totalTokens": 45978,
      "totalTokensOld": 39178,
      "costUSD": 13.780669,
      "entries": 145,
      "limits": [
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        },
        {
          "type": "opus_limit",
          "timestamp": "2025-06-24T13:29:44.425Z",
          "content": "Claude Opus 4 limit reached, now using Sonnet 4",
          "resetTime": null
        }
      ]
    },
    {
      "startTime": "2025-06-29T11:00:00.000Z",
      "endTime": "2025-06-29T16:00:00.000Z",
      "actualEndTime": "2025-06-29T14:37:01.091Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 242,
            "outputTokens": 4837,
            "cacheCreationTokens": 595924,
            "cacheReadTokens": 5849300,
            "totalTokens": 5079
          },
          "costUSD": 20.31393,
          "entriesCount": 56
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 652,
            "outputTokens": 62707,
            "cacheCreationTokens": 4150558,
            "cacheReadTokens": 6560609,
            "totalTokens": 63359
          },
          "costUSD": 18.475336,
          "entriesCount": 154
        }
      },
      "totalTokens": 88754,
      "totalTokensOld": 68438,
      "costUSD": 38.789266,
      "entries": 223,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:36:55.066Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-06-29T14:37:01.091Z",
          "content": "Claude AI usage limit reached|1751212800",
          "resetTime": "2025-06-29T16:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T04:00:00.000Z",
      "endTime": "2025-07-02T09:00:00.000Z",
      "actualEndTime": "2025-07-02T08:52:11.684Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1069,
            "outputTokens": 45178,
            "cacheCreationTokens": 2904081,
            "cacheReadTokens": 21540990,
            "totalTokens": 46247
          },
          "costUSD": 18.033478,
          "entriesCount": 265
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 225,
            "outputTokens": 11831,
            "cacheCreationTokens": 340469,
            "cacheReadTokens": 3586037,
            "totalTokens": 12056
          },
          "costUSD": 12.653549,
          "entriesCount": 34
        }
      },
      "totalTokens": 106527,
      "totalTokensOld": 58303,
      "costUSD": 30.687027,
      "entries": 307,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:00.606Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T08:52:11.684Z",
          "content": "Claude AI usage limit reached|1751446800",
          "resetTime": "2025-07-02T09:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-02T10:00:00.000Z",
      "endTime": "2025-07-02T15:00:00.000Z",
      "actualEndTime": "2025-07-02T13:55:12.355Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2300,
            "outputTokens": 73939,
            "cacheCreationTokens": 4527820,
            "cacheReadTokens": 34288738,
            "totalTokens": 76239
          },
          "costUSD": 28.381931,
          "entriesCount": 387
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 69,
            "outputTokens": 12001,
            "cacheCreationTokens": 191491,
            "cacheReadTokens": 330747,
            "totalTokens": 12070
          },
          "costUSD": 4.987687,
          "entriesCount": 9
        }
      },
      "totalTokens": 136589,
      "totalTokensOld": 88309,
      "costUSD": 33.369618,
      "entries": 399,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:54:35.755Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-02T13:55:12.355Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T00:00:00.000Z",
      "endTime": "2025-07-03T05:00:00.000Z",
      "actualEndTime": "2025-07-03T04:48:49.379Z",
      "perModelStats": {
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1853,
            "outputTokens": 26845,
            "cacheCreationTokens": 1882227,
            "cacheReadTokens": 40207722,
            "totalTokens": 28698
          },
          "costUSD": 19.528902,
          "entriesCount": 416
        },
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 268,
            "outputTokens": 6387,
            "cacheCreationTokens": 163105,
            "cacheReadTokens": 3325756,
            "totalTokens": 6655
          },
          "costUSD": 8.529898,
          "entriesCount": 46
        }
      },
      "totalTokens": 61973,
      "totalTokensOld": 35353,
      "costUSD": 28.058799999999998,
      "entries": 478,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T00:44:37.902Z",
          "content": "Claude AI usage limit reached|1751468400",
          "resetTime": "2025-07-02T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:14:38.822Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T03:15:49.794Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T04:48:49.379Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-03T05:00:00.000Z",
      "endTime": "2025-07-03T10:00:00.000Z",
      "actualEndTime": "2025-07-03T09:43:49.922Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1198,
            "outputTokens": 35722,
            "cacheCreationTokens": 1188516,
            "cacheReadTokens": 19530834,
            "totalTokens": 36920
          },
          "costUSD": 54.278046,
          "entriesCount": 239
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 574,
            "outputTokens": 12656,
            "cacheCreationTokens": 1128356,
            "cacheReadTokens": 15349155,
            "totalTokens": 13230
          },
          "costUSD": 9.027643,
          "entriesCount": 159
        }
      },
      "totalTokens": 197830,
      "totalTokensOld": 50150,
      "costUSD": 63.305689,
      "entries": 435,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T05:45:19.959Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:01.125Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T06:01:14.441Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:17:54.111Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-03T07:18:45.194Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-07T12:00:00.000Z",
      "endTime": "2025-07-07T17:00:00.000Z",
      "actualEndTime": "2025-07-07T15:26:14.805Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1334,
            "outputTokens": 38250,
            "cacheCreationTokens": 1788217,
            "cacheReadTokens": 32712425,
            "totalTokens": 39584
          },
          "costUSD": 85.486466,
          "entriesCount": 417
        },
        "claude-sonnet-4-20250514": {
          "tokenCounts": {
            "inputTokens": 149,
            "outputTokens": 2190,
            "cacheCreationTokens": 130837,
            "cacheReadTokens": 1802771,
            "totalTokens": 2339
          },
          "costUSD": 1.064767,
          "entriesCount": 42
        }
      },
      "totalTokens": 200259,
      "totalTokensOld": 41923,
      "costUSD": 86.551233,
      "entries": 479,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.161Z",
          "content": "Claude AI usage limit reached|1751518800",
          "resetTime": "2025-07-03T05:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-07T14:38:46.162Z",
          "content": "Claude AI usage limit reached|1751536800",
          "resetTime": "2025-07-03T10:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-13T02:00:00.000Z",
      "endTime": "2025-07-13T07:00:00.000Z",
      "actualEndTime": "2025-07-13T06:57:02.092Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1982,
            "outputTokens": 19375,
            "cacheCreationTokens": 2285531,
            "cacheReadTokens": 37192802,
            "totalTokens": 21357
          },
          "costUSD": 100.125764,
          "entriesCount": 376
        }
      },
      "totalTokens": 106785,
      "totalTokensOld": 21357,
      "costUSD": 100.125764,
      "entries": 380,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:22.352Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:51:28.659Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T04:53:42.791Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-13T06:57:02.092Z",
          "content": "Claude AI usage limit reached|1752390000",
          "resetTime": "2025-07-13T07:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-15T10:00:00.000Z",
      "endTime": "2025-07-15T15:00:00.000Z",
      "actualEndTime": "2025-07-15T14:41:16.998Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 2152,
            "outputTokens": 89802,
            "cacheCreationTokens": 2254600,
            "cacheReadTokens": 54716499,
            "totalTokens": 91954
          },
          "costUSD": 131.115928,
          "entriesCount": 644
        }
      },
      "totalTokens": 459770,
      "totalTokensOld": 91954,
      "costUSD": 131.115928,
      "entries": 647,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-15T14:41:16.998Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    },
    {
      "startTime": "2025-07-16T00:00:00.000Z",
      "endTime": "2025-07-16T05:00:00.000Z",
      "actualEndTime": "2025-07-16T02:16:52.142Z",
      "perModelStats": {
        "claude-opus-4-20250514": {
          "tokenCounts": {
            "inputTokens": 1517,
            "outputTokens": 51006,
            "cacheCreationTokens": 1964228,
            "cacheReadTokens": 31405887,
            "totalTokens": 52523
          },
          "costUSD": 87.78631,
          "entriesCount": 393
        }
      },
      "totalTokens": 262615,
      "totalTokensOld": 52523,
      "costUSD": 87.78631,
      "entries": 408,
      "limits": [
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:45:24.854Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T00:46:52.080Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:00:13.826Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        },
        {
          "type": "general_limit",
          "timestamp": "2025-07-16T01:20:13.306Z",
          "content": "Claude AI usage limit reached|1752591600",
          "resetTime": "2025-07-15T15:00:00.000Z"
        }
      ]
    }
  ]
}
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# Custom
*.enc
*.encrypted
config/settings.json
logs/
temp/
.DS_Store
.idea/
.vscode/
*.swp
*.swo
</file>

<file path="APPLICATION_GUIDE.md">
# Excel Macro Automation - ì• í”Œë¦¬ì¼€ì´ì…˜ ê°€ì´ë“œ

## ğŸš€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ ë°©ë²•

### 1. ì˜ì¡´ì„± í™•ì¸
```bash
# ì´ë¯¸ ì„¤ì¹˜ë¨ (pip3 install -r requirements.txt)
# ì£¼ìš” íŒ¨í‚¤ì§€: PyQt5, pandas, opencv-python, pyautogui, easyocr
```

### 2. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
```bash
# í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ì‹¤í–‰
cd /home/nosky/macro
python3 main.py

# ë˜ëŠ” (ê²½ë¡œ ë¬¸ì œê°€ ìˆì„ ê²½ìš°)
python3 test_app.py
```

## ğŸ“‹ ì£¼ìš” ê¸°ëŠ¥

### 1. Excel íƒ­
- **íŒŒì¼ ì„ íƒ**: Excel íŒŒì¼ì„ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” ì°¾ì•„ë³´ê¸°ë¡œ ì„ íƒ
- **ì‹œíŠ¸ ì„ íƒ**: ë“œë¡­ë‹¤ìš´ì—ì„œ ì‘ì—…í•  ì‹œíŠ¸ ì„ íƒ
- **ì—´ ë§¤í•‘**: ê° ì—´ì˜ ë°ì´í„° íƒ€ì… ìë™ ê°ì§€
- **ë¯¸ë¦¬ë³´ê¸°**: ì„ íƒí•œ ë°ì´í„°ì˜ ì²˜ìŒ 10í–‰ í‘œì‹œ
- **ìƒíƒœ ì—´**: ì‘ì—… ì™„ë£Œ ìƒíƒœë¥¼ ê¸°ë¡í•  ì—´ ìë™ ê°ì§€/ìƒì„±

### 2. Editor íƒ­ (ë§¤í¬ë¡œ í¸ì§‘ê¸°)
- **ë“œë˜ê·¸ ì•¤ ë“œë¡­**: ì™¼ìª½ íŒ”ë ˆíŠ¸ì—ì„œ ë‹¨ê³„ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€
- **ì§€ì›ë˜ëŠ” ë‹¨ê³„ íƒ€ì…**:
  - ğŸ–±ï¸ ë§ˆìš°ìŠ¤ í´ë¦­/ì´ë™
  - âŒ¨ï¸ í…ìŠ¤íŠ¸ ì…ë ¥/ë‹¨ì¶•í‚¤
  - â±ï¸ ëŒ€ê¸° ì‹œê°„
  - ğŸ–¼ï¸ ì´ë¯¸ì§€ ëŒ€ê¸°/ê²€ìƒ‰
  - ğŸ“· í™”ë©´ ìº¡ì²˜
  - â“ ì¡°ê±´ë¬¸ (êµ¬í˜„ ì˜ˆì •)
  - ğŸ”„ ë°˜ë³µë¬¸ (êµ¬í˜„ ì˜ˆì •)
- **ë‹¨ê³„ í¸ì§‘**: ê° ë‹¨ê³„ ë”ë¸”í´ë¦­ìœ¼ë¡œ ìƒì„¸ ì„¤ì •
- **ë³€ìˆ˜ ì‚¬ìš©**: {{column_name}} í˜•ì‹ìœ¼ë¡œ Excel ë°ì´í„° ì°¸ì¡°

### 3. Run íƒ­ (ì‹¤í–‰)
- **ì‹¤í–‰ ì œì–´**: ì‹œì‘/ì¼ì‹œì •ì§€/ì •ì§€ ë²„íŠ¼
- **í•«í‚¤ ì§€ì›**: 
  - F9: ì¼ì‹œì •ì§€/ì¬ê°œ
  - ESC: ì •ì§€
- **ì§„í–‰ ìƒíƒœ**: ì‹¤ì‹œê°„ ì§„í–‰ë¥  í‘œì‹œ
- **ì‹¤í–‰ ë¡œê·¸**: ê° ë‹¨ê³„ë³„ ì„±ê³µ/ì‹¤íŒ¨ ê¸°ë¡
- **ì˜µì…˜**: ë¯¸ì™„ë£Œ í•­ëª©ë§Œ ì‹¤í–‰ ì²´í¬ë°•ìŠ¤

## ğŸ¯ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤

### ì‹œë‚˜ë¦¬ì˜¤ 1: ë°˜ë³µì ì¸ ë°ì´í„° ì…ë ¥
1. Excel íŒŒì¼ì— ì…ë ¥í•  ë°ì´í„° ëª©ë¡ ì¤€ë¹„
2. ë§¤í¬ë¡œ í¸ì§‘ê¸°ì—ì„œ ë‹¤ìŒ ë‹¨ê³„ êµ¬ì„±:
   - ë§ˆìš°ìŠ¤ í´ë¦­ (ì…ë ¥ í•„ë“œ ìœ„ì¹˜)
   - í…ìŠ¤íŠ¸ ì…ë ¥ ({{ì´ë¦„}} ë³€ìˆ˜ ì‚¬ìš©)
   - ëŒ€ê¸° (0.5ì´ˆ)
   - ë‹¤ìŒ í•„ë“œë¡œ ì´ë™...
3. ì‹¤í–‰í•˜ë©´ Excelì˜ ê° í–‰ë§ˆë‹¤ ìë™ ì…ë ¥

### ì‹œë‚˜ë¦¬ì˜¤ 2: ì´ë¯¸ì§€ ê¸°ë°˜ ìë™í™”
1. ì´ë¯¸ì§€ ëŒ€ê¸° ë‹¨ê³„ ì¶”ê°€
2. "Capture" ë²„íŠ¼ìœ¼ë¡œ ëŒ€ìƒ ì´ë¯¸ì§€ ìº¡ì²˜
3. ROI(ê´€ì‹¬ ì˜ì—­) ì„¤ì •ìœ¼ë¡œ ê²€ìƒ‰ ë²”ìœ„ ì œí•œ
4. ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚˜ë©´ ë‹¤ìŒ ë™ì‘ ìˆ˜í–‰

## âš ï¸ ì£¼ì˜ì‚¬í•­

### í˜„ì¬ ìƒíƒœ
- âœ… ê¸°ë³¸ ìë™í™” ê¸°ëŠ¥ êµ¬í˜„ ì™„ë£Œ
- âœ… ì´ë¯¸ì§€ ì¸ì‹ (OpenCV) êµ¬í˜„ ì™„ë£Œ
- âŒ OCR í…ìŠ¤íŠ¸ ì¸ì‹ ë¯¸êµ¬í˜„
- âŒ ì¡°ê±´ë¬¸/ë°˜ë³µë¬¸ ì‹¤ì œ ë™ì‘ ë¯¸êµ¬í˜„
- âŒ ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ë¯¸êµ¬í˜„

### ì‹¤í–‰ í™˜ê²½
- GUI í™˜ê²½ í•„ìš” (X11, Wayland ë“±)
- ê´€ë¦¬ì ê¶Œí•œ ë¶ˆí•„ìš”
- Python 3.8+ í•„ìš”

## ğŸ”§ ë¬¸ì œ í•´ê²°

### 1. ImportError ë°œìƒ ì‹œ
```bash
# í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ì‹¤í–‰ í™•ì¸
cd /home/nosky/macro
export PYTHONPATH=$PWD/src:$PYTHONPATH
python3 main.py
```

### 2. Qt í”Œë«í¼ ì—ëŸ¬
```bash
# Linuxì—ì„œ X11 forwarding í•„ìš”
export DISPLAY=:0
# ë˜ëŠ” SSHì˜ ê²½ìš°
ssh -X user@host
```

### 3. ì˜ì¡´ì„± ë¬¸ì œ
```bash
# ê°œë³„ íŒ¨í‚¤ì§€ ì¬ì„¤ì¹˜
pip3 install --upgrade PyQt5
pip3 install --upgrade opencv-python
```

## ğŸ“ ë‹¤ìŒ ë‹¨ê³„

1. **OCR ê¸°ëŠ¥ êµ¬í˜„** (T-006)
   - EasyOCRì„ ì‚¬ìš©í•œ ë™ì  í…ìŠ¤íŠ¸ ê²€ìƒ‰
   - Excel ë°ì´í„° ê¸°ë°˜ í…ìŠ¤íŠ¸ ì°¾ê¸° ë° í´ë¦­

2. **ì¡°ê±´ë¬¸ êµ¬í˜„** (T-007)
   - If-Then-Else ë¡œì§
   - ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ì¡´ì¬ ì—¬ë¶€ íŒë‹¨

3. **ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°** (T-008)
   - JSON í˜•ì‹ìœ¼ë¡œ ë§¤í¬ë¡œ ì €ì¥
   - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë§¤í¬ë¡œ ë¼ì´ë¸ŒëŸ¬ë¦¬

4. **ê³ ê¸‰ ë¡œê¹…** (T-009)
   - CSV í˜•ì‹ ì‹¤í–‰ ë¡œê·¸
   - ì˜¤ë¥˜ ìŠ¤í¬ë¦°ìƒ· ìë™ ì €ì¥
</file>

<file path="claude.md">
# Git Commit Message Rules

## Format Structure
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

## Types (Required)
- `feat`: new feature
- `fix`: bug fix
- `docs`: documentation only
- `style`: formatting, missing semi colons, etc
- `refactor`: code change that neither fixes bug nor adds feature
- `perf`: performance improvement
- `test`: adding missing tests
- `chore`: updating grunt tasks, dependencies, etc
- `ci`: changes to CI configuration
- `build`: changes affecting build system
- `revert`: reverting previous commit

## Scope (Optional)
- Component, file, or feature area affected
- Use kebab-case: `user-auth`, `payment-api`
- Omit if change affects multiple areas

## Description Rules
- Use imperative mood: "add" not "added" or "adds"
- No capitalization of first letter
- No period at end
- Max 50 characters
- Be specific and actionable

## Body Guidelines
- Wrap at 72 characters
- Explain what and why, not how
- Separate from description with blank line
- Use bullet points for multiple changes

## Footer Format
- `BREAKING CHANGE:` for breaking changes
- `Closes #123` for issue references
- `Co-authored-by: Name <email>`

## Examples
```
feat(auth): add OAuth2 Google login

fix: resolve memory leak in user session cleanup

docs(api): update authentication endpoints

refactor(utils): extract validation helpers to separate module

BREAKING CHANGE: remove deprecated getUserData() method
```

## Workflow Integration
**ALWAYS write a commit message after completing any development task, feature, or bug fix.**

## Validation Checklist
- [ ] Type is from approved list
- [ ] Description under 50 chars
- [ ] Imperative mood used
- [ ] No trailing period
- [ ] Meaningful and clear context

# TDD Process Guidelines - Cursor Rules

## âš ï¸ MANDATORY: Follow these rules for EVERY implementation and modification

**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**

## Core Cycle: Red â†’ Green â†’ Refactor

### 1. RED Phase
- Write a failing test FIRST
- Test the simplest scenario
- Verify test fails for the right reason
- One test at a time

### 2. GREEN Phase  
- Write MINIMAL code to pass
- "Fake it till you make it" is OK
- No premature optimization
- YAGNI principle

### 3. REFACTOR Phase
- Remove duplication
- Improve naming
- Simplify structure
- Keep tests passing

## Test Quality: FIRST Principles
- **Fast**: Milliseconds, not seconds
- **Independent**: No shared state
- **Repeatable**: Same result every time
- **Self-validating**: Pass/fail, no manual checks
- **Timely**: Written just before code

## Test Structure: AAA Pattern
```
// Arrange
Set up test data and dependencies

// Act
Execute the function/method

// Assert
Verify expected outcome
```

## Implementation Flow
1. **List scenarios** before coding
2. **Pick one scenario** â†’ Write test
3. **Run test** â†’ See it fail (Red)
4. **Implement** â†’ Make it pass (Green)
5. **Refactor** â†’ Clean up (Still Green)
6. **Commit** â†’ Small, frequent commits
7. **Repeat** â†’ Next scenario

## Test Pyramid Strategy
- **Unit Tests** (70%): Fast, isolated, numerous
- **Integration Tests** (20%): Module boundaries
- **Acceptance Tests** (10%): User scenarios

## Outside-In vs Inside-Out
- **Outside-In**: Start with user-facing test â†’ Mock internals â†’ Implement details
- **Inside-Out**: Start with core logic â†’ Build outward â†’ Integrate components

## Common Anti-patterns to Avoid
- Testing implementation details
- Fragile tests tied to internals  
- Missing assertions
- Slow, environment-dependent tests
- Ignored failing tests

## When Tests Fail
1. **Identify**: Regression, flaky test, or spec change?
2. **Isolate**: Narrow down the cause
3. **Fix**: Code bug or test bug
4. **Learn**: Add missing test cases

## Team Practices
- CI/CD integration mandatory
- No merge without tests
- Test code = Production code quality
- Pair programming for complex tests
- Regular test refactoring

## Pragmatic Exceptions
- UI/Graphics: Manual + snapshot tests
- Performance: Benchmark suites
- Exploratory: Spike then test
- Legacy: Test on change

## Remember
- Tests are living documentation
- Test behavior, not implementation
- Small steps, fast feedback
- When in doubt, write a test
# Clean Code Guidelines

You are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:

## Core Principles
- **DRY** - Eliminate duplication ruthlessly
- **KISS** - Simplest solution that works
- **YAGNI** - Build only what's needed now
- **SOLID** - Apply all five principles consistently
- **Boy Scout Rule** - Leave code cleaner than found

## Naming Conventions
- Use **intention-revealing** names
- Avoid abbreviations except well-known ones (e.g., URL, API)
- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix
- Constants: UPPER_SNAKE_CASE
- No magic numbers - use named constants

## Functions & Methods
- **Single Responsibility** - one reason to change
- Maximum 20 lines (prefer under 10)
- Maximum 3 parameters (use objects for more)
- No side effects in pure functions
- Early returns over nested conditions

## Code Structure
- **Cyclomatic complexity** < 10
- Maximum nesting depth: 3 levels
- Organize by feature, not by type
- Dependencies point inward (Clean Architecture)
- Interfaces over implementations

## Comments & Documentation
- Code should be self-documenting
- Comments explain **why**, not what
- Update comments with code changes
- Delete commented-out code immediately
- Document public APIs thoroughly

## Error Handling
- Fail fast with clear messages
- Use exceptions over error codes
- Handle errors at appropriate levels
- Never catch generic exceptions
- Log errors with context

## Testing
- **TDD** when possible
- Test behavior, not implementation
- One assertion per test
- Descriptive test names: `should_X_when_Y`
- **AAA pattern**: Arrange, Act, Assert
- Maintain test coverage > 80%

## Performance & Optimization
- Profile before optimizing
- Optimize algorithms before micro-optimizations
- Cache expensive operations
- Lazy load when appropriate
- Avoid premature optimization

## Security
- Never trust user input
- Sanitize all inputs
- Use parameterized queries
- Follow **principle of least privilege**
- Keep dependencies updated
- No secrets in code

## Version Control
- Atomic commits - one logical change
- Imperative mood commit messages
- Reference issue numbers
- Branch names: `type/description`
- Rebase feature branches before merging

## Code Reviews
- Review for correctness first
- Check edge cases
- Verify naming clarity
- Ensure consistent style
- Suggest improvements constructively

## Refactoring Triggers
- Duplicate code (Rule of Three)
- Long methods/classes
- Feature envy
- Data clumps
- Divergent change
- Shotgun surgery

## Final Checklist
Before committing, ensure:
- [ ] All tests pass
- [ ] No linting errors
- [ ] No console logs
- [ ] No commented code
- [ ] No TODOs without tickets
- [ ] Performance acceptable
- [ ] Security considered
- [ ] Documentation updated

Remember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.
## Core Directive
You are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.

## Guiding Principles
- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity
- **Expert-Level Standards**: Every output must meet professional software engineering standards
- **Concrete Results**: Provide specific, actionable details at each step

---

## Phase 1: Codebase Exploration & Analysis
**REQUIRED ACTIONS:**
1. **Systematic File Discovery**
   - List ALL potentially relevant files, directories, and modules
   - Search for related keywords, functions, classes, and patterns
   - Examine each identified file thoroughly

2. **Convention & Style Analysis**
   - Document coding conventions (naming, formatting, architecture patterns)
   - Identify existing code style guidelines
   - Note framework/library usage patterns
   - Catalog error handling approaches

**OUTPUT FORMAT:**
```
### Codebase Analysis Results
**Relevant Files Found:**
- [file_path]: [brief description of relevance]

**Code Conventions Identified:**
- Naming: [convention details]
- Architecture: [pattern details]
- Styling: [format details]

**Key Dependencies & Patterns:**
- [library/framework]: [usage pattern]
```

---

## Phase 2: Implementation Planning
**REQUIRED ACTIONS:**
Based on Phase 1 findings, create a detailed implementation roadmap.

**OUTPUT FORMAT:**
```markdown
## Implementation Plan

### Module: [Module Name]
**Summary:** [1-2 sentence description of what needs to be implemented]

**Tasks:**
- [ ] [Specific implementation task]
- [ ] [Specific implementation task]

**Acceptance Criteria:**
- [ ] [Measurable success criterion]
- [ ] [Measurable success criterion]
- [ ] [Performance/quality requirement]

### Module: [Next Module Name]
[Repeat structure above]
```

---

## Phase 3: Implementation Execution
**REQUIRED ACTIONS:**
1. Implement each module following the plan from Phase 2
2. Verify ALL acceptance criteria are met before proceeding
3. Ensure code adheres to conventions identified in Phase 1

**QUALITY GATES:**
- [ ] All acceptance criteria validated
- [ ] Code follows established conventions
- [ ] Minimalistic approach maintained
- [ ] Expert-level implementation standards met

---

## Success Validation
Before completing any task, confirm:
- âœ… All three phases completed sequentially
- âœ… Each phase output meets specified format requirements
- âœ… Implementation satisfies all acceptance criteria
- âœ… Code quality meets professional standards

## Response Structure
Always structure your response as:
1. **Phase 1 Results**: [Codebase analysis findings]
2. **Phase 2 Plan**: [Implementation roadmap]  
3. **Phase 3 Implementation**: [Actual code with validation]
</file>

<file path="CURRENT_STATUS.md">
# Excel Macro Automation - í˜„ì¬ êµ¬í˜„ ìƒíƒœ

## ğŸš€ ì‹¤í–‰ ë°©ë²•

```bash
# 1. ê°€ìƒí™˜ê²½ í™œì„±í™”
source venv/bin/activate

# 2. GUI ì‹¤í–‰
python run_gui.py
# ë˜ëŠ”
./start_gui.sh
```

## âœ… êµ¬í˜„ ì™„ë£Œëœ ê¸°ëŠ¥

### 1. Excel ì—°ë™ (T-002) âœ“
- Excel íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° (.xlsx, .xls, .csv)
- ì‹œíŠ¸ ì„ íƒ ë° ì „í™˜
- ë°ì´í„° ë¯¸ë¦¬ë³´ê¸° (ì²˜ìŒ 100í–‰)
- ì—´ ë§¤í•‘ ì„¤ì •
- ìƒíƒœ ì—´ ìë™ ì¶”ê°€/ì—…ë°ì´íŠ¸

### 2. ë§¤í¬ë¡œ ì—ë””í„° (T-003) âœ“
- **ë“œë˜ê·¸ ì•¤ ë“œë¡­** ë°©ì‹ì˜ ì§ê´€ì ì¸ UI
- ë‹¨ê³„ ì¶”ê°€/ì‚­ì œ/ìˆœì„œ ë³€ê²½
- ê° ë‹¨ê³„ë³„ ìƒì„¸ ì„¤ì •
- ì‹¤ì‹œê°„ ë§¤í¬ë¡œ ë¯¸ë¦¬ë³´ê¸°

### 3. ì§€ì›ë˜ëŠ” ë§¤í¬ë¡œ ë‹¨ê³„

#### ë§ˆìš°ìŠ¤ ë™ì‘
- **ë§ˆìš°ìŠ¤ í´ë¦­** ğŸ–±ï¸
  - ì¢Œí‘œ ì§€ì •, í´ë¦­ íšŸìˆ˜, ë²„íŠ¼ ì„ íƒ
- **ë§ˆìš°ìŠ¤ ì´ë™** â†—ï¸
  - ì¢Œí‘œë¡œ ì´ë™, ì´ë™ ì‹œê°„ ì„¤ì •

#### í‚¤ë³´ë“œ ë™ì‘
- **í…ìŠ¤íŠ¸ ì…ë ¥** âŒ¨ï¸
  - ì¼ë°˜ í…ìŠ¤íŠ¸ ì…ë ¥
  - Excel ë³€ìˆ˜ ë°”ì¸ë”© ({{ë³€ìˆ˜ëª…}})
- **ë‹¨ì¶•í‚¤** âŒ˜
  - Ctrl, Alt, Shift ì¡°í•©í‚¤ ì§€ì›

#### ëŒ€ê¸° ë™ì‘
- **ì‹œê°„ ëŒ€ê¸°** â±ï¸
  - ì´ˆ ë‹¨ìœ„ ëŒ€ê¸° ì‹œê°„ ì„¤ì •
- **ì´ë¯¸ì§€ ëŒ€ê¸°** ğŸ–¼ï¸ (T-005) âœ“
  - í™”ë©´ì—ì„œ ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ ëŒ€ê¸°
  - ROI(ê´€ì‹¬ ì˜ì—­) ì§€ì • ê°€ëŠ¥
  - ì‹ ë¢°ë„ ì„¤ì •

#### í™”ë©´ ì¸ì‹ (T-005, T-006) âœ“
- **ì´ë¯¸ì§€ ê²€ìƒ‰** ğŸ”
  - OpenCV ê¸°ë°˜ ê³ ê¸‰ ì´ë¯¸ì§€ ë§¤ì¹­
  - DPI ìŠ¤ì¼€ì¼ë§ ìë™ ì²˜ë¦¬
  - ë©€í‹° ëª¨ë‹ˆí„° ì§€ì›
- **í…ìŠ¤íŠ¸ ê²€ìƒ‰** ğŸ”¤
  - EasyOCR ê¸°ë°˜ í•œêµ­ì–´/ì˜ì–´ í…ìŠ¤íŠ¸ ì¸ì‹
  - Excel ì—´ ë°ì´í„°ì™€ ì—°ë™
  - ì°¾ì€ í…ìŠ¤íŠ¸ ìë™ í´ë¦­

#### ì œì–´ êµ¬ì¡° (T-007) ğŸš§
- **ì¡°ê±´ë¬¸** â“ (ê°œë°œ ì¤‘)
- **ë°˜ë³µë¬¸** ğŸ”„ (ì˜ˆì •)

### 4. ë§¤í¬ë¡œ ì‹¤í–‰ ì—”ì§„ (T-004) âœ“
- Excel í–‰ ë‹¨ìœ„ ìˆœì°¨ ì‹¤í–‰
- ì¼ì‹œì •ì§€/ì¬ê°œ (F9)
- ê°•ì œ ì¢…ë£Œ (ESC)
- ì‹¤í–‰ ë¡œê·¸ ê¸°ë¡
- ì§„í–‰ë¥  í‘œì‹œ

### 5. ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° (T-008) âœ“
- JSON í˜•ì‹ ì €ì¥
- ì•”í˜¸í™” ì €ì¥ ì˜µì…˜
- ìë™ ë°±ì—…
- í…œí”Œë¦¿ ì œê³µ

## ğŸ”§ ê¸°ìˆ  ìŠ¤íƒ

- **ì–¸ì–´**: Python 3.10
- **GUI**: PyQt5
- **ìë™í™”**: PyAutoGUI
- **ì´ë¯¸ì§€ ì²˜ë¦¬**: OpenCV
- **OCR**: EasyOCR
- **Excel**: pandas, openpyxl

## ğŸ“ í”„ë¡œì íŠ¸ êµ¬ì¡°

```
macro/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ automation/     # ì‹¤í–‰ ì—”ì§„
â”‚   â”œâ”€â”€ config/         # ì„¤ì • ê´€ë¦¬
â”‚   â”œâ”€â”€ core/           # í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”œâ”€â”€ excel/          # Excel ì²˜ë¦¬
â”‚   â”œâ”€â”€ logger/         # ë¡œê¹…
â”‚   â”œâ”€â”€ ui/             # ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â”œâ”€â”€ dialogs/    # ë‹¤ì´ì–¼ë¡œê·¸
â”‚   â”‚   â””â”€â”€ widgets/    # ìœ„ì ¯ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ utils/          # ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ vision/         # ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ì¸ì‹
â”œâ”€â”€ venv/               # ê°€ìƒí™˜ê²½
â”œâ”€â”€ demo_data.xlsx      # í…ŒìŠ¤íŠ¸ìš© Excel ë°ì´í„°
â””â”€â”€ run_gui.py          # GUI ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
```

## ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ (ê°œë°œ ì¤‘)

- [ ] T-007: ì¡°ê±´ë¬¸ UI ë° ì‹¤í–‰ ë¡œì§
- [ ] T-009: ì‹¤í–‰ ë¡œê¹… ê°œì„ 
- [ ] T-010: ë§¤í¬ë¡œ í…ŒìŠ¤íŠ¸ ì‹œë®¬ë ˆì´í„°
- [ ] T-011: ë‹¤í¬ ëª¨ë“œ
- [ ] T-012: ë‹¤êµ­ì–´ ì§€ì›

## ğŸ’¡ ì‚¬ìš© íŒ

1. **Excel ë°ì´í„° ì¤€ë¹„**
   - ì²« ë²ˆì§¸ í–‰ì€ ì—´ ì œëª©ìœ¼ë¡œ ì‚¬ìš©
   - 'ìƒíƒœ' ì—´ì€ ìë™ìœ¼ë¡œ ì¶”ê°€ë¨

2. **ë§¤í¬ë¡œ ë§Œë“¤ê¸°**
   - ì™¼ìª½ íŒ”ë ˆíŠ¸ì—ì„œ ë‹¨ê³„ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€
   - ê° ë‹¨ê³„ë¥¼ í´ë¦­í•˜ì—¬ ìƒì„¸ ì„¤ì •
   - {{ë³€ìˆ˜ëª…}} í˜•ì‹ìœ¼ë¡œ Excel ë°ì´í„° ì°¸ì¡°

3. **ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ê²€ìƒ‰**
   - ROI ì„ íƒ ì‹œ í™”ë©´ì´ ë°˜íˆ¬ëª…í•˜ê²Œ ë³€í•¨
   - ë“œë˜ê·¸í•˜ì—¬ ê²€ìƒ‰ ì˜ì—­ ì§€ì •
   - í…ŒìŠ¤íŠ¸ ë²„íŠ¼ìœ¼ë¡œ ë¯¸ë¦¬ í™•ì¸ ê°€ëŠ¥

## ğŸ› ì•Œë ¤ì§„ ì´ìŠˆ

- WSL í™˜ê²½ì—ì„œ tkinter ê²½ê³  (ë¬´ì‹œ ê°€ëŠ¥)
- High DPI ë””ìŠ¤í”Œë ˆì´ì—ì„œ ì¢Œí‘œ ë³´ì • í•„ìš”í•  ìˆ˜ ìˆìŒ

## ğŸ“ ë¬¸ì˜

ë¬¸ì œê°€ ë°œìƒí•˜ê±°ë‚˜ ê¸°ëŠ¥ ì œì•ˆì´ ìˆìœ¼ì‹œë©´ ì´ìŠˆë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”.
</file>

<file path="package.json">
{
  "name": "macro",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs"
}
</file>

<file path="pyproject.toml">
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "excel-macro-automation"
version = "1.0.0"
description = "Excel-based task automation macro desktop application"
readme = "README.md"
requires-python = ">=3.8"
license = {text = "MIT"}
authors = [
    {name = "Excel Macro Team", email = "contact@excelmacro.com"}
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: MIT License",
    "Operating System :: Microsoft :: Windows",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Topic :: Office/Business",
]

[project.scripts]
excel-macro = "main:main"

[tool.black]
line-length = 100
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''

[tool.pytest.ini_options]
minversion = "6.0"
addopts = "-ra -q --strict-markers"
testpaths = [
    "tests",
]
python_files = [
    "test_*.py",
    "*_test.py",
]

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true

[tool.flake8]
max-line-length = 100
exclude = [
    ".git",
    "__pycache__",
    "docs/source/conf.py",
    "old",
    "build",
    "dist",
    ".eggs",
    "*.egg",
]
</file>

<file path="README.md">
# Excel Macro Automation

Excel-based task automation macro desktop application for Windows.

## Overview

This application allows users to automate repetitive tasks by reading task lists from Excel files and executing predefined sequences of mouse, keyboard, and screen recognition actions.

## Features

- Excel file integration with sheet/column mapping
- Drag & drop macro editor
- Mouse and keyboard automation
- Image search and OCR capabilities
- Conditional logic and loops
- Execution logging
- Multi-language support (Korean/English)

## Requirements

- Windows 10/11 64-bit
- Python 3.8+
- 1280x720 minimum screen resolution

## Installation

1. Clone the repository:
```bash
git clone https://github.com/reahbi/macro.git
cd macro
```

2. Create virtual environment (requires python3-venv package):
```bash
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

## Development

Run the application:
```bash
python main.py
```

Run tests:
```bash
pytest
```

Build executable:
```bash
pyinstaller excel_macro.spec
```

## Project Structure

```
macro/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ excel/        # Excel integration modules
â”‚   â”œâ”€â”€ ui/           # PyQt5 GUI components
â”‚   â”œâ”€â”€ automation/   # Automation engine
â”‚   â”œâ”€â”€ core/         # Core business logic
â”‚   â”œâ”€â”€ plugin/       # Plugin system
â”‚   â”œâ”€â”€ utils/        # Utilities (encryption, etc.)
â”‚   â”œâ”€â”€ config/       # Configuration management
â”‚   â””â”€â”€ logger/       # Logging system
â”œâ”€â”€ tests/            # Test suites
â”œâ”€â”€ resources/        # Icons, templates, locales
â”œâ”€â”€ docs/             # Documentation
â””â”€â”€ main.py           # Application entry point
```

## License

MIT License
</file>

<file path="run_automated_tests.py">
#!/usr/bin/env python3
"""
Automated test runner with logging and report generation
"""

import sys
import os
from pathlib import Path
import subprocess
import json
import time
from datetime import datetime
import pandas as pd
import argparse
from typing import Dict, List, Any

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / "src"))


class TestRunner:
    """Automated test runner with reporting"""
    
    def __init__(self, output_dir: str = "test_results"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.results = []
        self.start_time = None
        self.end_time = None
        
    def run_test_suite(self, test_files: List[str]) -> Dict[str, Any]:
        """Run a suite of test files"""
        self.start_time = datetime.now()
        suite_results = {
            'start_time': self.start_time.isoformat(),
            'test_files': test_files,
            'results': [],
            'summary': {}
        }
        
        for test_file in test_files:
            print(f"\n{'='*60}")
            print(f"Running tests in: {test_file}")
            print(f"{'='*60}\n")
            
            result = self.run_single_test(test_file)
            suite_results['results'].append(result)
            
        self.end_time = datetime.now()
        suite_results['end_time'] = self.end_time.isoformat()
        suite_results['duration'] = (self.end_time - self.start_time).total_seconds()
        
        # Calculate summary
        suite_results['summary'] = self.calculate_summary(suite_results['results'])
        
        return suite_results
        
    def run_single_test(self, test_file: str) -> Dict[str, Any]:
        """Run a single test file"""
        start_time = time.time()
        
        # Run pytest with JSON output
        json_output = self.output_dir / f"{Path(test_file).stem}_result.json"
        
        cmd = [
            sys.executable, "-m", "pytest",
            test_file,
            "-v",
            "--json-report",
            f"--json-report-file={json_output}",
            "--tb=short"
        ]
        
        # Set environment for headless testing
        env = os.environ.copy()
        env['QT_QPA_PLATFORM'] = 'offscreen'
        
        # Run the test
        process = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            env=env
        )
        
        duration = time.time() - start_time
        
        # Parse results
        test_result = {
            'file': test_file,
            'duration': duration,
            'return_code': process.returncode,
            'stdout': process.stdout,
            'stderr': process.stderr
        }
        
        # Try to load JSON report
        if json_output.exists():
            try:
                with open(json_output, 'r') as f:
                    test_result['pytest_report'] = json.load(f)
            except:
                test_result['pytest_report'] = None
                
        return test_result
        
    def calculate_summary(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Calculate test summary statistics"""
        total_tests = 0
        passed_tests = 0
        failed_tests = 0
        skipped_tests = 0
        total_duration = 0
        
        for result in results:
            total_duration += result['duration']
            
            if result.get('pytest_report'):
                report = result['pytest_report']
                summary = report.get('summary', {})
                total_tests += summary.get('total', 0)
                passed_tests += summary.get('passed', 0)
                failed_tests += summary.get('failed', 0)
                skipped_tests += summary.get('skipped', 0)
                
        return {
            'total_tests': total_tests,
            'passed_tests': passed_tests,
            'failed_tests': failed_tests,
            'skipped_tests': skipped_tests,
            'success_rate': (passed_tests / total_tests * 100) if total_tests > 0 else 0,
            'total_duration': total_duration
        }
        
    def generate_html_report(self, suite_results: Dict[str, Any]) -> Path:
        """Generate HTML test report"""
        report_path = self.output_dir / f"test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Test Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        h1, h2, h3 {{
            color: #333;
        }}
        .summary {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }}
        .stat-card {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }}
        .stat-card h3 {{
            margin: 0 0 10px 0;
            color: #666;
            font-size: 14px;
        }}
        .stat-card .value {{
            font-size: 32px;
            font-weight: bold;
            color: #333;
        }}
        .success {{ color: #28a745; }}
        .failure {{ color: #dc3545; }}
        .warning {{ color: #ffc107; }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }}
        th {{
            background-color: #f8f9fa;
            font-weight: bold;
        }}
        tr:hover {{
            background-color: #f5f5f5;
        }}
        .test-detail {{
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }}
        pre {{
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }}
        .progress-bar {{
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }}
        .progress-fill {{
            height: 100%;
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Excel Macro Automation - Test Report</h1>
        <p>Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        
        <h2>Summary</h2>
        <div class="summary">
            <div class="stat-card">
                <h3>Total Tests</h3>
                <div class="value">{suite_results['summary']['total_tests']}</div>
            </div>
            <div class="stat-card">
                <h3>Passed</h3>
                <div class="value success">{suite_results['summary']['passed_tests']}</div>
            </div>
            <div class="stat-card">
                <h3>Failed</h3>
                <div class="value failure">{suite_results['summary']['failed_tests']}</div>
            </div>
            <div class="stat-card">
                <h3>Success Rate</h3>
                <div class="value">{suite_results['summary']['success_rate']:.1f}%</div>
            </div>
            <div class="stat-card">
                <h3>Duration</h3>
                <div class="value">{suite_results['summary']['total_duration']:.1f}s</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" style="width: {suite_results['summary']['success_rate']}%">
                {suite_results['summary']['success_rate']:.1f}%
            </div>
        </div>
        
        <h2>Test Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Test File</th>
                    <th>Total</th>
                    <th>Passed</th>
                    <th>Failed</th>
                    <th>Duration</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
"""
        
        # Add test results
        for result in suite_results['results']:
            if result.get('pytest_report'):
                report = result['pytest_report'].get('summary', {})
                # Handle different report formats
                failed = report.get('failed', 0)
                if 'passed' in report and 'total' in report:
                    # Calculate failed from total - passed if not present
                    if 'failed' not in report:
                        failed = report['total'] - report['passed']
                status = "âœ… Pass" if failed == 0 else "âŒ Fail"
                status_class = "success" if failed == 0 else "failure"
            else:
                report = {'total': 0, 'passed': 0, 'failed': 0}
                status = "âš ï¸ Error"
                status_class = "warning"
                
            html_content += f"""
                <tr>
                    <td>{Path(result['file']).name}</td>
                    <td>{report.get('total', 0)}</td>
                    <td>{report.get('passed', 0)}</td>
                    <td>{failed}</td>
                    <td>{result['duration']:.2f}s</td>
                    <td class="{status_class}">{status}</td>
                </tr>
"""
        
        html_content += """
            </tbody>
        </table>
        
        <h2>Detailed Results</h2>
"""
        
        # Add detailed results for failed tests
        for result in suite_results['results']:
            if result.get('pytest_report'):
                summary = result['pytest_report'].get('summary', {})
                failed = summary.get('failed', summary.get('total', 0) - summary.get('passed', 0))
                if failed > 0:
                    html_content += f"""
        <div class="test-detail">
            <h3>{Path(result['file']).name}</h3>
            <h4>Failed Tests:</h4>
            <pre>{self._extract_failures(result['pytest_report'])}</pre>
        </div>
"""
        
        html_content += """
    </div>
</body>
</html>
"""
        
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
            
        return report_path
        
    def _extract_failures(self, pytest_report: Dict) -> str:
        """Extract failure information from pytest report"""
        failures = []
        
        for test in pytest_report.get('tests', []):
            if test['outcome'] == 'failed':
                failures.append(f"Test: {test['nodeid']}")
                if 'call' in test and 'longrepr' in test['call']:
                    failures.append(f"Error: {test['call']['longrepr']}")
                failures.append("-" * 60)
                
        return "\n".join(failures)
        
    def generate_csv_report(self, suite_results: Dict[str, Any]) -> Path:
        """Generate CSV test report"""
        report_path = self.output_dir / f"test_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        # Prepare data for CSV
        rows = []
        for result in suite_results['results']:
            if result.get('pytest_report'):
                for test in result['pytest_report'].get('tests', []):
                    rows.append({
                        'file': Path(result['file']).name,
                        'test_name': test['nodeid'],
                        'outcome': test['outcome'],
                        'duration': test.get('duration', 0),
                        'timestamp': datetime.now().isoformat()
                    })
                    
        # Create DataFrame and save
        df = pd.DataFrame(rows)
        df.to_csv(report_path, index=False)
        
        return report_path


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Run automated tests for Excel Macro Automation")
    parser.add_argument(
        '--tests', 
        nargs='+',
        help='Specific test files to run',
        default=None
    )
    parser.add_argument(
        '--output-dir',
        help='Output directory for test results',
        default='test_results'
    )
    parser.add_argument(
        '--no-html',
        action='store_true',
        help='Skip HTML report generation'
    )
    parser.add_argument(
        '--no-csv',
        action='store_true',
        help='Skip CSV report generation'
    )
    
    args = parser.parse_args()
    
    # Default test files if none specified
    if args.tests is None:
        test_dir = Path(__file__).parent / "tests" / "integration"
        args.tests = [
            str(test_dir / "test_drag_drop_integration.py"),
            str(test_dir / "test_step_configuration.py"),
            str(test_dir / "test_execution_logging.py")
        ]
    
    # Create runner
    runner = TestRunner(args.output_dir)
    
    print("Excel Macro Automation - Automated Test Runner")
    print("=" * 60)
    print(f"Running tests: {len(args.tests)} test files")
    print(f"Output directory: {runner.output_dir}")
    print("=" * 60)
    
    # Run tests
    results = runner.run_test_suite(args.tests)
    
    # Generate reports
    reports = []
    
    if not args.no_html:
        html_report = runner.generate_html_report(results)
        reports.append(('HTML', html_report))
        print(f"\nâœ… HTML report generated: {html_report}")
        
    if not args.no_csv:
        csv_report = runner.generate_csv_report(results)
        reports.append(('CSV', csv_report))
        print(f"âœ… CSV report generated: {csv_report}")
    
    # Print summary
    print("\n" + "=" * 60)
    print("TEST SUMMARY")
    print("=" * 60)
    print(f"Total Tests: {results['summary']['total_tests']}")
    print(f"Passed: {results['summary']['passed_tests']}")
    print(f"Failed: {results['summary']['failed_tests']}")
    print(f"Success Rate: {results['summary']['success_rate']:.1f}%")
    print(f"Total Duration: {results['summary']['total_duration']:.1f} seconds")
    print("=" * 60)
    
    # Return exit code based on test results
    return 0 if results['summary']['failed_tests'] == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="run_from_windows_native.ps1">
# Excel Macro Automation - Windows Native Execution
# PowerShell script for running the application directly on Windows

Write-Host "=" * 50
Write-Host "Excel Macro Automation - Windows Native Setup"
Write-Host "=" * 50

# Check if running as administrator
if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Host "ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤." -ForegroundColor Red
    Write-Host "PowerShellì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”." -ForegroundColor Yellow
    pause
    exit
}

# WSL path to Windows path conversion
$wslPath = "\\wsl.localhost\Ubuntu\home\nosky\macro"
$windowsPath = "C:\ExcelMacroAutomation"

Write-Host "`n1. í”„ë¡œì íŠ¸ íŒŒì¼ ë³µì‚¬ ì¤‘..." -ForegroundColor Green

# Create directory if not exists
if (!(Test-Path $windowsPath)) {
    New-Item -ItemType Directory -Path $windowsPath | Out-Null
}

# Copy files from WSL to Windows
Write-Host "   WSLì—ì„œ Windowsë¡œ íŒŒì¼ ë³µì‚¬ ì¤‘..."
Copy-Item -Path "$wslPath\*" -Destination $windowsPath -Recurse -Force -ErrorAction SilentlyContinue

Write-Host "`n2. Python í™•ì¸ ì¤‘..." -ForegroundColor Green

# Check Python installation
try {
    $pythonVersion = python --version 2>&1
    Write-Host "   Python ë°œê²¬: $pythonVersion" -ForegroundColor Green
} catch {
    Write-Host "   Pythonì´ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤." -ForegroundColor Red
    Write-Host "   Python ë‹¤ìš´ë¡œë“œ í˜ì´ì§€ë¥¼ ì—½ë‹ˆë‹¤..." -ForegroundColor Yellow
    Start-Process "https://www.python.org/downloads/"
    Write-Host "   Python ì„¤ì¹˜ í›„ ì´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”."
    pause
    exit
}

Write-Host "`n3. í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘..." -ForegroundColor Green

# Create virtual environment
Set-Location $windowsPath
if (!(Test-Path "venv_windows")) {
    Write-Host "   ê°€ìƒí™˜ê²½ ìƒì„± ì¤‘..."
    python -m venv venv_windows
}

# Activate virtual environment and install packages
Write-Host "   íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘ (ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤)..."
& "$windowsPath\venv_windows\Scripts\python.exe" -m pip install --upgrade pip | Out-Null
& "$windowsPath\venv_windows\Scripts\python.exe" -m pip install PyQt5 pandas openpyxl pyautogui opencv-python numpy easyocr flask

Write-Host "`n4. Windowsìš© ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì¤‘..." -ForegroundColor Green

# Create run script for Windows
$runScript = @'
import sys
import os
from pathlib import Path

# Add project paths
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# Import and run main
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    
    app = QApplication(sys.argv)
    
    from ui.main_window import MainWindow
    from config.settings import Settings
    
    settings = Settings()
    window = MainWindow(settings)
    window.show()
    
    print("\nExcel Macro Automationì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
    print("Windows ë„¤ì´í‹°ë¸Œ ëª¨ë“œë¡œ ì‹¤í–‰ ì¤‘...")
    
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"ì˜¤ë¥˜: {e}")
    import traceback
    traceback.print_exc()
    input("\nì—”í„°ë¥¼ ëˆŒëŸ¬ ì¢…ë£Œ...")
'@

$runScript | Out-File -FilePath "$windowsPath\run_windows.py" -Encoding UTF8

Write-Host "`n5. ë°°ì¹˜ íŒŒì¼ ìƒì„± ì¤‘..." -ForegroundColor Green

# Create batch file for easy execution
$batchFile = @"
@echo off
cd /d $windowsPath
call venv_windows\Scripts\activate
python run_windows.py
pause
"@

$batchFile | Out-File -FilePath "$windowsPath\ExcelMacroAutomation.bat" -Encoding ASCII

Write-Host "`n6. ë°”íƒ•í™”ë©´ ë°”ë¡œê°€ê¸° ìƒì„± ì¤‘..." -ForegroundColor Green

# Create desktop shortcut
$desktopPath = [Environment]::GetFolderPath("Desktop")
$shortcut = (New-Object -ComObject WScript.Shell).CreateShortcut("$desktopPath\Excel Macro Automation.lnk")
$shortcut.TargetPath = "$windowsPath\ExcelMacroAutomation.bat"
$shortcut.WorkingDirectory = $windowsPath
$shortcut.IconLocation = "C:\Windows\System32\shell32.dll,13"
$shortcut.Save()

Write-Host "`nâœ… ì„¤ì¹˜ ì™„ë£Œ!" -ForegroundColor Green
Write-Host "`nì‹¤í–‰ ì˜µì…˜:" -ForegroundColor Yellow
Write-Host "1. ë°”íƒ•í™”ë©´ì˜ 'Excel Macro Automation' ë°”ë¡œê°€ê¸° ë”ë¸”í´ë¦­"
Write-Host "2. $windowsPath\ExcelMacroAutomation.bat ì‹¤í–‰"
Write-Host "3. ì´ PowerShellì—ì„œ: & '$windowsPath\ExcelMacroAutomation.bat'"

Write-Host "`nì§€ê¸ˆ ì‹¤í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (Y/N): " -NoNewline
$response = Read-Host

if ($response -eq 'Y' -or $response -eq 'y') {
    Write-Host "`nì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‹¤í–‰í•©ë‹ˆë‹¤..." -ForegroundColor Green
    Start-Process "$windowsPath\ExcelMacroAutomation.bat"
}

Write-Host "`nì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì—”í„°ë¥¼ ëˆŒëŸ¬ ì¢…ë£Œ..." -ForegroundColor Green
pause
</file>

<file path="run_from_windows.bat">
@echo off
echo Excel Macro Automation - Windows ì‹¤í–‰
echo =====================================
echo.

REM WSL ê²½ë¡œë¥¼ Windows ê²½ë¡œë¡œ ë³€í™˜
set WSL_PATH=\\wsl.localhost\Ubuntu\home\nosky\macro

echo WSL í”„ë¡œì íŠ¸ ê²½ë¡œ: %WSL_PATH%
echo.

REM Windows Pythonìœ¼ë¡œ ì‹¤í–‰
echo Python ë²„ì „ í™•ì¸...
python --version

echo.
echo í•„ìš”í•œ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...
cd /d %WSL_PATH%
python -m pip install PyQt5 pandas openpyxl pyautogui opencv-python numpy

echo.
echo ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰...
set PYTHONPATH=%WSL_PATH%\src;%WSL_PATH%
python %WSL_PATH%\run_simple.py

pause
</file>

<file path="run_main_fixed.py">
#!/usr/bin/env python3
"""
Import ë¬¸ì œë¥¼ í•´ê²°í•œ ë©”ì¸ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
"""

import sys
import os
from pathlib import Path

# UTF-8 ì¸ì½”ë”© ì„¤ì •
import locale
if sys.platform == 'win32':
    # Windowsì—ì„œ UTF-8 ì„¤ì •
    os.environ['PYTHONIOENCODING'] = 'utf-8'
    try:
        locale.setlocale(locale.LC_ALL, 'ko_KR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_ALL, 'Korean_Korea.949')
        except:
            pass

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python ê²½ë¡œì— ì¶”ê°€
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# ëª¨ë“  import ë¬¸ì œ í•´ê²°
def fix_all_imports():
    """ëª¨ë“  íŒŒì¼ì˜ import ê²½ë¡œë¥¼ ìˆ˜ì •"""
    print("Import ê²½ë¡œ ìˆ˜ì • ì¤‘...")
    
    # src ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„±
    src_path.mkdir(exist_ok=True)
    
    # ëª¨ë“  Python íŒŒì¼ ì°¾ê¸°
    for py_file in src_path.rglob("*.py"):
        if py_file.is_file():
            try:
                content = py_file.read_text(encoding='utf-8')
                original_content = content
                
                # ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½
                import re
                
                # from ..module import íŒ¨í„´ ë³€ê²½
                content = re.sub(r'from \.\.\.([^.\s]+)', r'from \1', content)
                content = re.sub(r'from \.\.([^.\s]+)', r'from \1', content)
                content = re.sub(r'from \.([^.\s]+)', r'from ui.\1', content)
                
                # íŠ¹ì • import ìˆ˜ì •
                content = content.replace("from dialogs.", "from ui.dialogs.")
                content = content.replace("from widgets.", "from ui.widgets.")
                
                # ì˜ëª»ëœ ìœ„ì¹˜ ìˆ˜ì •
                content = content.replace("from ui.macro_types import", "from core.macro_types import")
                content = content.replace("from ui.macro_storage import", "from core.macro_storage import")
                content = content.replace("from ui.file_selector import", "from ui.widgets.file_selector import")
                content = content.replace("from ui.sheet_mapper import", "from ui.widgets.sheet_mapper import")
                content = content.replace("from ui.data_preview import", "from ui.widgets.data_preview import")
                content = content.replace("from ui.models import", "from excel.models import")
                content = content.replace("from ui.executor import", "from automation.executor import")
                content = content.replace("from ui.hotkey_listener import", "from automation.hotkey_listener import")
                content = content.replace("from ui.image_matcher import", "from vision.image_matcher import")
                content = content.replace("from ui.text_extractor import", "from vision.text_extractor import")
                
                # íŒŒì¼ì´ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ì €ì¥
                if content != original_content:
                    py_file.write_text(content, encoding='utf-8')
                    print(f"ìˆ˜ì •ë¨: {py_file.relative_to(src_path)}")
                    
            except Exception as e:
                print(f"íŒŒì¼ ìˆ˜ì • ì˜¤ë¥˜ {py_file}: {e}")
    
    print("Import ê²½ë¡œ ìˆ˜ì • ì™„ë£Œ")

# Import ìˆ˜ì • ì‹¤í–‰
fix_all_imports()

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
if sys.platform == 'win32':
    os.environ['QT_QPA_PLATFORM'] = 'windows'
else:
    os.environ['QT_QPA_PLATFORM'] = 'xcb'

# ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    from PyQt5.QtGui import QFont
    
    # High DPI ì§€ì›
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # í°íŠ¸ ì„¤ì •
    if sys.platform == 'win32':
        font = QFont("ë§‘ì€ ê³ ë”•", 10)
    else:
        font = QFont("Nanum Gothic", 10)
    app.setFont(font)
    
    # ë©”ì¸ ìœˆë„ìš° import ë° ì‹¤í–‰
    print("ëª¨ë“ˆ import ì¤‘...")
    
    try:
        from ui.main_window import MainWindow
        print("âœ“ MainWindow import ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— MainWindow import ì‹¤íŒ¨: {e}")
        raise
        
    try:
        from config.settings import Settings
        print("âœ“ Settings import ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Settings import ì‹¤íŒ¨: {e}")
        raise
        
    try:
        from logger.app_logger import setup_logger
        print("âœ“ Logger import ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Logger import ì‹¤íŒ¨: {e}")
        raise
    
    # ë¡œê±° ì„¤ì •
    try:
        logger = setup_logger()
        logger.info("Starting Excel Macro Automation Application")
        print("âœ“ Logger ì„¤ì • ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Logger ì„¤ì • ì‹¤íŒ¨: {e}")
        # Logger ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
        logger = None
    
    # ì„¤ì • ì´ˆê¸°í™”
    try:
        settings = Settings()
        print("âœ“ Settings ì´ˆê¸°í™” ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— Settings ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        raise
    
    # ë©”ì¸ ìœˆë„ìš° ìƒì„± ë° í‘œì‹œ
    try:
        print("âœ“ MainWindow ê°ì²´ ìƒì„± ì¤‘...")
        window = MainWindow(settings)
        print("âœ“ MainWindow ê°ì²´ ìƒì„± ì™„ë£Œ")
        
        print("âœ“ ìœˆë„ìš° íƒ€ì´í‹€ ì„¤ì • ì¤‘...")
        window.setWindowTitle("Excel ê¸°ë°˜ ì‘ì—… ìë™í™” ë§¤í¬ë¡œ")
        print("âœ“ ìœˆë„ìš° íƒ€ì´í‹€ ì„¤ì • ì™„ë£Œ")
        
        print("âœ“ ìœˆë„ìš° í‘œì‹œ ì¤‘...")
        window.show()
        print("âœ“ ìœˆë„ìš° í‘œì‹œ ì™„ë£Œ")
        
        print("\nâœ“ Excel Macro Automation ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
        print("âœ“ ëª¨ë“  GUI ì»´í¬ë„ŒíŠ¸ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.")
        print("\nê¸°ëŠ¥:")
        print("- Excel íƒ­: íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°, ì‹œíŠ¸ ì„ íƒ, ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°")
        print("- Editor íƒ­: ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë§¤í¬ë¡œ í¸ì§‘")
        print("- Run íƒ­: ë§¤í¬ë¡œ ì‹¤í–‰ ë° ëª¨ë‹ˆí„°ë§")
        print("\nì°½ì„ ë‹«ìœ¼ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.")
        print("\nâœ“ ì´ë²¤íŠ¸ ë£¨í”„ ì‹œì‘ ì¤‘...")
        
        # ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰
        result = app.exec_()
        print(f"\nâœ“ ì´ë²¤íŠ¸ ë£¨í”„ ì¢…ë£Œë¨ (ì½”ë“œ: {result})")
        sys.exit(result)
        
    except Exception as window_error:
        print(f"\në©”ì¸ ìœˆë„ìš° ìƒì„± ì¤‘ ì˜¤ë¥˜: {window_error}")
        import traceback
        traceback.print_exc()
        raise
    
except Exception as e:
    print(f"\nì˜¤ë¥˜ ë°œìƒ: {e}")
    print("\nìì„¸í•œ ì˜¤ë¥˜ ì •ë³´:")
    import traceback
    traceback.print_exc()
    
    print("\në””ë²„ê¹… ì •ë³´:")
    print(f"Project root: {project_root}")
    print(f"Src path: {src_path}")
    print(f"Python path: {sys.path[:3]}")
    print(f"Platform: {sys.platform}")
    
    input("\nPress Enter to exit...")
</file>

<file path="run_simple.py">
#!/usr/bin/env python3
"""
ê°„ë‹¨í•œ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸ - import ë¬¸ì œ í•´ê²°
"""

import sys
import os
from pathlib import Path

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python ê²½ë¡œì— ì¶”ê°€
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
os.environ['QT_QPA_PLATFORM'] = 'xcb'

print("Excel Macro Automation ì‹œì‘...")

try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    
    # High DPI ì„¤ì •
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒì„±
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # ì„¤ì • ë° ë¡œê±° ì´ˆê¸°í™”
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    settings = Settings()
    logger = setup_logger()
    
    # ë©”ì¸ ìœˆë„ìš° ìƒì„±
    from ui.main_window import MainWindow
    window = MainWindow(settings)
    
    # ìœˆë„ìš° í‘œì‹œ
    window.show()
    
    print("âœ“ GUIê°€ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
    print("ì¢…ë£Œí•˜ë ¤ë©´ ì°½ì„ ë‹«ìœ¼ì„¸ìš”.")
    
    # ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"\nì˜¤ë¥˜ ë°œìƒ: {e}")
    import traceback
    traceback.print_exc()
    input("\nEnterë¥¼ ëˆŒëŸ¬ ì¢…ë£Œ...")
</file>

<file path="run_windows_wsl.sh">
#!/bin/bash
# Windows + WSL2 í™˜ê²½ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

echo "Windows + WSL2 í™˜ê²½ì—ì„œ Excel Macro Automation ì‹¤í–‰"
echo "=================================================="

# Windows IP ì£¼ì†Œ ê°€ì ¸ì˜¤ê¸°
WINDOWS_IP=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}')
export DISPLAY=$WINDOWS_IP:0.0
export LIBGL_ALWAYS_INDIRECT=1

echo "Windows IP: $WINDOWS_IP"
echo "DISPLAY ì„¤ì •: $DISPLAY"
echo ""

# X Server ì—°ê²° í…ŒìŠ¤íŠ¸
echo "X Server ì—°ê²° í…ŒìŠ¤íŠ¸ ì¤‘..."
if command -v xset &> /dev/null; then
    if xset q &>/dev/null; then
        echo "âœ“ X Server ì—°ê²° ì„±ê³µ!"
    else
        echo "âœ— X Serverì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        echo ""
        echo "ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:"
        echo "1. Windowsì—ì„œ VcXsrv ë˜ëŠ” MobaXtermì´ ì‹¤í–‰ ì¤‘ì¸ê°€?"
        echo "2. VcXsrv ì„¤ì •ì—ì„œ 'Disable access control'ì´ ì²´í¬ë˜ì–´ ìˆëŠ”ê°€?"
        echo "3. Windows ë°©í™”ë²½ì´ X Serverë¥¼ ì°¨ë‹¨í•˜ê³  ìˆì§€ ì•Šì€ê°€?"
        echo ""
        echo "VcXsrv ë‹¤ìš´ë¡œë“œ: https://sourceforge.net/projects/vcxsrv/"
        exit 1
    fi
else
    echo "xsetì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. X Server í…ŒìŠ¤íŠ¸ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤."
fi

echo ""
echo "ê°€ìƒí™˜ê²½ í™œì„±í™”..."
source venv/bin/activate

echo "Python ê²½ë¡œ: $(which python)"
echo "Python ë²„ì „: $(python --version)"
echo ""

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
echo "ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‹¤í–‰í•©ë‹ˆë‹¤..."
python run_simple.py
</file>

<file path="run_windows.bat">
@echo off
echo === Excel Macro Automation Tool - Windows Runner ===
echo.

REM Handle UNC path issue by mapping to a temporary drive
if "%~d0"=="\\" (
    echo Detected UNC path. Creating temporary drive mapping...
    pushd "%~dp0"
) else (
    cd /d "%~dp0"
)

echo Working directory: %cd%
echo.

REM Check if Python is installed
python --version >nul 2>&1
if errorlevel 1 (
    echo Python is not installed or not in PATH!
    echo Please install Python from python.org
    pause
    exit /b 1
)

REM Check for virtual environment
if exist "venv\Scripts\activate.bat" (
    echo Activating virtual environment...
    call venv\Scripts\activate.bat
) else (
    echo Creating virtual environment...
    python -m venv venv
    if errorlevel 1 (
        echo Failed to create virtual environment!
        pause
        exit /b 1
    )
    call venv\Scripts\activate.bat
)

REM Install dependencies
echo.
echo Checking dependencies...
if exist "requirements.txt" (
    echo Installing requirements...
    python -m pip install --upgrade pip
    pip install -r requirements.txt
) else (
    echo Installing core packages...
    python -m pip install --upgrade pip
    pip install PyQt5 pandas openpyxl pyautogui pillow screeninfo cryptography opencv-python numpy mss easyocr
)

REM Set environment variables
set QT_AUTO_SCREEN_SCALE_FACTOR=1
set QT_ENABLE_HIGHDPI_SCALING=1
set PYTHONIOENCODING=utf-8

REM Run the application
echo.
echo Starting Excel Macro Automation Tool...
echo Note: Running in native Windows mode for better GUI compatibility
echo.

python run_main_fixed.py

REM Keep window open regardless of result
echo.
echo Program execution completed.
pause

REM Clean up temporary drive mapping if used
if "%~d0"=="\\" (
    popd
)
</file>

<file path="run_windows.ps1">
# PowerShell script to run the macro application on Windows
# This script helps run the WSL-developed app in native Windows environment

Write-Host "=== Excel Macro Automation Tool - Windows Runner ===" -ForegroundColor Cyan

# Check if Python is installed
try {
    $pythonVersion = python --version 2>&1
    Write-Host "Found Python: $pythonVersion" -ForegroundColor Green
} catch {
    Write-Host "Python is not installed or not in PATH!" -ForegroundColor Red
    Write-Host "Please install Python from python.org" -ForegroundColor Yellow
    exit 1
}

# Get the script directory
$scriptPath = $PSScriptRoot
if (-not $scriptPath) {
    $scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
}

# Handle UNC/WSL paths
if ($scriptPath -like "\\wsl*" -or $scriptPath -like "\\\\*") {
    Write-Host "Detected WSL/UNC path. Creating temporary copy..." -ForegroundColor Yellow
    
    $tempDir = Join-Path $env:TEMP "excel_macro_tool"
    if (Test-Path $tempDir) {
        Remove-Item $tempDir -Recurse -Force
    }
    
    # Create the directory first
    New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
    
    Write-Host "Copying files to: $tempDir" -ForegroundColor Yellow
    
    # Copy files and directories separately to avoid errors
    Get-ChildItem -Path $scriptPath -File | ForEach-Object {
        Copy-Item -Path $_.FullName -Destination $tempDir -Force
    }
    
    # Copy src directory
    if (Test-Path (Join-Path $scriptPath "src")) {
        Copy-Item -Path (Join-Path $scriptPath "src") -Destination $tempDir -Recurse -Force
    }
    
    # Copy other important directories if they exist
    @("resources", "captures", "docs") | ForEach-Object {
        $dirPath = Join-Path $scriptPath $_
        if (Test-Path $dirPath) {
            Copy-Item -Path $dirPath -Destination $tempDir -Recurse -Force
        }
    }
    
    $scriptPath = $tempDir
}

# Change to the script directory
Set-Location $scriptPath
Write-Host "Working directory: $(Get-Location)" -ForegroundColor Green

# Check if virtual environment exists
$venvPath = Join-Path $scriptPath "venv"
$venvActivate = Join-Path $venvPath "Scripts\Activate.ps1"

if (Test-Path $venvActivate) {
    Write-Host "Activating virtual environment..." -ForegroundColor Yellow
    & $venvActivate
} else {
    Write-Host "No virtual environment found. Creating one..." -ForegroundColor Yellow
    python -m venv venv
    & $venvActivate
}

# Install/update dependencies
Write-Host "`nChecking dependencies..." -ForegroundColor Yellow
$requirementsPath = Join-Path $scriptPath "requirements.txt"

if (Test-Path $requirementsPath) {
    Write-Host "Installing requirements..." -ForegroundColor Yellow
    pip install -r requirements.txt --quiet
} else {
    Write-Host "No requirements.txt found. Installing core packages..." -ForegroundColor Yellow
    pip install PyQt5 pandas openpyxl pyautogui pillow screeninfo cryptography --quiet
}

# Set environment variables for better Windows compatibility
$env:QT_AUTO_SCREEN_SCALE_FACTOR = "1"
$env:QT_ENABLE_HIGHDPI_SCALING = "1"

# Run the application
Write-Host "`nStarting Excel Macro Automation Tool..." -ForegroundColor Green
Write-Host "Note: Running in native Windows mode for better GUI compatibility" -ForegroundColor Cyan

try {
    python run_main_fixed.py
} catch {
    Write-Host "`nError running application: $_" -ForegroundColor Red
    Write-Host "Press any key to exit..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}
</file>

<file path="run_with_debug.py">
#!/usr/bin/env python3
"""
ë””ë²„ê·¸ ëª¨ë“œë¡œ ì‹¤í–‰
"""

import sys
import os
from pathlib import Path

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# Windows IP ìë™ ê°ì§€
import subprocess
result = subprocess.run(['cat', '/etc/resolv.conf'], capture_output=True, text=True)
for line in result.stdout.split('\n'):
    if 'nameserver' in line:
        windows_ip = line.split()[1]
        break

# ì—¬ëŸ¬ DISPLAY ì„¤ì • ì‹œë„
display_options = [
    f"{windows_ip}:0.0",
    f"{windows_ip}:0",
    "localhost:0.0",
    "localhost:0",
    ":0.0",
    ":0"
]

print("=== GUI ì‹¤í–‰ ì‹œë„ ===")
print(f"Windows IP: {windows_ip}")

for display in display_options:
    print(f"\nDISPLAY={display} ì‹œë„ ì¤‘...")
    os.environ['DISPLAY'] = display
    os.environ['LIBGL_ALWAYS_INDIRECT'] = '1'
    
    try:
        from PyQt5.QtWidgets import QApplication, QMessageBox
        from PyQt5.QtCore import Qt, QTimer
        
        # High DPI ì„¤ì •
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        
        app = QApplication(sys.argv)
        
        # ê°„ë‹¨í•œ ë©”ì‹œì§€ ë°•ìŠ¤ í‘œì‹œ
        msg = QMessageBox()
        msg.setWindowTitle("ì—°ê²° ì„±ê³µ!")
        msg.setText(f"X Server ì—°ê²° ì„±ê³µ!\nDISPLAY: {display}")
        msg.setIcon(QMessageBox.Information)
        msg.setStandardButtons(QMessageBox.Ok)
        
        # 3ì´ˆ í›„ ìë™ ë‹«ê¸°
        QTimer.singleShot(3000, msg.close)
        
        msg.show()
        
        print(f"âœ“ ì„±ê³µ! DISPLAY={display}")
        print("\nì˜¬ë°”ë¥¸ DISPLAY ì„¤ì •ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
        print(f"ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì‹¤í–‰í•˜ì„¸ìš”:")
        print(f"export DISPLAY={display}")
        print(f"source venv/bin/activate")
        print(f"python run_simple.py")
        
        app.exec_()
        break
        
    except Exception as e:
        print(f"âœ— ì‹¤íŒ¨: {e}")
        continue
else:
    print("\nëª¨ë“  DISPLAY ì„¤ì •ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
    print("\nVcXsrv ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”:")
    print("1. VcXsrvê°€ ì‹¤í–‰ ì¤‘ì¸ê°€?")
    print("2. 'Disable access control' ì˜µì…˜ì´ ì²´í¬ë˜ì–´ ìˆëŠ”ê°€?")
    print("3. Windows ë°©í™”ë²½ì´ ì°¨ë‹¨í•˜ê³  ìˆì§€ ì•Šì€ê°€?")
</file>

<file path="RUNNING_GUIDE.md">
# Excel Macro Automation ì‹¤í–‰ ê°€ì´ë“œ

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

### 1. ê°€ìƒí™˜ê²½ í™œì„±í™”
```bash
source venv/bin/activate
```

### 2. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
```bash
python run_simple.py
```

ë˜ëŠ”

```bash
./start_gui.sh
```

## âš™ï¸ ì‹¤í–‰ í™˜ê²½ í™•ì¸

### WSL2 GUI ì§€ì› í™•ì¸
```bash
# DISPLAY í™˜ê²½ ë³€ìˆ˜ í™•ì¸
echo $DISPLAY
# ì¶œë ¥: :0 ë˜ëŠ” :0.0

# X11 ì†Œì¼“ í™•ì¸
ls /tmp/.X11-unix/
# ì¶œë ¥: X0
```

### Python í™˜ê²½ í™•ì¸
```bash
# ê°€ìƒí™˜ê²½ í™œì„±í™” ìƒíƒœ í™•ì¸
which python
# ì¶œë ¥: /home/nosky/macro/venv/bin/python

# PyQt5 ì„¤ì¹˜ í™•ì¸
python -c "import PyQt5; print('PyQt5 OK')"
```

## ğŸ”§ ë¬¸ì œ í•´ê²°

### GUIê°€ í‘œì‹œë˜ì§€ ì•Šì„ ë•Œ

1. **WSLg ì—…ë°ì´íŠ¸**
   ```bash
   wsl --update
   ```

2. **X11 ê´€ë ¨ íŒ¨í‚¤ì§€ ì„¤ì¹˜**
   ```bash
   sudo apt-get update
   sudo apt-get install x11-apps
   
   # í…ŒìŠ¤íŠ¸
   xclock  # ì‹œê³„ê°€ í‘œì‹œë˜ë©´ ì •ìƒ
   ```

3. **í•œê¸€ í°íŠ¸ ì„¤ì¹˜** (ì´ë¯¸ ì„¤ì¹˜ë¨)
   ```bash
   sudo apt-get install fonts-nanum fonts-noto-cjk
   ```

### "tkinter" ê²½ê³  ë©”ì‹œì§€
- PyAutoGUIì˜ ì˜ì¡´ì„± ë•Œë¬¸ì— ë‚˜íƒ€ë‚˜ëŠ” ë©”ì‹œì§€ë¡œ ë¬´ì‹œí•´ë„ ë©ë‹ˆë‹¤
- ìš°ë¦¬ ì•±ì€ PyQt5ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ tkinterê°€ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤

### Import ì˜¤ë¥˜ ë°œìƒ ì‹œ
```bash
# run_main.py ëŒ€ì‹  run_simple.py ì‚¬ìš©
python run_simple.py
```

## ğŸ“ ì‹¤í–‰ íŒŒì¼ ì„¤ëª…

- `run_main.py`: ìë™ import íŒ¨ì¹˜ ê¸°ëŠ¥ì´ ìˆëŠ” ë©”ì¸ ì‹¤í–‰ íŒŒì¼
- `run_simple.py`: ê°„ë‹¨í•œ ì‹¤í–‰ íŒŒì¼ (import ë¬¸ì œ ì‹œ ì‚¬ìš©)
- `start_gui.sh`: ì…¸ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ íŒŒì¼

## ğŸ’¡ íŒ

1. **ì²« ì‹¤í–‰ ì‹œ**
   - EasyOCR ëª¨ë¸ì„ ë‹¤ìš´ë¡œë“œí•˜ë¯€ë¡œ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤
   - ì¸í„°ë„· ì—°ê²°ì´ í•„ìš”í•©ë‹ˆë‹¤

2. **ì„±ëŠ¥ í–¥ìƒ**
   - ROI(ê´€ì‹¬ ì˜ì—­)ë¥¼ ì§€ì •í•˜ì—¬ OCR/ì´ë¯¸ì§€ ê²€ìƒ‰ ì†ë„ í–¥ìƒ
   - ë¶ˆí•„ìš”í•œ ë‹¨ê³„ëŠ” ë¹„í™œì„±í™”

3. **ë””ë²„ê¹…**
   - ë¡œê·¸ íŒŒì¼ í™•ì¸: `logs/` ë””ë ‰í† ë¦¬
   - ì„¤ì • íŒŒì¼: `~/.excel_macro_automation/settings.yaml`

## ğŸ¯ ë‹¤ìŒ ë‹¨ê³„

1. Excel íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° (Excel íƒ­)
2. ë§¤í¬ë¡œ ë‹¨ê³„ ì¶”ê°€ (Editor íƒ­)
3. ë§¤í¬ë¡œ ì‹¤í–‰ (Run íƒ­)

ìì„¸í•œ ì‚¬ìš©ë²•ì€ `CURRENT_STATUS.md` ì°¸ì¡°
</file>

<file path="setup_wsl_gui.sh">
#!/bin/bash
# WSL GUI ì„¤ì • ìŠ¤í¬ë¦½íŠ¸

echo "=== WSL GUI í™˜ê²½ ì„¤ì • ==="

# 1. Windows IP ìë™ ê°ì§€
WINDOWS_IP=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2; exit;}')
echo "Windows IP: $WINDOWS_IP"

# 2. DISPLAY í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
export DISPLAY=$WINDOWS_IP:0.0
export LIBGL_ALWAYS_INDIRECT=1

echo "DISPLAY ì„¤ì •: $DISPLAY"

# 3. .bashrcì— ì˜êµ¬ ì„¤ì • ì¶”ê°€ (ì´ë¯¸ ì—†ëŠ” ê²½ìš°ë§Œ)
if ! grep -q "export DISPLAY=" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "# WSL GUI Support" >> ~/.bashrc
    echo "export DISPLAY=\$(cat /etc/resolv.conf | grep nameserver | awk '{print \$2; exit;}'):0.0" >> ~/.bashrc
    echo "export LIBGL_ALWAYS_INDIRECT=1" >> ~/.bashrc
    echo "âœ“ ~/.bashrcì— DISPLAY ì„¤ì •ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤."
else
    echo "âœ“ ~/.bashrcì— ì´ë¯¸ DISPLAY ì„¤ì •ì´ ìˆìŠµë‹ˆë‹¤."
fi

# 4. í•„ìš”í•œ íŒ¨í‚¤ì§€ í™•ì¸
echo ""
echo "í•„ìš”í•œ íŒ¨í‚¤ì§€ í™•ì¸ ì¤‘..."

# PyQt5 í™•ì¸
if python3 -c "import PyQt5" 2>/dev/null; then
    echo "âœ“ PyQt5ê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
else
    echo "âœ— PyQt5ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
fi

# 5. X Server ì—°ê²° í…ŒìŠ¤íŠ¸
echo ""
echo "X Server ì—°ê²° í…ŒìŠ¤íŠ¸..."
if command -v xeyes &> /dev/null; then
    timeout 2 xeyes 2>/dev/null &
    XEYES_PID=$!
    sleep 1
    if kill -0 $XEYES_PID 2>/dev/null; then
        echo "âœ“ X Server ì—°ê²° ì„±ê³µ! (xeyesê°€ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤)"
        kill $XEYES_PID 2>/dev/null
    else
        echo "âœ— X Server ì—°ê²° ì‹¤íŒ¨"
        echo ""
        echo "ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:"
        echo "1. Windowsì—ì„œ VcXsrvê°€ ì‹¤í–‰ ì¤‘ì¸ê°€?"
        echo "2. VcXsrv ì„¤ì •ì—ì„œ 'Disable access control'ì´ ì²´í¬ë˜ì–´ ìˆëŠ”ê°€?"
        echo "3. Windows ë°©í™”ë²½ì´ VcXsrvë¥¼ ì°¨ë‹¨í•˜ê³  ìˆì§€ ì•Šì€ê°€?"
    fi
fi

echo ""
echo "ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
echo "ìƒˆ í„°ë¯¸ë„ì„ ì—´ê±°ë‚˜ ë‹¤ìŒ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì„¸ìš”:"
echo "source ~/.bashrc"
</file>

<file path="start_gui.sh">
#!/bin/bash
# Excel Macro Automation ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

echo "Excel Macro Automation GUI ì‹œì‘..."
echo "=================================="

# ê°€ìƒí™˜ê²½ í™œì„±í™”
source venv/bin/activate

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
export DISPLAY=${DISPLAY:-:0}
export QT_QPA_PLATFORM=xcb
export QT_DEBUG_PLUGINS=0

# Python ê²½ë¡œ ì¶œë ¥
echo "Python ê²½ë¡œ: $(which python)"
echo "Python ë²„ì „: $(python --version)"
echo ""

# GUI ì‹¤í–‰
echo "GUIë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤..."
python run_main.py

echo "=================================="
echo "í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
</file>

<file path="test_compact_mode.py">
#!/usr/bin/env python3
"""Test script for compact mode functionality"""

import sys
from PyQt5.QtWidgets import QApplication
from src.ui.main_window import MainWindow
from src.config.settings import Settings

def main():
    app = QApplication(sys.argv)
    
    # Initialize settings
    settings = Settings()
    
    # Create and show main window
    window = MainWindow(settings)
    window.show()
    
    # Print instructions
    print("Compact Mode Test")
    print("-" * 40)
    print("1. Check View menu - 'Compact Mode' option should be visible")
    print("2. Use Ctrl+Shift+C to toggle compact mode")
    print("3. When enabled:")
    print("   - UI elements should be more condensed")
    print("   - Font size should be smaller (11px)")
    print("   - Padding and margins should be reduced")
    print("   - Tab bar should be more compact")
    print("   - Status bar should be smaller")
    print("4. Setting should persist after restart")
    print("-" * 40)
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
</file>

<file path="test_demo_scenario.py">
#!/usr/bin/env python3
"""
Demo test scenario for manual testing
Creates a simple macro and executes it with logging
"""

import sys
import os
from pathlib import Path
import time
import pandas as pd
import tempfile

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from PyQt5.QtWidgets import QApplication
from ui.main_window import MainWindow
from config.settings import Settings
from core.macro_types import Macro, MacroStep, StepType
from logger.app_logger import setup_logger


def create_demo_excel_file():
    """Create a demo Excel file for testing"""
    temp_file = tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False)
    
    # Create test data
    test_data = pd.DataFrame({
        'ì‘ì—…í•­ëª©': ['ë¡œê·¸ì¸', 'ë°ì´í„° ì…ë ¥', 'ê²€ìƒ‰', 'ê²°ê³¼ í™•ì¸', 'ë¡œê·¸ì•„ì›ƒ'],
        'ëŒ€ê¸°ì‹œê°„': [2, 1, 1, 3, 1],
        'ì…ë ¥í…ìŠ¤íŠ¸': ['test@example.com', 'í…ŒìŠ¤íŠ¸ ë°ì´í„°', 'ê²€ìƒ‰ì–´', '', ''],
        'ìƒíƒœ': ['ëŒ€ê¸°', 'ëŒ€ê¸°', 'ëŒ€ê¸°', 'ëŒ€ê¸°', 'ëŒ€ê¸°'],
        'Status': ['', '', '', '', '']
    })
    
    # Save to Excel
    test_data.to_excel(temp_file.name, index=False, sheet_name='ì‘ì—…ëª©ë¡')
    temp_file.close()
    
    print(f"âœ… Demo Excel file created: {temp_file.name}")
    return temp_file.name


def create_demo_macro():
    """Create a demo macro for testing"""
    macro = Macro(name="ë°ëª¨ í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ")
    
    # Step 1: Wait
    wait_step = MacroStep(step_type=StepType.WAIT_TIME)
    wait_step.name = "ì´ˆê¸° ëŒ€ê¸°"
    wait_step.config = {"duration_seconds": 1}
    macro.add_step(wait_step)
    
    # Step 2: Type text with variable
    type_step = MacroStep(step_type=StepType.KEYBOARD_TYPE)
    type_step.name = "ì‘ì—… í•­ëª© ì…ë ¥"
    type_step.config = {
        "text": "ì‘ì—…: {{ì‘ì—…í•­ëª©}}",
        "use_variable": True
    }
    macro.add_step(type_step)
    
    # Step 3: Variable wait time
    var_wait_step = MacroStep(step_type=StepType.WAIT_TIME)
    var_wait_step.name = "ë³€ìˆ˜ ëŒ€ê¸° ì‹œê°„"
    var_wait_step.config = {
        "duration_seconds": "{{ëŒ€ê¸°ì‹œê°„}}",
        "use_variable": True
    }
    macro.add_step(var_wait_step)
    
    # Step 4: Conditional text input
    cond_step = MacroStep(step_type=StepType.IF_CONDITION)
    cond_step.name = "í…ìŠ¤íŠ¸ ì…ë ¥ í™•ì¸"
    cond_step.config = {
        "condition_type": "variable_not_empty",
        "variable_name": "ì…ë ¥í…ìŠ¤íŠ¸"
    }
    
    # True branch - type the text
    true_type_step = MacroStep(step_type=StepType.KEYBOARD_TYPE)
    true_type_step.name = "ì¡°ê±´ë¶€ í…ìŠ¤íŠ¸ ì…ë ¥"
    true_type_step.config = {
        "text": "{{ì…ë ¥í…ìŠ¤íŠ¸}}",
        "use_variable": True
    }
    cond_step.true_steps = [true_type_step]
    
    macro.add_step(cond_step)
    
    print("âœ… Demo macro created with 4 steps")
    return macro


def run_demo_test():
    """Run the demo test scenario"""
    print("\n" + "="*60)
    print("Excel Macro Automation - Demo Test Scenario")
    print("="*60)
    
    # Setup logger
    logger = setup_logger()
    logger.info("Starting demo test scenario")
    
    # Create test data
    excel_file = create_demo_excel_file()
    macro = create_demo_macro()
    
    print("\nğŸ“‹ Test Scenario:")
    print("1. Excel íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤")
    print("2. ë§¤í¬ë¡œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤")
    print("3. ê° í–‰ì— ëŒ€í•´ ë§¤í¬ë¡œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤")
    print("4. ì‹¤í–‰ ë¡œê·¸ë¥¼ í™•ì¸í•©ë‹ˆë‹¤")
    print("\nì‹œì‘í•˜ë ¤ë©´ Enterë¥¼ ëˆ„ë¥´ì„¸ìš”...")
    input()
    
    # Create Qt application
    app = QApplication(sys.argv)
    
    # Create settings
    settings = Settings()
    
    # Create main window
    window = MainWindow(settings)
    window.show()
    
    print("\nğŸ“Œ ìˆ˜ë™ í…ŒìŠ¤íŠ¸ ë‹¨ê³„:")
    print("1. Excel íƒ­ì—ì„œ 'ì—´ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ê³  ìƒì„±ëœ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”")
    print(f"   íŒŒì¼ ê²½ë¡œ: {excel_file}")
    print("2. 'ì‘ì—…ëª©ë¡' ì‹œíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”")
    print("3. ì—´ ë§¤í•‘ì„ ì„¤ì •í•˜ì„¸ìš”:")
    print("   - ì‘ì—…í•­ëª© â†’ ì‘ì—…í•­ëª©")
    print("   - ëŒ€ê¸°ì‹œê°„ â†’ ëŒ€ê¸°ì‹œê°„")
    print("   - ì…ë ¥í…ìŠ¤íŠ¸ â†’ ì…ë ¥í…ìŠ¤íŠ¸")
    print("   - Status â†’ Status")
    print("4. Editor íƒ­ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”")
    print("5. ì´ë¯¸ ìƒì„±ëœ ë§¤í¬ë¡œê°€ í‘œì‹œë©ë‹ˆë‹¤")
    print("6. Run íƒ­ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”")
    print("7. 'ì‹œì‘' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì‹¤í–‰í•˜ì„¸ìš”")
    print("8. ì‹¤í–‰ ì¤‘/í›„ 'CSV ë¡œê·¸ ë³´ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”")
    print("\nğŸ’¡ í…ŒìŠ¤íŠ¸ í¬ì¸íŠ¸:")
    print("- ê° ë‹¨ê³„ê°€ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰ë˜ëŠ”ì§€ í™•ì¸")
    print("- ë³€ìˆ˜ê°€ ì˜¬ë°”ë¥´ê²Œ ì¹˜í™˜ë˜ëŠ”ì§€ í™•ì¸")
    print("- ì¡°ê±´ë¬¸ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸")
    print("- ë¡œê·¸ê°€ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ëŠ”ì§€ í™•ì¸")
    print("- ì—ëŸ¬ ë°œìƒ ì‹œ ì—ëŸ¬ ë‹¤ì´ì–¼ë¡œê·¸ê°€ í‘œì‹œë˜ëŠ”ì§€ í™•ì¸")
    
    # Pre-load the macro in the editor
    window.macro_editor.set_macro(macro)
    
    # Pre-load Excel manager setup hint
    print("\nâš ï¸  ì£¼ì˜: ì‹¤ì œ í™”ë©´ í´ë¦­ì´ë‚˜ í…ìŠ¤íŠ¸ ì…ë ¥ì€ ì‹œë®¬ë ˆì´ì…˜ë©ë‹ˆë‹¤.")
    print("ì‹¤ì œ ìë™í™”ë¥¼ í…ŒìŠ¤íŠ¸í•˜ë ¤ë©´ ì´ë¯¸ì§€ ìº¡ì²˜ì™€ ì‹¤ì œ ëŒ€ìƒ í”„ë¡œê·¸ë¨ì´ í•„ìš”í•©ë‹ˆë‹¤.")
    
    # Run the application
    app.exec_()
    
    print("\nâœ… í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")
    print(f"ìƒì„±ëœ Excel íŒŒì¼: {excel_file}")
    print("ë¡œê·¸ íŒŒì¼ ìœ„ì¹˜: ~/.excel_macro_automation/execution_logs/")
    
    # Cleanup option
    cleanup = input("\nì„ì‹œ íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ")
    if cleanup.lower() == 'y':
        try:
            os.unlink(excel_file)
            print("âœ… ì„ì‹œ íŒŒì¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.")
        except:
            print("âš ï¸  íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨. ìˆ˜ë™ìœ¼ë¡œ ì‚­ì œí•´ì£¼ì„¸ìš”.")


if __name__ == "__main__":
    run_demo_test()
</file>

<file path="test_drag_drop.py">
#!/usr/bin/env python3
"""
Test script to reproduce the drag-and-drop issue
"""

import sys
import os
from pathlib import Path

# Add src to path
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt, QByteArray, QDataStream, QIODevice

def test_drag_drop_data():
    """Test the drag and drop data serialization"""
    try:
        # Create Qt application
        app = QApplication.instance()
        if not app:
            app = QApplication(sys.argv)
        
        # Import after Qt is set up
        from core.macro_types import StepType
        
        # Test serialization like it happens in drag-and-drop
        test_step_type = StepType.IMAGE_SEARCH
        print(f"âœ“ Original step type: {test_step_type}")
        print(f"âœ“ Step type value: {test_step_type.value}")
        
        # Simulate the writeQString process
        byte_array = QByteArray()
        write_stream = QDataStream(byte_array, QIODevice.WriteOnly)
        write_stream.writeQString(test_step_type.value)
        print(f"âœ“ Serialized successfully")
        
        # Simulate the readQString process
        read_stream = QDataStream(byte_array, QIODevice.ReadOnly)
        step_type_str_result = read_stream.readQString()
        print(f"âœ“ Read result: {step_type_str_result}")
        print(f"âœ“ Result type: {type(step_type_str_result)}")
        
        # Apply the fix
        step_type_str = step_type_str_result[0] if isinstance(step_type_str_result, tuple) else step_type_str_result
        print(f"âœ“ Fixed string: {step_type_str}")
        print(f"âœ“ Fixed string type: {type(step_type_str)}")
        
        # Test StepType conversion
        recreated_step_type = StepType(step_type_str)
        print(f"âœ“ Recreated step type: {recreated_step_type}")
        
        # Test step creation
        from core.macro_types import StepFactory
        new_step = StepFactory.create_step(recreated_step_type)
        print(f"âœ“ Created step: {new_step}")
        
        print("âœ“ All drag-and-drop serialization tests passed!")
        
    except Exception as e:
        print(f"âœ— Error during drag-and-drop test: {e}")
        import traceback
        traceback.print_exc()
        
    return True

if __name__ == "__main__":
    test_drag_drop_data()
</file>

<file path="test_easyocr.py">
#!/usr/bin/env python3
"""
Test script to check EasyOCR installation
"""

try:
    import easyocr
    print("âœ“ EasyOCR is installed")
    print(f"âœ“ EasyOCR version: {easyocr.__version__}")
    
    # Test basic initialization
    reader = easyocr.Reader(['en'], gpu=False)
    print("âœ“ EasyOCR Reader initialized successfully")
    
    # Test with dummy image
    import numpy as np
    dummy_img = np.zeros((100, 100, 3), dtype=np.uint8)
    result = reader.readtext(dummy_img)
    print(f"âœ“ EasyOCR test completed. Results: {len(result)} items found")
    
except ImportError as e:
    print("âœ— EasyOCR is not installed")
    print(f"Error: {e}")
    print("\nTo install EasyOCR, run:")
    print("pip install easyocr")
    
except Exception as e:
    print(f"âœ— Error testing EasyOCR: {e}")
    import traceback
    traceback.print_exc()
</file>

<file path="test_if_condition.py">
#!/usr/bin/env python3
"""
Test script for if condition functionality
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src.core.macro_types import (
    IfConditionStep, MouseClickStep, KeyboardTypeStep, 
    WaitTimeStep, StepFactory
)
from src.automation.executor import StepExecutor
from src.config.settings import Settings
import logging

# Setup logging
logging.basicConfig(level=logging.DEBUG)

def test_if_condition():
    """Test if condition step creation and execution"""
    
    # Create settings
    settings = Settings()
    
    # Create executor
    executor = StepExecutor(settings)
    
    # Test 1: Variable comparison condition
    print("\n=== Test 1: Variable comparison ===")
    
    # Set test variables
    executor.set_variables({
        'name': 'í™ê¸¸ë™',
        'age': '25',
        'department': 'ì˜ë£Œì •ë³´íŒ€'
    })
    
    # Create if condition step
    if_step = IfConditionStep()
    if_step.name = "ë‚˜ì´ í™•ì¸"
    if_step.condition_type = "variable_greater"
    if_step.condition_value = {
        'variable': 'age',
        'compare_value': '20'
    }
    
    # Add true branch steps
    true_step = KeyboardTypeStep()
    true_step.name = "ì„±ì¸ ë©”ì‹œì§€"
    true_step.text = "{{name}}ë‹˜ì€ ì„±ì¸ì…ë‹ˆë‹¤."
    if_step.true_steps.append(true_step)
    
    # Add false branch steps
    false_step = KeyboardTypeStep()
    false_step.name = "ë¯¸ì„±ë…„ ë©”ì‹œì§€"
    false_step.text = "{{name}}ë‹˜ì€ ë¯¸ì„±ë…„ìì…ë‹ˆë‹¤."
    if_step.false_steps.append(false_step)
    
    # Execute (dry run - just log)
    print(f"Condition: age ({executor.variables['age']}) > 20")
    result = executor._execute_if_condition(if_step)
    print(f"Result: {result}")
    
    # Test 2: Text contains condition
    print("\n=== Test 2: Text contains ===")
    
    if_step2 = IfConditionStep()
    if_step2.name = "ë¶€ì„œ í™•ì¸"
    if_step2.condition_type = "variable_contains"
    if_step2.condition_value = {
        'variable': 'department',
        'compare_value': 'ì˜ë£Œ'
    }
    
    print(f"Condition: department ({executor.variables['department']}) contains 'ì˜ë£Œ'")
    result2 = executor._execute_if_condition(if_step2)
    print(f"Result: {result2}")
    
    # Test 3: Variable with template substitution
    print("\n=== Test 3: Variable template ===")
    
    executor.set_variables({
        'threshold': '30',
        'current_value': '25'
    })
    
    if_step3 = IfConditionStep()
    if_step3.name = "ì„ê³„ê°’ ë¹„êµ"
    if_step3.condition_type = "variable_less"
    if_step3.condition_value = {
        'variable': 'current_value',
        'compare_value': '{{threshold}}'  # Using variable in comparison
    }
    
    print(f"Condition: current_value ({executor.variables['current_value']}) < threshold ({executor.variables['threshold']})")
    result3 = executor._execute_if_condition(if_step3)
    print(f"Result: {result3}")
    
    # Test 4: Serialization
    print("\n=== Test 4: Serialization ===")
    
    # Convert to dict
    step_dict = if_step.to_dict()
    print(f"Serialized step type: {step_dict['step_type']}")
    print(f"Condition type: {step_dict['condition_type']}")
    print(f"True steps count: {len(step_dict['true_steps'])}")
    print(f"False steps count: {len(step_dict['false_steps'])}")
    
    # Recreate from dict
    recreated_step = StepFactory.from_dict(step_dict)
    print(f"Recreated step name: {recreated_step.name}")
    print(f"Recreated condition type: {recreated_step.condition_type}")
    
    print("\nâœ… All tests completed!")

if __name__ == "__main__":
    test_if_condition()
</file>

<file path="test_logging_system.py">
#!/usr/bin/env python3
"""
Test script for execution logging system
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from pathlib import Path
from logger.execution_logger import ExecutionLogger
from ui.dialogs.log_viewer_dialog import LogViewerDialog
from ui.dialogs.error_report_dialog import ErrorReportDialog
from PyQt5.QtWidgets import QApplication
import time

def test_logging():
    """Test the logging system"""
    print("Testing execution logging system...")
    
    # Create logger
    logger = ExecutionLogger()
    
    # Start session
    log_file = logger.start_session("Test Macro", "test_data.xlsx")
    print(f"Created log file: {log_file}")
    
    # Simulate macro execution
    for row_idx in range(3):
        logger.log_row_start(row_idx, {"Name": f"User{row_idx}", "Email": f"user{row_idx}@test.com"})
        
        # Simulate steps
        for step_idx in range(2):
            step_name = f"Step {step_idx + 1}"
            
            # Simulate success/failure
            if row_idx == 1 and step_idx == 1:
                # Simulate failure
                logger.log_step_execution(
                    row_idx, step_idx, step_name, "click",
                    False, 150.5, "Image not found: button.png"
                )
            else:
                # Success
                logger.log_step_execution(
                    row_idx, step_idx, step_name, "type",
                    True, 50.3
                )
            
            time.sleep(0.1)  # Small delay
        
        # Log row complete
        if row_idx == 1:
            logger.log_row_complete(row_idx, False, 350.8, "Step 2 failed")
        else:
            logger.log_row_complete(row_idx, True, 200.6)
    
    # Log session end
    logger.log_session_end(3, 2, 1)
    
    # Flush and close
    logger.flush()
    logger.close()
    
    print("Logging test completed!")
    return log_file

def test_ui(log_file):
    """Test the UI components"""
    print("\nTesting UI components...")
    
    app = QApplication(sys.argv)
    
    # Test log viewer
    print("Opening log viewer...")
    viewer = LogViewerDialog(log_file)
    viewer.show()
    
    # Test error dialog
    print("Showing error dialog...")
    ErrorReportDialog.show_error(
        "Image not found",
        "Could not find button.png on screen",
        error_details="Failed at step 2 of macro execution\nRow index: 1",
        log_file=log_file,
        parent=viewer
    )
    
    app.exec_()

if __name__ == "__main__":
    # Test logging
    log_file = test_logging()
    
    # Test UI
    test_ui(log_file)
</file>

<file path="test_pyqt.py">
#!/usr/bin/env python3
"""
PyQt5 í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
"""

import sys
import os

print("PyQt5 í…ŒìŠ¤íŠ¸ ì‹œì‘...")

try:
    from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel
    from PyQt5.QtCore import Qt
    print("âœ“ PyQt5 import ì„±ê³µ")
except Exception as e:
    print(f"âœ— PyQt5 import ì‹¤íŒ¨: {e}")
    input("Press Enter to exit...")
    sys.exit(1)

try:
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒì„±
    app = QApplication(sys.argv)
    print("âœ“ QApplication ìƒì„± ì„±ê³µ")
    
    # ê°„ë‹¨í•œ ìœˆë„ìš° ìƒì„±
    window = QMainWindow()
    window.setWindowTitle("PyQt5 Test")
    window.setGeometry(100, 100, 300, 200)
    
    label = QLabel("PyQt5ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤!", window)
    label.setAlignment(Qt.AlignCenter)
    window.setCentralWidget(label)
    
    window.show()
    print("âœ“ ìœˆë„ìš° ìƒì„± ë° í‘œì‹œ ì„±ê³µ")
    
    print("\ní…ŒìŠ¤íŠ¸ ìœˆë„ìš°ê°€ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤. ì°½ì„ ë‹«ìœ¼ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.")
    
    # ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"âœ— PyQt5 í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    import traceback
    traceback.print_exc()
    input("Press Enter to exit...")
    sys.exit(1)
</file>

<file path="test_roi_issue.py">
#!/usr/bin/env python3
"""
Test script to reproduce the ROI selection issue
"""

import sys
import os
from pathlib import Path

# Add src to path
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt

# Fix import paths
def fix_imports():
    import importlib
    import sys
    
    # This ensures the imports work
    from core.macro_types import StepType, StepFactory
    from ui.dialogs.image_step_dialog import ImageSearchStepDialog
    print("âœ“ All imports successful")

def test_roi_issue():
    """Test the ROI selection issue"""
    try:
        # Create Qt application
        app = QApplication.instance()
        if not app:
            app = QApplication(sys.argv)
        
        fix_imports()
        
        # Create a test image search step
        from core.macro_types import StepType, StepFactory
        test_step = StepFactory.create_step(StepType.IMAGE_SEARCH)
        test_step.name = "í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ê²€ìƒ‰"
        
        print(f"âœ“ Created test step: {test_step}")
        print(f"âœ“ Step type: {test_step.step_type}")
        print(f"âœ“ Step ID: {test_step.step_id}")
        
        # Try to create the dialog
        from ui.dialogs.image_step_dialog import ImageSearchStepDialog
        dialog = ImageSearchStepDialog(test_step, parent=None)
        
        print("âœ“ Dialog created successfully")
        print("âœ“ Test passed - no tuple/string errors detected")
        
        # Don't show the dialog, just test creation
        dialog.close()
        
    except Exception as e:
        print(f"âœ— Error during test: {e}")
        import traceback
        traceback.print_exc()
        
    return True

if __name__ == "__main__":
    test_roi_issue()
</file>

<file path="test_simple_if.py">
#!/usr/bin/env python3
"""
Simple test for if condition logic
"""

# Test variable comparison logic
def test_variable_comparison():
    """Test variable comparison operations"""
    
    # Test data
    variables = {
        'name': 'í™ê¸¸ë™',
        'age': '25',
        'score': '85.5',
        'department': 'ì˜ë£Œì •ë³´íŒ€'
    }
    
    print("=== Variable Comparison Tests ===")
    
    # Test equals
    print(f"\nTest: age == '25' -> {variables['age'] == '25'}")
    print(f"Test: age == '30' -> {variables['age'] == '30'}")
    
    # Test contains
    print(f"\nTest: 'ì˜ë£Œ' in department -> {'ì˜ë£Œ' in variables['department']}")
    print(f"Test: 'ì˜ì—…' in department -> {'ì˜ì—…' in variables['department']}")
    
    # Test numeric comparison
    age_val = float(variables['age'])
    print(f"\nTest: age > 20 -> {age_val > 20}")
    print(f"Test: age < 30 -> {age_val < 30}")
    
    # Test variable substitution pattern
    import re
    
    def substitute_variables(text, vars):
        pattern = r'\{\{(\w+)\}\}'
        def replacer(match):
            var_name = match.group(1)
            return str(vars.get(var_name, match.group(0)))
        return re.sub(pattern, replacer, text)
    
    # Test substitution
    text = "{{name}}ë‹˜ì˜ ë‚˜ì´ëŠ” {{age}}ì„¸ì…ë‹ˆë‹¤."
    result = substitute_variables(text, variables)
    print(f"\nTemplate: {text}")
    print(f"Result: {result}")
    
    # Test nested substitution
    variables['threshold'] = '80'
    compare_text = "{{threshold}}"
    compare_value = substitute_variables(compare_text, variables)
    score_val = float(variables['score'])
    threshold_val = float(compare_value)
    
    print(f"\nTest: score ({score_val}) > threshold ({threshold_val}) -> {score_val > threshold_val}")

if __name__ == "__main__":
    test_variable_comparison()
</file>

<file path="usage_tracking2.json">
{
  "user_id": "f6904afa-4a7e-42ad-8e37-34f0262bc38a",
  "first_run": "2025-07-15T22:50:40.701999"
}
</file>

<file path="web_ui_enhanced.py">
#!/usr/bin/env python3
"""
í–¥ìƒëœ ì›¹ UI - ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜ ë° ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸° ê¸°ëŠ¥ í¬í•¨
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
import base64
import tempfile
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List
import io

# Flask ì„¤ì¹˜ í™•ì¸
try:
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS
except ImportError:
    print("í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask", "flask-cors"])
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS

# ì¶”ê°€ íŒ¨í‚¤ì§€ ì„¤ì¹˜ í™•ì¸
try:
    import pyautogui
    import pyperclip
    from PIL import Image, ImageGrab
    import keyboard
    import mouse
except ImportError:
    print("ì¶”ê°€ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "pyautogui", "pyperclip", "pillow", "keyboard", "mouse"])
    import pyautogui
    import pyperclip
    from PIL import Image, ImageGrab
    import keyboard
    import mouse

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# ê¸°ì¡´ ë§¤í¬ë¡œ ëª¨ë“ˆ import ì‹œë„
try:
    from core.macro_types import (
        MacroStep, StepType, MouseClickStep, KeyboardTypeStep,
        WaitTimeStep, ImageSearchStep, TextSearchStep, IfConditionStep,
        ConditionType, ComparisonOperator
    )
    from automation.executor import MacroExecutor
    from excel.excel_manager import ExcelManager
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    MODULES_LOADED = True
except Exception as e:
    print(f"ê²½ê³ : ì¼ë¶€ ëª¨ë“ˆì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
    MODULES_LOADED = False

app = Flask(__name__)
CORS(app)

# ì „ì—­ ìƒíƒœ ê´€ë¦¬
class AppState:
    def __init__(self):
        self.excel_manager = ExcelManager() if MODULES_LOADED else None
        self.macro_steps: List[Dict] = []
        self.executor = None
        self.execution_thread = None
        self.execution_log = []
        self.is_running = False
        self.settings = Settings() if MODULES_LOADED else None
        self.mouse_position = {'x': 0, 'y': 0}
        self.is_tracking_mouse = False
        self.captured_images = {}  # ì´ë¯¸ì§€ ì„ì‹œ ì €ì¥ì†Œ
        
    def add_log(self, message: str, level: str = "info"):
        self.execution_log.append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': level,
            'message': message
        })

app_state = AppState()

# ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  ìŠ¤ë ˆë“œ
def track_mouse_position():
    """ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ê³„ì† ì¶”ì """
    while True:
        if app_state.is_tracking_mouse:
            try:
                x, y = pyautogui.position()
                app_state.mouse_position = {'x': x, 'y': y}
            except:
                pass
        time.sleep(0.1)

# ë§ˆìš°ìŠ¤ ì¶”ì  ìŠ¤ë ˆë“œ ì‹œì‘
mouse_thread = threading.Thread(target=track_mouse_position, daemon=True)
mouse_thread.start()

# HTML í…œí”Œë¦¿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - Enhanced</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #667eea;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        .button.secondary {
            background: #757575;
        }
        .button.success {
            background: #4CAF50;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }
        .step-type-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .macro-step {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .step-config-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .form-group {
            margin: 20px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .mouse-position {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 20px;
            margin: 20px 0;
        }
        .capture-button {
            background: #FF9800;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            margin: 10px;
        }
        .image-preview {
            max-width: 100%;
            max-height: 300px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .paste-area {
            border: 2px dashed #667eea;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s;
        }
        .paste-area:hover {
            background: #f8f9ff;
            border-color: #764ba2;
        }
        .paste-area.dragover {
            background: #e8eaff;
            border-color: #4CAF50;
        }
        .coordinate-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }
        .coord-box {
            background: #f8f9ff;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .hint-text {
            color: #666;
            font-size: 14px;
            margin: 10px 0;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Excel Macro Automation - Enhanced</h1>
            <p>ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜ ë° ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸° ê¸°ëŠ¥ í¬í•¨</p>
            <div class="status-badge">
                ìƒíƒœ: <span id="status">ì¤€ë¹„ë¨</span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">ğŸ“Š Excel</button>
            <button class="tab" onclick="showTab('editor')">âœï¸ Editor</button>
            <button class="tab" onclick="showTab('run')">â–¶ï¸ Run</button>
            <button class="tab" onclick="showTab('tools')">ğŸ› ï¸ Tools</button>
        </div>
        
        <div class="content">
            <!-- Excel íƒ­ -->
            <div id="excel" class="panel active">
                <h2>Excel íŒŒì¼ ê´€ë¦¬</h2>
                <div>
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">ì—…ë¡œë“œ</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor íƒ­ -->
            <div id="editor" class="panel">
                <h2>ë§¤í¬ë¡œ í¸ì§‘ê¸°</h2>
                <div class="step-palette">
                    <div class="step-type-card" onclick="addStep('mouse_click')">
                        <div>ğŸ–±ï¸</div>
                        <div>ë§ˆìš°ìŠ¤ í´ë¦­</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('keyboard_type')">
                        <div>âŒ¨ï¸</div>
                        <div>í…ìŠ¤íŠ¸ ì…ë ¥</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('wait_time')">
                        <div>â±ï¸</div>
                        <div>ëŒ€ê¸°</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('image_search')">
                        <div>ğŸ”</div>
                        <div>ì´ë¯¸ì§€ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('ocr_text')">
                        <div>ğŸ”¤</div>
                        <div>í…ìŠ¤íŠ¸ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('if_condition')">
                        <div>â“</div>
                        <div>ì¡°ê±´ë¬¸</div>
                    </div>
                </div>
                
                <h3>í˜„ì¬ ë§¤í¬ë¡œ</h3>
                <div id="macroSteps"></div>
                
                <button class="button" onclick="saveMacro()">ğŸ’¾ ë§¤í¬ë¡œ ì €ì¥</button>
                <button class="button secondary" onclick="clearMacro()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            </div>
            
            <!-- Run íƒ­ -->
            <div id="run" class="panel">
                <h2>ë§¤í¬ë¡œ ì‹¤í–‰</h2>
                <button class="button" onclick="runMacro()">â–¶ï¸ ì‹¤í–‰</button>
                <button class="button secondary" onclick="stopMacro()">â¹ï¸ ì¤‘ì§€</button>
                
                <h3>ì‹¤í–‰ ë¡œê·¸</h3>
                <div id="executionLog" class="execution-log"></div>
            </div>
            
            <!-- Tools íƒ­ -->
            <div id="tools" class="panel">
                <h2>ìœ ìš©í•œ ë„êµ¬</h2>
                
                <h3>ğŸ¯ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜</h3>
                <div class="mouse-position">
                    <div class="coordinate-display">
                        <div class="coord-box">X: <span id="mouseX">0</span></div>
                        <div class="coord-box">Y: <span id="mouseY">0</span></div>
                    </div>
                    <p class="hint-text">ë§ˆìš°ìŠ¤ë¥¼ ì›€ì§ì—¬ì„œ ì¢Œí‘œë¥¼ í™•ì¸í•˜ì„¸ìš”</p>
                    <button class="capture-button" onclick="toggleMouseTracking()">
                        <span id="trackingText">ğŸ¯ ì¢Œí‘œ ì¶”ì  ì‹œì‘</span>
                    </button>
                    <p class="hint-text" id="captureHint" style="display: none;">
                        F9 í‚¤ë¥¼ ëˆŒëŸ¬ì„œ í˜„ì¬ ì¢Œí‘œë¥¼ ìº¡ì²˜í•˜ì„¸ìš”
                    </p>
                </div>
                
                <h3>ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜</h3>
                <button class="button success" onclick="captureScreen()">
                    ğŸ“· ì „ì²´ í™”ë©´ ìº¡ì²˜
                </button>
                <button class="button success" onclick="captureRegion()">
                    âœ‚ï¸ ì˜ì—­ ì„ íƒ ìº¡ì²˜
                </button>
                
                <h3>ğŸ–¼ï¸ ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸°</h3>
                <div class="paste-area" onclick="document.getElementById('imageUpload').click()" 
                     ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <p>ì´ë¯¸ì§€ë¥¼ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
                    <p>ë˜ëŠ” Ctrl+Vë¡œ í´ë¦½ë³´ë“œì—ì„œ ë¶™ì—¬ë„£ê¸°</p>
                    <input type="file" id="imageUpload" accept="image/*" style="display: none;" onchange="handleFileSelect(event)">
                </div>
                <div id="imagePreview"></div>
            </div>
        </div>
    </div>
    
    <!-- ìŠ¤í… ì„¤ì • ëª¨ë‹¬ -->
    <div id="stepConfigModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">ìŠ¤í… ì„¤ì •</h2>
            <div id="modalBody"></div>
            <button class="button" onclick="saveStepConfig()">ì €ì¥</button>
            <button class="button secondary" onclick="closeModal()">ì·¨ì†Œ</button>
        </div>
    </div>
    
    <script>
        let currentStepIndex = null;
        let isTracking = false;
        let capturedPosition = null;
        
        // íƒ­ ì „í™˜
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        // Excel ì—…ë¡œë“œ
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('excelInfo').innerHTML = 
                    '<p>íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ' + data.filename + '</p>';
            });
        }
        
        // ë§¤í¬ë¡œ ìŠ¤í… ì¶”ê°€
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
                // ì¦‰ì‹œ ì„¤ì • ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
                configureStep(data.index);
            });
        }
        
        // ë§¤í¬ë¡œ ìŠ¤í… ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => `
                    <div class="macro-step">
                        <div>
                            <strong>${i + 1}. ${step.name}</strong>
                            ${step.description ? '<br>' + step.description : ''}
                        </div>
                        <div>
                            <button class="step-config-button" onclick="configureStep(${i})">ì„¤ì •</button>
                            <button class="button secondary" onclick="removeStep(${i})">ì‚­ì œ</button>
                        </div>
                    </div>
                `).join('');
            });
        }
        
        // ìŠ¤í… ì„¤ì •
        function configureStep(index) {
            currentStepIndex = index;
            
            fetch('/get_step_config/' + index)
            .then(response => response.json())
            .then(data => {
                document.getElementById('modalTitle').textContent = data.title;
                document.getElementById('modalBody').innerHTML = data.html;
                document.getElementById('stepConfigModal').style.display = 'block';
                
                // ë§ˆìš°ìŠ¤ í´ë¦­ ìŠ¤í…ì¸ ê²½ìš° ì¢Œí‘œ ìº¡ì²˜ ë²„íŠ¼ ì¶”ê°€
                if (data.step_type === 'mouse_click') {
                    setupMouseCaptureForModal();
                }
            });
        }
        
        // ëª¨ë‹¬ì— ë§ˆìš°ìŠ¤ ìº¡ì²˜ ê¸°ëŠ¥ ì„¤ì •
        function setupMouseCaptureForModal() {
            // ìº¡ì²˜ëœ ì¢Œí‘œê°€ ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ ì…ë ¥
            if (capturedPosition) {
                document.querySelector('input[name="x"]').value = capturedPosition.x;
                document.querySelector('input[name="y"]').value = capturedPosition.y;
            }
        }
        
        // ìŠ¤í… ì„¤ì • ì €ì¥
        function saveStepConfig() {
            const formData = new FormData();
            const inputs = document.querySelectorAll('#modalBody input, #modalBody select, #modalBody textarea');
            
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    formData.append(input.name, input.checked);
                } else if (input.type === 'file' && input.files.length > 0) {
                    formData.append(input.name, input.files[0]);
                } else {
                    formData.append(input.name, input.value);
                }
            });
            
            fetch('/save_step_config/' + currentStepIndex, {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    refreshMacroSteps();
                } else {
                    alert('ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        // ëª¨ë‹¬ ë‹«ê¸°
        function closeModal() {
            document.getElementById('stepConfigModal').style.display = 'none';
        }
        
        // ìŠ¤í… ì œê±°
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        // ë§¤í¬ë¡œ ì €ì¥
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('ë§¤í¬ë¡œê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }
        
        // ë§¤í¬ë¡œ ì´ˆê¸°í™”
        function clearMacro() {
            if (confirm('ëª¨ë“  ë§¤í¬ë¡œ ìŠ¤í…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        // ë§¤í¬ë¡œ ì‹¤í–‰
        function runMacro() {
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('ì‹¤í–‰ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        // ë§¤í¬ë¡œ ì¤‘ì§€
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'});
        }
        
        // ì‹¤í–‰ ë¡œê·¸ ì—…ë°ì´íŠ¸
        function updateExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    '<div class="log-entry ' + entry.level + '">[' + entry.time + '] ' + entry.message + '</div>'
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        // ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì¶”ì 
        function toggleMouseTracking() {
            isTracking = !isTracking;
            
            fetch('/toggle_mouse_tracking', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({tracking: isTracking})
            });
            
            if (isTracking) {
                document.getElementById('trackingText').textContent = 'â¹ï¸ ì¢Œí‘œ ì¶”ì  ì¤‘ì§€';
                document.getElementById('captureHint').style.display = 'block';
                startMousePositionUpdate();
            } else {
                document.getElementById('trackingText').textContent = 'ğŸ¯ ì¢Œí‘œ ì¶”ì  ì‹œì‘';
                document.getElementById('captureHint').style.display = 'none';
            }
        }
        
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        function startMousePositionUpdate() {
            if (isTracking) {
                fetch('/get_mouse_position')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('mouseX').textContent = data.x;
                    document.getElementById('mouseY').textContent = data.y;
                    
                    if (isTracking) {
                        setTimeout(startMousePositionUpdate, 100);
                    }
                });
            }
        }
        
        // ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜
        function captureScreen() {
            fetch('/capture_screen', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('ìŠ¤í¬ë¦°ìƒ·ì´ ìº¡ì²˜ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // ì˜ì—­ ìº¡ì²˜
        function captureRegion() {
            alert('í™”ë©´ì—ì„œ ìº¡ì²˜í•  ì˜ì—­ì„ ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”.');
            fetch('/capture_region', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
        function showImagePreview(imageUrl) {
            const previewDiv = document.getElementById('imagePreview');
            previewDiv.innerHTML = `<img src="${imageUrl}" class="image-preview">`;
        }
        
        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ í•¸ë“¤ëŸ¬
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleImageFile(files[0]);
            }
        }
        
        // íŒŒì¼ ì„ íƒ í•¸ë“¤ëŸ¬
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        }
        
        // ì´ë¯¸ì§€ íŒŒì¼ ì²˜ë¦¬
        function handleImageFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            
            fetch('/upload_image', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showImagePreview(data.image_url);
                }
            });
        }
        
        // í´ë¦½ë³´ë“œ ë¶™ì—¬ë„£ê¸° í•¸ë“¤ëŸ¬
        document.addEventListener('paste', function(e) {
            const items = e.clipboardData.items;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    handleImageFile(blob);
                    e.preventDefault();
                    break;
                }
            }
        });
        
        // F9 í‚¤ë¡œ ì¢Œí‘œ ìº¡ì²˜
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F9' && isTracking) {
                fetch('/capture_mouse_position', {method: 'POST'})
                .then(response => response.json())
                .then(data => {
                    capturedPosition = {x: data.x, y: data.y};
                    alert(`ì¢Œí‘œê°€ ìº¡ì²˜ë˜ì—ˆìŠµë‹ˆë‹¤: X=${data.x}, Y=${data.y}`);
                });
            }
        });
        
        // ì´ˆê¸°í™”
        window.onload = function() {
            refreshMacroSteps();
            setInterval(updateExecutionLog, 1000);
        };
        
        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function(event) {
            if (event.target == document.getElementById('stepConfigModal')) {
                closeModal();
            }
        }
    </script>
</body>
</html>
'''

# API ì—”ë“œí¬ì¸íŠ¸ë“¤
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(tempfile.gettempdir(), file.filename)
        file.save(filepath)
        
        if MODULES_LOADED and app_state.excel_manager:
            app_state.excel_manager.load_file(filepath)
        
        return jsonify({'success': True, 'filename': file.filename})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    
    step_data = {
        'type': step_type,
        'name': get_step_name(step_type),
        'config': get_default_config(step_type)
    }
    
    app_state.macro_steps.append(step_data)
    
    return jsonify({
        'success': True,
        'index': len(app_state.macro_steps) - 1
    })

@app.route('/get_macro')
def get_macro():
    steps_info = []
    for step in app_state.macro_steps:
        step_info = {
            'type': step['type'],
            'name': step['name'],
            'description': get_step_description(step)
        }
        steps_info.append(step_info)
    
    return jsonify({'steps': steps_info})

@app.route('/get_step_config/<int:index>')
def get_step_config(index):
    if index >= len(app_state.macro_steps):
        return jsonify({'title': 'ì˜¤ë¥˜', 'html': '<p>ì˜ëª»ëœ ì¸ë±ìŠ¤</p>'})
    
    step = app_state.macro_steps[index]
    step_type = step['type']
    config = step.get('config', {})
    
    title = f"{step['name']} ì„¤ì •"
    html = generate_config_html(step_type, config)
    
    return jsonify({
        'title': title,
        'html': html,
        'step_type': step_type
    })

@app.route('/save_step_config/<int:index>', methods=['POST'])
def save_step_config(index):
    try:
        if index >= len(app_state.macro_steps):
            return jsonify({'success': False, 'error': 'ì˜ëª»ëœ ì¸ë±ìŠ¤'})
        
        step = app_state.macro_steps[index]
        
        # í¼ ë°ì´í„°ë¥¼ configì— ì €ì¥
        for key, value in request.form.items():
            if value == 'true':
                step['config'][key] = True
            elif value == 'false':
                step['config'][key] = False
            else:
                try:
                    step['config'][key] = float(value)
                except ValueError:
                    step['config'][key] = value
        
        # ì´ë¯¸ì§€ íŒŒì¼ ì²˜ë¦¬
        if 'image' in request.files:
            image_file = request.files['image']
            if image_file.filename:
                image_id = f"step_{index}_{int(time.time())}"
                image_path = save_uploaded_image(image_file, image_id)
                step['config']['image_path'] = image_path
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state.macro_steps):
        app_state.macro_steps.pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state.macro_steps = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state.macro_steps, f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    if not app_state.macro_steps:
        return jsonify({'success': False, 'error': 'ì‹¤í–‰í•  ë§¤í¬ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.'})
    
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œì‘", "info")
    
    # ì‹¤ì œ ì‹¤í–‰ ë¡œì§
    for i, step in enumerate(app_state.macro_steps):
        app_state.add_log(f"ë‹¨ê³„ {i+1}: {step['name']} ì‹¤í–‰", "info")
        
        if step['type'] == 'mouse_click':
            x = int(step['config'].get('x', 0))
            y = int(step['config'].get('y', 0))
            pyautogui.click(x, y)
            app_state.add_log(f"ë§ˆìš°ìŠ¤ í´ë¦­: ({x}, {y})", "success")
            
        elif step['type'] == 'keyboard_type':
            text = step['config'].get('text', '')
            pyautogui.typewrite(text)
            if step['config'].get('press_enter'):
                pyautogui.press('enter')
            app_state.add_log(f"í…ìŠ¤íŠ¸ ì…ë ¥: {text}", "success")
            
        elif step['type'] == 'wait_time':
            seconds = float(step['config'].get('seconds', 1))
            time.sleep(seconds)
            app_state.add_log(f"{seconds}ì´ˆ ëŒ€ê¸°", "success")
        
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ", "success")
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state.is_running = False
    app_state.add_log("ë§¤í¬ë¡œ ì¤‘ì§€ë¨", "warning")
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state.execution_log[-50:]})

# ë§ˆìš°ìŠ¤ ì¶”ì  ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
@app.route('/toggle_mouse_tracking', methods=['POST'])
def toggle_mouse_tracking():
    app_state.is_tracking_mouse = request.json.get('tracking', False)
    return jsonify({'success': True})

@app.route('/get_mouse_position')
def get_mouse_position():
    return jsonify(app_state.mouse_position)

@app.route('/capture_mouse_position', methods=['POST'])
def capture_mouse_position():
    return jsonify(app_state.mouse_position)

# ìŠ¤í¬ë¦°ìƒ· ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
@app.route('/capture_screen', methods=['POST'])
def capture_screen():
    try:
        # ì „ì²´ í™”ë©´ ìº¡ì²˜
        screenshot = ImageGrab.grab()
        
        # ì´ë¯¸ì§€ ì €ì¥
        image_id = f"screenshot_{int(time.time())}"
        image_path = save_screenshot(screenshot, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/capture_region', methods=['POST'])
def capture_region():
    try:
        # ê°„ë‹¨íˆ êµ¬í˜„ - ì‹¤ì œë¡œëŠ” ì˜ì—­ ì„ íƒ UIê°€ í•„ìš”
        app_state.add_log("ì˜ì—­ ìº¡ì²˜ ê¸°ëŠ¥ì€ ì¶”ê°€ êµ¬í˜„ì´ í•„ìš”í•©ë‹ˆë‹¤", "warning")
        
        # ì„ì‹œë¡œ ì „ì²´ í™”ë©´ ìº¡ì²˜
        screenshot = ImageGrab.grab()
        
        image_id = f"region_{int(time.time())}"
        image_path = save_screenshot(screenshot, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/upload_image', methods=['POST'])
def upload_image():
    try:
        image_file = request.files['image']
        image_id = f"upload_{int(time.time())}"
        image_path = save_uploaded_image(image_file, image_id)
        
        return jsonify({
            'success': True,
            'image_url': f'/image/{image_id}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/image/<image_id>')
def get_image(image_id):
    if image_id in app_state.captured_images:
        image_data = app_state.captured_images[image_id]
        return send_file(
            io.BytesIO(image_data),
            mimetype='image/png',
            as_attachment=False
        )
    return '', 404

# í—¬í¼ í•¨ìˆ˜ë“¤
def get_step_name(step_type):
    names = {
        'mouse_click': 'ë§ˆìš°ìŠ¤ í´ë¦­',
        'keyboard_type': 'í…ìŠ¤íŠ¸ ì…ë ¥',
        'wait_time': 'ëŒ€ê¸°',
        'image_search': 'ì´ë¯¸ì§€ ê²€ìƒ‰',
        'ocr_text': 'í…ìŠ¤íŠ¸ ê²€ìƒ‰',
        'if_condition': 'ì¡°ê±´ë¬¸'
    }
    return names.get(step_type, 'ì•Œ ìˆ˜ ì—†ìŒ')

def get_default_config(step_type):
    configs = {
        'mouse_click': {'x': 0, 'y': 0, 'button': 'left', 'click_type': 'single'},
        'keyboard_type': {'text': '', 'press_enter': False},
        'wait_time': {'seconds': 1.0},
        'image_search': {'image_path': '', 'confidence': 0.8},
        'ocr_text': {'search_text': '', 'exact_match': False},
        'if_condition': {'condition_type': 'image_found', 'value': ''}
    }
    return configs.get(step_type, {})

def get_step_description(step):
    config = step.get('config', {})
    step_type = step['type']
    
    if step_type == 'mouse_click':
        return f"({config.get('x', 0)}, {config.get('y', 0)}) í´ë¦­"
    elif step_type == 'keyboard_type':
        text = config.get('text', '')
        return f"'{text[:20]}...' ì…ë ¥" if len(text) > 20 else f"'{text}' ì…ë ¥"
    elif step_type == 'wait_time':
        return f"{config.get('seconds', 1)}ì´ˆ ëŒ€ê¸°"
    elif step_type == 'image_search':
        return "ì´ë¯¸ì§€ ê²€ìƒ‰ í›„ í´ë¦­"
    elif step_type == 'ocr_text':
        return f"'{config.get('search_text', '')}' í…ìŠ¤íŠ¸ ê²€ìƒ‰"
    elif step_type == 'if_condition':
        return f"{config.get('condition_type', '')} ì¡°ê±´"
    
    return ""

def generate_config_html(step_type, config):
    if step_type == 'mouse_click':
        return f'''
        <div class="form-group">
            <label>X ì¢Œí‘œ</label>
            <input type="number" name="x" value="{config.get('x', 0)}" required>
        </div>
        <div class="form-group">
            <label>Y ì¢Œí‘œ</label>
            <input type="number" name="y" value="{config.get('y', 0)}" required>
        </div>
        <div class="form-group" style="background: #f8f9ff; padding: 15px; border-radius: 5px;">
            <p style="text-align: center; color: #667eea; font-weight: bold;">
                ğŸ’¡ íŒ: Tools íƒ­ì—ì„œ ë§ˆìš°ìŠ¤ ì¢Œí‘œë¥¼ ì‰½ê²Œ ìº¡ì²˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!
            </p>
            <p style="text-align: center; margin-top: 10px;">
                1. Tools íƒ­ìœ¼ë¡œ ì´ë™<br>
                2. "ì¢Œí‘œ ì¶”ì  ì‹œì‘" í´ë¦­<br>
                3. ì›í•˜ëŠ” ìœ„ì¹˜ì—ì„œ F9 í‚¤ ëˆ„ë¥´ê¸°
            </p>
        </div>
        <div class="form-group">
            <label>ë§ˆìš°ìŠ¤ ë²„íŠ¼</label>
            <select name="button">
                <option value="left" {'selected' if config.get('button') == 'left' else ''}>ì™¼ìª½</option>
                <option value="right" {'selected' if config.get('button') == 'right' else ''}>ì˜¤ë¥¸ìª½</option>
            </select>
        </div>
        <div class="form-group">
            <label>í´ë¦­ íƒ€ì…</label>
            <select name="click_type">
                <option value="single" {'selected' if config.get('click_type') == 'single' else ''}>ì‹±ê¸€ í´ë¦­</option>
                <option value="double" {'selected' if config.get('click_type') == 'double' else ''}>ë”ë¸” í´ë¦­</option>
            </select>
        </div>
        '''
        
    elif step_type == 'keyboard_type':
        return f'''
        <div class="form-group">
            <label>ì…ë ¥í•  í…ìŠ¤íŠ¸</label>
            <textarea name="text" rows="3">{config.get('text', '')}</textarea>
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="press_enter" value="true" {'checked' if config.get('press_enter') else ''}>
                ì…ë ¥ í›„ Enter í‚¤ ëˆ„ë¥´ê¸°
            </label>
        </div>
        '''
        
    elif step_type == 'wait_time':
        return f'''
        <div class="form-group">
            <label>ëŒ€ê¸° ì‹œê°„ (ì´ˆ)</label>
            <input type="number" name="seconds" value="{config.get('seconds', 1.0)}" step="0.1" min="0.1" required>
        </div>
        '''
        
    elif step_type == 'image_search':
        return f'''
        <div class="form-group">
            <label>ê²€ìƒ‰í•  ì´ë¯¸ì§€</label>
            <input type="file" name="image" accept="image/*">
            <p style="margin-top: 10px; color: #666;">
                ğŸ’¡ íŒ: Tools íƒ­ì—ì„œ ìŠ¤í¬ë¦°ìƒ·ì„ ìº¡ì²˜í•˜ê±°ë‚˜ í´ë¦½ë³´ë“œì—ì„œ ì´ë¯¸ì§€ë¥¼ ë¶™ì—¬ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!
            </p>
        </div>
        <div class="form-group">
            <label>ìœ ì‚¬ë„ (0.0 ~ 1.0)</label>
            <input type="number" name="confidence" value="{config.get('confidence', 0.8)}" step="0.1" min="0" max="1" required>
        </div>
        '''
        
    elif step_type == 'ocr_text':
        return f'''
        <div class="form-group">
            <label>ê²€ìƒ‰í•  í…ìŠ¤íŠ¸</label>
            <input type="text" name="search_text" value="{config.get('search_text', '')}">
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="exact_match" value="true" {'checked' if config.get('exact_match') else ''}>
                ì •í™•íˆ ì¼ì¹˜
            </label>
        </div>
        '''
        
    elif step_type == 'if_condition':
        return f'''
        <div class="form-group">
            <label>ì¡°ê±´ íƒ€ì…</label>
            <select name="condition_type">
                <option value="image_found" {'selected' if config.get('condition_type') == 'image_found' else ''}>ì´ë¯¸ì§€ ë°œê²¬</option>
                <option value="text_found" {'selected' if config.get('condition_type') == 'text_found' else ''}>í…ìŠ¤íŠ¸ ë°œê²¬</option>
                <option value="excel_value" {'selected' if config.get('condition_type') == 'excel_value' else ''}>Excel ê°’</option>
            </select>
        </div>
        <div class="form-group">
            <label>ë¹„êµ ê°’</label>
            <input type="text" name="value" value="{config.get('value', '')}">
        </div>
        '''
    
    return '<p>ì„¤ì •ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>'

def save_screenshot(image, image_id):
    # ë©”ëª¨ë¦¬ì— ì €ì¥
    buffer = io.BytesIO()
    image.save(buffer, format='PNG')
    app_state.captured_images[image_id] = buffer.getvalue()
    return image_id

def save_uploaded_image(image_file, image_id):
    # ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë¥¼ ë©”ëª¨ë¦¬ì— ì €ì¥
    image_data = image_file.read()
    app_state.captured_images[image_id] = image_data
    return image_id

# ë©”ì¸ ì‹¤í–‰
if __name__ == '__main__':
    # pyautogui ì•ˆì „ ì„¤ì •
    pyautogui.FAILSAFE = True
    pyautogui.PAUSE = 0.1
    
    print("=" * 60)
    print("Excel Macro Automation - Enhanced Version")
    print("=" * 60)
    print("\nâœ¨ ìƒˆë¡œìš´ ê¸°ëŠ¥:")
    print("- ğŸ¯ ì‹¤ì‹œê°„ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì¶”ì ")
    print("- ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜ ë° ì €ì¥")
    print("- ğŸ–¼ï¸ ì´ë¯¸ì§€ ë“œë˜ê·¸ ì•¤ ë“œë¡­ / í´ë¦½ë³´ë“œ ë¶™ì—¬ë„£ê¸°")
    print("- âŒ¨ï¸ F9 í‚¤ë¡œ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ìº¡ì²˜")
    print("- ğŸ–¥ï¸ ë©€í‹° ëª¨ë‹ˆí„° ì§€ì›")
    print("\në¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤...")
    print("ìˆ˜ë™ìœ¼ë¡œ ì—´ë ¤ë©´: http://localhost:5558")
    print("\nì¢…ë£Œí•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.")
    print("=" * 60)
    
    # ë¸Œë¼ìš°ì € ìë™ ì—´ê¸°
    def open_browser():
        time.sleep(1.5)
        webbrowser.open('http://localhost:5558')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask ì•± ì‹¤í–‰
    app.run(host='0.0.0.0', port=5558, debug=False)
</file>

<file path="web_ui_integrated_working.py">
#!/usr/bin/env python3
"""
ì›¹ UIì™€ ê¸°ì¡´ ë§¤í¬ë¡œ ê¸°ëŠ¥ì„ í†µí•©í•œ ì‹¤í–‰ ê°€ëŠ¥í•œ ë²„ì „
ë§¤í¬ë¡œ ìŠ¤í… ì„¤ì • ê¸°ëŠ¥ì´ í¬í•¨ëœ ì™„ì „í•œ ì›¹ ì¸í„°í˜ì´ìŠ¤
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
import base64
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

# Flask ì„¤ì¹˜ í™•ì¸
try:
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS
except ImportError:
    print("í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask", "flask-cors"])
    from flask import Flask, render_template_string, jsonify, request, send_file
    from flask_cors import CORS

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# ê¸°ì¡´ ë§¤í¬ë¡œ ëª¨ë“ˆ import
try:
    from core.macro_types import (
        MacroStep, StepType, MouseClickStep, KeyboardTypeStep,
        WaitTimeStep, ImageSearchStep, TextSearchStep, IfConditionStep,
        ConditionType, ComparisonOperator
    )
    from automation.executor import MacroExecutor
    from excel.excel_manager import ExcelManager
    from config.settings import Settings
    from logger.app_logger import setup_logger
    from vision.image_matcher import ImageMatcher
    from vision.text_extractor import TextExtractor
    
    MODULES_LOADED = True
except Exception as e:
    print(f"ê²½ê³ : ì¼ë¶€ ëª¨ë“ˆì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
    MODULES_LOADED = False

app = Flask(__name__)
CORS(app)

# ë¡œê±° ì„¤ì •
logger = setup_logger() if MODULES_LOADED else None

# ì „ì—­ ìƒíƒœ ê´€ë¦¬
class AppState:
    def __init__(self):
        self.excel_manager = ExcelManager() if MODULES_LOADED else None
        self.macro_steps: List[Dict] = []  # ë‹¨ìˆœí™”ëœ ìŠ¤í… ì €ì¥
        self.executor = None
        self.execution_thread = None
        self.execution_log = []
        self.is_running = False
        self.settings = Settings() if MODULES_LOADED else None
        
    def add_log(self, message: str, level: str = "info"):
        self.execution_log.append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': level,
            'message': message
        })
        if logger:
            getattr(logger, level)(message)

app_state = AppState()

# HTML í…œí”Œë¦¿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - í†µí•© ì›¹ UI</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #667eea;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        .button.secondary {
            background: #757575;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }
        .step-type-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .macro-step {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .step-config-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
        }
        .form-group {
            margin: 20px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .execution-log {
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .log-entry {
            padding: 5px 0;
        }
        .log-entry.error {
            color: #ff5252;
        }
        .log-entry.success {
            color: #69f0ae;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Excel Macro Automation</h1>
            <p>ì™„ì „í•œ ë§¤í¬ë¡œ ìë™í™” ì‹œìŠ¤í…œ (ìŠ¤í… ì„¤ì • ê¸°ëŠ¥ í¬í•¨)</p>
            <div class="status-badge">
                ìƒíƒœ: <span id="status">ì¤€ë¹„ë¨</span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">ğŸ“Š Excel</button>
            <button class="tab" onclick="showTab('editor')">âœï¸ Editor</button>
            <button class="tab" onclick="showTab('run')">â–¶ï¸ Run</button>
        </div>
        
        <div class="content">
            <!-- Excel íƒ­ -->
            <div id="excel" class="panel active">
                <h2>Excel íŒŒì¼ ê´€ë¦¬</h2>
                <div>
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">ì—…ë¡œë“œ</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor íƒ­ -->
            <div id="editor" class="panel">
                <h2>ë§¤í¬ë¡œ í¸ì§‘ê¸°</h2>
                <div class="step-palette">
                    <div class="step-type-card" onclick="addStep('mouse_click')">
                        <div>ğŸ–±ï¸</div>
                        <div>ë§ˆìš°ìŠ¤ í´ë¦­</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('keyboard_type')">
                        <div>âŒ¨ï¸</div>
                        <div>í…ìŠ¤íŠ¸ ì…ë ¥</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('wait_time')">
                        <div>â±ï¸</div>
                        <div>ëŒ€ê¸°</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('image_search')">
                        <div>ğŸ”</div>
                        <div>ì´ë¯¸ì§€ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('ocr_text')">
                        <div>ğŸ”¤</div>
                        <div>í…ìŠ¤íŠ¸ ê²€ìƒ‰</div>
                    </div>
                    <div class="step-type-card" onclick="addStep('if_condition')">
                        <div>â“</div>
                        <div>ì¡°ê±´ë¬¸</div>
                    </div>
                </div>
                
                <h3>í˜„ì¬ ë§¤í¬ë¡œ</h3>
                <div id="macroSteps"></div>
                
                <button class="button" onclick="saveMacro()">ğŸ’¾ ë§¤í¬ë¡œ ì €ì¥</button>
                <button class="button secondary" onclick="clearMacro()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            </div>
            
            <!-- Run íƒ­ -->
            <div id="run" class="panel">
                <h2>ë§¤í¬ë¡œ ì‹¤í–‰</h2>
                <button class="button" onclick="runMacro()">â–¶ï¸ ì‹¤í–‰</button>
                <button class="button secondary" onclick="stopMacro()">â¹ï¸ ì¤‘ì§€</button>
                
                <h3>ì‹¤í–‰ ë¡œê·¸</h3>
                <div id="executionLog" class="execution-log"></div>
            </div>
        </div>
    </div>
    
    <!-- ìŠ¤í… ì„¤ì • ëª¨ë‹¬ -->
    <div id="stepConfigModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">ìŠ¤í… ì„¤ì •</h2>
            <div id="modalBody"></div>
            <button class="button" onclick="saveStepConfig()">ì €ì¥</button>
            <button class="button secondary" onclick="closeModal()">ì·¨ì†Œ</button>
        </div>
    </div>
    
    <script>
        let currentStepIndex = null;
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('excelInfo').innerHTML = 
                    '<p>íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ' + data.filename + '</p>';
            });
        }
        
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
                // ì¦‰ì‹œ ì„¤ì • ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
                configureStep(data.index);
            });
        }
        
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => `
                    <div class="macro-step">
                        <div>
                            <strong>${i + 1}. ${step.name}</strong>
                            ${step.description ? '<br>' + step.description : ''}
                        </div>
                        <div>
                            <button class="step-config-button" onclick="configureStep(${i})">ì„¤ì •</button>
                            <button class="button secondary" onclick="removeStep(${i})">ì‚­ì œ</button>
                        </div>
                    </div>
                `).join('');
            });
        }
        
        function configureStep(index) {
            currentStepIndex = index;
            
            fetch('/get_step_config/' + index)
            .then(response => response.json())
            .then(data => {
                document.getElementById('modalTitle').textContent = data.title;
                document.getElementById('modalBody').innerHTML = data.html;
                document.getElementById('stepConfigModal').style.display = 'block';
            });
        }
        
        function saveStepConfig() {
            const formData = new FormData();
            const inputs = document.querySelectorAll('#modalBody input, #modalBody select, #modalBody textarea');
            
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    formData.append(input.name, input.checked);
                } else {
                    formData.append(input.name, input.value);
                }
            });
            
            fetch('/save_step_config/' + currentStepIndex, {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    refreshMacroSteps();
                } else {
                    alert('ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        function closeModal() {
            document.getElementById('stepConfigModal').style.display = 'none';
        }
        
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('ë§¤í¬ë¡œê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }
        
        function clearMacro() {
            if (confirm('ëª¨ë“  ë§¤í¬ë¡œ ìŠ¤í…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        function runMacro() {
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('ì‹¤í–‰ ì‹¤íŒ¨: ' + data.error);
                }
            });
        }
        
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'});
        }
        
        function updateExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    '<div class="log-entry ' + entry.level + '">[' + entry.time + '] ' + entry.message + '</div>'
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        // ì´ˆê¸°í™”
        window.onload = function() {
            refreshMacroSteps();
            setInterval(updateExecutionLog, 1000);
        };
        
        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function(event) {
            if (event.target == document.getElementById('stepConfigModal')) {
                closeModal();
            }
        }
    </script>
</body>
</html>
'''

# API ì—”ë“œí¬ì¸íŠ¸ë“¤
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(tempfile.gettempdir(), file.filename)
        file.save(filepath)
        
        if MODULES_LOADED and app_state.excel_manager:
            app_state.excel_manager.load_file(filepath)
        
        return jsonify({'success': True, 'filename': file.filename})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    
    # ê¸°ë³¸ê°’ìœ¼ë¡œ ìŠ¤í… ì¶”ê°€
    step_data = {
        'type': step_type,
        'name': get_step_name(step_type),
        'config': get_default_config(step_type)
    }
    
    app_state.macro_steps.append(step_data)
    
    return jsonify({
        'success': True,
        'index': len(app_state.macro_steps) - 1
    })

@app.route('/get_macro')
def get_macro():
    steps_info = []
    for step in app_state.macro_steps:
        step_info = {
            'type': step['type'],
            'name': step['name'],
            'description': get_step_description(step)
        }
        steps_info.append(step_info)
    
    return jsonify({'steps': steps_info})

@app.route('/get_step_config/<int:index>')
def get_step_config(index):
    if index >= len(app_state.macro_steps):
        return jsonify({'title': 'ì˜¤ë¥˜', 'html': '<p>ì˜ëª»ëœ ì¸ë±ìŠ¤</p>'})
    
    step = app_state.macro_steps[index]
    step_type = step['type']
    config = step.get('config', {})
    
    title = f"{step['name']} ì„¤ì •"
    html = generate_config_html(step_type, config)
    
    return jsonify({'title': title, 'html': html})

@app.route('/save_step_config/<int:index>', methods=['POST'])
def save_step_config(index):
    try:
        if index >= len(app_state.macro_steps):
            return jsonify({'success': False, 'error': 'ì˜ëª»ëœ ì¸ë±ìŠ¤'})
        
        step = app_state.macro_steps[index]
        
        # í¼ ë°ì´í„°ë¥¼ configì— ì €ì¥
        for key, value in request.form.items():
            if value == 'true':
                step['config'][key] = True
            elif value == 'false':
                step['config'][key] = False
            else:
                try:
                    step['config'][key] = float(value)
                except ValueError:
                    step['config'][key] = value
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state.macro_steps):
        app_state.macro_steps.pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state.macro_steps = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state.macro_steps, f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    if not app_state.macro_steps:
        return jsonify({'success': False, 'error': 'ì‹¤í–‰í•  ë§¤í¬ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.'})
    
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œì‘", "info")
    
    # ì‹¤ì œ ì‹¤í–‰ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
    for i, step in enumerate(app_state.macro_steps):
        app_state.add_log(f"ë‹¨ê³„ {i+1}: {step['name']} ì‹¤í–‰", "info")
        # ì‹¤ì œ ì‹¤í–‰ ì½”ë“œ...
        
    app_state.add_log("ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ", "success")
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state.is_running = False
    app_state.add_log("ë§¤í¬ë¡œ ì¤‘ì§€ë¨", "warning")
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state.execution_log[-50:]})

# í—¬í¼ í•¨ìˆ˜ë“¤
def get_step_name(step_type):
    names = {
        'mouse_click': 'ë§ˆìš°ìŠ¤ í´ë¦­',
        'keyboard_type': 'í…ìŠ¤íŠ¸ ì…ë ¥',
        'wait_time': 'ëŒ€ê¸°',
        'image_search': 'ì´ë¯¸ì§€ ê²€ìƒ‰',
        'ocr_text': 'í…ìŠ¤íŠ¸ ê²€ìƒ‰',
        'if_condition': 'ì¡°ê±´ë¬¸'
    }
    return names.get(step_type, 'ì•Œ ìˆ˜ ì—†ìŒ')

def get_default_config(step_type):
    configs = {
        'mouse_click': {'x': 0, 'y': 0, 'button': 'left', 'click_type': 'single'},
        'keyboard_type': {'text': '', 'press_enter': False},
        'wait_time': {'seconds': 1.0},
        'image_search': {'image_path': '', 'confidence': 0.8},
        'ocr_text': {'search_text': '', 'exact_match': False},
        'if_condition': {'condition_type': 'image_found', 'value': ''}
    }
    return configs.get(step_type, {})

def get_step_description(step):
    config = step.get('config', {})
    step_type = step['type']
    
    if step_type == 'mouse_click':
        return f"({config.get('x', 0)}, {config.get('y', 0)}) í´ë¦­"
    elif step_type == 'keyboard_type':
        text = config.get('text', '')
        return f"'{text[:20]}...' ì…ë ¥" if len(text) > 20 else f"'{text}' ì…ë ¥"
    elif step_type == 'wait_time':
        return f"{config.get('seconds', 1)}ì´ˆ ëŒ€ê¸°"
    elif step_type == 'image_search':
        return "ì´ë¯¸ì§€ ê²€ìƒ‰ í›„ í´ë¦­"
    elif step_type == 'ocr_text':
        return f"'{config.get('search_text', '')}' í…ìŠ¤íŠ¸ ê²€ìƒ‰"
    elif step_type == 'if_condition':
        return f"{config.get('condition_type', '')} ì¡°ê±´"
    
    return ""

def generate_config_html(step_type, config):
    if step_type == 'mouse_click':
        return f'''
        <div class="form-group">
            <label>X ì¢Œí‘œ</label>
            <input type="number" name="x" value="{config.get('x', 0)}" required>
        </div>
        <div class="form-group">
            <label>Y ì¢Œí‘œ</label>
            <input type="number" name="y" value="{config.get('y', 0)}" required>
        </div>
        <div class="form-group">
            <label>ë§ˆìš°ìŠ¤ ë²„íŠ¼</label>
            <select name="button">
                <option value="left" {'selected' if config.get('button') == 'left' else ''}>ì™¼ìª½</option>
                <option value="right" {'selected' if config.get('button') == 'right' else ''}>ì˜¤ë¥¸ìª½</option>
            </select>
        </div>
        <div class="form-group">
            <label>í´ë¦­ íƒ€ì…</label>
            <select name="click_type">
                <option value="single" {'selected' if config.get('click_type') == 'single' else ''}>ì‹±ê¸€ í´ë¦­</option>
                <option value="double" {'selected' if config.get('click_type') == 'double' else ''}>ë”ë¸” í´ë¦­</option>
            </select>
        </div>
        '''
        
    elif step_type == 'keyboard_type':
        return f'''
        <div class="form-group">
            <label>ì…ë ¥í•  í…ìŠ¤íŠ¸</label>
            <textarea name="text" rows="3">{config.get('text', '')}</textarea>
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="press_enter" value="true" {'checked' if config.get('press_enter') else ''}>
                ì…ë ¥ í›„ Enter í‚¤ ëˆ„ë¥´ê¸°
            </label>
        </div>
        '''
        
    elif step_type == 'wait_time':
        return f'''
        <div class="form-group">
            <label>ëŒ€ê¸° ì‹œê°„ (ì´ˆ)</label>
            <input type="number" name="seconds" value="{config.get('seconds', 1.0)}" step="0.1" min="0.1" required>
        </div>
        '''
        
    elif step_type == 'image_search':
        return f'''
        <div class="form-group">
            <label>ì´ë¯¸ì§€ ê²½ë¡œ</label>
            <input type="text" name="image_path" value="{config.get('image_path', '')}" placeholder="ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ">
        </div>
        <div class="form-group">
            <label>ìœ ì‚¬ë„ (0.0 ~ 1.0)</label>
            <input type="number" name="confidence" value="{config.get('confidence', 0.8)}" step="0.1" min="0" max="1" required>
        </div>
        '''
        
    elif step_type == 'ocr_text':
        return f'''
        <div class="form-group">
            <label>ê²€ìƒ‰í•  í…ìŠ¤íŠ¸</label>
            <input type="text" name="search_text" value="{config.get('search_text', '')}">
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" name="exact_match" value="true" {'checked' if config.get('exact_match') else ''}>
                ì •í™•íˆ ì¼ì¹˜
            </label>
        </div>
        '''
        
    elif step_type == 'if_condition':
        return f'''
        <div class="form-group">
            <label>ì¡°ê±´ íƒ€ì…</label>
            <select name="condition_type">
                <option value="image_found" {'selected' if config.get('condition_type') == 'image_found' else ''}>ì´ë¯¸ì§€ ë°œê²¬</option>
                <option value="text_found" {'selected' if config.get('condition_type') == 'text_found' else ''}>í…ìŠ¤íŠ¸ ë°œê²¬</option>
                <option value="excel_value" {'selected' if config.get('condition_type') == 'excel_value' else ''}>Excel ê°’</option>
            </select>
        </div>
        <div class="form-group">
            <label>ë¹„êµ ê°’</label>
            <input type="text" name="value" value="{config.get('value', '')}">
        </div>
        '''
    
    return '<p>ì„¤ì •ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>'

# ë©”ì¸ ì‹¤í–‰
if __name__ == '__main__':
    print("=" * 60)
    print("Excel Macro Automation - í†µí•© ì›¹ UI (ë™ì‘ ë²„ì „)")
    print("=" * 60)
    print("\nâœ… ë§¤í¬ë¡œ ìŠ¤í… ì„¤ì • ê¸°ëŠ¥ì´ ì™„ì „íˆ êµ¬í˜„ëœ ë²„ì „ì…ë‹ˆë‹¤.")
    print("\nê¸°ëŠ¥:")
    print("- ê° ìŠ¤í…ë³„ ìƒì„¸ ì„¤ì • ê°€ëŠ¥")
    print("- ë§ˆìš°ìŠ¤ í´ë¦­: ì¢Œí‘œ, ë²„íŠ¼, í´ë¦­ íƒ€ì…")
    print("- í…ìŠ¤íŠ¸ ì…ë ¥: í…ìŠ¤íŠ¸ ë‚´ìš©, Enter í‚¤")
    print("- ëŒ€ê¸°: ëŒ€ê¸° ì‹œê°„")
    print("- ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ê²€ìƒ‰: ê²€ìƒ‰ ì¡°ê±´")
    print("- ì¡°ê±´ë¬¸: ì¡°ê±´ íƒ€ì…, ë¹„êµê°’")
    print("\në¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤...")
    print("ìˆ˜ë™ìœ¼ë¡œ ì—´ë ¤ë©´: http://localhost:5557")
    print("\nì¢…ë£Œí•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.")
    print("=" * 60)
    
    # ë¸Œë¼ìš°ì € ìë™ ì—´ê¸°
    def open_browser():
        import time
        time.sleep(1.5)
        webbrowser.open('http://localhost:5557')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask ì•± ì‹¤í–‰
    app.run(host='0.0.0.0', port=5557, debug=False)
</file>

<file path="web_ui_launcher.py">
#!/usr/bin/env python3
"""
WSL GUI ë¬¸ì œë¥¼ ìš°íšŒí•˜ëŠ” ì›¹ ê¸°ë°˜ UI ëŸ°ì²˜
ë¸Œë¼ìš°ì €ë¥¼ í†µí•´ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì œì–´í•©ë‹ˆë‹¤.
"""

import os
import sys
import json
import threading
import webbrowser
import subprocess
from pathlib import Path
from datetime import datetime

# Flask ì„¤ì¹˜ í™•ì¸
try:
    from flask import Flask, render_template_string, jsonify, request
except ImportError:
    print("Flask ì„¤ì¹˜ ì¤‘...")
    subprocess.run([sys.executable, "-m", "pip", "install", "flask"])
    from flask import Flask, render_template_string, jsonify, request

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

app = Flask(__name__)

# ì „ì—­ ìƒíƒœ ê´€ë¦¬
app_state = {
    "status": "ready",
    "excel_file": None,
    "macro_steps": [],
    "execution_log": []
}

# HTML í…œí”Œë¦¿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>Excel Macro Automation - Web UI</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5; 
            color: #333;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .header h1 {
            color: #2196F3;
            margin-bottom: 10px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #2196F3;
            color: white;
        }
        .tab:hover {
            background: #1976D2;
            color: white;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 400px;
        }
        .panel {
            display: none;
        }
        .panel.active {
            display: block;
        }
        .button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }
        .button:hover {
            background: #45a049;
        }
        .button.secondary {
            background: #757575;
        }
        .button.secondary:hover {
            background: #616161;
        }
        .file-input {
            margin: 20px 0;
        }
        .status-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .macro-step {
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .log-entry {
            padding: 5px 10px;
            margin: 2px 0;
            background: #f9f9f9;
            border-radius: 3px;
            font-family: monospace;
            font-size: 14px;
        }
        .log-entry.error {
            background: #ffebee;
            color: #c62828;
        }
        .log-entry.success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .step-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .step-type {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .step-type:hover {
            background: #2196F3;
            color: white;
            transform: translateY(-2px);
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Excel Macro Automation</h1>
            <p>WSL GUI ë¬¸ì œë¥¼ ìš°íšŒí•˜ëŠ” ì›¹ ê¸°ë°˜ ì»¨íŠ¸ë¡¤ íŒ¨ë„</p>
            <div class="status-box">
                ìƒíƒœ: <span id="status">ì¤€ë¹„ë¨</span>
                <span id="loading" class="loading" style="display: none;"></span>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('excel')">ğŸ“Š Excel</button>
            <button class="tab" onclick="showTab('editor')">âœï¸ Editor</button>
            <button class="tab" onclick="showTab('run')">â–¶ï¸ Run</button>
            <button class="tab" onclick="showTab('native')">ğŸ–¥ï¸ Native GUI</button>
        </div>
        
        <div class="content">
            <!-- Excel íƒ­ -->
            <div id="excel" class="panel active">
                <h2>Excel íŒŒì¼ ê´€ë¦¬</h2>
                <div class="file-input">
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                    <button class="button" onclick="uploadExcel()">ì—…ë¡œë“œ</button>
                </div>
                <div id="excelInfo"></div>
            </div>
            
            <!-- Editor íƒ­ -->
            <div id="editor" class="panel">
                <h2>ë§¤í¬ë¡œ í¸ì§‘ê¸°</h2>
                <div class="step-palette">
                    <div class="step-type" onclick="addStep('mouse_click')">ğŸ–±ï¸ ë§ˆìš°ìŠ¤ í´ë¦­</div>
                    <div class="step-type" onclick="addStep('keyboard_type')">âŒ¨ï¸ í…ìŠ¤íŠ¸ ì…ë ¥</div>
                    <div class="step-type" onclick="addStep('wait_time')">â±ï¸ ëŒ€ê¸°</div>
                    <div class="step-type" onclick="addStep('image_search')">ğŸ” ì´ë¯¸ì§€ ê²€ìƒ‰</div>
                    <div class="step-type" onclick="addStep('ocr_text')">ğŸ”¤ í…ìŠ¤íŠ¸ ê²€ìƒ‰</div>
                    <div class="step-type" onclick="addStep('if_condition')">â“ ì¡°ê±´ë¬¸</div>
                </div>
                <h3>í˜„ì¬ ë§¤í¬ë¡œ</h3>
                <div id="macroSteps"></div>
                <button class="button" onclick="saveMacro()">ë§¤í¬ë¡œ ì €ì¥</button>
                <button class="button secondary" onclick="clearMacro()">ì´ˆê¸°í™”</button>
            </div>
            
            <!-- Run íƒ­ -->
            <div id="run" class="panel">
                <h2>ë§¤í¬ë¡œ ì‹¤í–‰</h2>
                <button class="button" onclick="runMacro()">â–¶ï¸ ì‹¤í–‰</button>
                <button class="button secondary" onclick="stopMacro()">â¹ï¸ ì¤‘ì§€</button>
                <h3>ì‹¤í–‰ ë¡œê·¸</h3>
                <div id="executionLog"></div>
            </div>
            
            <!-- Native GUI íƒ­ -->
            <div id="native" class="panel">
                <h2>ë„¤ì´í‹°ë¸Œ GUI ì‹¤í–‰ ì˜µì…˜</h2>
                <p>ì›¹ UI ëŒ€ì‹  ì›ë˜ GUIë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ ì•„ë˜ ì˜µì…˜ì„ ì‹œë„í•˜ì„¸ìš”:</p>
                
                <div style="margin: 20px 0;">
                    <h3>ì˜µì…˜ 1: X Server í™•ì¸ í›„ ì‹¤í–‰</h3>
                    <button class="button" onclick="runNative('check')">X Server ì²´í¬ & ì‹¤í–‰</button>
                    
                    <h3>ì˜µì…˜ 2: ê°€ìƒ ë””ìŠ¤í”Œë ˆì´ (Xvfb)</h3>
                    <button class="button" onclick="runNative('xvfb')">Xvfbë¡œ ì‹¤í–‰</button>
                    
                    <h3>ì˜µì…˜ 3: Windowsì—ì„œ ì§ì ‘ ì‹¤í–‰</h3>
                    <button class="button" onclick="runNative('windows')">Windows ìŠ¤í¬ë¦½íŠ¸ ìƒì„±</button>
                    
                    <h3>ì˜µì…˜ 4: ë””ë²„ê·¸ ëª¨ë“œ</h3>
                    <button class="button" onclick="runNative('debug')">ë””ë²„ê·¸ ì •ë³´ ë³´ê¸°</button>
                </div>
                
                <div id="nativeOutput" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>
    
    <script>
        let currentTab = 'excel';
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            currentTab = tabName;
        }
        
        function updateStatus(status, loading = false) {
            document.getElementById('status').textContent = status;
            document.getElementById('loading').style.display = loading ? 'inline-block' : 'none';
        }
        
        function uploadExcel() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            updateStatus('Excel íŒŒì¼ ì—…ë¡œë“œ ì¤‘...', true);
            
            fetch('/upload_excel', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                updateStatus('Excel íŒŒì¼ ë¡œë“œ ì™„ë£Œ');
                document.getElementById('excelInfo').innerHTML = 
                    `<p>íŒŒì¼ëª…: ${data.filename}</p>
                     <p>ì‹œíŠ¸: ${data.sheets.join(', ')}</p>
                     <p>í–‰ ìˆ˜: ${data.rows}</p>`;
            })
            .catch(error => {
                updateStatus('ì˜¤ë¥˜ ë°œìƒ');
                alert('ì˜¤ë¥˜: ' + error);
            });
        }
        
        function addStep(stepType) {
            fetch('/add_step', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({step_type: stepType})
            })
            .then(response => response.json())
            .then(data => {
                refreshMacroSteps();
            });
        }
        
        function refreshMacroSteps() {
            fetch('/get_macro')
            .then(response => response.json())
            .then(data => {
                const stepsDiv = document.getElementById('macroSteps');
                stepsDiv.innerHTML = data.steps.map((step, i) => 
                    `<div class="macro-step">
                        ${i + 1}. ${step.name} (${step.type})
                        <button onclick="removeStep(${i})" style="float: right;">ì‚­ì œ</button>
                    </div>`
                ).join('');
            });
        }
        
        function removeStep(index) {
            fetch('/remove_step/' + index, {method: 'DELETE'})
            .then(() => refreshMacroSteps());
        }
        
        function saveMacro() {
            fetch('/save_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                alert('ë§¤í¬ë¡œ ì €ì¥ ì™„ë£Œ!');
            });
        }
        
        function clearMacro() {
            if (confirm('ë§¤í¬ë¡œë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                fetch('/clear_macro', {method: 'POST'})
                .then(() => refreshMacroSteps());
            }
        }
        
        function runMacro() {
            updateStatus('ë§¤í¬ë¡œ ì‹¤í–‰ ì¤‘...', true);
            fetch('/run_macro', {method: 'POST'})
            .then(response => response.json())
            .then(data => {
                updateStatus('ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ');
                refreshExecutionLog();
            });
        }
        
        function stopMacro() {
            fetch('/stop_macro', {method: 'POST'})
            .then(() => {
                updateStatus('ë§¤í¬ë¡œ ì¤‘ì§€ë¨');
            });
        }
        
        function refreshExecutionLog() {
            fetch('/get_log')
            .then(response => response.json())
            .then(data => {
                const logDiv = document.getElementById('executionLog');
                logDiv.innerHTML = data.log.map(entry => 
                    `<div class="log-entry ${entry.level}">[${entry.time}] ${entry.message}</div>`
                ).join('');
                logDiv.scrollTop = logDiv.scrollHeight;
            });
        }
        
        function runNative(mode) {
            updateStatus('ë„¤ì´í‹°ë¸Œ GUI ì‹¤í–‰ ì‹œë„ ì¤‘...', true);
            fetch('/run_native/' + mode)
            .then(response => response.json())
            .then(data => {
                updateStatus(data.status);
                document.getElementById('nativeOutput').innerHTML = 
                    `<pre>${data.output}</pre>`;
            });
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        window.onload = function() {
            refreshMacroSteps();
            refreshExecutionLog();
        };
        
        // ì£¼ê¸°ì ìœ¼ë¡œ ë¡œê·¸ ì—…ë°ì´íŠ¸
        setInterval(refreshExecutionLog, 2000);
    </script>
</body>
</html>
'''

# API ì—”ë“œí¬ì¸íŠ¸ë“¤
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    try:
        file = request.files['file']
        filepath = os.path.join(project_root, 'temp_excel.xlsx')
        file.save(filepath)
        
        import pandas as pd
        xls = pd.ExcelFile(filepath)
        
        app_state['excel_file'] = filepath
        
        return jsonify({
            'success': True,
            'filename': file.filename,
            'sheets': xls.sheet_names,
            'rows': len(pd.read_excel(xls, xls.sheet_names[0]))
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/add_step', methods=['POST'])
def add_step():
    step_type = request.json['step_type']
    step_names = {
        'mouse_click': 'ë§ˆìš°ìŠ¤ í´ë¦­',
        'keyboard_type': 'í…ìŠ¤íŠ¸ ì…ë ¥',
        'wait_time': 'ëŒ€ê¸°',
        'image_search': 'ì´ë¯¸ì§€ ê²€ìƒ‰',
        'ocr_text': 'í…ìŠ¤íŠ¸ ê²€ìƒ‰',
        'if_condition': 'ì¡°ê±´ë¬¸'
    }
    
    app_state['macro_steps'].append({
        'type': step_type,
        'name': step_names.get(step_type, step_type)
    })
    
    return jsonify({'success': True})

@app.route('/get_macro')
def get_macro():
    return jsonify({'steps': app_state['macro_steps']})

@app.route('/remove_step/<int:index>', methods=['DELETE'])
def remove_step(index):
    if 0 <= index < len(app_state['macro_steps']):
        app_state['macro_steps'].pop(index)
    return jsonify({'success': True})

@app.route('/clear_macro', methods=['POST'])
def clear_macro():
    app_state['macro_steps'] = []
    return jsonify({'success': True})

@app.route('/save_macro', methods=['POST'])
def save_macro():
    with open('web_macro.json', 'w', encoding='utf-8') as f:
        json.dump(app_state['macro_steps'], f, ensure_ascii=False, indent=2)
    return jsonify({'success': True})

@app.route('/run_macro', methods=['POST'])
def run_macro():
    app_state['execution_log'].append({
        'time': datetime.now().strftime('%H:%M:%S'),
        'level': 'info',
        'message': 'ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œì‘'
    })
    
    # ì‹¤ì œ ë§¤í¬ë¡œ ì‹¤í–‰ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
    for i, step in enumerate(app_state['macro_steps']):
        app_state['execution_log'].append({
            'time': datetime.now().strftime('%H:%M:%S'),
            'level': 'success',
            'message': f'ë‹¨ê³„ {i+1}: {step["name"]} ì‹¤í–‰ ì™„ë£Œ'
        })
    
    app_state['execution_log'].append({
        'time': datetime.now().strftime('%H:%M:%S'),
        'level': 'success',
        'message': 'ë§¤í¬ë¡œ ì‹¤í–‰ ì™„ë£Œ'
    })
    
    return jsonify({'success': True})

@app.route('/stop_macro', methods=['POST'])
def stop_macro():
    app_state['status'] = 'stopped'
    return jsonify({'success': True})

@app.route('/get_log')
def get_log():
    return jsonify({'log': app_state['execution_log'][-50:]})  # ìµœê·¼ 50ê°œë§Œ

@app.route('/run_native/<mode>')
def run_native(mode):
    try:
        output = ""
        
        if mode == 'check':
            # X Server ì²´í¬ í›„ ì‹¤í–‰
            result = subprocess.run(['python3', 'run_main.py'], 
                                  capture_output=True, text=True, timeout=5)
            output = result.stdout + result.stderr
            status = "ì‹¤í–‰ ì‹œë„ ì™„ë£Œ"
            
        elif mode == 'xvfb':
            # Xvfbë¡œ ì‹¤í–‰
            subprocess.Popen(['xvfb-run', '-a', 'python3', 'run_main.py'])
            output = "Xvfb ê°€ìƒ ë””ìŠ¤í”Œë ˆì´ë¡œ ì‹¤í–‰ ì¤‘..."
            status = "Xvfb ì‹¤í–‰"
            
        elif mode == 'windows':
            # Windows ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
            output = "Windowsì—ì„œ ì‹¤í–‰:\n"
            output += "1. PowerShellì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰\n"
            output += "2. cd \\\\wsl.localhost\\Ubuntu\\home\\nosky\\macro\n"
            output += "3. .\\run_from_windows.ps1"
            status = "Windows ìŠ¤í¬ë¦½íŠ¸ ì•ˆë‚´"
            
        elif mode == 'debug':
            # ë””ë²„ê·¸ ì •ë³´
            output = f"DISPLAY: {os.environ.get('DISPLAY', 'Not set')}\n"
            output += f"Project Root: {project_root}\n"
            output += "Python Path: " + str(sys.path[:3])
            status = "ë””ë²„ê·¸ ì •ë³´"
            
    except Exception as e:
        output = str(e)
        status = "ì˜¤ë¥˜ ë°œìƒ"
    
    return jsonify({'status': status, 'output': output})

# ë©”ì¸ ì‹¤í–‰
if __name__ == '__main__':
    print("=" * 50)
    print("Excel Macro Automation - Web UI")
    print("=" * 50)
    print("\nWSL GUI ë¬¸ì œë¥¼ ìš°íšŒí•˜ëŠ” ì›¹ ê¸°ë°˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
    print("\në¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤...")
    print("ìˆ˜ë™ìœ¼ë¡œ ì—´ë ¤ë©´: http://localhost:5555")
    print("\nì¢…ë£Œí•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.")
    print("=" * 50)
    
    # ë¸Œë¼ìš°ì € ìë™ ì—´ê¸°
    def open_browser():
        import time
        time.sleep(1.5)
        webbrowser.open('http://localhost:5555')
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # Flask ì•± ì‹¤í–‰
    app.run(host='0.0.0.0', port=5555, debug=False)
</file>

<file path="WINDOWS_GUIDE.md">
# Windows ì‹¤í–‰ ê°€ì´ë“œ

ì´ ë¬¸ì„œëŠ” WSLì—ì„œ ê°œë°œëœ Excel ë§¤í¬ë¡œ ìë™í™” ë„êµ¬ë¥¼ Windows ë„¤ì´í‹°ë¸Œ í™˜ê²½ì—ì„œ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## ì™œ Windowsì—ì„œ ì§ì ‘ ì‹¤í–‰í•´ì•¼ í•˜ë‚˜ìš”?

WSL(Windows Subsystem for Linux)ì—ì„œ GUI ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‹¤í–‰í•  ë•Œ ë‹¤ìŒê³¼ ê°™ì€ ì œì•½ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤:
- í™”ë©´ ìº¡ì²˜ ê¸°ëŠ¥ì´ ì œëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•ŠìŒ
- ë§ˆìš°ìŠ¤/í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ìº¡ì²˜ ë¬¸ì œ
- íˆ¬ëª… ì˜¤ë²„ë ˆì´ ë Œë”ë§ ë¬¸ì œ
- í´ë¦½ë³´ë“œ ì ‘ê·¼ ì œí•œ

Windowsì—ì„œ ì§ì ‘ ì‹¤í–‰í•˜ë©´ ì´ëŸ¬í•œ ë¬¸ì œê°€ í•´ê²°ë©ë‹ˆë‹¤.

## ì‚¬ì „ ì¤€ë¹„ì‚¬í•­

1. **Python ì„¤ì¹˜**
   - [python.org](https://www.python.org/downloads/)ì—ì„œ Python 3.8 ì´ìƒ ë²„ì „ ë‹¤ìš´ë¡œë“œ
   - ì„¤ì¹˜ ì‹œ "Add Python to PATH" ì˜µì…˜ ì²´í¬ í•„ìˆ˜

2. **íŒŒì¼ ì ‘ê·¼**
   - WSL íŒŒì¼ì€ `\\wsl$\Ubuntu\home\ì‚¬ìš©ìëª…\macro` ê²½ë¡œë¡œ ì ‘ê·¼ ê°€ëŠ¥
   - ë˜ëŠ” Windows í´ë”ë¡œ í”„ë¡œì íŠ¸ ë³µì‚¬

## ì‹¤í–‰ ë°©ë²•

### ë°©ë²• 1: ê°„ë‹¨í•œ ì‹¤í–‰ê¸° ì‚¬ìš© (ê¶Œì¥)

1. Windows íƒìƒ‰ê¸°ì—ì„œ í”„ë¡œì íŠ¸ í´ë” ì—´ê¸°:
   ```
   \\wsl.localhost\Ubuntu-22.04\home\nosky\macro
   ```

2. `RUN_ON_WINDOWS.bat` ë”ë¸”í´ë¦­
   - UNC ê²½ë¡œ ë¬¸ì œë¥¼ ìë™ìœ¼ë¡œ í•´ê²°
   - ì„ì‹œ í´ë”ì— ë³µì‚¬ í›„ ì‹¤í–‰

### ë°©ë²• 2: ì¼ë°˜ ë°°ì¹˜ íŒŒì¼ ì‚¬ìš©

1. `run_windows.bat` ë”ë¸”í´ë¦­
   - UNC ê²½ë¡œ ìë™ ì²˜ë¦¬
   - ê°€ìƒí™˜ê²½ ì§€ì›

### ë°©ë²• 3: PowerShell ì‚¬ìš©

1. PowerShellì„ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰

2. í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™:
   ```powershell
   cd \\wsl$\Ubuntu\home\nosky\macro
   ```

3. PowerShell ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰:
   ```powershell
   .\run_windows.ps1
   ```

   ì‹¤í–‰ ì •ì±… ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´:
   ```powershell
   Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
   ```

### ë°©ë²• 4: ìˆ˜ë™ ì‹¤í–‰

1. ëª…ë ¹ í”„ë¡¬í”„íŠ¸ ë˜ëŠ” PowerShell ì—´ê¸°

2. í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™

3. ê°€ìƒí™˜ê²½ ìƒì„± ë° í™œì„±í™”:
   ```cmd
   python -m venv venv
   venv\Scripts\activate
   ```

4. íŒ¨í‚¤ì§€ ì„¤ì¹˜:
   ```cmd
   pip install -r requirements.txt
   ```

5. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰:
   ```cmd
   python run_main.py
   ```

## ë¬¸ì œ í•´ê²°

### UNC ê²½ë¡œ ì˜¤ë¥˜
WSL ê²½ë¡œì—ì„œ ì§ì ‘ ì‹¤í–‰ ì‹œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜:
```
'\\wsl.localhost\Ubuntu-22.04\...' ìœ„ì˜ ê²½ë¡œë¥¼ í˜„ì¬ ë””ë ‰í„°ë¦¬ë¡œ í•˜ì—¬ CMD.EXEê°€ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤.
UNC ê²½ë¡œëŠ” ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
```

**í•´ê²°ë°©ë²•**:
- `RUN_ON_WINDOWS.bat` ì‚¬ìš© (ìë™ìœ¼ë¡œ ë¡œì»¬ í´ë”ë¡œ ë³µì‚¬)
- í”„ë¡œì íŠ¸ë¥¼ C:\ ë“œë¼ì´ë¸Œë¡œ ë³µì‚¬ í›„ ì‹¤í–‰

### Pythonì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
- Pythonì´ PATHì— ì¶”ê°€ë˜ì—ˆëŠ”ì§€ í™•ì¸
- `python --version` ëª…ë ¹ìœ¼ë¡œ ì„¤ì¹˜ í™•ì¸

### íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì˜¤ë¥˜
- pip ì—…ê·¸ë ˆì´ë“œ: `python -m pip install --upgrade pip`
- íŠ¹ì • íŒ¨í‚¤ì§€ ìˆ˜ë™ ì„¤ì¹˜: `pip install PyQt5`

### GUI ê´€ë ¨ ë¬¸ì œ
- Windows ë””ìŠ¤í”Œë ˆì´ ìŠ¤ì¼€ì¼ë§ ì„¤ì • í™•ì¸
- ê·¸ë˜í”½ ë“œë¼ì´ë²„ ì—…ë°ì´íŠ¸

### íŒŒì¼ ê²½ë¡œ ë¬¸ì œ
- WSL ê²½ë¡œ ì‚¬ìš© ì‹œ `\\wsl$\` í”„ë¦¬í”½ìŠ¤ í™•ì¸
- ê²½ë¡œì— ê³µë°±ì´ ìˆìœ¼ë©´ ë”°ì˜´í‘œë¡œ ê°ì‹¸ê¸°

## ì£¼ìš” ì°¨ì´ì 

| ê¸°ëŠ¥ | WSL | Windows Native |
|------|-----|----------------|
| í™”ë©´ ìº¡ì²˜ | ì œí•œì  | ì™„ì „ ì§€ì› |
| ROI ì„ íƒ | ë¶ˆì•ˆì • | ì •ìƒ ì‘ë™ |
| í´ë¦½ë³´ë“œ | ì œí•œì  | ì™„ì „ ì§€ì› |
| ì„±ëŠ¥ | ì•½ê°„ ëŠë¦¼ | ë¹ ë¦„ |

## ê¶Œì¥ì‚¬í•­

1. **ê°œë°œ**: WSL/VSCodeì—ì„œ ì§„í–‰
2. **í…ŒìŠ¤íŠ¸/ì‹¤í–‰**: Windows PowerShellì—ì„œ ì‹¤í–‰
3. **ë°°í¬**: Windows ì‹¤í–‰ íŒŒì¼ë¡œ íŒ¨í‚¤ì§•

## ì¶”ê°€ ë„êµ¬

Windowsì—ì„œ ë” ë‚˜ì€ ê²½í—˜ì„ ìœ„í•´:
- **Windows Terminal**: í–¥ìƒëœ í„°ë¯¸ë„ í™˜ê²½
- **PyInstaller**: ì‹¤í–‰ íŒŒì¼ ìƒì„± ë„êµ¬

---

ë¬¸ì œê°€ ë°œìƒí•˜ë©´ í”„ë¡œì íŠ¸ì˜ Issue í˜ì´ì§€ì— ë³´ê³ í•´ì£¼ì„¸ìš”.
</file>

<file path="WINDOWS_WSL_SETUP.md">
# Windows + VSCode + WSL2 í™˜ê²½ì—ì„œ GUI ì‹¤í–‰í•˜ê¸°

## ğŸ–¥ï¸ Windowsì—ì„œ X Server ì„¤ì¹˜ ë° ì‹¤í–‰

### ë°©ë²• 1: VcXsrv ì‚¬ìš© (ê¶Œì¥)

1. **VcXsrv ë‹¤ìš´ë¡œë“œ ë° ì„¤ì¹˜**
   - https://sourceforge.net/projects/vcxsrv/
   - ì„¤ì¹˜ í›„ "XLaunch" ì‹¤í–‰

2. **VcXsrv ì„¤ì •**
   - Display settings: Multiple windows
   - Client startup: Start no client
   - Extra settings: 
     - âœ… Clipboard
     - âœ… Primary Selection
     - âœ… Native opengl
     - âœ… **Disable access control** (ì¤‘ìš”!)

3. **Windows ë°©í™”ë²½ í—ˆìš©**
   - VcXsrvê°€ ë°©í™”ë²½ í—ˆìš© ìš”ì²­í•˜ë©´ "í—ˆìš©" í´ë¦­

### ë°©ë²• 2: MobaXterm ì‚¬ìš©

1. **MobaXterm ë‹¤ìš´ë¡œë“œ**
   - https://mobaxterm.mobatek.net/
   - Home Edition (ë¬´ë£Œ) ì‚¬ìš©

2. **X server ìë™ ì‹œì‘**
   - MobaXterm ì‹¤í–‰í•˜ë©´ ìë™ìœ¼ë¡œ X server ì‹œì‘ë¨

## ğŸ§ WSL2 ì„¤ì •

### 1. DISPLAY í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

```bash
# ~/.bashrc ë˜ëŠ” ~/.zshrcì— ì¶”ê°€
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
export LIBGL_ALWAYS_INDIRECT=1
```

ë˜ëŠ” ì„ì‹œë¡œ ì„¤ì •:

```bash
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
```

### 2. í˜„ì¬ ì„¤ì • í™•ì¸

```bash
echo $DISPLAY
# ì¶œë ¥ ì˜ˆ: 172.x.x.x:0.0
```

## ğŸš€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰

### 1. X Server í™•ì¸
```bash
# Windowsì—ì„œ VcXsrv ë˜ëŠ” MobaXtermì´ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
# ì‹œìŠ¤í…œ íŠ¸ë ˆì´ì— X ì•„ì´ì½˜ì´ ìˆì–´ì•¼ í•¨
```

### 2. í…ŒìŠ¤íŠ¸
```bash
# X11 ì•± í…ŒìŠ¤íŠ¸
sudo apt-get install x11-apps
xeyes  # ëˆˆì´ ë”°ë¼ë‹¤ë‹ˆëŠ” ì°½ì´ ë‚˜íƒ€ë‚˜ë©´ ì„±ê³µ!
```

### 3. Excel Macro Automation ì‹¤í–‰
```bash
source venv/bin/activate
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
python run_simple.py
```

## ğŸ”§ ë¬¸ì œ í•´ê²°

### "cannot connect to X server" ì˜¤ë¥˜

1. **Windows IP í™•ì¸**
   ```bash
   cat /etc/resolv.conf | grep nameserver
   # nameserver ë’¤ì˜ IP ì£¼ì†Œ í™•ì¸
   ```

2. **ìˆ˜ë™ìœ¼ë¡œ DISPLAY ì„¤ì •**
   ```bash
   export DISPLAY=<Windows-IP>:0.0
   # ì˜ˆ: export DISPLAY=172.31.32.1:0.0
   ```

3. **VcXsrv ì¬ì‹œì‘**
   - Windowsì—ì„œ VcXsrv ì¢…ë£Œ í›„ ë‹¤ì‹œ ì‹œì‘
   - "Disable access control" ì˜µì…˜ í™•ì¸

### "Authorization required" ì˜¤ë¥˜

```bash
# X ì¸ì¦ ë¹„í™œì„±í™” (ë³´ì•ˆìƒ ë¡œì»¬ì—ì„œë§Œ ì‚¬ìš©)
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
xhost +
```

### WSLg ì‚¬ìš© (Windows 11)

Windows 11 + WSL2 ìµœì‹  ë²„ì „ì—ì„œëŠ” WSLgê°€ ê¸°ë³¸ ì§€ì›ë©ë‹ˆë‹¤:

```bash
# WSL ì—…ë°ì´íŠ¸
wsl --update

# WSL ì¬ì‹œì‘
wsl --shutdown
# Windowsì—ì„œ ë‹¤ì‹œ WSL ì‹¤í–‰

# DISPLAY í™•ì¸
echo $DISPLAY
# :0 ë˜ëŠ” :0.0ì´ë©´ WSLg ì‚¬ìš© ì¤‘
```

## ğŸ“ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

`run_windows_wsl.sh` ìƒì„±:

```bash
#!/bin/bash
# Windows + WSL2 í™˜ê²½ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

echo "Windows + WSL2 í™˜ê²½ì—ì„œ Excel Macro Automation ì‹¤í–‰"
echo "=================================================="

# DISPLAY ì„¤ì •
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
echo "DISPLAY ì„¤ì •: $DISPLAY"

# ê°€ìƒí™˜ê²½ í™œì„±í™”
source venv/bin/activate

# Python ì‹¤í–‰
python run_simple.py
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] Windowsì— X Server (VcXsrv ë˜ëŠ” MobaXterm) ì„¤ì¹˜
- [ ] X Server ì‹¤í–‰ ì¤‘ (ì‹œìŠ¤í…œ íŠ¸ë ˆì´ í™•ì¸)
- [ ] VcXsrvì—ì„œ "Disable access control" ì²´í¬
- [ ] WSLì—ì„œ DISPLAY í™˜ê²½ë³€ìˆ˜ ì„¤ì •
- [ ] xeyes ë˜ëŠ” xclockìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ì„±ê³µ

ëª¨ë“  í•­ëª©ì„ í™•ì¸í–ˆë‹¤ë©´ GUIê°€ ì •ìƒì ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤!
</file>

<file path="WSL_GUI_GUIDE.md">
# WSLì—ì„œ Excel Macro Automation ì‹¤í–‰ ê°€ì´ë“œ

## Windows 11 (WSL2 + WSLg)

Windows 11ì—ì„œëŠ” WSLgê°€ ê¸°ë³¸ ì§€ì›ë˜ë¯€ë¡œ ì¶”ê°€ ì„¤ì • ì—†ì´ GUI ì•±ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 1. í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜
```bash
# WSL í„°ë¯¸ë„ì—ì„œ ì‹¤í–‰
sudo apt update
sudo apt install -y python3-pyqt5 \
    libxcb-xinerama0 libxcb-icccm4 libxcb-image0 \
    libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 \
    libxcb-xfixes0 libxcb-shape0 libgl1-mesa-glx
```

### 2. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
```bash
cd /home/nosky/macro
python3 test_gui.py
```

## Windows 10 (WSL2 + X Server)

Windows 10ì—ì„œëŠ” X Serverë¥¼ ë³„ë„ë¡œ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.

### 1. X Server ì„¤ì¹˜
- **VcXsrv** ë‹¤ìš´ë¡œë“œ: https://sourceforge.net/projects/vcxsrv/
- ë˜ëŠ” **X410** (Microsoft Storeì—ì„œ êµ¬ë§¤)

### 2. X Server ì„¤ì • ë° ì‹¤í–‰
1. VcXsrv ì‹¤í–‰ (XLaunch)
2. ì„¤ì •:
   - Display number: 0
   - "Disable access control" ì²´í¬
   - "Native opengl" ì²´í¬ í•´ì œ

### 3. WSL í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
```bash
# .bashrc ë˜ëŠ” .zshrcì— ì¶”ê°€
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
export LIBGL_ALWAYS_INDIRECT=1
```

### 4. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
```bash
source ~/.bashrc  # í™˜ê²½ë³€ìˆ˜ ì ìš©
cd /home/nosky/macro
python3 test_gui.py
```

## ë¬¸ì œ í•´ê²°

### Qt platform plugin "xcb" ì˜¤ë¥˜
```bash
# ì¶”ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜
sudo apt install -y qt5-default libqt5gui5 libqt5core5a libqt5widgets5
```

### OpenGL ê´€ë ¨ ì˜¤ë¥˜
```bash
export LIBGL_ALWAYS_SOFTWARE=1
```

### í•œê¸€ í°íŠ¸ ë¬¸ì œ
```bash
sudo apt install -y fonts-nanum fonts-noto-cjk
```

## í˜„ì¬ êµ¬í˜„ ìƒíƒœ

### âœ… êµ¬í˜„ ì™„ë£Œ
1. **Excel í†µí•©** (T-002)
   - íŒŒì¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­
   - ì‹œíŠ¸ ì„ íƒ ë° ë¯¸ë¦¬ë³´ê¸°
   - ì—´ ë§¤í•‘ UI

2. **ë§¤í¬ë¡œ ì—ë””í„°** (T-003)
   - ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë‹¨ê³„ í¸ì§‘
   - ì‹œê°ì  ë‹¨ê³„ í‘œì‹œ
   - ë³€ìˆ˜ ì¹˜í™˜ ì§€ì›

3. **ì‹¤í–‰ ì—”ì§„** (T-004)
   - ë©€í‹°ìŠ¤ë ˆë“œ ì‹¤í–‰
   - í•«í‚¤ ì§€ì›
   - ì§„í–‰ë¥  í‘œì‹œ

4. **ì´ë¯¸ì§€ ì¸ì‹** (T-005)
   - OpenCV ê¸°ë°˜ ë§¤ì¹­
   - ROI ì„ íƒ UI
   - DPI ìŠ¤ì¼€ì¼ë§ ì§€ì›

### âŒ ë¯¸êµ¬í˜„
- OCR í…ìŠ¤íŠ¸ ì¸ì‹ (T-006)
- ì¡°ê±´ë¬¸ ë¡œì§ (T-007)
- ë§¤í¬ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° (T-008)
- ê³ ê¸‰ ë¡œê¹… (T-009)

## ì‹¤ì œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰

import ë¬¸ì œë¥¼ í•´ê²°í•œ í›„:
```bash
python3 main.py
```

ë˜ëŠ” import ë¬¸ì œë¥¼ ìš°íšŒí•˜ì—¬ ì‹¤í–‰:
1. ëª¨ë“  ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½
2. ë˜ëŠ” PYTHONPATH ì„¤ì •:
   ```bash
   export PYTHONPATH=/home/nosky/macro/src:$PYTHONPATH
   cd /home/nosky/macro
   python3 -m main
   ```
</file>

<file path="src/automation/executor.py">
"""
Step executor for macro steps
"""

import re
import time
import os
from typing import Dict, Any, Optional, Tuple
import pyautogui
from core.macro_types import MacroStep, StepType
from config.settings import Settings
from logger.app_logger import get_logger

class StepExecutor:
    """Executes individual macro steps"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger(__name__)
        self.variables: Dict[str, Any] = {}
        
        # Initialize image matcher
        self._image_matcher = None
        self._init_image_matcher()
        
        # Initialize text extractor
        self._text_extractor = None
        self._init_text_extractor()
        
        # Step handlers mapping
        self._handlers = {
            StepType.MOUSE_CLICK: self._execute_mouse_click,
            StepType.MOUSE_MOVE: self._execute_mouse_move,
            StepType.MOUSE_DRAG: self._execute_mouse_drag,
            StepType.MOUSE_SCROLL: self._execute_mouse_scroll,
            StepType.KEYBOARD_TYPE: self._execute_keyboard_type,
            StepType.KEYBOARD_HOTKEY: self._execute_keyboard_hotkey,
            StepType.WAIT_TIME: self._execute_wait_time,
            StepType.WAIT_IMAGE: self._execute_wait_image,
            StepType.SCREENSHOT: self._execute_screenshot,
            StepType.IMAGE_SEARCH: self._execute_image_search,
            StepType.OCR_TEXT: self._execute_text_search,
            StepType.IF_CONDITION: self._execute_if_condition,
            StepType.LOOP: self._execute_loop,
        }
        
    def _init_image_matcher(self):
        """Initialize image matcher with fallback"""
        try:
            from vision.image_matcher import ImageMatcher
            self._image_matcher = ImageMatcher(self.settings)
            self.logger.info("Using OpenCV-based image matcher")
        except ImportError:
            self.logger.warning("OpenCV not available, using pyautogui fallback")
            self._image_matcher = None
            
    def _init_text_extractor(self):
        """Initialize text extractor with fallback"""
        try:
            from vision.text_extractor import TextExtractor
            self._text_extractor = TextExtractor()
            self.logger.info("Using EasyOCR-based text extractor")
        except ImportError:
            self.logger.warning("EasyOCR not available, text search disabled")
            self._text_extractor = None
        
    def set_variables(self, variables: Dict[str, Any]):
        """Set variables for template substitution"""
        self.variables = variables
        
    def execute_step(self, step: MacroStep) -> Any:
        """Execute a single step"""
        handler = self._handlers.get(step.step_type)
        if not handler:
            raise NotImplementedError(f"No handler for step type: {step.step_type}")
            
        self.logger.debug(f"Executing step: {step.name} ({step.step_type.value})")
        
        try:
            result = handler(step)
            return result
        except Exception as e:
            self.logger.error(f"Step execution failed: {e}")
            raise
            
    def _substitute_variables(self, text: str) -> str:
        """Substitute variables in text"""
        if not text:
            return text
            
        # Find all {{variable}} patterns
        pattern = r'\{\{(\w+)\}\}'
        
        def replacer(match):
            var_name = match.group(1)
            if var_name in self.variables:
                return str(self.variables[var_name])
            return match.group(0)  # Keep original if not found
            
        return re.sub(pattern, replacer, text)
        
    def _get_absolute_position(self, x: int, y: int, relative_to: str) -> Tuple[int, int]:
        """Convert coordinates to absolute screen position"""
        if relative_to == "screen":
            return x, y
        elif relative_to == "window":
            # TODO: Implement window-relative coordinates
            # For now, treat as screen coordinates
            return x, y
        elif relative_to == "image":
            # TODO: Implement image-relative coordinates
            # For now, treat as screen coordinates
            return x, y
        else:
            return x, y
            
    # Mouse handlers
    
    def _execute_mouse_click(self, step) -> None:
        """Execute mouse click"""
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        
        pyautogui.click(
            x=x,
            y=y,
            clicks=step.clicks,
            interval=step.interval,
            button=step.button.value
        )
        
    def _execute_mouse_move(self, step) -> None:
        """Execute mouse move"""
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        
        if step.duration > 0:
            pyautogui.moveTo(x, y, duration=step.duration)
        else:
            pyautogui.moveTo(x, y)
            
    def _execute_mouse_drag(self, step) -> None:
        """Execute mouse drag"""
        # This would need to be implemented with proper drag coordinates
        # For now, using simple drag
        x, y = self._get_absolute_position(step.x, step.y, step.relative_to)
        pyautogui.dragTo(x, y, duration=step.duration, button=step.button.value)
        
    def _execute_mouse_scroll(self, step) -> None:
        """Execute mouse scroll"""
        pyautogui.scroll(step.clicks)
        
    # Keyboard handlers
    
    def _execute_keyboard_type(self, step) -> None:
        """Execute keyboard typing"""
        text = step.text
        
        # Substitute variables if enabled
        if step.use_variables:
            text = self._substitute_variables(text)
            
        pyautogui.typewrite(text, interval=step.interval)
        
    def _execute_keyboard_hotkey(self, step) -> None:
        """Execute keyboard hotkey"""
        if step.keys:
            pyautogui.hotkey(*step.keys)
            
    # Wait handlers
    
    def _execute_wait_time(self, step) -> None:
        """Execute time wait"""
        time.sleep(step.seconds)
        
    def _execute_wait_image(self, step) -> Optional[Tuple[int, int, int, int]]:
        """Execute wait for image"""
        if self._image_matcher:
            # Use OpenCV-based matcher
            result = self._image_matcher.wait_for_image(
                step.image_path,
                timeout=step.timeout,
                confidence=step.confidence,
                region=step.region
            )
            
            if result.found:
                self.logger.debug(f"Image found at: {result.location}")
                return result.location
            else:
                raise TimeoutError(f"Image not found within {step.timeout} seconds")
        else:
            # Fallback to pyautogui
            start_time = time.time()
            
            while time.time() - start_time < step.timeout:
                try:
                    # Try to locate image
                    location = pyautogui.locateOnScreen(
                        step.image_path,
                        confidence=step.confidence,
                        region=step.region
                    )
                    
                    if location:
                        self.logger.debug(f"Image found at: {location}")
                        return location
                        
                except Exception as e:
                    self.logger.debug(f"Image search error: {e}")
                    
                time.sleep(0.5)  # Check every 500ms
                
            raise TimeoutError(f"Image not found within {step.timeout} seconds")
        
    # Screen handlers
    
    def _execute_screenshot(self, step) -> str:
        """Execute screenshot"""
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        
        # Create screenshots directory
        screenshots_dir = os.path.join(
            os.path.dirname(__file__), 
            "../../screenshots"
        )
        os.makedirs(screenshots_dir, exist_ok=True)
        
        # Generate filename
        filename = os.path.join(
            screenshots_dir,
            f"screenshot_{timestamp}.png"
        )
        
        if self._image_matcher and hasattr(step, 'region') and step.region:
            # Capture specific region
            self._image_matcher.capture_region(step.region, filename)
        else:
            # Full screen capture
            pyautogui.screenshot(filename)
            
        self.logger.info(f"Screenshot saved: {filename}")
        return filename
        
    def _execute_image_search(self, step) -> Optional[Tuple[int, int, int, int]]:
        """Execute image search"""
        if self._image_matcher:
            # Use OpenCV-based matcher
            result = self._image_matcher.find_image(
                step.image_path,
                confidence=step.confidence,
                region=step.region
            )
            
            if result.found:
                self.logger.debug(f"Image found at: {result.location}")
                return result.location
            else:
                return None
        else:
            # Fallback to pyautogui
            try:
                location = pyautogui.locateOnScreen(
                    step.image_path,
                    confidence=step.confidence,
                    region=step.region
                )
                return location
            except:
                return None
            
    def _execute_text_search(self, step) -> Optional[Tuple[int, int]]:
        """Execute text search and optionally click"""
        if not self._text_extractor:
            raise RuntimeError("Text extractor not available (EasyOCR not installed)")
            
        # Get search text
        search_text = step.search_text
        
        # If using Excel column, get value from variables
        if step.excel_column and step.excel_column in self.variables:
            search_text = str(self.variables[step.excel_column])
            
        if not search_text:
            raise ValueError("No search text specified")
            
        # Replace variables in search text
        search_text = self._substitute_variables(search_text)
        
        self.logger.info(f"Searching for text: {search_text}")
        
        # Find text on screen
        result = self._text_extractor.find_text(
            search_text,
            region=step.region,
            exact_match=step.exact_match,
            confidence_threshold=step.confidence
        )
        
        if result:
            self.logger.info(f"Text found at: {result.center}")
            
            # Click if requested
            if step.click_after_find:
                click_x = result.center[0] + step.click_offset[0]
                click_y = result.center[1] + step.click_offset[1]
                
                pyautogui.click(click_x, click_y)
                self.logger.debug(f"Clicked at: ({click_x}, {click_y})")
                
            return result.center
        else:
            self.logger.warning(f"Text not found: {search_text}")
            return None
    
    # Flow control handlers
    
    def _execute_if_condition(self, step) -> bool:
        """Execute if condition and run appropriate branch"""
        condition_result = False
        
        try:
            # Evaluate condition based on type
            if step.condition_type == "image_exists":
                # Check if image exists on screen
                image_path = step.condition_value.get('image_path', '')
                confidence = step.condition_value.get('confidence', 0.9)
                region = step.condition_value.get('region')
                
                if self._image_matcher:
                    result = self._image_matcher.find_image(
                        image_path,
                        confidence=confidence,
                        region=region
                    )
                    condition_result = result.found if result else False
                else:
                    # Fallback to pyautogui
                    try:
                        location = pyautogui.locateOnScreen(
                            image_path,
                            confidence=confidence,
                            region=region
                        )
                        condition_result = location is not None
                    except:
                        condition_result = False
                        
            elif step.condition_type == "text_exists":
                # Check if text exists on screen
                search_text = step.condition_value.get('text', '')
                exact_match = step.condition_value.get('exact_match', False)
                region = step.condition_value.get('region')
                
                # Substitute variables in search text
                search_text = self._substitute_variables(search_text)
                
                if self._text_extractor and search_text:
                    result = self._text_extractor.find_text(
                        search_text,
                        region=region,
                        exact_match=exact_match,
                        confidence_threshold=0.5
                    )
                    condition_result = result is not None
                else:
                    condition_result = False
                    
            elif step.condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
                # Variable comparison conditions
                variable_name = step.condition_value.get('variable', '')
                compare_value = step.condition_value.get('compare_value', '')
                
                # Get variable value
                variable_value = self.variables.get(variable_name, '')
                
                # Substitute variables in compare value
                compare_value = self._substitute_variables(compare_value)
                
                # Perform comparison
                if step.condition_type == "variable_equals":
                    condition_result = str(variable_value) == str(compare_value)
                elif step.condition_type == "variable_contains":
                    condition_result = str(compare_value) in str(variable_value)
                elif step.condition_type == "variable_greater":
                    try:
                        condition_result = float(variable_value) > float(compare_value)
                    except (ValueError, TypeError):
                        # If not numeric, do string comparison
                        condition_result = str(variable_value) > str(compare_value)
                elif step.condition_type == "variable_less":
                    try:
                        condition_result = float(variable_value) < float(compare_value)
                    except (ValueError, TypeError):
                        # If not numeric, do string comparison
                        condition_result = str(variable_value) < str(compare_value)
                        
            self.logger.info(f"Condition '{step.condition_type}' evaluated to: {condition_result}")
            
            # Execute appropriate branch
            if condition_result:
                # Execute true branch steps
                for nested_step in step.true_steps:
                    if nested_step.enabled:
                        self.execute_step(nested_step)
            else:
                # Execute false branch steps
                for nested_step in step.false_steps:
                    if nested_step.enabled:
                        self.execute_step(nested_step)
                        
            return condition_result
            
        except Exception as e:
            self.logger.error(f"Error evaluating condition: {e}")
            # On error, execute false branch
            for nested_step in step.false_steps:
                if nested_step.enabled:
                    self.execute_step(nested_step)
            return False
        
    def _execute_loop(self, step) -> None:
        """Execute loop"""
        # TODO: Implement loop execution
        # This would need to interact with the main engine
        pass
</file>

<file path="src/core/__init__.py">
"""
Core business logic module
"""

from core.macro_types import (
    MacroStep, StepType, MouseButton, ConditionOperator,
    MouseClickStep, MouseMoveStep,
    KeyboardTypeStep, KeyboardHotkeyStep, 
    WaitTimeStep, WaitImageStep, TextSearchStep,
    IfConditionStep, LoopStep,
    Macro, StepFactory
)

from core.macro_storage import MacroStorage

__all__ = [
    # Types and Enums
    'MacroStep', 'StepType', 'MouseButton', 'ConditionOperator',
    
    # Step Classes
    'MouseClickStep', 'MouseMoveStep',
    'KeyboardTypeStep', 'KeyboardHotkeyStep',
    'WaitTimeStep', 'WaitImageStep', 'TextSearchStep',
    'IfConditionStep', 'LoopStep',
    
    # Main Classes
    'Macro', 'StepFactory', 'MacroStorage'
]
</file>

<file path="src/core/macro_types.py">
"""
Macro step type definitions
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Union, Tuple
from enum import Enum
import uuid
from datetime import datetime

class StepType(Enum):
    """Available macro step types"""
    # Mouse actions
    MOUSE_CLICK = "mouse_click"
    MOUSE_MOVE = "mouse_move"
    MOUSE_DRAG = "mouse_drag"
    MOUSE_SCROLL = "mouse_scroll"
    
    # Keyboard actions
    KEYBOARD_TYPE = "keyboard_type"
    KEYBOARD_HOTKEY = "keyboard_hotkey"
    
    # Wait actions
    WAIT_TIME = "wait_time"
    WAIT_IMAGE = "wait_image"
    WAIT_TEXT = "wait_text"
    
    # Screen actions
    SCREENSHOT = "screenshot"
    IMAGE_SEARCH = "image_search"
    OCR_TEXT = "ocr_text"
    
    # Flow control
    IF_CONDITION = "if_condition"
    LOOP = "loop"
    
    # Excel operations
    EXCEL_READ = "excel_read"
    EXCEL_WRITE = "excel_write"

class ErrorHandling(Enum):
    """Error handling strategies"""
    STOP = "stop"           # Stop execution on error
    CONTINUE = "continue"   # Continue to next step
    RETRY = "retry"         # Retry the step

class MouseButton(Enum):
    """Mouse button types"""
    LEFT = "left"
    RIGHT = "right"
    MIDDLE = "middle"

class ConditionOperator(Enum):
    """Condition operators for conditional steps"""
    EQUALS = "equals"
    NOT_EQUALS = "not_equals"
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    GREATER_THAN = "greater_than"
    LESS_THAN = "less_than"
    EXISTS = "exists"
    NOT_EXISTS = "not_exists"

@dataclass
class MacroStep(ABC):
    """Base class for all macro steps"""
    step_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    step_type: StepType = field(init=False)
    name: str = ""
    description: str = ""
    enabled: bool = True
    error_handling: ErrorHandling = ErrorHandling.STOP
    retry_count: int = 0
    
    @abstractmethod
    def validate(self) -> List[str]:
        """Validate step configuration"""
        pass
    
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """Convert step to dictionary"""
        base_dict = {
            "step_id": self.step_id,
            "step_type": self.step_type.value,
            "name": self.name,
            "description": self.description,
            "enabled": self.enabled,
            "error_handling": self.error_handling.value,
            "retry_count": self.retry_count
        }
        return base_dict
    
    @classmethod
    @abstractmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MacroStep':
        """Create step from dictionary"""
        pass

# Mouse Steps

@dataclass
class MouseClickStep(MacroStep):
    """Mouse click action"""
    step_type: StepType = field(default=StepType.MOUSE_CLICK, init=False)
    x: int = 0
    y: int = 0
    button: MouseButton = MouseButton.LEFT
    clicks: int = 1
    interval: float = 0.0
    relative_to: str = "screen"  # screen, window, image
    
    def validate(self) -> List[str]:
        errors = []
        if self.x < 0 or self.y < 0:
            errors.append("Coordinates must be non-negative")
        if self.clicks < 1:
            errors.append("Click count must be at least 1")
        if self.interval < 0:
            errors.append("Interval must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "x": self.x,
            "y": self.y,
            "button": self.button.value,
            "clicks": self.clicks,
            "interval": self.interval,
            "relative_to": self.relative_to
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MouseClickStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            x=data.get("x", 0),
            y=data.get("y", 0),
            button=MouseButton(data.get("button", "left")),
            clicks=data.get("clicks", 1),
            interval=data.get("interval", 0.0),
            relative_to=data.get("relative_to", "screen")
        )

@dataclass
class MouseMoveStep(MacroStep):
    """Mouse move action"""
    step_type: StepType = field(default=StepType.MOUSE_MOVE, init=False)
    x: int = 0
    y: int = 0
    duration: float = 0.0
    relative_to: str = "screen"
    
    def validate(self) -> List[str]:
        errors = []
        if self.x < 0 or self.y < 0:
            errors.append("Coordinates must be non-negative")
        if self.duration < 0:
            errors.append("Duration must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "x": self.x,
            "y": self.y,
            "duration": self.duration,
            "relative_to": self.relative_to
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MouseMoveStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            x=data.get("x", 0),
            y=data.get("y", 0),
            duration=data.get("duration", 0.0),
            relative_to=data.get("relative_to", "screen")
        )

# Keyboard Steps

@dataclass
class KeyboardTypeStep(MacroStep):
    """Keyboard typing action"""
    step_type: StepType = field(default=StepType.KEYBOARD_TYPE, init=False)
    text: str = ""
    interval: float = 0.0
    use_variables: bool = True
    
    def validate(self) -> List[str]:
        errors = []
        if not self.text:
            errors.append("Text cannot be empty")
        if self.interval < 0:
            errors.append("Interval must be non-negative")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "text": self.text,
            "interval": self.interval,
            "use_variables": self.use_variables
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'KeyboardTypeStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            text=data.get("text", ""),
            interval=data.get("interval", 0.0),
            use_variables=data.get("use_variables", True)
        )

@dataclass
class KeyboardHotkeyStep(MacroStep):
    """Keyboard hotkey action"""
    step_type: StepType = field(default=StepType.KEYBOARD_HOTKEY, init=False)
    keys: List[str] = field(default_factory=list)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.keys:
            errors.append("At least one key must be specified")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "keys": self.keys
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'KeyboardHotkeyStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            keys=data.get("keys", [])
        )

# Wait Steps

@dataclass
class WaitTimeStep(MacroStep):
    """Wait for specified time"""
    step_type: StepType = field(default=StepType.WAIT_TIME, init=False)
    seconds: float = 1.0
    
    def validate(self) -> List[str]:
        errors = []
        if self.seconds <= 0:
            errors.append("Wait time must be positive")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "seconds": self.seconds
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WaitTimeStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            seconds=data.get("seconds", 1.0)
        )

@dataclass
class WaitImageStep(MacroStep):
    """Wait for image to appear"""
    step_type: StepType = field(default=StepType.WAIT_IMAGE, init=False)
    image_path: str = ""
    timeout: float = 10.0
    confidence: float = 0.9
    region: Optional[tuple] = None  # (x, y, width, height)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.image_path:
            errors.append("Image path cannot be empty")
        if self.timeout <= 0:
            errors.append("Timeout must be positive")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "image_path": self.image_path,
            "timeout": self.timeout,
            "confidence": self.confidence,
            "region": list(self.region) if self.region else None
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WaitImageStep':
        region = data.get("region")
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            image_path=data.get("image_path", ""),
            timeout=data.get("timeout", 10.0),
            confidence=data.get("confidence", 0.9),
            region=tuple(region) if region else None
        )

@dataclass
class TextSearchStep(MacroStep):
    """Search for dynamic text and click"""
    step_type: StepType = field(default=StepType.OCR_TEXT, init=False)
    search_text: str = ""  # Text to search for (can include {{variables}})
    excel_column: Optional[str] = None  # Excel column to bind for dynamic text
    region: Optional[tuple] = None  # (x, y, width, height)
    exact_match: bool = False
    confidence: float = 0.5
    click_after_find: bool = True
    click_offset: Tuple[int, int] = (0, 0)  # Offset from center of found text
    
    def validate(self) -> List[str]:
        errors = []
        if not self.search_text and not self.excel_column:
            errors.append("Either search text or Excel column must be specified")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "search_text": self.search_text,
            "excel_column": self.excel_column,
            "region": list(self.region) if self.region else None,
            "exact_match": self.exact_match,
            "confidence": self.confidence,
            "click_after_find": self.click_after_find,
            "click_offset": list(self.click_offset)
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TextSearchStep':
        region = data.get("region")
        click_offset = data.get("click_offset", [0, 0])
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            search_text=data.get("search_text", ""),
            excel_column=data.get("excel_column"),
            region=tuple(region) if region else None,
            exact_match=data.get("exact_match", False),
            confidence=data.get("confidence", 0.5),
            click_after_find=data.get("click_after_find", True),
            click_offset=tuple(click_offset)
        )

# Flow Control Steps

@dataclass
class IfConditionStep(MacroStep):
    """Conditional execution"""
    step_type: StepType = field(default=StepType.IF_CONDITION, init=False)
    condition_type: str = "image_exists"  # image_exists, text_exists, variable_equals, variable_contains, variable_greater, variable_less
    condition_value: Dict[str, Any] = field(default_factory=dict)  # Store all condition parameters
    true_steps: List['MacroStep'] = field(default_factory=list)  # Nested steps for true branch
    false_steps: List['MacroStep'] = field(default_factory=list)  # Nested steps for false branch
    
    def validate(self) -> List[str]:
        errors = []
        if not self.condition_type:
            errors.append("Condition type must be specified")
            
        # Validate based on condition type
        if self.condition_type == "image_exists":
            if not self.condition_value.get("image_path"):
                errors.append("Image path must be specified for image_exists condition")
        elif self.condition_type == "text_exists":
            if not self.condition_value.get("text"):
                errors.append("Text must be specified for text_exists condition")
        elif self.condition_type in ["variable_equals", "variable_contains", "variable_greater", "variable_less"]:
            if not self.condition_value.get("variable"):
                errors.append("Variable name must be specified")
            if not self.condition_value.get("compare_value"):
                errors.append("Comparison value must be specified")
                
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "condition_type": self.condition_type,
            "condition_value": self.condition_value,
            "true_steps": [step.to_dict() for step in self.true_steps],
            "false_steps": [step.to_dict() for step in self.false_steps]
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'IfConditionStep':
        # Create true/false steps from data
        true_steps = []
        for step_data in data.get("true_steps", []):
            true_steps.append(StepFactory.from_dict(step_data))
            
        false_steps = []
        for step_data in data.get("false_steps", []):
            false_steps.append(StepFactory.from_dict(step_data))
            
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            condition_type=data.get("condition_type", "image_exists"),
            condition_value=data.get("condition_value", {}),
            true_steps=true_steps,
            false_steps=false_steps
        )

@dataclass
class LoopStep(MacroStep):
    """Loop execution"""
    step_type: StepType = field(default=StepType.LOOP, init=False)
    loop_type: str = "count"  # count, while_image, for_each_row
    loop_count: int = 1
    loop_steps: List[str] = field(default_factory=list)  # Step IDs to loop
    
    def validate(self) -> List[str]:
        errors = []
        if self.loop_type == "count" and self.loop_count < 1:
            errors.append("Loop count must be at least 1")
        if not self.loop_steps:
            errors.append("Loop must contain at least one step")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "loop_type": self.loop_type,
            "loop_count": self.loop_count,
            "loop_steps": self.loop_steps
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LoopStep':
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            loop_type=data.get("loop_type", "count"),
            loop_count=data.get("loop_count", 1),
            loop_steps=data.get("loop_steps", [])
        )

# Additional Step Classes

@dataclass
class ImageSearchStep(MacroStep):
    """Image search and click action"""
    step_type: StepType = field(default=StepType.IMAGE_SEARCH, init=False)
    image_path: str = ""
    confidence: float = 0.9
    region: Optional[tuple] = None  # (x, y, width, height)
    click_after_find: bool = True
    click_offset: Tuple[int, int] = (0, 0)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.image_path:
            errors.append("Image path cannot be empty")
        if not 0 <= self.confidence <= 1:
            errors.append("Confidence must be between 0 and 1")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "image_path": self.image_path,
            "confidence": self.confidence,
            "region": list(self.region) if self.region else None,
            "click_after_find": self.click_after_find,
            "click_offset": list(self.click_offset)
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ImageSearchStep':
        region = data.get("region")
        click_offset = data.get("click_offset", [0, 0])
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            image_path=data.get("image_path", ""),
            confidence=data.get("confidence", 0.9),
            region=tuple(region) if region else None,
            click_after_find=data.get("click_after_find", True),
            click_offset=tuple(click_offset)
        )

@dataclass
class ScreenshotStep(MacroStep):
    """Take screenshot action"""
    step_type: StepType = field(default=StepType.SCREENSHOT, init=False)
    filename_pattern: str = "screenshot_{timestamp}.png"
    save_directory: str = "./screenshots/"
    region: Optional[tuple] = None  # (x, y, width, height)
    
    def validate(self) -> List[str]:
        errors = []
        if not self.filename_pattern:
            errors.append("Filename pattern cannot be empty")
        if not self.save_directory:
            errors.append("Save directory cannot be empty")
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            "filename_pattern": self.filename_pattern,
            "save_directory": self.save_directory,
            "region": list(self.region) if self.region else None
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ScreenshotStep':
        region = data.get("region")
        return cls(
            step_id=data.get("step_id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            error_handling=ErrorHandling(data.get("error_handling", "stop")),
            retry_count=data.get("retry_count", 0),
            filename_pattern=data.get("filename_pattern", "screenshot_{timestamp}.png"),
            save_directory=data.get("save_directory", "./screenshots/"),
            region=tuple(region) if region else None
        )

# Step Factory

class StepFactory:
    """Factory for creating macro steps"""
    
    _step_classes = {
        StepType.MOUSE_CLICK: MouseClickStep,
        StepType.MOUSE_MOVE: MouseMoveStep,
        StepType.KEYBOARD_TYPE: KeyboardTypeStep,
        StepType.KEYBOARD_HOTKEY: KeyboardHotkeyStep,
        StepType.WAIT_TIME: WaitTimeStep,
        StepType.WAIT_IMAGE: WaitImageStep,
        StepType.IMAGE_SEARCH: ImageSearchStep,
        StepType.SCREENSHOT: ScreenshotStep,
        StepType.OCR_TEXT: TextSearchStep,
        StepType.IF_CONDITION: IfConditionStep,
        StepType.LOOP: LoopStep
    }
    
    @classmethod
    def create_step(cls, step_type: StepType) -> MacroStep:
        """Create a new step of given type"""
        step_class = cls._step_classes.get(step_type)
        if not step_class:
            raise ValueError(f"Unknown step type: {step_type}")
        return step_class()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> MacroStep:
        """Create step from dictionary"""
        step_type = StepType(data.get("step_type"))
        step_class = cls._step_classes.get(step_type)
        if not step_class:
            raise ValueError(f"Unknown step type: {step_type}")
        return step_class.from_dict(data)

# Macro Definition

@dataclass
class Macro:
    """Complete macro definition"""
    macro_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = "ìƒˆ ë§¤í¬ë¡œ"
    description: str = ""
    version: str = "1.0.0"
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    steps: List[MacroStep] = field(default_factory=list)
    variables: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def add_step(self, step: MacroStep, index: Optional[int] = None):
        """Add step to macro"""
        if index is None:
            self.steps.append(step)
        else:
            self.steps.insert(index, step)
        self.updated_at = datetime.now()
    
    def remove_step(self, step_id: str):
        """Remove step by ID"""
        self.steps = [s for s in self.steps if s.step_id != step_id]
        self.updated_at = datetime.now()
    
    def move_step(self, step_id: str, new_index: int):
        """Move step to new position"""
        step = None
        for i, s in enumerate(self.steps):
            if s.step_id == step_id:
                step = self.steps.pop(i)
                break
        
        if step:
            self.steps.insert(new_index, step)
            self.updated_at = datetime.now()
    
    def validate(self) -> List[str]:
        """Validate entire macro"""
        errors = []
        if not self.name:
            errors.append("Macro name cannot be empty")
        
        # Validate each step
        for i, step in enumerate(self.steps):
            step_errors = step.validate()
            for error in step_errors:
                errors.append(f"Step {i+1} ({step.name}): {error}")
        
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert macro to dictionary"""
        return {
            "macro_id": self.macro_id,
            "name": self.name,
            "description": self.description,
            "version": self.version,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "steps": [step.to_dict() for step in self.steps],
            "variables": self.variables,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Macro':
        """Create macro from dictionary"""
        steps = []
        for step_data in data.get("steps", []):
            steps.append(StepFactory.from_dict(step_data))
        
        return cls(
            macro_id=data.get("macro_id", str(uuid.uuid4())),
            name=data.get("name", "ìƒˆ ë§¤í¬ë¡œ"),
            description=data.get("description", ""),
            version=data.get("version", "1.0.0"),
            created_at=datetime.fromisoformat(data.get("created_at", datetime.now().isoformat())),
            updated_at=datetime.fromisoformat(data.get("updated_at", datetime.now().isoformat())),
            steps=steps,
            variables=data.get("variables", {}),
            metadata=data.get("metadata", {})
        )
</file>

<file path="src/excel/excel_manager.py">
"""
Core Excel file management functionality
"""

import os
from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple
import pandas as pd
import openpyxl
from logger.app_logger import get_logger
from excel.models import (
    ExcelFileInfo, SheetInfo, ColumnInfo, ColumnType, 
    ExcelData, ColumnMapping
)

class ExcelManager:
    """Manages Excel file operations"""
    
    def __init__(self):
        self.logger = get_logger(__name__)
        self._current_file: Optional[str] = None
        self._current_data: Optional[ExcelData] = None
        self._column_mappings: Dict[str, ColumnMapping] = {}
        
    def load_file(self, file_path: str) -> ExcelFileInfo:
        """Load Excel file and return file information"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Excel file not found: {file_path}")
        
        if not file_path.suffix.lower() in ['.xlsx', '.xls', '.xlsm']:
            raise ValueError(f"Invalid Excel file format: {file_path.suffix}")
        
        self.logger.info(f"Loading Excel file: {file_path}")
        
        # Get file info
        file_size = file_path.stat().st_size
        
        # Load workbook to get sheet names
        workbook = openpyxl.load_workbook(file_path, read_only=True, data_only=True)
        sheet_names = workbook.sheetnames
        workbook.close()
        
        # Analyze each sheet
        sheets = []
        for sheet_name in sheet_names:
            sheet_info = self._analyze_sheet(file_path, sheet_name)
            sheets.append(sheet_info)
        
        self._current_file = str(file_path)
        
        return ExcelFileInfo(
            file_path=str(file_path),
            file_size=file_size,
            sheet_count=len(sheets),
            sheets=sheets
        )
    
    def _analyze_sheet(self, file_path: Path, sheet_name: str) -> SheetInfo:
        """Analyze a specific sheet"""
        # Read first 1000 rows for analysis
        df = pd.read_excel(file_path, sheet_name=sheet_name, nrows=1000)
        
        # Get full row count
        full_df = pd.read_excel(file_path, sheet_name=sheet_name, usecols=[0])
        row_count = len(full_df)
        
        # Analyze columns
        columns = []
        for idx, col in enumerate(df.columns):
            col_info = self._analyze_column(df[col], col, idx)
            columns.append(col_info)
        
        return SheetInfo(
            name=sheet_name,
            row_count=row_count,
            column_count=len(columns),
            columns=columns
        )
    
    def _analyze_column(self, series: pd.Series, name: str, index: int) -> ColumnInfo:
        """Analyze a single column"""
        # Get non-null values
        non_null = series.dropna()
        
        # Determine data type
        data_type = self._detect_column_type(non_null)
        
        # Get sample values
        sample_values = non_null.head(5).tolist()
        
        return ColumnInfo(
            name=str(name),
            index=index,
            data_type=data_type,
            sample_values=sample_values,
            null_count=series.isnull().sum(),
            unique_count=series.nunique()
        )
    
    def _detect_column_type(self, series: pd.Series) -> ColumnType:
        """Detect column data type"""
        if len(series) == 0:
            return ColumnType.EMPTY
        
        # Try to infer type
        try:
            pd.to_numeric(series)
            return ColumnType.NUMBER
        except:
            pass
        
        try:
            pd.to_datetime(series)
            return ColumnType.DATE
        except:
            pass
        
        # Check for boolean
        unique_values = series.unique()
        if len(unique_values) <= 2:
            bool_values = {True, False, 'True', 'False', 'true', 'false', 
                          'TRUE', 'FALSE', 'ì˜ˆ', 'ì•„ë‹ˆì˜¤', 'Yes', 'No'}
            if all(val in bool_values for val in unique_values):
                return ColumnType.BOOLEAN
        
        return ColumnType.TEXT
    
    def read_sheet(self, sheet_name: str, max_rows: Optional[int] = None) -> ExcelData:
        """Read data from a specific sheet"""
        if not self._current_file:
            raise ValueError("No Excel file loaded")
        
        self.logger.info(f"Reading sheet: {sheet_name}")
        
        # Read data
        df = pd.read_excel(self._current_file, sheet_name=sheet_name, nrows=max_rows)
        
        # Create ExcelData instance
        excel_data = ExcelData(df, sheet_name, self._current_file)
        
        # Check for status column
        status_columns = ['ìƒíƒœ', 'Status', 'ì™„ë£Œì—¬ë¶€', 'ì²˜ë¦¬ìƒíƒœ', 'status', 'STATUS']
        for col in status_columns:
            if col in df.columns:
                excel_data.set_status_column(col)
                break
        
        # If no status column found, create one
        if not excel_data.get_status_column():
            excel_data.set_status_column('ì²˜ë¦¬ìƒíƒœ')
            self.logger.info("Created new status column: ì²˜ë¦¬ìƒíƒœ")
        
        self._current_data = excel_data
        return excel_data
    
    def save_file(self, file_path: Optional[str] = None) -> str:
        """Save current data back to Excel"""
        if not self._current_data:
            raise ValueError("No data to save")
        
        save_path = file_path or self._current_file
        
        # Read all sheets to preserve
        with pd.ExcelFile(self._current_file) as xls:
            sheets = {}
            for sheet_name in xls.sheet_names:
                if sheet_name == self._current_data.sheet_name:
                    sheets[sheet_name] = self._current_data.dataframe
                else:
                    sheets[sheet_name] = pd.read_excel(xls, sheet_name)
        
        # Save all sheets
        with pd.ExcelWriter(save_path, engine='openpyxl') as writer:
            for sheet_name, df in sheets.items():
                df.to_excel(writer, sheet_name=sheet_name, index=False)
        
        self.logger.info(f"Saved Excel file: {save_path}")
        return save_path
    
    def set_column_mapping(self, excel_column: str, variable_name: str, 
                          data_type: ColumnType, is_required: bool = True):
        """Set mapping between Excel column and variable"""
        mapping = ColumnMapping(
            excel_column=excel_column,
            variable_name=variable_name,
            data_type=data_type,
            is_required=is_required
        )
        self._column_mappings[variable_name] = mapping
    
    def get_mapped_data(self, row_index: int) -> Dict[str, Any]:
        """Get row data with variable mappings applied"""
        if not self._current_data:
            raise ValueError("No data loaded")
        
        row_data = self._current_data.get_row_data(row_index)
        mapped_data = {}
        
        for var_name, mapping in self._column_mappings.items():
            if mapping.excel_column in row_data:
                mapped_data[var_name] = row_data[mapping.excel_column]
            elif mapping.default_value is not None:
                mapped_data[var_name] = mapping.default_value
            elif mapping.is_required:
                raise ValueError(f"Required column '{mapping.excel_column}' not found")
        
        return mapped_data
    
    def update_row_status(self, row_index: int, status: str, save_immediately: bool = False):
        """Update status for a specific row"""
        if not self._current_data:
            raise ValueError("No data loaded")
        
        self._current_data.update_row_status(row_index, status)
        
        if save_immediately:
            self.save_file()
    
    def get_pending_rows(self) -> List[int]:
        """Get list of row indices that need processing"""
        if not self._current_data:
            return []
        
        incomplete = self._current_data.get_incomplete_rows()
        return incomplete.index.tolist()
</file>

<file path="src/ui/dialogs/text_search_step_dialog.py">
"""
Dialog for configuring text search steps with Excel column binding
"""

from typing import Optional, Dict, Any, Tuple
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QPushButton, QLabel, QCheckBox, QSpinBox,
    QDoubleSpinBox, QComboBox, QGroupBox, QMessageBox,
    QDialogButtonBox, QWidget, QApplication
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor
from core.macro_types import TextSearchStep
from ui.widgets.roi_selector import ROISelectorOverlay
from vision.text_extractor import TextExtractor
import pyautogui

class TextSearchStepDialog(QDialog):
    """Dialog for configuring text search steps"""
    
    def __init__(self, step: Optional[TextSearchStep] = None, 
                 excel_columns: list = None, parent=None):
        super().__init__(parent)
        self.step = step or TextSearchStep()
        self.excel_columns = excel_columns or []
        self.region = self.step.region
        self.text_extractor = TextExtractor()
        self.setWindowTitle("í…ìŠ¤íŠ¸ ê²€ìƒ‰ ë‹¨ê³„ ì„¤ì •")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Basic info
        form_layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("ì˜ˆ: í™˜ì ì´ë¦„ ì°¾ê¸°")
        form_layout.addRow("ë‹¨ê³„ ì´ë¦„:", self.name_edit)
        
        layout.addLayout(form_layout)
        
        # Text search configuration
        search_group = QGroupBox("í…ìŠ¤íŠ¸ ê²€ìƒ‰ ì„¤ì •")
        search_layout = QVBoxLayout()
        
        # Search text type selection
        text_type_layout = QHBoxLayout()
        text_type_layout.addWidget(QLabel("ê²€ìƒ‰ ë°©ë²•:"))
        
        self.fixed_text_radio = QCheckBox("ê³ ì • í…ìŠ¤íŠ¸")
        self.excel_column_radio = QCheckBox("ì—‘ì…€ ì—´ ë°ì´í„°")
        self.fixed_text_radio.setChecked(True)
        
        # Make them mutually exclusive
        self.fixed_text_radio.toggled.connect(
            lambda checked: self.excel_column_radio.setChecked(not checked) if checked else None
        )
        self.excel_column_radio.toggled.connect(
            lambda checked: self.fixed_text_radio.setChecked(not checked) if checked else None
        )
        
        text_type_layout.addWidget(self.fixed_text_radio)
        text_type_layout.addWidget(self.excel_column_radio)
        text_type_layout.addStretch()
        search_layout.addLayout(text_type_layout)
        
        # Fixed text input
        self.fixed_text_widget = QWidget()
        fixed_text_layout = QHBoxLayout()
        fixed_text_layout.setContentsMargins(0, 0, 0, 0)
        fixed_text_layout.addWidget(QLabel("ê²€ìƒ‰í•  í…ìŠ¤íŠ¸:"))
        self.search_text_edit = QLineEdit()
        self.search_text_edit.setPlaceholderText("ì˜ˆ: í™ê¸¸ë™")
        fixed_text_layout.addWidget(self.search_text_edit)
        self.fixed_text_widget.setLayout(fixed_text_layout)
        search_layout.addWidget(self.fixed_text_widget)
        
        # Excel column selection
        self.excel_column_widget = QWidget()
        excel_layout = QHBoxLayout()
        excel_layout.setContentsMargins(0, 0, 0, 0)
        excel_layout.addWidget(QLabel("ì—‘ì…€ ì—´:"))
        self.excel_column_combo = QComboBox()
        self.excel_column_combo.addItems(self.excel_columns)
        excel_layout.addWidget(self.excel_column_combo)
        self.excel_column_widget.setLayout(excel_layout)
        self.excel_column_widget.setVisible(False)
        search_layout.addWidget(self.excel_column_widget)
        
        # Connect radio buttons to show/hide widgets
        self.fixed_text_radio.toggled.connect(self.fixed_text_widget.setVisible)
        self.excel_column_radio.toggled.connect(self.excel_column_widget.setVisible)
        
        search_group.setLayout(search_layout)
        layout.addWidget(search_group)
        
        # Search region configuration
        region_group = QGroupBox("ê²€ìƒ‰ ì˜ì—­")
        region_layout = QVBoxLayout()
        
        # Region display
        self.region_label = QLabel("ì „ì²´ í™”ë©´")
        if self.region:
            self.region_label.setText(
                f"ì˜ì—­: ({self.region[0]}, {self.region[1]}) "
                f"í¬ê¸°: {self.region[2]}x{self.region[3]}"
            )
        region_layout.addWidget(self.region_label)
        
        # Region buttons
        region_btn_layout = QHBoxLayout()
        
        self.select_region_btn = QPushButton("ì˜ì—­ ì„ íƒ")
        self.select_region_btn.clicked.connect(self._select_region)
        region_btn_layout.addWidget(self.select_region_btn)
        
        self.clear_region_btn = QPushButton("ì˜ì—­ ì´ˆê¸°í™”")
        self.clear_region_btn.clicked.connect(self._clear_region)
        region_btn_layout.addWidget(self.clear_region_btn)
        
        self.preview_region_btn = QPushButton("ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°")
        self.preview_region_btn.clicked.connect(self._preview_region)
        region_btn_layout.addWidget(self.preview_region_btn)
        
        region_layout.addLayout(region_btn_layout)
        region_group.setLayout(region_layout)
        layout.addWidget(region_group)
        
        # Matching options
        options_group = QGroupBox("ë§¤ì¹­ ì˜µì…˜")
        options_layout = QFormLayout()
        
        self.exact_match_check = QCheckBox("ì •í™•íˆ ì¼ì¹˜")
        self.exact_match_check.setToolTip(
            "ì²´í¬ ì‹œ: ê²€ìƒ‰ í…ìŠ¤íŠ¸ì™€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ ì°¾ìŒ\n"
            "ì²´í¬ í•´ì œ ì‹œ: ë¶€ë¶„ ì¼ì¹˜ë„ í—ˆìš©"
        )
        options_layout.addRow("ë§¤ì¹­ ë°©ì‹:", self.exact_match_check)
        
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setRange(0.0, 1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.5)
        self.confidence_spin.setToolTip("OCR ì¸ì‹ ì‹ ë¢°ë„ (0.0~1.0)")
        options_layout.addRow("ì¸ì‹ ì‹ ë¢°ë„:", self.confidence_spin)
        
        options_group.setLayout(options_layout)
        layout.addWidget(options_group)
        
        # Click options
        click_group = QGroupBox("í´ë¦­ ì˜µì…˜")
        click_layout = QFormLayout()
        
        self.click_after_find_check = QCheckBox("ì°¾ì€ í›„ í´ë¦­")
        self.click_after_find_check.setChecked(True)
        click_layout.addRow("ë™ì‘:", self.click_after_find_check)
        
        # Click offset
        offset_widget = QWidget()
        offset_layout = QHBoxLayout()
        offset_layout.setContentsMargins(0, 0, 0, 0)
        
        offset_layout.addWidget(QLabel("X:"))
        self.offset_x_spin = QSpinBox()
        self.offset_x_spin.setRange(-100, 100)
        self.offset_x_spin.setValue(0)
        self.offset_x_spin.setToolTip("í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì—ì„œ X ì˜¤í”„ì…‹")
        offset_layout.addWidget(self.offset_x_spin)
        
        offset_layout.addWidget(QLabel("Y:"))
        self.offset_y_spin = QSpinBox()
        self.offset_y_spin.setRange(-100, 100)
        self.offset_y_spin.setValue(0)
        self.offset_y_spin.setToolTip("í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì—ì„œ Y ì˜¤í”„ì…‹")
        offset_layout.addWidget(self.offset_y_spin)
        
        offset_widget.setLayout(offset_layout)
        click_layout.addRow("í´ë¦­ ì˜¤í”„ì…‹:", offset_widget)
        
        click_group.setLayout(click_layout)
        layout.addWidget(click_group)
        
        # Test button
        self.test_btn = QPushButton("í…ŒìŠ¤íŠ¸")
        self.test_btn.clicked.connect(self._test_search)
        layout.addWidget(self.test_btn)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            Qt.Horizontal, self
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
    def load_step_data(self):
        """Load data from step"""
        self.name_edit.setText(self.step.name)
        
        # Set search method
        if self.step.excel_column:
            self.excel_column_radio.setChecked(True)
            # Find and select the column
            index = self.excel_column_combo.findText(self.step.excel_column)
            if index >= 0:
                self.excel_column_combo.setCurrentIndex(index)
        else:
            self.fixed_text_radio.setChecked(True)
            self.search_text_edit.setText(self.step.search_text)
        
        # Set options
        self.exact_match_check.setChecked(self.step.exact_match)
        self.confidence_spin.setValue(self.step.confidence)
        self.click_after_find_check.setChecked(self.step.click_after_find)
        self.offset_x_spin.setValue(self.step.click_offset[0])
        self.offset_y_spin.setValue(self.step.click_offset[1])
        
    def _select_region(self):
        """Select screen region"""
        # Hide dialog temporarily
        self.hide()
        # Give time for dialog to hide before showing ROI selector
        QTimer.singleShot(200, self._show_region_selector)
        
    def _show_region_selector(self):
        """Show region selector overlay"""
        try:
            print("DEBUG: Creating ROI selector")
            # Create ROI selector as a top-level window
            self.roi_selector = ROISelectorOverlay(parent=None)
            self.roi_selector.selectionComplete.connect(self._on_region_selected)
            self.roi_selector.selectionCancelled.connect(lambda: self.show())
            print("DEBUG: Starting ROI selection")
            self.roi_selector.start_selection()
        except Exception as e:
            print(f"DEBUG: Error in _show_region_selector: {e}")
            import traceback
            traceback.print_exc()
            self.show()
            
    def _on_selection_cancelled(self):
        """Handle selection cancellation"""
        print("DEBUG: Selection cancelled")
        self.show()
        
    def _on_region_selected(self, region: Tuple[int, int, int, int]):
        """Handle region selection"""
        try:
            # Ensure region is properly formatted
            if region and len(region) == 4:
                # Convert all values to integers to avoid any type issues
                formatted_region = tuple(int(x) for x in region)
                self.region = formatted_region
                self.region_label.setText(
                    f"ì˜ì—­: ({formatted_region[0]}, {formatted_region[1]}) "
                    f"í¬ê¸°: {formatted_region[2]}x{formatted_region[3]}"
                )
            else:
                self.region = None
                self.region_label.setText("ì „ì²´ í™”ë©´")
            
            # Restore dialog visibility
            self.show()
            self.raise_()
            self.activateWindow()
        except Exception as e:
            print(f"DEBUG: Error in _on_region_selected: {e}")
            import traceback
            traceback.print_exc()
            # Still try to show the dialog
            self.region = None
            self.region_label.setText("ì „ì²´ í™”ë©´")
            self.show()
        
    def _clear_region(self):
        """Clear selected region"""
        self.region = None
        self.region_label.setText("ì „ì²´ í™”ë©´")
        
    def _preview_region(self):
        """Preview selected region"""
        if not self.region:
            QMessageBox.information(self, "ì•Œë¦¼", "ì„ íƒëœ ì˜ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
            
        try:
            # Take screenshot of region
            x, y, width, height = self.region
            screenshot = pyautogui.screenshot(region=(x, y, width, height))
            
            # Convert to QPixmap
            # Save to bytes first to avoid direct conversion issues
            import io
            bytes_io = io.BytesIO()
            screenshot.save(bytes_io, format='PNG')
            bytes_io.seek(0)
            
            pixmap = QPixmap()
            pixmap.loadFromData(bytes_io.read())
            
            if pixmap.isNull():
                QMessageBox.warning(self, "ê²½ê³ ", "ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                return
            
            # Create preview dialog
            preview_dialog = QDialog(self)
            preview_dialog.setWindowTitle("ì˜ì—­ ë¯¸ë¦¬ë³´ê¸°")
            layout = QVBoxLayout()
            
            label = QLabel()
            # Scale pixmap if too large
            if pixmap.width() > 800 or pixmap.height() > 600:
                pixmap = pixmap.scaled(800, 600, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            label.setPixmap(pixmap)
            layout.addWidget(label)
            
            # Add region info
            info_label = QLabel(f"ì˜ì—­: ({x}, {y}) - í¬ê¸°: {width}x{height}")
            layout.addWidget(info_label)
            
            preview_dialog.setLayout(layout)
            preview_dialog.exec_()
            
        except Exception as e:
            print(f"DEBUG: Error in preview: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(self, "ì˜¤ë¥˜", f"ë¯¸ë¦¬ë³´ê¸° ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
        
    def _test_search(self):
        """Test text search"""
        # Get search text
        if self.fixed_text_radio.isChecked():
            search_text = self.search_text_edit.text()
            if not search_text:
                QMessageBox.warning(self, "ê²½ê³ ", "ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
                return
        else:
            if self.excel_column_combo.currentText():
                search_text = f"[{self.excel_column_combo.currentText()} ì—´ì˜ ë°ì´í„°]"
            else:
                QMessageBox.warning(self, "ê²½ê³ ", "ì—‘ì…€ ì—´ì„ ì„ íƒí•˜ì„¸ìš”.")
                return
        
        # Perform test search
        self.hide()
        QTimer.singleShot(300, lambda: self._perform_test_search(search_text))
        
    def _perform_test_search(self, search_text: str):
        """Perform the actual test search"""
        try:
            print(f"DEBUG: Starting test search for: {search_text}")
            print(f"DEBUG: Current region: {self.region}")
            
            # For testing with Excel column, use sample text
            if self.excel_column_radio.isChecked():
                test_text = QMessageBox.getText(
                    self, "í…ŒìŠ¤íŠ¸ í…ìŠ¤íŠ¸",
                    f"{self.excel_column_combo.currentText()} ì—´ì˜ í…ŒìŠ¤íŠ¸ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”:",
                    text="í™ê¸¸ë™"
                )
                if test_text[1]:
                    search_text = test_text[0]
                else:
                    self.show()
                    return
            
            print("DEBUG: Extracting text from region...")
            # Extract text from region
            results = self.text_extractor.extract_text_from_region(
                self.region, 
                self.confidence_spin.value()
            )
            print(f"DEBUG: Found {len(results)} text results")
            
            print("DEBUG: Finding matching text...")
            # Find matching text
            found_result = self.text_extractor.find_text(
                search_text,
                self.region,
                self.exact_match_check.isChecked(),
                self.confidence_spin.value()
            )
            
            if found_result:
                print(f"DEBUG: Found text at {found_result.center}")
                # Show result
                if self.click_after_find_check.isChecked():
                    # Calculate click position
                    click_x = found_result.center[0] + self.offset_x_spin.value()
                    click_y = found_result.center[1] + self.offset_y_spin.value()
                    
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"í´ë¦­ ìœ„ì¹˜: ({click_x}, {click_y})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                else:
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                
                # Highlight found text briefly
                self._highlight_found_text(found_result)
                
            else:
                print("DEBUG: Text not found")
                # Show all found text for debugging
                if results:
                    all_text = "\n".join([f"- {r.text} (ì‹ ë¢°ë„: {r.confidence:.2f})" 
                                         for r in results[:10]])  # Show max 10
                else:
                    all_text = "í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                    
                message = (
                    f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n"
                    f"ë°œê²¬ëœ í…ìŠ¤íŠ¸:\n{all_text}"
                )
            
            QMessageBox.information(self, "í…ŒìŠ¤íŠ¸ ê²°ê³¼", message)
            
        except Exception as e:
            print(f"DEBUG: Error in test search: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
        finally:
            self.show()
            
    def _highlight_found_text(self, result):
        """Briefly highlight the found text on screen"""
        # This is a simplified version - in production, you might want
        # to create a temporary overlay window
        import time
        x, y = result.center
        pyautogui.moveTo(x, y, duration=0.5)
        
    def _perform_test_search_immediate(self, search_text: str):
        """Perform test search without hiding dialog (for Windows compatibility)"""
        loading_msg = None
        try:
            print(f"DEBUG: Starting immediate test search for: {search_text}")
            print(f"DEBUG: Current region: {self.region}")
            
            # Extract text from region first (before showing loading)
            results = self.text_extractor.extract_text_from_region(
                self.region, 
                self.confidence_spin.value()
            )
            print(f"DEBUG: Found {len(results)} text results")
            
            # Find matching text
            found_result = self.text_extractor.find_text(
                search_text,
                self.region,
                self.exact_match_check.isChecked(),
                self.confidence_spin.value()
            )
            
            if found_result:
                print(f"DEBUG: Found text at {found_result.center}")
                # Show result
                if self.click_after_find_check.isChecked():
                    # Calculate click position
                    click_x = found_result.center[0] + self.offset_x_spin.value()
                    click_y = found_result.center[1] + self.offset_y_spin.value()
                    
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"í´ë¦­ ìœ„ì¹˜: ({click_x}, {click_y})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                else:
                    message = (
                        f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì•˜ìŠµë‹ˆë‹¤!\n\n"
                        f"ìœ„ì¹˜: ({found_result.center[0]}, {found_result.center[1]})\n"
                        f"ì‹ ë¢°ë„: {found_result.confidence:.2f}"
                    )
                
                QMessageBox.information(self, "í…ŒìŠ¤íŠ¸ ì„±ê³µ", message)
                
                # Highlight found text
                self._highlight_found_text(found_result)
                
            else:
                print("DEBUG: Text not found")
                # Show all found text for debugging
                if results:
                    all_text = "\n".join([f"â€¢ {r.text} (ì‹ ë¢°ë„: {r.confidence:.2f})" 
                                         for r in results[:10]])  # Show max 10
                else:
                    all_text = "ì¸ì‹ëœ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤."
                    
                message = (
                    f"í…ìŠ¤íŠ¸ '{search_text}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n"
                    f"ê²€ìƒ‰ ì˜ì—­ì—ì„œ ë°œê²¬ëœ í…ìŠ¤íŠ¸:\n{all_text}"
                )
                
                QMessageBox.warning(self, "í…ŒìŠ¤íŠ¸ ê²°ê³¼", message)
                
        except Exception as e:
            print(f"DEBUG: Error in immediate test search: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{str(e)}")
        
    def get_step_data(self) -> Dict[str, Any]:
        """Get step configuration data"""
        return {
            'name': self.name_edit.text() or "í…ìŠ¤íŠ¸ ê²€ìƒ‰",
            'search_text': self.search_text_edit.text() if self.fixed_text_radio.isChecked() else "",
            'excel_column': self.excel_column_combo.currentText() if self.excel_column_radio.isChecked() else None,
            'region': self.region,
            'exact_match': self.exact_match_check.isChecked(),
            'confidence': self.confidence_spin.value(),
            'click_after_find': self.click_after_find_check.isChecked(),
            'click_offset': (self.offset_x_spin.value(), self.offset_y_spin.value())
        }
</file>

<file path="src/ui/widgets/roi_selector.py">
"""
Region of Interest (ROI) selector widget with transparent overlay
"""

from typing import Optional, Tuple, Callable
from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QVBoxLayout, QDialog
from PyQt5.QtCore import Qt, QRect, QPoint, pyqtSignal, QTimer
from PyQt5.QtGui import QPainter, QPen, QColor, QBrush, QPixmap, QFont, QCursor, QPalette
import sys

class ROISelectorOverlay(QDialog):
    """Transparent overlay for ROI selection"""
    
    # Signals
    selectionComplete = pyqtSignal(tuple)  # (x, y, width, height)
    selectionCancelled = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Selection state
        self.selecting = False
        self.start_point = QPoint()
        self.end_point = QPoint()
        self.selection_rect = QRect()
        
        # UI setup
        # Use flags that work well on Windows
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Dialog)
        self.setModal(True)
        
        # Set dark background
        palette = self.palette()
        palette.setColor(QPalette.Background, QColor(0, 0, 0, 150))
        self.setPalette(palette)
        self.setAutoFillBackground(True)
        
        # Cursor and mouse tracking
        self.setCursor(Qt.CrossCursor)
        self.setMouseTracking(True)
        self.setFocusPolicy(Qt.StrongFocus)
        
        # Cover all screens
        self._setup_multi_monitor()
        
    def _setup_multi_monitor(self):
        """Setup to cover all monitors"""
        # Get combined screen geometry
        desktop = QApplication.desktop()
        total_rect = QRect()
        
        for i in range(desktop.screenCount()):
            screen_rect = desktop.screenGeometry(i)
            total_rect = total_rect.united(screen_rect)
            
        self.setGeometry(total_rect)
        
    def start_selection(self):
        """Start ROI selection"""
        print("DEBUG: ROI start_selection called")
        
        # Ensure window covers full screen
        desktop = QApplication.desktop()
        screen_rect = desktop.screenGeometry()
        self.setGeometry(screen_rect)
        
        # Show window using exec_ for modal dialog
        print(f"DEBUG: Showing ROI window at {screen_rect}")
        
        # Start with a slight delay to ensure proper display
        QTimer.singleShot(100, self._prepare_selection)
        
        # Show as modal dialog
        self.exec_()
        
    def _prepare_selection(self):
        """Prepare for selection after dialog is shown"""
        print("DEBUG: _prepare_selection called")
        self.raise_()
        self.activateWindow()
        self.grabMouse()
        self.grabKeyboard()
        self.update()
        
    def _grab_input(self):
        """Grab mouse and keyboard input after delay"""
        print("DEBUG: _grab_input called")
        try:
            self.grabMouse()
            self.grabKeyboard()
            self.setFocus()
            print("DEBUG: Input grabbed successfully")
        except Exception as e:
            print(f"DEBUG: Error grabbing input: {e}")
        
    def mousePressEvent(self, event):
        """Handle mouse press"""
        if event.button() == Qt.LeftButton:
            self.selecting = True
            self.start_point = event.globalPos()
            self.end_point = self.start_point
            self.update()
            
    def mouseMoveEvent(self, event):
        """Handle mouse move"""
        if self.selecting:
            self.end_point = event.globalPos()
            self.update()
            
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() == Qt.LeftButton and self.selecting:
            self.selecting = False
            self.end_point = event.globalPos()
            
            # Calculate selection rectangle
            x = min(self.start_point.x(), self.end_point.x())
            y = min(self.start_point.y(), self.end_point.y())
            w = abs(self.end_point.x() - self.start_point.x())
            h = abs(self.end_point.y() - self.start_point.y())
            
            # Emit result if selection is valid
            if w > 5 and h > 5:
                region = (int(x), int(y), int(w), int(h))
                self.selectionComplete.emit(region)
            
            self.close()
            
    def keyPressEvent(self, event):
        """Handle key press"""
        if event.key() == Qt.Key_Escape:
            self.selecting = False
            self.selectionCancelled.emit()
            self.close()
            
    def paintEvent(self, event):
        """Paint overlay and selection"""
        print("DEBUG: paintEvent called")
        painter = QPainter(self)
        
        # Fill with solid color to ensure visibility
        painter.fillRect(self.rect(), QColor(50, 50, 50, 200))
        
        # Draw visible text
        painter.setPen(QColor(255, 255, 255))
        font = QFont()
        font.setPointSize(24)
        font.setBold(True)
        painter.setFont(font)
        
        instructions = "ë§ˆìš°ìŠ¤ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”. ESCë¡œ ì·¨ì†Œ"
        rect = self.rect()
        rect.setTop(50)
        painter.drawText(rect, Qt.AlignTop | Qt.AlignHCenter, instructions)
        
        if self.selecting or (self.start_point and self.end_point):
            # Calculate selection rectangle
            x = min(self.start_point.x(), self.end_point.x())
            y = min(self.start_point.y(), self.end_point.y())
            w = abs(self.end_point.x() - self.start_point.x())
            h = abs(self.end_point.y() - self.start_point.y())
            
            # Adjust to widget coordinates
            selection = QRect(x - self.x(), y - self.y(), w, h)
            
            # Draw selection area with lighter background
            painter.fillRect(selection, QColor(255, 255, 255, 50))
            
            # Draw selection border
            painter.setPen(QPen(QColor(50, 150, 250), 3, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(selection)
            
            # Draw dimensions text
            if w > 50 and h > 30:
                painter.setPen(QColor(255, 255, 255))
                font = QFont()
                font.setPointSize(12)
                font.setBold(True)
                painter.setFont(font)
                
                text = f"{w} Ã— {h}"
                text_rect = selection.adjusted(5, 5, -5, -5)
                painter.drawText(text_rect, Qt.AlignTop | Qt.AlignLeft, text)
                
            # Draw corner handles
            self._draw_handles(painter, selection)
            
    def _draw_handles(self, painter: QPainter, rect: QRect):
        """Draw resize handles at corners"""
        handle_size = 8
        painter.setBrush(QBrush(QColor(50, 150, 250)))
        painter.setPen(Qt.NoPen)
        
        # Top-left
        painter.drawRect(rect.x() - handle_size//2, 
                        rect.y() - handle_size//2,
                        handle_size, handle_size)
        
        # Top-right
        painter.drawRect(rect.x() + rect.width() - handle_size//2,
                        rect.y() - handle_size//2,
                        handle_size, handle_size)
        
        # Bottom-left
        painter.drawRect(rect.x() - handle_size//2,
                        rect.y() + rect.height() - handle_size//2,
                        handle_size, handle_size)
        
        # Bottom-right
        painter.drawRect(rect.x() + rect.width() - handle_size//2,
                        rect.y() + rect.height() - handle_size//2,
                        handle_size, handle_size)
                        
    def close(self):
        """Clean up and close"""
        print("DEBUG: ROI close() called")
        self.releaseMouse()
        self.releaseKeyboard()
        self.accept()  # Close the dialog properly

class ROISelectorWidget(QWidget):
    """Widget for ROI selection with preview"""
    
    regionSelected = pyqtSignal(tuple)  # (x, y, width, height)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_region: Optional[Tuple[int, int, int, int]] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Preview label
        self.preview_label = QLabel()
        self.preview_label.setMinimumSize(200, 150)
        self.preview_label.setMaximumSize(400, 300)
        self.preview_label.setScaledContents(True)
        self.preview_label.setStyleSheet("""
            QLabel {
                border: 2px solid #ccc;
                background-color: #f0f0f0;
            }
        """)
        self.preview_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.preview_label)
        
        # Info label
        self.info_label = QLabel("ì„ íƒëœ ì˜ì—­ ì—†ìŒ")
        self.info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.info_label)
        
        self.setLayout(layout)
        
    def start_selection(self):
        """Start ROI selection"""
        self.selector = ROISelectorOverlay()
        self.selector.selectionComplete.connect(self._on_selection_complete)
        self.selector.selectionCancelled.connect(self._on_selection_cancelled)
        self.selector.start_selection()
        
    def _on_selection_complete(self, region: Tuple[int, int, int, int]):
        """Handle selection completion"""
        self.current_region = region
        self.info_label.setText(f"ì˜ì—­: {region[0]}, {region[1]} - {region[2]}Ã—{region[3]}")
        self.regionSelected.emit(region)
        
        # Capture and show preview
        self._update_preview()
        
    def _on_selection_cancelled(self):
        """Handle selection cancellation"""
        self.info_label.setText("ì„ íƒ ì·¨ì†Œë¨")
        
    def _update_preview(self):
        """Update preview of selected region"""
        if not self.current_region:
            return
            
        try:
            # Capture the selected region
            import mss
            import numpy as np
            from PIL import Image
            
            with mss.mss() as sct:
                monitor = {
                    "left": self.current_region[0],
                    "top": self.current_region[1],
                    "width": self.current_region[2],
                    "height": self.current_region[3]
                }
                
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.bgra, "raw", "BGRX")
                
                # Convert to QPixmap
                qpixmap = QPixmap.fromImage(self._pil_to_qimage(img))
                self.preview_label.setPixmap(qpixmap)
                
        except Exception as e:
            self.info_label.setText(f"Preview error: {str(e)}")
            
    def _pil_to_qimage(self, pil_image):
        """Convert PIL image to QImage"""
        from PyQt5.QtGui import QImage
        
        if pil_image.mode == "RGB":
            r, g, b = pil_image.split()
            pil_image = Image.merge("RGB", (b, g, r))
        elif pil_image.mode == "RGBA":
            r, g, b, a = pil_image.split()
            pil_image = Image.merge("RGBA", (b, g, r, a))
            
        width, height = pil_image.size
        data = pil_image.tobytes("raw", pil_image.mode)
        
        if pil_image.mode == "RGB":
            qimage = QImage(data, width, height, QImage.Format_RGB888)
        elif pil_image.mode == "RGBA":
            qimage = QImage(data, width, height, QImage.Format_RGBA8888)
            
        return qimage
        
    def set_region(self, region: Optional[Tuple[int, int, int, int]]):
        """Set region programmatically"""
        self.current_region = region
        if region:
            self.info_label.setText(f"ì˜ì—­: {region[0]}, {region[1]} - {region[2]}Ã—{region[3]}")
            self._update_preview()
        else:
            self.info_label.setText("ì„ íƒëœ ì˜ì—­ ì—†ìŒ")
            self.preview_label.clear()
        
    def get_region(self) -> Optional[Tuple[int, int, int, int]]:
        """Get current region"""
        return self.current_region
</file>

<file path="src/vision/__init__.py">
"""
Vision module for image recognition and text extraction
"""

from vision.image_matcher import ImageMatcher, MatchResult
from vision.text_extractor import TextExtractor, TextResult

__all__ = ['ImageMatcher', 'MatchResult', 'TextExtractor', 'TextResult']
</file>

<file path="src/vision/text_extractor.py">
"""
Text extraction using EasyOCR for dynamic text search
"""

import os
import numpy as np
from typing import Optional, List, Tuple, Dict, Any
from dataclasses import dataclass
import cv2
from PIL import Image
import mss
from logger.app_logger import get_logger

# EasyOCR is required
import easyocr

@dataclass
class TextResult:
    """Result from text detection"""
    text: str
    confidence: float
    bbox: Tuple[int, int, int, int]  # (x, y, width, height)
    center: Tuple[int, int]  # (center_x, center_y)

class TextExtractor:
    """Extract text from screen regions using EasyOCR"""
    
    _instance = None
    _reader = None
    
    def __new__(cls):
        """Singleton pattern to avoid multiple EasyOCR reader instances"""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        """Initialize text extractor"""
        if not hasattr(self, 'initialized'):
            self.logger = get_logger(__name__)
            self.sct = mss.mss()
            self.initialized = True
            
    def _get_reader(self) -> easyocr.Reader:
        """Get or create EasyOCR reader (lazy loading)"""
        if TextExtractor._reader is None:
            self.logger.info("Initializing EasyOCR reader with Korean and English support...")
            # Initialize with Korean and English
            TextExtractor._reader = easyocr.Reader(['ko', 'en'], gpu=False)
            self.logger.info("EasyOCR reader initialized successfully")
        return TextExtractor._reader
    
    def extract_text_from_region(self, region: Optional[Tuple[int, int, int, int]] = None,
                                confidence_threshold: float = 0.5) -> List[TextResult]:
        """
        Extract text from screen region
        
        Args:
            region: (x, y, width, height) or None for full screen
            confidence_threshold: Minimum confidence for text detection
            
        Returns:
            List of TextResult objects
        """
        try:
            # Capture screen region
            if region:
                x, y, width, height = region
                monitor = {"left": x, "top": y, "width": width, "height": height}
            else:
                monitor = self.sct.monitors[1]  # Primary monitor
                
            # Capture screenshot
            screenshot = self.sct.grab(monitor)
            
            # Convert to numpy array
            img = np.array(screenshot)
            # Convert BGRA to RGB
            img_rgb = cv2.cvtColor(img, cv2.COLOR_BGRA2RGB)
            
            # Get reader
            reader = self._get_reader()
            
            # Perform OCR
            results = reader.readtext(img_rgb)
            
            # Process results
            text_results = []
            for bbox, text, confidence in results:
                if confidence >= confidence_threshold:
                    # Convert bbox format
                    # EasyOCR returns [[x1,y1], [x2,y1], [x2,y2], [x1,y2]]
                    x_coords = [point[0] for point in bbox]
                    y_coords = [point[1] for point in bbox]
                    
                    min_x = int(min(x_coords))
                    min_y = int(min(y_coords))
                    max_x = int(max(x_coords))
                    max_y = int(max(y_coords))
                    
                    width = max_x - min_x
                    height = max_y - min_y
                    
                    # Calculate center point
                    center_x = min_x + width // 2
                    center_y = min_y + height // 2
                    
                    # Adjust coordinates if region was specified
                    if region:
                        min_x += region[0]
                        min_y += region[1]
                        center_x += region[0]
                        center_y += region[1]
                    
                    result = TextResult(
                        text=text,
                        confidence=confidence,
                        bbox=(min_x, min_y, width, height),
                        center=(center_x, center_y)
                    )
                    text_results.append(result)
                    
            self.logger.info(f"Extracted {len(text_results)} text items from region")
            return text_results
            
        except Exception as e:
            self.logger.error(f"Error extracting text: {e}")
            return []
    
    def find_text(self, target_text: str, region: Optional[Tuple[int, int, int, int]] = None,
                  exact_match: bool = False, confidence_threshold: float = 0.5) -> Optional[TextResult]:
        """
        Find specific text in screen region
        
        Args:
            target_text: Text to search for
            region: (x, y, width, height) or None for full screen
            exact_match: If True, requires exact match. If False, allows partial match
            confidence_threshold: Minimum OCR confidence
            
        Returns:
            TextResult if found, None otherwise
        """
        try:
            # Extract all text from region
            text_results = self.extract_text_from_region(region, confidence_threshold)
            
            # Normalize target text for comparison
            target_lower = target_text.lower().strip()
            
            # Find matching text
            best_match = None
            best_score = 0.0
            
            for result in text_results:
                text_lower = result.text.lower().strip()
                
                if exact_match:
                    if text_lower == target_lower:
                        return result
                else:
                    # Partial match - check if target is in detected text
                    if target_lower in text_lower:
                        # Score based on how much of the detected text matches
                        score = len(target_lower) / len(text_lower)
                        if score > best_score:
                            best_match = result
                            best_score = score
                    # Also check if detected text is in target (for partial OCR results)
                    elif text_lower in target_lower and len(text_lower) > 2:
                        score = len(text_lower) / len(target_lower)
                        if score > best_score:
                            best_match = result
                            best_score = score
            
            if best_match:
                self.logger.info(f"Found text '{target_text}' at {best_match.center}")
            else:
                self.logger.info(f"Text '{target_text}' not found in region")
                
            return best_match
            
        except Exception as e:
            self.logger.error(f"Error finding text: {e}")
            return None
    
    def find_all_text(self, target_text: str, region: Optional[Tuple[int, int, int, int]] = None,
                      exact_match: bool = False, confidence_threshold: float = 0.5) -> List[TextResult]:
        """
        Find all occurrences of text in screen region
        
        Args:
            target_text: Text to search for
            region: (x, y, width, height) or None for full screen
            exact_match: If True, requires exact match. If False, allows partial match
            confidence_threshold: Minimum OCR confidence
            
        Returns:
            List of TextResult objects
        """
        try:
            # Extract all text from region
            text_results = self.extract_text_from_region(region, confidence_threshold)
            
            # Normalize target text for comparison
            target_lower = target_text.lower().strip()
            
            # Find all matching text
            matches = []
            
            for result in text_results:
                text_lower = result.text.lower().strip()
                
                if exact_match:
                    if text_lower == target_lower:
                        matches.append(result)
                else:
                    # Partial match
                    if target_lower in text_lower or text_lower in target_lower:
                        matches.append(result)
            
            self.logger.info(f"Found {len(matches)} occurrences of '{target_text}'")
            return matches
            
        except Exception as e:
            self.logger.error(f"Error finding all text: {e}")
            return []
    
    def preload_models(self):
        """Preload OCR models to avoid delay on first use"""
        try:
            self.logger.info("Preloading EasyOCR models...")
            reader = self._get_reader()
            # Do a dummy recognition to load models
            dummy_img = np.zeros((100, 100, 3), dtype=np.uint8)
            reader.readtext(dummy_img)
            self.logger.info("EasyOCR models preloaded successfully")
        except Exception as e:
            self.logger.error(f"Error preloading models: {e}")
</file>

<file path="test_results/test_drag_drop_integration_result.json">
{"created": 1752636299.6804233, "duration": 1.383589267730713, "exitcode": 0, "root": "/home/nosky/macro", "environment": {}, "summary": {"passed": 6, "total": 6, "collected": 6}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py", "type": "Module"}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "outcome": "passed", "result": []}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "type": "Function", "lineno": 42}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "type": "Function", "lineno": 72}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "type": "Function", "lineno": 102}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "type": "Function", "lineno": 130}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "type": "Function", "lineno": 157}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "type": "Function", "lineno": 177}]}, {"nodeid": "tests/integration/test_drag_drop_integration.py", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestScenario", "type": "Class"}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration", "type": "Class"}]}], "tests": [{"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_new_step_from_palette", "lineno": 42, "outcome": "passed", "keywords": ["test_drag_new_step_from_palette", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.008672042982652783, "outcome": "passed"}, "call": {"duration": 0.20474275600281544, "outcome": "passed"}, "teardown": {"duration": 0.0002611030067782849, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_multiple_steps", "lineno": 72, "outcome": "passed", "keywords": ["test_drag_multiple_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005240975006017834, "outcome": "passed"}, "call": {"duration": 0.42886567598907277, "outcome": "passed"}, "teardown": {"duration": 0.00034497000160627067, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_reorder_existing_steps", "lineno": 102, "outcome": "passed", "keywords": ["test_reorder_existing_steps", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005278473981888965, "outcome": "passed"}, "call": {"duration": 0.2657914630253799, "outcome": "passed"}, "teardown": {"duration": 0.00031732101342640817, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drop_at_specific_positions", "lineno": 130, "outcome": "passed", "keywords": ["test_drop_at_specific_positions", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005129875004058704, "outcome": "passed"}, "call": {"duration": 0.21060508702066727, "outcome": "passed"}, "teardown": {"duration": 0.00047970798914320767, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_drag_cancel", "lineno": 157, "outcome": "passed", "keywords": ["test_drag_cancel", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.005245287000434473, "outcome": "passed"}, "call": {"duration": 0.10115242601023056, "outcome": "passed"}, "teardown": {"duration": 0.00041857000906020403, "outcome": "passed"}}, {"nodeid": "tests/integration/test_drag_drop_integration.py::TestDragDropIntegration::test_invalid_mime_data", "lineno": 177, "outcome": "passed", "keywords": ["test_invalid_mime_data", "TestDragDropIntegration", "test_drag_drop_integration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.006249186000786722, "outcome": "passed"}, "call": {"duration": 0.10108442802447826, "outcome": "passed"}, "teardown": {"duration": 0.0004092309973202646, "outcome": "passed"}}], "warnings": [{"message": "cannot collect test class 'TestScenario' because it has a __init__ constructor (from: tests/integration/test_drag_drop_integration.py)", "category": "PytestCollectionWarning", "when": "collect", "filename": "/home/nosky/macro/tests/test_helpers.py", "lineno": 227}]}
</file>

<file path="test_results/test_step_configuration_result.json">
{"created": 1752636301.615554, "duration": 1.790482521057129, "exitcode": 1, "root": "/home/nosky/macro", "environment": {}, "summary": {"failed": 6, "passed": 1, "total": 7, "collected": 7}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_step_configuration.py", "type": "Module"}]}, {"nodeid": "tests/integration/test_step_configuration.py::TestScenario", "outcome": "passed", "result": []}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_image_step_dialog_creation", "type": "Function", "lineno": 46}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_text_search_dialog_with_excel_binding", "type": "Function", "lineno": 74}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_if_condition_dialog_complex_setup", "type": "Function", "lineno": 112}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_coordinate_recording_simulation", "type": "Function", "lineno": 158}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_dialog_validation", "type": "Function", "lineno": 184}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_step_editing", "type": "Function", "lineno": 203}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_error_handling_options", "type": "Function", "lineno": 236}]}, {"nodeid": "tests/integration/test_step_configuration.py", "outcome": "passed", "result": [{"nodeid": "tests/integration/test_step_configuration.py::TestScenario", "type": "Class"}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration", "type": "Class"}]}], "tests": [{"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_image_step_dialog_creation", "lineno": 46, "outcome": "failed", "keywords": ["test_image_step_dialog_creation", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.024844100989867002, "outcome": "passed"}, "call": {"duration": 0.1170911259832792, "outcome": "failed", "crash": {"path": "/home/nosky/macro/tests/integration/test_step_configuration.py", "lineno": 71, "message": "AssertionError: assert <StepType.WAIT_IMAGE: 'wait_image'> == 'wait_image'\n +  where 'wait_image' = <StepType.WAIT_IMAGE: 'wait_image'>.value\n +    where <StepType.WAIT_IMAGE: 'wait_image'> = StepType.WAIT_IMAGE"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 71, "message": "in test_image_step_dialog_creation"}], "longrepr": "tests/integration/test_step_configuration.py:71: in test_image_step_dialog_creation\n    assert step_dict['step_type'] == StepType.WAIT_IMAGE.value\nE   AssertionError: assert <StepType.WAIT_IMAGE: 'wait_image'> == 'wait_image'\nE    +  where 'wait_image' = <StepType.WAIT_IMAGE: 'wait_image'>.value\nE    +    where <StepType.WAIT_IMAGE: 'wait_image'> = StepType.WAIT_IMAGE\n----------------------------- Captured Qt messages -----------------------------\nQtWarningMsg: This plugin does not support propagateSizeHints()"}, "teardown": {"duration": 0.0004891989810857922, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_text_search_dialog_with_excel_binding", "lineno": 74, "outcome": "failed", "keywords": ["test_text_search_dialog_with_excel_binding", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.0001747639907989651, "outcome": "passed"}, "call": {"duration": 0.000890194991370663, "outcome": "failed", "crash": {"path": "/home/nosky/macro/src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "NameError: name 'QWidget' is not defined"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 82, "message": "in test_text_search_dialog_with_excel_binding"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 32, "message": "in __init__"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "in init_ui"}], "longrepr": "tests/integration/test_step_configuration.py:82: in test_text_search_dialog_with_excel_binding\n    dialog = TextSearchStepDialog(excel_columns=excel_columns)\nsrc/ui/dialogs/text_search_step_dialog.py:32: in __init__\n    self.init_ui()\nsrc/ui/dialogs/text_search_step_dialog.py:74: in init_ui\n    self.fixed_text_widget = QWidget()\nE   NameError: name 'QWidget' is not defined"}, "teardown": {"duration": 0.0002888650051318109, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_if_condition_dialog_complex_setup", "lineno": 112, "outcome": "failed", "keywords": ["test_if_condition_dialog_complex_setup", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00019962899386882782, "outcome": "passed"}, "call": {"duration": 0.0005808589921798557, "outcome": "failed", "crash": {"path": "/home/nosky/macro/src/ui/dialogs/if_condition_step_dialog.py", "lineno": 277, "message": "TypeError: index 0 has type 'tuple' but 'str' is expected"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 118, "message": "in test_if_condition_dialog_complex_setup"}, {"path": "src/ui/dialogs/if_condition_step_dialog.py", "lineno": 241, "message": "in __init__"}, {"path": "src/ui/dialogs/if_condition_step_dialog.py", "lineno": 277, "message": "in init_ui"}], "longrepr": "tests/integration/test_step_configuration.py:118: in test_if_condition_dialog_complex_setup\n    dialog = IfConditionStepDialog(excel_columns=excel_columns)\nsrc/ui/dialogs/if_condition_step_dialog.py:241: in __init__\n    self.init_ui()\nsrc/ui/dialogs/if_condition_step_dialog.py:277: in init_ui\n    self.condition_type_combo.addItems([\nE   TypeError: index 0 has type 'tuple' but 'str' is expected"}, "teardown": {"duration": 0.0001856969902291894, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_coordinate_recording_simulation", "lineno": 158, "outcome": "failed", "keywords": ["test_coordinate_recording_simulation", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00014237299910746515, "outcome": "passed"}, "call": {"duration": 0.00010810099774971604, "outcome": "failed", "crash": {"path": "/home/nosky/macro/tests/integration/test_step_configuration.py", "lineno": 180, "message": "assert False"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 180, "message": "in test_coordinate_recording_simulation"}], "longrepr": "tests/integration/test_step_configuration.py:180: in test_coordinate_recording_simulation\n    assert results['success']\nE   assert False"}, "teardown": {"duration": 0.00010320899309590459, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_dialog_validation", "lineno": 184, "outcome": "failed", "keywords": ["test_dialog_validation", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00013367398059926927, "outcome": "passed"}, "call": {"duration": 0.10393847801606171, "outcome": "failed", "crash": {"path": "/home/nosky/macro/tests/integration/test_step_configuration.py", "lineno": 198, "message": "AttributeError: 'WaitImageStepDialog' object has no attribute 'button_box'"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 198, "message": "in test_dialog_validation"}], "longrepr": "tests/integration/test_step_configuration.py:198: in test_dialog_validation\n    ok_button = dialog.button_box.button(dialog.button_box.Ok)\nE   AttributeError: 'WaitImageStepDialog' object has no attribute 'button_box'\n----------------------------- Captured Qt messages -----------------------------\nQtWarningMsg: This plugin does not support propagateSizeHints()"}, "teardown": {"duration": 0.0003361229901202023, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_step_editing", "lineno": 203, "outcome": "failed", "keywords": ["test_step_editing", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00016349999350495636, "outcome": "passed"}, "call": {"duration": 0.00023993299691937864, "outcome": "failed", "crash": {"path": "/home/nosky/macro/src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "NameError: name 'QWidget' is not defined"}, "traceback": [{"path": "tests/integration/test_step_configuration.py", "lineno": 214, "message": "in test_step_editing"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 32, "message": "in __init__"}, {"path": "src/ui/dialogs/text_search_step_dialog.py", "lineno": 74, "message": "in init_ui"}], "longrepr": "tests/integration/test_step_configuration.py:214: in test_step_editing\n    dialog = TextSearchStepDialog(step=initial_step)\nsrc/ui/dialogs/text_search_step_dialog.py:32: in __init__\n    self.init_ui()\nsrc/ui/dialogs/text_search_step_dialog.py:74: in init_ui\n    self.fixed_text_widget = QWidget()\nE   NameError: name 'QWidget' is not defined"}, "teardown": {"duration": 0.000176066008862108, "outcome": "passed"}}, {"nodeid": "tests/integration/test_step_configuration.py::TestStepConfiguration::test_error_handling_options", "lineno": 236, "outcome": "passed", "keywords": ["test_error_handling_options", "TestStepConfiguration", "test_step_configuration.py", "integration", "tests", "macro", ""], "setup": {"duration": 0.00014642099267803133, "outcome": "passed"}, "call": {"duration": 0.10420315599185415, "outcome": "passed"}, "teardown": {"duration": 0.00018910999642685056, "outcome": "passed"}}], "warnings": [{"message": "cannot collect test class 'TestScenario' because it has a __init__ constructor (from: tests/integration/test_step_configuration.py)", "category": "PytestCollectionWarning", "when": "collect", "filename": "/home/nosky/macro/tests/test_helpers.py", "lineno": 227}]}
</file>

<file path=".mcp.json">
{
  "mcpServers": {
    "vooster-ai": {
      "command": "npx",
      "args": [
        "-y",
        "--package=@vooster/mcp@latest",
        "vooster-ai",
        "--api-key=ak_arb850vwbd36cacmyp86xiah"
      ]
    },
    "playwright": {
      "command": "npx",
      "args": [
        "@playwright/mcp@latest"
      ]
    }
  }
}
</file>

<file path="prd.md">
# ì œí’ˆ ìš”êµ¬ì‚¬í•­ ë¬¸ì„œ(PRD)  
ì—‘ì…€ ê¸°ë°˜ ì‘ì—… ìë™í™” ë§¤í¬ë¡œ ë°ìŠ¤í¬íƒ‘ ì•±  

## 1. ê°œìš”  
ë³¸ ë°ìŠ¤í¬íƒ‘ ì•±ì€ ì—‘ì…€(Excel) íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ ì‚¬ìš©ìê°€ ì •ì˜í•œ ìˆœì„œëŒ€ë¡œ ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œÂ·í™”ë©´ ì¸ì‹ ë™ì‘ì„ ìë™ ìˆ˜í–‰í•˜ê³  ì™„ë£Œ ì—¬ë¶€ë¥¼ í‘œì‹œí•œë‹¤. ë¹„ê°œë°œì ì˜ë£Œì¸ì´ ë°˜ë³µì ì¸ ì»´í“¨í„° ì‘ì—…ì„ ì½”ë“œ ì‘ì„± ì—†ì´ ìë™í™”í•˜ì—¬ ì—…ë¬´ íš¨ìœ¨ì„ ê·¹ëŒ€í™”í•  ìˆ˜ ìˆë„ë¡ ì§ê´€ì  GUIë¥¼ ì œê³µí•œë‹¤.

## 2. ë¬¸ì œ ì •ì˜  
- ì˜ë£Œ í˜„ì¥Â·ì‚¬ë¬´ì‹¤ì˜ ë°˜ë³µì  ì „ì‚° ì—…ë¬´(í™˜ì ì •ë³´ ì…ë ¥, ë³´ê³ ì„œ ì—…ë¡œë“œ ë“±)ëŠ” ìˆ˜ì‘ì—… ì‹œê°„ì´ ê¸¸ê³  ì˜¤ë¥˜ ë°œìƒë¥ ì´ ë†’ìŒ.  
- ë³‘ì› ì „ì‚°íŒ€ ì§€ì›ì„ ë°›ì§€ ëª»í•˜ëŠ” ê°œì¸Â·ì†Œê·œëª¨ ê¸°ê´€ì€ ë³„ë„ ìë™í™” ì†”ë£¨ì…˜ ë„ì…ì´ ì–´ë ¤ì›€.  
- ì—‘ì…€ì— ì •ë¦¬ëœ ì‘ì—… ëª©ë¡ì„ ë°”íƒ•ìœ¼ë¡œ ìë™í™”í•˜ë ¤ í•´ë„ RPAÂ·ë§¤í¬ë¡œ íˆ´ì€ ë³µì¡í•œ ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±ì´ í•„ìš”.  

## 3. ëª©í‘œ ë° ì§€í‘œ  
- 1ì°¨ ëª©í‘œ: ì—‘ì…€â†’GUI êµ¬ì„±â†’ë§¤í¬ë¡œ ì‹¤í–‰ê¹Œì§€ 30ë¶„ ì´ë‚´ ë‹¬ì„±(ë¹„ê°œë°œì ê¸°ì¤€).  
- 2ì°¨ ëª©í‘œ: ìˆ˜ì‘ì—… ëŒ€ë¹„ ì—…ë¬´ ì‹œê°„ 50% ì´ìƒ ë‹¨ì¶•, ì˜¤ë¥˜ 90% ì´ìƒ ê°ì†Œ.  
- ì„±ê³µ ì§€í‘œ  
  - Onboarding ì™„ë£Œ ì‹œê°„ â‰¤30ë¶„ ì‚¬ìš©ì ë¹„ìœ¨ 80%  
  - ì›”ê°„ í™œì„± ì‚¬ìš©ì(MAU) â‰¥500 ì˜ë£Œì¸  
  - ì‘ì—…ë‹¹ í‰ê·  ì†Œìš” ì‹œê°„ 50%â†“  
  - ìë™í™” ì‹¤íŒ¨ìœ¨ â‰¤5%  

## 4. ëŒ€ìƒ ì‚¬ìš©ì  
### ì£¼ìš” ì‚¬ìš©ì  
- ì§êµ°: ê°„í˜¸ì‚¬Â·ì˜ë¬´ê¸°ë¡ì‚¬Â·ì˜ì‚¬Â·í–‰ì •ì›  
- íŠ¹ì„±: ì½”ë”© ì§€ì‹ ì—†ìŒ, ì—‘ì…€ ì‚¬ìš© ëŠ¥ìˆ™, ë°˜ë³µì…ë ¥Â·ì—…ë¡œë“œ ì—…ë¬´ ë¹ˆë²ˆ  
- ë‹ˆì¦ˆ: í´ë¦­Â·í‚¤ ì…ë ¥ ìë™í™”, ìƒíƒœ í™•ì¸, ì˜¤ë¥˜ ìµœì†Œí™”  

### ë¶€ìˆ˜ ì‚¬ìš©ì  
- ë³‘ì› IT ë‹´ë‹¹ì(ë°°í¬Â·íŒ¨í‚¤ì§•)  
- ì»¨ì„¤í„´íŠ¸(RPA PoC)  

## 5. ì‚¬ìš©ì ìŠ¤í† ë¦¬  
- â€œê°„í˜¸ì‚¬ë¡œì„œ í™˜ì 100ëª…ì˜ ê²€ì‚¬ ê²°ê³¼ë¥¼ ë³‘ì› í¬í„¸ì— ë“±ë¡í•˜ë ¤ê³  ì—‘ì…€ ëª©ë¡ì„ ë¶ˆëŸ¬ì™€ í´ë¦­Â·ì…ë ¥ì„ ìë™í™”í•˜ì—¬ ì‹œê°„ì„ ì ˆì•½í•˜ê³  ì‹¶ë‹¤.â€  
- â€œì˜ë¬´ê¸°ë¡ì‚¬ë¡œì„œ ì™„ë£Œë˜ì§€ ì•Šì€ í–‰ë§Œ ì¬ì‹¤í–‰í•´ ëˆ„ë½ ì—†ì´ ê¸°ë¡ì„ ë§ˆê°í•˜ê³  ì‹¶ë‹¤.â€  
- â€œí–‰ì •ì›ìœ¼ë¡œì„œ íŠ¹ì • ë²„íŠ¼ ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚˜ì•¼ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ë„ë¡ ì¡°ê±´ë¶€ ë¡œì§ì„ ì„¤ì •í•˜ê³  ì‹¶ë‹¤.â€  

## 6. ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­  
### 6.1 í•µì‹¬ ê¸°ëŠ¥  
1. ì—‘ì…€ ì—°ë™  
   - íŒŒì¼ ì„ íƒ í›„ ì‹œíŠ¸Â·ì—´ ë§¤í•‘ UI ì œê³µ  
   - ì§€ì • ì—´ì˜ ë°ì´í„° ë¯¸ë¦¬ë³´ê¸° ë° íƒ€ì… ê²€ì¦  
   - ì‹¤í–‰ í›„ ìƒíƒœ ì—´ ìë™ ì—…ë°ì´íŠ¸(ì™„ë£Œ/ì‹¤íŒ¨/ì‚¬ìš©ì ì •ì˜ í…ìŠ¤íŠ¸)  
   - ìˆ˜ë½ ê¸°ì¤€: ì˜ëª»ëœ ê²½ë¡œÂ·ì‹œíŠ¸ ì§€ì • ì‹œ ì˜¤ë¥˜ ì•Œë¦¼, ìƒíƒœ ì—´ì´ ì—†ëŠ” ê²½ìš° ìë™ ìƒì„±  

2. GUI ê¸°ë°˜ ì‘ì—… í¸ì§‘ê¸°  
   - Drag & Drop ë°©ì‹ ë‹¨ê³„ í¸ì§‘ íŒ¨ë„  
   - ì§€ì› ë™ì‘  
     â‘  ë§ˆìš°ìŠ¤: ì´ë™Â·í´ë¦­Â·ë”ë¸”í´ë¦­Â·ë“œë˜ê·¸  
     â‘¡ í‚¤ë³´ë“œ: í…ìŠ¤íŠ¸Â·íŠ¹ìˆ˜í‚¤Â·ë‹¨ì¶•í‚¤(ì¡°í•©)  
â‘¢ í™”ë©´ ì¸ì‹: ì´ë¯¸ì§€ ì„œì¹˜(OpenCV), OCR(EasyOCR)
â‘£ ë™ì  í…ìŠ¤íŠ¸ ê²€ìƒ‰ ë° í´ë¦­(Dynamic Text Search & Click)
   - ê°„í¸í•œ í™”ë©´ ì˜ì—­ ì„¤ì •: ì‚¬ìš©ìê°€ 'ì˜ì—­ ì§€ì •' ë²„íŠ¼ì„ ëˆ„ë¥´ë©´, í™”ë©´ì´ ë°˜íˆ¬ëª…í•˜ê²Œ ë³€í•˜ë©° ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸í•˜ì—¬ ê²€ìƒ‰í•  ì‚¬ê°í˜• ì˜ì—­ì„ ì†ì‰½ê²Œ ì§€ì •í•  ìˆ˜ ìˆìŒ(í™”ë©´ ìº¡ì²˜ ë„êµ¬ì²˜ëŸ¼)
   - ì§€ì •ëœ ì˜ì—­ì˜ ì¢Œí‘œëŠ” ì‘ì—… ë‹¨ê³„ì— ìë™ìœ¼ë¡œ ì €ì¥
   - ì—‘ì…€ ë°ì´í„° ê¸°ë°˜ í…ìŠ¤íŠ¸ ê²€ìƒ‰ ë° í´ë¦­: ì‚¬ìš©ìëŠ” ì‘ì—… íë¦„ì— "ë™ì  í…ìŠ¤íŠ¸ ì°¾ê¸°" ë‹¨ê³„ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŒ
   - ì´ ë‹¨ê³„ì—ì„œ ì—‘ì…€ì˜ íŠ¹ì • ì—´(e.g., 'ì´ë¦„' ë˜ëŠ” 'ë³‘ë ¥ë²ˆí˜¸' ì—´)ì„ ì§€ì •
   - ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œ, í”„ë¡œê·¸ë¨ì€ ë¯¸ë¦¬ ì§€ì •ëœ í™”ë©´ ì˜ì—­ ì•ˆì—ì„œ í˜„ì¬ ì‘ì—… ìˆœì„œì— í•´ë‹¹í•˜ëŠ” ì—‘ì…€ì˜ í…ìŠ¤íŠ¸(e.g., "í™ê¸¸ë™")ë¥¼ OCR(EasyOCR)ë¡œ ì°¾ì•„ëƒ„
   - í•´ë‹¹ í…ìŠ¤íŠ¸ë¥¼ ì°¾ìœ¼ë©´ ê·¸ ì¢Œí‘œë¥¼ ìë™ìœ¼ë¡œ í´ë¦­í•˜ê±°ë‚˜, ë‹¤ìŒ ë™ì‘ì˜ ê¸°ì¤€ì ìœ¼ë¡œ ì‚¬ìš©
â‘¤ íë¦„ ì œì–´: DelayÂ·LoopÂ·If(ì¡°ê±´)
   - ì—‘ì…€ ë³€ìˆ˜ ë°”ì¸ë”©(ì˜ˆ: {{ì´ë¦„}}) í…œí”Œë¦¿ ì§€ì›  
   - ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°Â·í…ŒìŠ¤íŠ¸ ì‹¤í–‰  
   - ìˆ˜ë½ ê¸°ì¤€: ë‹¨ê³„ ì¶”ê°€Â·ì‚­ì œÂ·ìˆœì„œë³€ê²½ì´ 3í´ë¦­ ì´ë‚´, ë¯¸ë¦¬ë³´ê¸° ì˜¤ë¥˜ìœ¨ â‰¤5%  

3. ë§¤í¬ë¡œ ì‹¤í–‰/ì œì–´  
   - í–‰ ë‹¨ìœ„ ìˆœì°¨ ì‹¤í–‰, â€œë¯¸ì™„ë£Œë§Œ ì‹¤í–‰â€ ì˜µì…˜  
   - ì¼ì‹œì •ì§€Â·ê°•ì œì¢…ë£Œ í•«í‚¤(ê¸°ë³¸ F9, Esc)  
   - ì‹¤í–‰ ë¡œê·¸: í–‰ ë²ˆí˜¸, ë‹¨ê³„, ì„±ê³µ/ì‹¤íŒ¨, ì†Œìš”ì‹œê°„(ms) CSV ì €ì¥  
   - ìˆ˜ë½ ê¸°ì¤€: 10,000í–‰ ì²˜ë¦¬ ì‹œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì—†ì´ ì™„ë£Œ  

### 6.2 ë³´ì¡° ê¸°ëŠ¥  
- ì‘ì—… í…œí”Œë¦¿ ê°¤ëŸ¬ë¦¬(ë¡œê·¸ì¸ ë¶ˆí•„ìš”, ë¡œì»¬ ì €ì¥)  
- ë‹¤êµ­ì–´ UI(í•œêµ­ì–´ ê¸°ë³¸, ì˜ì–´ ì„ íƒ)  
- ìë™ ì—…ë°ì´íŠ¸ ì²´í¬  
- ë‹¤í¬ëª¨ë“œ  

### 6.3 Nice-to-Have ì œì•ˆ  
- ìŒì„± ëª…ë ¹ìœ¼ë¡œ ë§¤í¬ë¡œ ì‹œì‘/ì •ì§€  
- ì‘ì—… ìŠ¤ì¼€ì¤„ëŸ¬(íŠ¹ì • ì‹œê°„ì— ìë™ ì‹¤í–‰)  
- í´ë¼ìš°ë“œ ë™ê¸°í™”ë¡œ ì—¬ëŸ¬ PC ì„¤ì • ê³µìœ   
- ì˜¤ë¥˜ ë°œìƒ ì‹œ ìŠ¤í¬ë¦°ìƒ· ìë™ ì²¨ë¶€ ë¦¬í¬íŠ¸  

## 7. ë¹„ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­  
- ì„±ëŠ¥: 1ë‹¨ê³„ ì‹¤í–‰ ì‘ë‹µ â‰¤300ms, 500ë‹¨ê³„/í–‰ ì²˜ë¦¬ ì‹œ CPU ì‚¬ìš©ë¥  50%â†“  
- ë³´ì•ˆ: ë¡œì»¬ íŒŒì¼Â·ìŠ¤í¬ë¦½íŠ¸ ì•”í˜¸í™” ì €ì¥(AES-256), ë„¤íŠ¸ì›Œí¬ ì „ì†¡ ì—†ìŒ ê¸°ë³¸  
- ì‚¬ìš©ì„±: ì˜¨ë³´ë”© íŠœí† ë¦¬ì–¼ 5ë¶„, UI ì ‘ê·¼ì„± WCAG 2.1 AA  
- í™•ì¥ì„±: í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜ë¡œ ìƒˆ ë™ì‘ íƒ€ì… ì¶”ê°€ ê°€ëŠ¥  
- í˜¸í™˜ì„±: Windows 10/11 64bit, í•´ìƒë„ 1280Ã—720 ì´ìƒ  

## 8. ê¸°ìˆ  ê³ ë ¤ì‚¬í•­  
- ì–¸ì–´: Python 3.8+  
- GUI: PyQt5(ê¶Œì¥), Fallback Tkinter  
- ìë™í™”: PyAutoGUI  
- ì´ë¯¸ì§€: OpenCV 4.x  
- OCR: EasyOCR
- ì—‘ì…€: pandas, openpyxl  
- íŒ¨í‚¤ì§•: PyInstaller(onefile)  
- êµ¬ì¡°: MVC íŒ¨í„´, ì‘ì—… ë‹¨ê³„ëŠ” JSON ì •ì˜ ì €ì¥
- ë©€í‹°/ì‹±ê¸€ ëª¨ë‹ˆí„° í™˜ê²½ ìë™ ì¸ì‹ ë° ì£¼ ëª¨ë‹ˆí„° ê¸°ì¤€ ë™ì‘ ë³´ì¥
- í†µí•©: ë³‘ì› ì‚¬ë‚´ë§ ì œí•œ í™˜ê²½ ê³ ë ¤, ì¸í„°ë„· í•„ìš” ì—†ìŒ  

## 9. ì„±ê³µ ì§€í‘œ  
- ê¸°ëŠ¥ ì§€í‘œ: ë§¤í¬ë¡œ ì™„ë£Œìœ¨ â‰¥95%, ë¡œê·¸ ì˜¤ë¥˜ìœ¨ â‰¤2%  
- ì‚¬ìš©ì ì§€í‘œ: NPSâ‰¥50, ì¬ë°©ë¬¸ë¥  70%  
- ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œ: ë¼ì´ì„ ìŠ¤ ì—…ì…€ ë¹„ìœ¨ 20%  
- ê¸°ìˆ  ì§€í‘œ: í‰ê·  ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ â‰¤500MB, í¬ë˜ì‹œ 0.1/ì„¸ì…˜â†“  

## 10. ì¼ì • ë° ë§ˆì¼ìŠ¤í†¤  
- 1ë‹¨ê³„(MVP, 3ê°œì›”)  
  - ì—‘ì…€ ë¶ˆëŸ¬ì˜¤ê¸°, ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œ ë™ì‘, ìˆœì°¨ ì‹¤í–‰, ìƒíƒœ ì—…ë°ì´íŠ¸  
- 2ë‹¨ê³„(ê³ ë„í™”, +2ê°œì›”)  
  - ì´ë¯¸ì§€ ì„œì¹˜, OCR, ì¡°ê±´Â·ë°˜ë³µ, ë¡œê·¸ ë·°ì–´  
- 3ë‹¨ê³„(í™•ì¥, +2ê°œì›”)  
  - í…œí”Œë¦¿ ê°¤ëŸ¬ë¦¬, ë‹¤êµ­ì–´, ìë™ ì—…ë°ì´íŠ¸, ë‹¤í¬ëª¨ë“œ  
- 4ë‹¨ê³„(NTH, +3ê°œì›”)  
  - ìŒì„± ëª…ë ¹, ìŠ¤ì¼€ì¤„ëŸ¬, í´ë¼ìš°ë“œ ì‹±í¬  

## 11. ìœ„í—˜ ë° ì™„í™”  
- ê¸°ìˆ : í™”ë©´ í•´ìƒë„ ë° ë©€í‹°/ì‹±ê¸€ ëª¨ë‹ˆí„° í™˜ê²½ì—ì„œ ì´ë¯¸ì§€ ë§¤ì¹­Â·ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥ â†’ DPI ìŠ¤ì¼€ì¼ ë³´ì • ì•Œê³ ë¦¬ì¦˜ ë° ë©€í‹° ëª¨ë‹ˆí„° íƒì§€, ì¢Œí‘œ ì¼ì¹˜ ë¡œì§ ì ìš©
- ë¹„ì¦ˆë‹ˆìŠ¤: ì˜ë£Œê¸°ê´€ ë³´ì•ˆ ì •ì±…ìœ¼ë¡œ ì‹¤í–‰ íŒŒì¼ ì°¨ë‹¨ â†’ ì˜¤í”„ë¼ì¸ ì„¤ì¹˜ íŒ¨í‚¤ì§€Â·ì„œëª… ë°°í¬  
- ì‚¬ìš©ì: ë¹„ê°œë°œì í˜¼ë€ â†’ ì¸ì•± ê°€ì´ë“œÂ·íˆ´íŒÂ·ì˜ìƒ ì œê³µ  

## 12. í–¥í›„ ê³ ë ¤ì‚¬í•­  
- MacÂ·ë¦¬ëˆ…ìŠ¤ ë²„ì „  
- AI ê¸°ë°˜ ìë™ ë‹¨ê³„ ì¶”ì²œ(ì‚¬ìš© íŒ¨í„´ í•™ìŠµ)  
- HIPAAÂ·GDPR ë“± ì˜ë£Œ ë°ì´í„° ê·œì • ì¤€ìˆ˜ ëª¨ë“ˆ  
- SaaS RPA ì—°ê³„ API ê³µê°œ  

(ë¬¸ì„œ ê¸¸ì´: ì•½ 4,100ì)
</file>

<file path="requirements.txt">
# Core GUI Framework
PyQt5>=5.15.0

# Data Processing
pandas>=1.3.0
openpyxl>=3.0.0
numpy>=1.21.0

# Screen Automation
pyautogui>=0.9.53
pillow>=8.3.0
opencv-python>=4.5.0

# Screen Information
screeninfo>=0.8.0

# Image Processing
mss>=6.1.0

# OCR (Optical Character Recognition)
easyocr>=1.7.0

# Security
cryptography>=3.4.0

# Testing (optional)
pytest>=6.2.0
pytest-qt>=4.0.0

# Development tools (optional)
black>=21.0
flake8>=3.9.0
</file>

<file path="run_main.py">
#!/usr/bin/env python3
"""
ì‹¤ì œ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
ëª¨ë“  import ë¬¸ì œë¥¼ í•´ê²°í•˜ì—¬ ì‹¤í–‰
"""

import sys
import os
from pathlib import Path

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
project_root = Path(__file__).parent.absolute()
src_path = project_root / "src"

# Python ê²½ë¡œì— ì¶”ê°€
sys.path.insert(0, str(src_path))
sys.path.insert(0, str(project_root))

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
if sys.platform == 'win32':
    os.environ['QT_QPA_PLATFORM'] = 'windows'
else:
    os.environ['QT_QPA_PLATFORM'] = 'xcb'
os.environ['PYTHONPATH'] = f"{project_root}:{src_path}"
os.environ['PYTHONIOENCODING'] = 'utf-8'

# ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½í•˜ê¸° ìœ„í•œ monkey patching
def patch_imports():
    """ëª¨ë“  ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½"""
    
    # settings.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    settings_file = src_path / "config" / "settings.py"
    content = settings_file.read_text(encoding='utf-8')
    content = content.replace("from ..utils.encryption", "from utils.encryption")
    content = content.replace("from ..logger.app_logger", "from logger.app_logger")
    settings_file.write_text(content, encoding='utf-8')
    
    # main_window.pyì˜ ìƒëŒ€ import ìˆ˜ì •  
    main_window_file = src_path / "ui" / "main_window.py"
    if main_window_file.exists():
        content = main_window_file.read_text(encoding='utf-8')
        content = content.replace("from ..config.settings", "from config.settings")
        content = content.replace("from ..logger.app_logger", "from logger.app_logger")
        content = content.replace("from .widgets.excel_widget", "from ui.widgets.excel_widget")
        content = content.replace("from .widgets.macro_editor", "from ui.widgets.macro_editor")
        content = content.replace("from .widgets.execution_widget", "from ui.widgets.execution_widget")
        main_window_file.write_text(content, encoding='utf-8')
    
    # excel_widget.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    excel_widget_file = src_path / "ui" / "widgets" / "excel_widget.py"
    if excel_widget_file.exists():
        content = excel_widget_file.read_text(encoding='utf-8')
        content = content.replace("from ...excel.excel_manager", "from excel.excel_manager")
        content = content.replace("from ...config.settings", "from config.settings")
        content = content.replace("from ...logger.app_logger", "from logger.app_logger")
        excel_widget_file.write_text(content, encoding='utf-8')
    
    # macro_editor.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    macro_editor_file = src_path / "ui" / "widgets" / "macro_editor.py"
    if macro_editor_file.exists():
        content = macro_editor_file.read_text(encoding='utf-8')
        content = content.replace("from ...core", "from core")
        content = content.replace("from ..dialogs", "from ui.dialogs")
        macro_editor_file.write_text(content, encoding='utf-8')
    
    # execution_widget.pyì˜ ìƒëŒ€ import ìˆ˜ì •
    execution_widget_file = src_path / "ui" / "widgets" / "execution_widget.py"
    if execution_widget_file.exists():
        content = execution_widget_file.read_text(encoding='utf-8')
        content = content.replace("from ...automation", "from automation")
        content = content.replace("from ...core", "from core")
        content = content.replace("from ...config", "from config")
        content = content.replace("from ...logger", "from logger")
        execution_widget_file.write_text(content, encoding='utf-8')
    
    # ë‹¤ë¥¸ íŒŒì¼ë“¤ë„ ìˆ˜ì •
    for py_file in src_path.rglob("*.py"):
        try:
            content = py_file.read_text(encoding='utf-8')
            if "from .." in content:
                # ìƒëŒ€ importë¥¼ ì ˆëŒ€ importë¡œ ë³€ê²½
                content = content.replace("from ...", "from ")
                content = content.replace("from ..", "from ")
                py_file.write_text(content, encoding='utf-8')
        except:
            pass

# Import ìˆ˜ì • ì ìš©
print("Import ê²½ë¡œ ìˆ˜ì • ì¤‘...")
patch_imports()
print("Import ê²½ë¡œ ìˆ˜ì • ì™„ë£Œ!")

# ì´ì œ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
try:
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt
    from PyQt5.QtGui import QFont
    
    # High DPI ì§€ì› - QApplication ìƒì„± ì „ì— ì„¤ì •
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”
    app = QApplication(sys.argv)
    app.setApplicationName("Excel Macro Automation")
    
    # í•œê¸€ í°íŠ¸ ì„¤ì •
    font = QFont("Nanum Gothic", 10)
    app.setFont(font)
    
    # ë©”ì¸ ìœˆë„ìš° import ë° ì‹¤í–‰
    from ui.main_window import MainWindow
    from config.settings import Settings
    from logger.app_logger import setup_logger
    
    # ë¡œê±° ì„¤ì •
    logger = setup_logger()
    logger.info("Starting Excel Macro Automation Application")
    
    # ì„¤ì • ì´ˆê¸°í™”
    settings = Settings()
    
    # ë©”ì¸ ìœˆë„ìš° ìƒì„± ë° í‘œì‹œ
    window = MainWindow(settings)
    window.setWindowTitle("Excel ê¸°ë°˜ ì‘ì—… ìë™í™” ë§¤í¬ë¡œ")
    window.show()
    
    print("\nâœ“ Excel Macro Automation ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤!")
    print("âœ“ ëª¨ë“  GUI ì»´í¬ë„ŒíŠ¸ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.")
    print("\nê¸°ëŠ¥:")
    print("- Excel íƒ­: íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°, ì‹œíŠ¸ ì„ íƒ, ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°")
    print("- Editor íƒ­: ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë§¤í¬ë¡œ í¸ì§‘")
    print("- Run íƒ­: ë§¤í¬ë¡œ ì‹¤í–‰ ë° ëª¨ë‹ˆí„°ë§")
    print("\nì°½ì„ ë‹«ìœ¼ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.")
    
    # ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰
    sys.exit(app.exec_())
    
except Exception as e:
    print(f"\nì˜¤ë¥˜ ë°œìƒ: {e}")
    print("\nìì„¸í•œ ì˜¤ë¥˜ ì •ë³´:")
    import traceback
    traceback.print_exc()
    
    print("\në””ë²„ê¹… ì •ë³´:")
    print(f"Project root: {project_root}")
    print(f"Src path: {src_path}")
    print(f"Python path: {sys.path[:3]}")
</file>

<file path="trd.md">
# Technical Requirements Document (TRD)

## 1. Executive Technical Summary
- **í”„ë¡œì íŠ¸ ê°œìš”**  
  Python ê¸°ë°˜ ë°ìŠ¤í¬íƒ‘ ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ, ì—‘ì…€ íŒŒì¼ì˜ ì‘ì—… ëª©ë¡ì„ GUIë¡œ ë¡œë“œÂ·í¸ì§‘í•˜ê³  PyAutoGUI/OpenCV/Tesseractë¥¼ ì´ìš©í•´ ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œÂ·í™”ë©´ ì¸ì‹ ë§¤í¬ë¡œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤. MVC íŒ¨í„´ì„ ì ìš©í•´ ìœ ì§€ ë³´ìˆ˜ì„±ê³¼ í™•ì¥ì„±ì„ í™•ë³´í•˜ë©°, ì˜¤í”„ë¼ì¸ í™˜ê²½ì—ì„œ ë‹¨ì¼ íŒŒì¼ ë°°í¬ ë°©ì‹(PyInstaller)ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

- **í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ**  
Python 3.8+, PyQt5(Tkinter ëŒ€ì²´), PyAutoGUI, OpenCV 4.x, EasyOCR, pandas, openpyxl, PyInstaller

- **ì£¼ìš” ê¸°ìˆ  ëª©í‘œ**  
  â€¢ 1ë‹¨ê³„ ì‹¤í–‰ ì‘ë‹µ â‰¤300ms  
  â€¢ 10,000í–‰ ì²˜ë¦¬ ì‹œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì—†ì´ ì™„ë£Œ  
  â€¢ CPU ì‚¬ìš©ë¥  500ë‹¨ê³„/í–‰ ì²˜ë¦¬ ì‹œ 50% ì´í•˜ ìœ ì§€  
  â€¢ ìë™í™” ì‹¤íŒ¨ìœ¨ â‰¤5%  

- **ì¤‘ìš” ê°€ì • ì‚¬í•­**  
  â€¢ Windows 10/11 64bit ì „ìš©  
  â€¢ ì¸í„°ë„· ì—°ê²° ì—†ì´ ì˜¤í”„ë¼ì¸ ì‹¤í–‰  
  â€¢ ë‹¨ì¼ ì‚¬ìš©ì í™˜ê²½(ë¡œì»¬ íŒŒì¼ ì €ì¥)  
  â€¢ DPI ìŠ¤ì¼€ì¼ & ë©€í‹° ëª¨ë‹ˆí„° í™˜ê²½ ìë™ ì¸ì‹  

---

## 2. Tech Stack

| Category         | Technology / Library   | Reasoning (ì„ íƒ ì´ìœ )                                    |
| ---------------- | ---------------------- | ------------------------------------------------------- |
| ì–¸ì–´             | Python 3.8+            | í’ë¶€í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ ì»¤ë®¤ë‹ˆí‹°, ë¹ ë¥¸ ê°œë°œ ì†ë„              |
| GUI í”„ë ˆì„ì›Œí¬   | PyQt5                  | ì§ê´€ì  WYSIWYG ì—ë””í„°, í’ë¶€í•œ ìœ„ì ¯, ë°˜ì‘í˜• ë ˆì´ì•„ì›ƒ ì§€ì›  |
| GUI ëŒ€ì²´         | Tkinter                | PyQt5 ë¹„ì„¤ì¹˜ ì‹œ ê¸°ë³¸ ì œê³µ, ìµœì†Œ ê¸°ëŠ¥ ë³´ì¥                |
| ìë™í™” ì—”ì§„      | PyAutoGUI              | ë§ˆìš°ìŠ¤/í‚¤ë³´ë“œ ì œì–´, í¬ë¡œìŠ¤ í”Œë«í¼ ì§€ì›                   |
| ì´ë¯¸ì§€ ì²˜ë¦¬      | OpenCV 4.x             | ê³ ì„±ëŠ¥ ì´ë¯¸ì§€ ì„œì¹˜ ë° DPI ìŠ¤ì¼€ì¼ ë³´ì •                     |
| OCR ì—”ì§„         | EasyOCR                | í•œê¸€ ì¸ì‹ ì •í™•ë„ê°€ ë†’ê³ , Tesseract ëŒ€ë¹„ ì‹¤íŒ¨ìœ¨ì´ ë‚®ìŒ. íŒŒì´ì¬ ì—°ë™ë„ ë§¤ìš° ê°„í¸í•¨. |
| ì—‘ì…€ ì²˜ë¦¬        | pandas, openpyxl       | ëŒ€ìš©ëŸ‰ ì—‘ì…€ ë°ì´í„° ì²˜ë¦¬, ì‹œíŠ¸Â·ì…€ CRUD ì§€ì›               |
| íŒ¨í‚¤ì§•           | PyInstaller (onefile)  | ë‹¨ì¼ ì‹¤í–‰ íŒŒì¼ ë°°í¬, ì˜¤í”„ë¼ì¸ ì„¤ì¹˜ ì§€ì›                 |
| êµ¬ì¡° íŒ¨í„´        | MVC                    | ì—­í•  ë¶„ë¦¬ë¡œ ìœ ì§€ë³´ìˆ˜ì„±Â·í™•ì¥ì„± í™•ë³´                        |
| ì„¤ì •Â·ì •ì˜ ì €ì¥   | JSON                   | ê°€ë³ê³  ê°€ë…ì„± ë†’ì€ ë§¤í¬ë¡œ ë‹¨ê³„ ì •ì˜ íŒŒì¼                  |

---

## 3. System Architecture Design

### Top-Level Building Blocks
- UI Layer (PyQt5/Tkinter)  
  â€¢ ì‘ì—… í¸ì§‘ê¸°, ì‹œíŠ¸Â·ì—´ ë§¤í•‘, ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°  
- Core Controller  
  â€¢ ì‚¬ìš©ì ì¸í„°ë™ì…˜ ì²˜ë¦¬, ë§¤í¬ë¡œ ë‹¨ê³„ ì¡°í•©, ìƒíƒœ ê´€ë¦¬  
- Automation Engine  
  â€¢ PyAutoGUI ê¸°ë°˜ ë™ì‘ ì‹¤í–‰, OpenCV ì´ë¯¸ì§€ ì„œì¹˜, EasyOCR ì—”ì§„ OCR  
- Data Access Layer  
  â€¢ pandas/openpyxlë¡œ ì—‘ì…€ ì…ì¶œë ¥, ë¡œê·¸(CSV) ì €ì¥  
- Config & Plugin Manager  
  â€¢ JSON ê¸°ë°˜ í”ŒëŸ¬ê·¸ì¸/ë‹¨ê³„ ì •ì˜ ë¡œë”©, ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤  
- Packaging & Deployment  
  â€¢ PyInstaller ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸, AES-256 ì•”í˜¸í™” ì˜µì…˜  

### Top-Level Component Interaction Diagram
```mermaid
graph TD
    U[UI Layer] --> C[Core Controller]
    C --> A[Automation Engine]
    C --> D[Data Access Layer]
    A --> I[Image/OCR]
    D --> E[Excel Files]
    D --> L[Log CSV]
```

- UI Layerì—ì„œ Core Controllerë¡œ ì‚¬ìš©ì ì…ë ¥Â·ëª…ë ¹ ì „ë‹¬  
- Core Controllerê°€ Automation Engineê³¼ Data Access Layerë¥¼ ì¡°ì •  
- Automation Engineì€ OpenCVÂ·Tesseractë¡œ í™”ë©´ ì¸ì‹ í›„ PyAutoGUIë¡œ ë™ì‘ ì‹¤í–‰  
- Data Access LayerëŠ” ì—‘ì…€ íŒŒì¼ ì…ì¶œë ¥ ë° ì‹¤í–‰ ë¡œê·¸(CSV) ì €ì¥  

### Code Organization & Convention

**Domain-Driven Organization Strategy**  
- Domain Separation: `excel`, `ui`, `automation`, `core`, `plugin`  
- Layer-Based Architecture: `presentation(UI)`, `application(core)`, `domain(automation)`, `infrastructure(data)`  
- Feature-Based Modules: ë‹¨ê³„ë³„(`mouse_actions`, `keyboard_actions`, `image_search`, `flow_control`)  
- Shared Components: ê³µí†µ ìœ í‹¸(`utils`), ì•”í˜¸í™”Â·ì„¤ì •(`config`), ë¡œê¹…(`logger`)

**Universal File & Folder Structure**
```
/project-root
â”œâ”€â”€ build/                     # PyInstaller ë¹Œë“œ ì¶œë ¥
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ settings.json         # ì•± ì„¤ì •(ì•”í˜¸í™”)
â”‚   â””â”€â”€ locales/              # ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤
â”œâ”€â”€ plugin/                    # í™•ì¥ í”ŒëŸ¬ê·¸ì¸ ì •ì˜(JSON)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/                  # ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§
â”‚   â”œâ”€â”€ ui/                    # PyQt5/Tkinter ë·°
â”‚   â”œâ”€â”€ automation/            # PyAutoGUI, OpenCV, OCR ëª¨ë“ˆ
â”‚   â”œâ”€â”€ data/                  # ì—‘ì…€ ë° ë¡œê·¸ ì…ì¶œë ¥
â”‚   â”œâ”€â”€ utils/                 # ê³µí†µ ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ main.py                # ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸
â”œâ”€â”€ tests/                     # ë‹¨ìœ„/í†µí•© í…ŒìŠ¤íŠ¸
â””â”€â”€ requirements.txt           # íŒ¨í‚¤ì§€ ì˜ì¡´ì„±
```

### Data Flow & Communication Patterns
- **í´ë¼ì´ì–¸íŠ¸-ì»¨íŠ¸ë¡¤ëŸ¬ í†µì‹ **: UI ì´ë²¤íŠ¸ â†’ Core Controller ë©”ì„œë“œ í˜¸ì¶œ  
- **ë°ì´í„°ë² ì´ìŠ¤(ì—‘ì…€) ìƒí˜¸ì‘ìš©**: pandas/openpyxl ë™ê¸°ì‹ ì½ê¸°Â·ì“°ê¸°  
- **ì™¸ë¶€ ì„œë¹„ìŠ¤ ì—°ë™**: ì—†ìŒ(ì˜¤í”„ë¼ì¸ í™˜ê²½ ê¸°ë³¸)  
- **ì‹¤ì‹œê°„ í†µì‹ **: UI ìŠ¤ë ˆë“œì™€ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ìŠ¤ë ˆë“œ ê°„ í/ì‹œê·¸ë„  
- **ë°ì´í„° ë™ê¸°í™”**: ì‹¤í–‰ ë¡œê·¸(CSV)ì— ë‹¨ê³„ë³„ ê²°ê³¼ ì¦‰ì‹œ ê¸°ë¡  

---

## 4. Performance & Optimization Strategy
- ì´ë¯¸ì§€ ë§¤ì¹­ìš© ROI(Region of Interest) ë° í…œí”Œë¦¿ ìºì‹±ìœ¼ë¡œ ê²€ìƒ‰ ì†ë„ ê°œì„   
- ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ì‚¬ìš©ìœ¼ë¡œ UI ì‘ë‹µì„± í™•ë³´  
- OpenCV ë©€í‹°ìŠ¤ë ˆë“œ ë¹Œë“œ í™œìš© ë° Tesseract ROI ì„¤ì •ìœ¼ë¡œ OCR ì†ë„ ìµœì í™”  
- ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ ìœ„í•´ ì‹¤í–‰ í›„ ë¦¬ì†ŒìŠ¤(ì´ë¯¸ì§€Â·ê°ì²´) ëª…ì‹œì  í•´ì œ  

---

## 5. Implementation Roadmap & Milestones

### Phase 1: Foundation (MVP Implementation)
- **Core Infrastructure**: ê°œë°œ í™˜ê²½ ì„¤ì •, CI/CD(GitHub Actions), ê¸°ë³¸ í”„ë¡œì íŠ¸ êµ¬ì¡°  
- **Essential Features**: ì—‘ì…€ ë¶ˆëŸ¬ì˜¤ê¸°Â·ë§¤í•‘ UI, ë§ˆìš°ìŠ¤Â·í‚¤ë³´ë“œ ìˆœì°¨ ì‹¤í–‰, ìƒíƒœ ì—´ ì—…ë°ì´íŠ¸  
- **Basic Security**: ì„¤ì • íŒŒì¼ AES-256 ì•”í˜¸í™” ì €ì¥  
- **Development Setup**: ê°€ìƒí™˜ê²½, lint(Flake8), ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬  
- **Timeline**: 3ê°œì›”

### Phase 2: Feature Enhancement
- **Advanced Features**: ì´ë¯¸ì§€ ì„œì¹˜(OpenCV), OCR(pytesseract), LoopÂ·If ì œì–´  
- **Performance Optimization**: ìŠ¤ë ˆë“œ ìµœì í™”, í…œí”Œë¦¿ ìºì‹± ê°œì„   
- **Enhanced Security**: ì½”ë“œ ì„œëª…, ì„¤ì¹˜ íŒ¨í‚¤ì§€ ë³´ì•ˆ ì˜µì…˜  
- **Monitoring Implementation**: ìƒì„¸ ì‹¤í–‰ ë¡œê·¸ CSV ë·°ì–´ ëª¨ë“ˆ  
- **Timeline**: 2ê°œì›”

### Phase 3: Scaling & Optimization
- **Scalability Implementation**: í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜ ì™„ì„±, ë©€í‹° ëª¨ë‹ˆí„° ì•ˆì •í™”  
- **Advanced Integrations**: ìë™ ì—…ë°ì´íŠ¸ ì²´í¬, ë‹¤êµ­ì–´ UI, ë‹¤í¬ëª¨ë“œ  
- **Enterprise Features**: ë¡œì»¬ í…œí”Œë¦¿ ê°¤ëŸ¬ë¦¬, êµ¬ì„± ë™ê¸°í™” ì˜µì…˜  
- **Compliance & Auditing**: ê°ì‚¬ ë¡œê·¸, ì‹¤í–‰ ì´ë ¥ ë¦¬í¬íŠ¸  
- **Timeline**: 2ê°œì›”

---

## 6. Risk Assessment & Mitigation Strategies

### Technical Risk Analysis
- **ê¸°ìˆ  ë¦¬ìŠ¤í¬**: ì´ë¯¸ì§€ ë§¤ì¹­ ì˜¤ë¥˜ â†’ DPI ë³´ì • ì•Œê³ ë¦¬ì¦˜ ë° ë©€í‹° ëª¨ë‹ˆí„° ì¢Œí‘œ ë™ê¸°í™”  
- **ì„±ëŠ¥ ë¦¬ìŠ¤í¬**: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œ ëŠë ¤ì§ â†’ ROI ìºì‹±Â·ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ í™œìš©  
- **ë³´ì•ˆ ë¦¬ìŠ¤í¬**: ì„¤ì • íŒŒì¼ ë¬´ë‹¨ ì—´ëŒ â†’ AES-256 ì•”í˜¸í™” ë° íŒŒì¼ ê¶Œí•œ ì œí•œ  
- **í†µí•© ë¦¬ìŠ¤í¬**: Tesseract ë²„ì „ í˜¸í™˜ì„± â†’ ì‚¬ì „ í…ŒìŠ¤íŠ¸ ë° ë¡œì»¬ ë²ˆë“¤ë§  
- **Mitigation**: ì‚¬ì „ í™˜ê²½ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸, ìë™í™” í…ŒìŠ¤íŠ¸, ì£¼ê¸°ì  ë³´ì•ˆ ê°ì‚¬

### Project Delivery Risks
- **ì¼ì • ë¦¬ìŠ¤í¬**: ê¸°ëŠ¥ ë³µì¡ë„ ê³¼ì†Œí‰ê°€ â†’ MVP ë²”ìœ„ ëª…í™•í™” ë° ì£¼ê¸°ì  ìŠ¤ì½”í”„ ë¦¬ë·°  
- **ë¦¬ì†ŒìŠ¤ ë¦¬ìŠ¤í¬**: Python GUI ì „ë¬¸ ê°œë°œì ë¶€ì¡± â†’ ë¬¸ì„œí™”Â·ë‚´ë¶€ ì›Œí¬ìˆ ì‹¤ì‹œ  
- **í’ˆì§ˆ ë¦¬ìŠ¤í¬**: í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ì €ì¡° â†’ CI ë³‘í•© ì „ 80% ì´ìƒ ì»¤ë²„ë¦¬ì§€ ê°•ì œ  
- **ë°°í¬ ë¦¬ìŠ¤í¬**: ë³‘ì› ë³´ì•ˆ ì •ì±… ì°¨ë‹¨ â†’ ì˜¤í”„ë¼ì¸ ì„¤ì¹˜ íŒ¨í‚¤ì§€, ë””ì§€í„¸ ì„œëª… ì œê³µ  
- **ë¹„ìƒ ê³„íš**: ì£¼ìš” ê¸°ëŠ¥ ì§€ì—° ì‹œ Nice-to-Have í›„ìˆœìœ„ ì¡°ì •, í˜ì¼ì˜¤ë²„ ì„¤ì¹˜ ì§€ì¹¨ ì‘ì„±
</file>

<file path="web_macro.json">
[
  {
    "type": "mouse_click",
    "name": "ë§ˆìš°ìŠ¤ í´ë¦­"
  },
  {
    "type": "keyboard_type",
    "name": "í…ìŠ¤íŠ¸ ì…ë ¥"
  },
  {
    "type": "wait_time",
    "name": "ëŒ€ê¸°"
  }
]
</file>

<file path="WINDOWS_RUN.bat">
@echo off
REM === Windows ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸ ===

cls

echo ===============================
echo Excel Macro Automation Tool
echo ===============================
echo.

REM í˜„ì¬ ë””ë ‰í† ë¦¬ë¡œ ì´ë™
cd /d "%~dp0"
echo ì‘ì—… í´ë”: %CD%

REM Python í™•ì¸
python --version >nul 2>&1
if errorlevel 1 (
    echo.
    echo [ì˜¤ë¥˜] Pythonì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!
    echo.
    echo 1. https://python.org ì—ì„œ Python ë‹¤ìš´ë¡œë“œ
    echo 2. ì„¤ì¹˜ ì‹œ "Add Python to PATH" ì²´í¬
    echo.
    pause
    exit /b
)

echo Python í™•ì¸ ì™„ë£Œ
echo.

REM í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜
echo íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘... (ì²« ì‹¤í–‰ ì‹œ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤)
echo.
echo ì£¼ìš” íŒ¨í‚¤ì§€:
echo - PyQt5 (GUI í”„ë ˆì„ì›Œí¬)
echo - pandas, openpyxl (Excel ì²˜ë¦¬)
echo - pyautogui, opencv-python (í™”ë©´ ìë™í™”)
echo - easyocr (í…ìŠ¤íŠ¸ ì¸ì‹) - ì„¤ì¹˜ì— ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤
echo.

python -m pip install --upgrade pip
pip install PyQt5 pandas openpyxl pyautogui pillow screeninfo cryptography opencv-python numpy mss

echo.
echo EasyOCR ì„¤ì¹˜ ì¤‘... (ì²« ì‹¤í–‰ ì‹œ ëª¨ë¸ ë‹¤ìš´ë¡œë“œë¡œ ì‹œê°„ì´ ê±¸ë¦½ë‹ˆë‹¤)
pip install easyocr

if errorlevel 1 (
    echo.
    echo [ê²½ê³ ] ì¼ë¶€ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì‹¤íŒ¨. ìˆ˜ë™ ì„¤ì¹˜ê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    echo.
)

REM ì‹¤í–‰
echo.
echo ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì¤‘...
echo ===============================
echo.

REM íŒŒì¼ ì¡´ì¬ í™•ì¸
if not exist "run_main_fixed.py" (
    echo.
    echo [ì˜¤ë¥˜] run_main_fixed.py íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!
    echo í˜„ì¬ ë””ë ‰í† ë¦¬: %CD%
    echo.
    pause
    exit /b
)

python run_main_fixed.py

REM ì¢…ë£Œ ì‹œ ì¼ì‹œì •ì§€ (ì˜¤ë¥˜ ë°œìƒ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´)
if errorlevel 1 (
    echo.
    echo [ì˜¤ë¥˜] í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
    echo.
)

echo.
echo === í”„ë¡œê·¸ë¨ ì¢…ë£Œ ===
echo ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ë©´ ì°½ì´ ë‹«í™ë‹ˆë‹¤...
pause >nul
</file>

<file path="src/automation/engine.py">
"""
Main macro execution engine
"""

import time
import threading
from typing import Optional, Dict, Any, List, Callable
from enum import Enum
from PyQt5.QtCore import QThread, pyqtSignal, QObject
import pyautogui
from core.macro_types import Macro, MacroStep
from excel.excel_manager import ExcelManager
from logger.app_logger import get_logger
from config.settings import Settings
from automation.executor import StepExecutor
from automation.hotkey_listener import HotkeyListener
from logger.execution_logger import get_execution_logger

class ExecutionState(Enum):
    """Execution states"""
    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

class ExecutionResult:
    """Result of a single execution"""
    def __init__(self, row_index: int, success: bool, 
                 error: Optional[str] = None, duration_ms: float = 0):
        self.row_index = row_index
        self.success = success
        self.error = error
        self.duration_ms = duration_ms
        self.timestamp = time.time()

class ExecutionEngine(QThread):
    """Main macro execution engine"""
    
    # Signals
    stateChanged = pyqtSignal(ExecutionState)
    progressUpdated = pyqtSignal(int, int)  # current, total
    rowCompleted = pyqtSignal(ExecutionResult)
    stepExecuting = pyqtSignal(MacroStep, int)  # step, row_index
    executionFinished = pyqtSignal()
    error = pyqtSignal(str)
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.logger = get_logger(__name__)
        self.settings = settings
        
        # State management
        self._state = ExecutionState.IDLE
        self._state_lock = threading.Lock()
        self._pause_event = threading.Event()
        self._pause_event.set()  # Not paused by default
        
        # Execution components
        self.step_executor = StepExecutor(settings)
        self.hotkey_listener = HotkeyListener(settings)
        self.execution_logger = get_execution_logger()
        
        # Current execution context
        self.macro: Optional[Macro] = None
        self.excel_manager: Optional[ExcelManager] = None
        self.target_rows: List[int] = []
        self.current_row_index: Optional[int] = None
        
        # Configure PyAutoGUI
        self._configure_pyautogui()
        
        # Connect hotkey signals
        self.hotkey_listener.pausePressed.connect(self.toggle_pause)
        self.hotkey_listener.stopPressed.connect(self.stop_execution)
        
    def _configure_pyautogui(self):
        """Configure PyAutoGUI settings"""
        pyautogui.FAILSAFE = True  # Move mouse to corner to abort
        pyautogui.PAUSE = self.settings.get("execution.default_delay_ms", 100) / 1000.0
        
        # Log screen size for debugging
        screen_width, screen_height = pyautogui.size()
        self.logger.info(f"Screen size: {screen_width}x{screen_height}")
        
    @property
    def state(self) -> ExecutionState:
        """Get current execution state"""
        with self._state_lock:
            return self._state
            
    def _set_state(self, new_state: ExecutionState):
        """Set execution state"""
        with self._state_lock:
            old_state = self._state
            self._state = new_state
            
        if old_state != new_state:
            self.logger.info(f"State changed: {old_state.value} -> {new_state.value}")
            self.stateChanged.emit(new_state)
            
    def set_macro(self, macro: Macro, excel_manager: ExcelManager):
        """Set macro and Excel manager for execution"""
        if self.state != ExecutionState.IDLE:
            raise RuntimeError("Cannot set macro while execution is active")
            
        self.macro = macro
        self.excel_manager = excel_manager
        
        # Validate macro
        errors = macro.validate()
        if errors:
            raise ValueError(f"Macro validation failed: {', '.join(errors)}")
            
    def set_target_rows(self, row_indices: List[int]):
        """Set specific rows to execute"""
        self.target_rows = row_indices
        
    def run(self):
        """Main execution thread"""
        if not self.macro or not self.excel_manager:
            self.error.emit("No macro or Excel data loaded")
            return
            
        try:
            self._set_state(ExecutionState.RUNNING)
            self.hotkey_listener.start()
            
            # Start CSV logging session
            excel_file = self.excel_manager.file_path if self.excel_manager else "Unknown"
            log_file = self.execution_logger.start_session(self.macro.name, excel_file)
            self.logger.info(f"Execution log started: {log_file}")
            
            # Get rows to process
            if not self.target_rows:
                # Process all incomplete rows
                self.target_rows = self.excel_manager.get_pending_rows()
                
            total_rows = len(self.target_rows)
            self.logger.info(f"Starting execution for {total_rows} rows")
            
            # Track statistics
            successful_rows = 0
            failed_rows = 0
            
            # Execute each row
            for i, row_index in enumerate(self.target_rows):
                # Check if stopping
                if self.state == ExecutionState.STOPPING:
                    break
                    
                # Handle pause
                self._pause_event.wait()
                
                # Update progress
                self.progressUpdated.emit(i + 1, total_rows)
                self.current_row_index = row_index
                
                # Execute macro for this row
                result = self._execute_row(row_index)
                
                # Update statistics
                if result.success:
                    successful_rows += 1
                else:
                    failed_rows += 1
                
                # Update Excel status
                status = "ì™„ë£Œ" if result.success else f"ì‹¤íŒ¨: {result.error}"
                self.excel_manager.update_row_status(row_index, status)
                
                # Emit result
                self.rowCompleted.emit(result)
                
                # Small delay between rows
                time.sleep(0.1)
                
            # Save Excel file after all rows
            self.excel_manager.save_file()
            
            # Log session summary
            self.execution_logger.log_session_end(
                total_rows=len(self.target_rows),
                successful_rows=successful_rows,
                failed_rows=failed_rows
            )
            
            self._set_state(ExecutionState.IDLE)
            self.executionFinished.emit()
            
        except Exception as e:
            self.logger.error(f"Execution error: {e}", exc_info=True)
            self.execution_logger.log_error("EXECUTION_ERROR", str(e), details=str(e))
            self.error.emit(str(e))
            self._set_state(ExecutionState.ERROR)
            
        finally:
            self.hotkey_listener.stop()
            self.current_row_index = None
            self.execution_logger.close()
            
    def _execute_row(self, row_index: int) -> ExecutionResult:
        """Execute macro for a single row"""
        start_time = time.time()
        
        try:
            # Get row data with mappings
            row_data = self.excel_manager.get_mapped_data(row_index)
            
            # Log row start
            self.execution_logger.log_row_start(row_index, row_data)
            
            # Set variables in executor context
            self.step_executor.set_variables(row_data)
            
            # Execute each step
            for step_index, step in enumerate(self.macro.steps):
                # Check if stopping
                if self.state == ExecutionState.STOPPING:
                    return ExecutionResult(row_index, False, "Execution stopped")
                    
                # Handle pause
                self._pause_event.wait()
                
                # Skip disabled steps
                if not step.enabled:
                    continue
                    
                # Emit step executing signal
                self.stepExecuting.emit(step, row_index)
                
                # Execute step
                step_start_time = time.time()
                step_success = False
                step_error = ""
                
                try:
                    self.step_executor.execute_step(step)
                    step_success = True
                except Exception as e:
                    error_msg = f"Step '{step.name}' failed: {str(e)}"
                    self.logger.error(error_msg)
                    step_error = str(e)
                    
                    # Emit detailed error for UI
                    if step.error_handling.value == "stop":
                        self.error.emit(error_msg)
                    
                    # Handle error based on step configuration
                    if step.error_handling.value == "stop":
                        # Log failed step
                        step_duration = (time.time() - step_start_time) * 1000
                        self.execution_logger.log_step_execution(
                            row_index, step_index, step.name, step.step_type.value,
                            False, step_duration, step_error
                        )
                        return ExecutionResult(row_index, False, error_msg)
                    elif step.error_handling.value == "retry":
                        # Retry logic
                        for retry in range(step.retry_count):
                            try:
                                time.sleep(1)  # Wait before retry
                                self.step_executor.execute_step(step)
                                step_success = True
                                step_error = ""
                                break
                            except:
                                if retry == step.retry_count - 1:
                                    # Log failed step after all retries
                                    step_duration = (time.time() - step_start_time) * 1000
                                    self.execution_logger.log_step_execution(
                                        row_index, step_index, step.name, step.step_type.value,
                                        False, step_duration, step_error
                                    )
                                    return ExecutionResult(row_index, False, error_msg)
                    # For "continue", just log and proceed
                
                # Log step execution result
                step_duration = (time.time() - step_start_time) * 1000
                self.execution_logger.log_step_execution(
                    row_index, step_index, step.name, step.step_type.value,
                    step_success, step_duration, step_error
                )
                    
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(row_index, True, duration_ms)
            return ExecutionResult(row_index, True, None, duration_ms)
            
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            self.execution_logger.log_row_complete(row_index, False, duration_ms, str(e))
            return ExecutionResult(row_index, False, str(e), duration_ms)
            
    def toggle_pause(self):
        """Toggle pause state"""
        if self.state == ExecutionState.RUNNING:
            self._set_state(ExecutionState.PAUSED)
            self._pause_event.clear()
            self.logger.info("Execution paused")
        elif self.state == ExecutionState.PAUSED:
            self._set_state(ExecutionState.RUNNING)
            self._pause_event.set()
            self.logger.info("Execution resumed")
            
    def stop_execution(self):
        """Stop execution"""
        if self.state in [ExecutionState.RUNNING, ExecutionState.PAUSED]:
            self._set_state(ExecutionState.STOPPING)
            self._pause_event.set()  # Resume if paused
            self.logger.info("Stopping execution...")
            
    def is_running(self) -> bool:
        """Check if execution is active"""
        return self.state in [ExecutionState.RUNNING, ExecutionState.PAUSED]
</file>

<file path="src/config/settings.py">
"""
Application settings management with encryption support
"""

import json
import os
from pathlib import Path
from typing import Any, Dict, Optional
from utils.encryption import EncryptionManager

class Settings:
    """Manages application settings with encryption support"""
    
    DEFAULT_SETTINGS = {
        "version": "1.0.0",
        "language": "ko",
        "theme": "light",
        "hotkeys": {
            "pause": "F9",
            "stop": "Escape"
        },
        "execution": {
            "default_delay_ms": 100,
            "screenshot_quality": 95,
            "ocr_confidence_threshold": 0.7
        },
        "ui": {
            "window_size": [1280, 720],
            "show_tooltips": True,
            "confirm_exit": True,
            "compact_mode": False
        }
    }
    
    def __init__(self, config_dir: Optional[Path] = None):
        """Initialize settings manager"""
        self.config_dir = config_dir or Path.home() / ".excel_macro_automation"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        self.settings_file = self.config_dir / "settings.json"
        self.encrypted_settings_file = self.config_dir / "settings.enc"
        
        self.encryption_manager = EncryptionManager()
        self.settings = self._load_settings()
    
    def _load_settings(self) -> Dict[str, Any]:
        """Load settings from file or create defaults"""
        # Try loading encrypted settings first
        if self.encrypted_settings_file.exists():
            try:
                encrypted_data = self.encrypted_settings_file.read_bytes()
                decrypted_data = self.encryption_manager.decrypt(encrypted_data)
                return json.loads(decrypted_data.decode('utf-8'))
            except Exception as e:
                print(f"Failed to load encrypted settings: {e}")
        
        # Try loading plain JSON settings
        if self.settings_file.exists():
            try:
                return json.loads(self.settings_file.read_text(encoding='utf-8'))
            except Exception as e:
                print(f"Failed to load settings: {e}")
        
        # Return default settings
        return self.DEFAULT_SETTINGS.copy()
    
    def save(self, encrypted: bool = True) -> None:
        """Save settings to file"""
        settings_json = json.dumps(self.settings, indent=2, ensure_ascii=False)
        
        if encrypted:
            encrypted_data = self.encryption_manager.encrypt(settings_json.encode('utf-8'))
            self.encrypted_settings_file.write_bytes(encrypted_data)
            # Remove plain text version if it exists
            if self.settings_file.exists():
                self.settings_file.unlink()
        else:
            self.settings_file.write_text(settings_json, encoding='utf-8')
            # Remove encrypted version if it exists
            if self.encrypted_settings_file.exists():
                self.encrypted_settings_file.unlink()
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get setting value by key (supports dot notation)"""
        keys = key.split('.')
        value = self.settings
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def set(self, key: str, value: Any) -> None:
        """Set setting value by key (supports dot notation)"""
        keys = key.split('.')
        target = self.settings
        
        for k in keys[:-1]:
            if k not in target:
                target[k] = {}
            target = target[k]
        
        target[keys[-1]] = value
    
    def reset_to_defaults(self) -> None:
        """Reset all settings to defaults"""
        self.settings = self.DEFAULT_SETTINGS.copy()
        self.save()
</file>

<file path="src/core/macro_storage.py">
"""
Macro storage and JSON serialization
"""

import json
import os
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
import shutil
from enum import Enum
from utils.encryption import EncryptionManager
from logger.app_logger import get_logger
from core.macro_types import Macro


class MacroFormat(Enum):
    """Supported macro file formats"""
    JSON = "json"
    ENCRYPTED = "encrypted"

class MacroStorage:
    """Handles macro storage, loading, and saving"""
    
    SCHEMA_VERSION = "1.0.0"
    
    def __init__(self, storage_dir: Optional[Path] = None):
        """Initialize macro storage"""
        self.logger = get_logger(__name__)
        self.storage_dir = storage_dir or Path.home() / ".excel_macro_automation" / "macros"
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        self.encryption_manager = EncryptionManager()
        
    def save_macro(self, macro: Macro, file_path: Optional[str] = None, 
                   format_type: MacroFormat = MacroFormat.JSON, create_backup: bool = True) -> bool:
        """Save macro to file"""
        if not file_path:
            file_name = f"{macro.name.replace(' ', '_')}_{macro.macro_id[:8]}.json"
            file_path = self.storage_dir / file_name
        else:
            file_path = Path(file_path)
            
        # Create backup if requested and file exists
        if create_backup and file_path.exists():
            self._create_backup(file_path)
            
        # Prepare data
        data = {
            "schema_version": self.SCHEMA_VERSION,
            "macro": macro.to_dict()
        }
        
        # Convert to JSON
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        
        # Save file
        try:
            if format_type == MacroFormat.ENCRYPTED:
                encrypted_data = self.encryption_manager.encrypt(json_str.encode('utf-8'))
                file_path = file_path.with_suffix('.emf')
                file_path.write_bytes(encrypted_data)
                self.logger.info(f"Saved encrypted macro: {file_path}")
            else:
                file_path.write_text(json_str, encoding='utf-8')
                self.logger.info(f"Saved macro: {file_path}")
                
            return True
        except Exception as e:
            self.logger.error(f"Failed to save macro: {e}")
            return False
        
    def load_macro(self, file_path: str) -> Macro:
        """Load macro from file"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Macro file not found: {file_path}")
            
        # Check if encrypted
        if file_path.suffix in ['.emacro', '.emf']:
            encrypted_data = file_path.read_bytes()
            json_data = self.encryption_manager.decrypt(encrypted_data).decode('utf-8')
            data = json.loads(json_data)
        else:
            data = json.loads(file_path.read_text(encoding='utf-8'))
            
        # Check schema version
        schema_version = data.get("schema_version", "0.0.0")
        if schema_version != self.SCHEMA_VERSION:
            self.logger.warning(f"Schema version mismatch: {schema_version} != {self.SCHEMA_VERSION}")
            # In future, handle migration here
            
        # Load macro
        macro_data = data.get("macro", {})
        macro = Macro.from_dict(macro_data)
        
        self.logger.info(f"Loaded macro: {macro.name} from {file_path}")
        return macro
        
    def list_macros(self, include_encrypted: bool = True) -> List[Dict[str, Any]]:
        """List all saved macros"""
        macros = []
        
        # Search for macro files
        patterns = ['*.json']
        if include_encrypted:
            patterns.append('*.emacro')
            
        for pattern in patterns:
            for file_path in self.storage_dir.glob(pattern):
                try:
                    # Get basic info without fully loading
                    if file_path.suffix == '.emacro':
                        # For encrypted files, we need to decrypt to get info
                        macro = self.load_macro(str(file_path))
                        info = {
                            "file_path": str(file_path),
                            "file_name": file_path.name,
                            "macro_id": macro.macro_id,
                            "name": macro.name,
                            "description": macro.description,
                            "created_at": macro.created_at.isoformat(),
                            "updated_at": macro.updated_at.isoformat(),
                            "encrypted": True
                        }
                    else:
                        # For JSON files, we can peek without full parsing
                        data = json.loads(file_path.read_text(encoding='utf-8'))
                        macro_data = data.get("macro", {})
                        info = {
                            "file_path": str(file_path),
                            "file_name": file_path.name,
                            "macro_id": macro_data.get("macro_id", ""),
                            "name": macro_data.get("name", ""),
                            "description": macro_data.get("description", ""),
                            "created_at": macro_data.get("created_at", ""),
                            "updated_at": macro_data.get("updated_at", ""),
                            "encrypted": False
                        }
                    macros.append(info)
                except Exception as e:
                    self.logger.error(f"Failed to read macro file {file_path}: {e}")
                    
        # Sort by updated date
        macros.sort(key=lambda x: x["updated_at"], reverse=True)
        return macros
        
    def delete_macro(self, file_path: str, create_backup: bool = True) -> bool:
        """Delete a macro file"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            return False
            
        if create_backup:
            self._create_backup(file_path)
            
        file_path.unlink()
        self.logger.info(f"Deleted macro: {file_path}")
        return True
        
    def export_macro(self, macro: Macro, export_path: str) -> str:
        """Export macro for sharing"""
        export_path = Path(export_path)
        
        # Always export as unencrypted JSON for sharing
        data = {
            "schema_version": self.SCHEMA_VERSION,
            "macro": macro.to_dict(),
            "export_info": {
                "exported_at": datetime.now().isoformat(),
                "export_version": "1.0.0"
            }
        }
        
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        export_path.write_text(json_str, encoding='utf-8')
        
        self.logger.info(f"Exported macro: {export_path}")
        return str(export_path)
        
    def import_macro(self, import_path: str, save_to_storage: bool = True) -> Macro:
        """Import macro from external file"""
        import_path = Path(import_path)
        
        if not import_path.exists():
            raise FileNotFoundError(f"Import file not found: {import_path}")
            
        # Load the macro
        data = json.loads(import_path.read_text(encoding='utf-8'))
        
        # Check if it's an export file
        if "export_info" in data:
            self.logger.info(f"Importing from export: {data['export_info']}")
            
        macro_data = data.get("macro", {})
        macro = Macro.from_dict(macro_data)
        
        # Generate new ID to avoid conflicts
        import uuid
        macro.macro_id = str(uuid.uuid4())
        macro.updated_at = datetime.now()
        
        # Save to storage if requested
        if save_to_storage:
            self.save_macro(macro)
            
        self.logger.info(f"Imported macro: {macro.name}")
        return macro
        
    def _create_backup(self, file_path: Path):
        """Create backup of file"""
        backup_dir = self.storage_dir / "backups"
        backup_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{file_path.stem}_backup_{timestamp}{file_path.suffix}"
        backup_path = backup_dir / backup_name
        
        shutil.copy2(file_path, backup_path)
        self.logger.info(f"Created backup: {backup_path}")
        
        # Clean old backups (keep last 10)
        self._clean_old_backups(file_path.stem)
        
    def _clean_old_backups(self, file_stem: str, keep_count: int = 10):
        """Clean old backup files"""
        backup_dir = self.storage_dir / "backups"
        if not backup_dir.exists():
            return
            
        # Find all backups for this file
        backups = list(backup_dir.glob(f"{file_stem}_backup_*"))
        backups.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        # Delete old backups
        for backup in backups[keep_count:]:
            backup.unlink()
            self.logger.info(f"Deleted old backup: {backup}")
            
    def get_templates(self) -> List[Dict[str, Any]]:
        """Get available macro templates"""
        templates = [
            {
                "name": "ê¸°ë³¸ ìë™í™”",
                "description": "ë§ˆìš°ìŠ¤ í´ë¦­ê³¼ í…ìŠ¤íŠ¸ ì…ë ¥ì„ í¬í•¨í•œ ê¸°ë³¸ í…œí”Œë¦¿",
                "macro": self._create_basic_template()
            },
            {
                "name": "ì›¹ ìë™í™”",
                "description": "ì›¹ ë¸Œë¼ìš°ì € ìë™í™”ë¥¼ ìœ„í•œ í…œí”Œë¦¿",
                "macro": self._create_web_template()
            },
            {
                "name": "ì—‘ì…€ ë°ì´í„° ì…ë ¥",
                "description": "ì—‘ì…€ ë°ì´í„°ë¥¼ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì— ì…ë ¥í•˜ëŠ” í…œí”Œë¦¿",
                "macro": self._create_excel_input_template()
            }
        ]
        return templates
        
    def _create_basic_template(self) -> Macro:
        """Create basic automation template"""
        from core.macro_types import MouseClickStep, WaitTimeStep, KeyboardTypeStep
        
        macro = Macro(name="ê¸°ë³¸ ìë™í™” í…œí”Œë¦¿")
        
        # Add sample steps
        click_step = MouseClickStep(
            name="í”„ë¡œê·¸ë¨ í´ë¦­",
            description="ìë™í™”í•  í”„ë¡œê·¸ë¨ì„ í´ë¦­í•©ë‹ˆë‹¤"
        )
        macro.add_step(click_step)
        
        wait_step = WaitTimeStep(
            name="ëŒ€ê¸°",
            description="í”„ë¡œê·¸ë¨ì´ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°",
            seconds=2.0
        )
        macro.add_step(wait_step)
        
        type_step = KeyboardTypeStep(
            name="í…ìŠ¤íŠ¸ ì…ë ¥",
            description="ì…ë ¥í•  í…ìŠ¤íŠ¸",
            text="{{ì´ë¦„}}"
        )
        macro.add_step(type_step)
        
        return macro
        
    def _create_web_template(self) -> Macro:
        """Create web automation template"""
        from core.macro_types import WaitTimeStep, KeyboardHotkeyStep, KeyboardTypeStep
        
        macro = Macro(name="ì›¹ ìë™í™” í…œí”Œë¦¿")
        
        # Open browser
        hotkey_step = KeyboardHotkeyStep(
            name="ë¸Œë¼ìš°ì € ì—´ê¸°",
            description="ì›¹ ë¸Œë¼ìš°ì €ë¥¼ ì—½ë‹ˆë‹¤",
            keys=["win", "r"]
        )
        macro.add_step(hotkey_step)
        
        wait_step = WaitTimeStep(seconds=1.0)
        macro.add_step(wait_step)
        
        type_step = KeyboardTypeStep(
            name="ë¸Œë¼ìš°ì € ì‹¤í–‰",
            text="chrome"
        )
        macro.add_step(type_step)
        
        return macro
        
    def _create_excel_input_template(self) -> Macro:
        """Create Excel input template"""
        from core.macro_types import LoopStep, KeyboardTypeStep, KeyboardHotkeyStep
        
        macro = Macro(name="ì—‘ì…€ ë°ì´í„° ì…ë ¥ í…œí”Œë¦¿")
        
        # This is a placeholder - would need proper implementation
        # with Excel row iteration
        
        return macro
</file>

<file path="src/ui/dialogs/image_step_dialog.py">
"""
Configuration dialogs for image-based macro steps
"""

import os
from typing import Optional, Dict, Any, Tuple
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QLineEdit, QSpinBox, QDoubleSpinBox, QGroupBox, QFileDialog,
    QDialogButtonBox, QMessageBox, QCheckBox, QComboBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QPixmap, QImage, QKeySequence
from PyQt5.QtWidgets import QShortcut
from core.macro_types import MacroStep, WaitImageStep, StepType
from vision.image_matcher import ImageMatcher
from config.settings import Settings
from ui.widgets.roi_selector import ROISelectorWidget
from utils.clipboard_utils import save_clipboard_image

class ImageStepDialog(QDialog):
    """Base dialog for image step configuration"""
    
    def __init__(self, step: Optional[MacroStep] = None, 
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(parent)
        self.step = step
        self.settings = settings or Settings()
        self.image_matcher = ImageMatcher(self.settings)
        
        # Step data
        self.step_data: Dict[str, Any] = {}
        if step:
            self.step_data = step.to_dict()
            
        self.init_ui()
        self.load_step_data()
        
    def init_ui(self):
        """Initialize base UI"""
        self.setModal(True)
        self.setMinimumWidth(600)
        
        layout = QVBoxLayout()
        
        # Name input
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("ë‹¨ê³„ ì´ë¦„:"))
        self.name_input = QLineEdit()
        name_layout.addWidget(self.name_input)
        layout.addLayout(name_layout)
        
        # Image selection group
        image_group = QGroupBox("ì°¸ì¡° ì´ë¯¸ì§€")
        image_layout = QVBoxLayout()
        
        # Image path
        path_layout = QHBoxLayout()
        path_layout.addWidget(QLabel("ì´ë¯¸ì§€ ê²½ë¡œ:"))
        self.image_path_input = QLineEdit()
        self.image_path_input.setReadOnly(True)
        path_layout.addWidget(self.image_path_input)
        
        # Browse button
        self.browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°...")
        self.browse_btn.clicked.connect(self._browse_image)
        path_layout.addWidget(self.browse_btn)
        
        # Capture button
        self.capture_btn = QPushButton("ìº¡ì²˜")
        self.capture_btn.clicked.connect(self._capture_image)
        path_layout.addWidget(self.capture_btn)
        
        # Paste button for clipboard
        self.paste_btn = QPushButton("ë¶™ì—¬ë„£ê¸° (Ctrl+V)")
        self.paste_btn.clicked.connect(self._paste_from_clipboard)
        path_layout.addWidget(self.paste_btn)
        
        # Add Ctrl+V shortcut
        paste_shortcut = QShortcut(QKeySequence("Ctrl+V"), self)
        paste_shortcut.activated.connect(self._paste_from_clipboard)
        
        image_layout.addLayout(path_layout)
        
        # Image preview
        self.image_preview = QLabel()
        self.image_preview.setMinimumHeight(150)
        self.image_preview.setMaximumHeight(300)
        self.image_preview.setScaledContents(False)  # Don't stretch image
        self.image_preview.setAlignment(Qt.AlignCenter)
        self.image_preview.setStyleSheet("""
            QLabel {
                border: 1px solid #ccc;
                background-color: #f9f9f9;
            }
        """)
        image_layout.addWidget(self.image_preview)
        
        # Help text
        help_label = QLabel(
            "ğŸ’¡ íŒ: Shift + Win + S ë¡œ í™”ë©´ì„ ìº¡ì²˜í•œ í›„ Ctrl+V ë˜ëŠ” 'ë¶™ì—¬ë„£ê¸°' ë²„íŠ¼ìœ¼ë¡œ ì´ë¯¸ì§€ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
        )
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #0066cc; font-size: 12px; padding: 5px; background-color: #e6f2ff; border-radius: 3px; margin-top: 5px;")
        image_layout.addWidget(help_label)
        
        image_group.setLayout(image_layout)
        layout.addWidget(image_group)
        
        # ROI selection group
        roi_group = QGroupBox("ê²€ìƒ‰ ì˜ì—­ (ì„ íƒì‚¬í•­)")
        roi_layout = QVBoxLayout()
        
        # ROI selector widget
        self.roi_selector = ROISelectorWidget()
        roi_layout.addWidget(self.roi_selector)
        
        # Select region button
        self.select_region_btn = QPushButton("í™”ë©´ ì˜ì—­ ì„ íƒ")
        self.select_region_btn.clicked.connect(self._select_region)
        roi_layout.addWidget(self.select_region_btn)
        
        # Clear region button
        self.clear_region_btn = QPushButton("ì˜ì—­ ì´ˆê¸°í™”")
        self.clear_region_btn.clicked.connect(self._clear_region)
        roi_layout.addWidget(self.clear_region_btn)
        
        roi_group.setLayout(roi_layout)
        layout.addWidget(roi_group)
        
        # Additional controls (implemented by subclasses)
        self.add_custom_controls(layout)
        
        # Dialog buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
        self.setLayout(layout)
        
        # Update preview after dialog is shown
        from PyQt5.QtCore import QTimer
        QTimer.singleShot(100, self._update_preview)
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Override to add step-specific controls"""
        pass
        
    def _browse_image(self):
        """Browse for image file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "ì°¸ì¡° ì´ë¯¸ì§€ ì„ íƒ",
            "",
            "ì´ë¯¸ì§€ íŒŒì¼ (*.png *.jpg *.jpeg *.bmp);;ëª¨ë“  íŒŒì¼ (*.*)"
        )
        
        if file_path:
            self.image_path_input.setText(file_path)
            self._update_preview()
            
    def _capture_image(self):
        """Capture new reference image"""
        # Show instructions for Windows screen capture
        reply = QMessageBox.question(
            self,
            "í™”ë©´ ìº¡ì²˜ ì•ˆë‚´",
            "Windows í™”ë©´ ìº¡ì²˜ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n"
            "1. Shift + Win + S í‚¤ë¥¼ ëˆŒëŸ¬ í™”ë©´ ìº¡ì²˜\n"
            "2. ìº¡ì²˜í•  ì˜ì—­ì„ ì„ íƒ\n"
            "3. 'ë¶™ì—¬ë„£ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì´ë¯¸ì§€ ì¶”ê°€\n\n"
            "ì´ ë°©ë²•ì„ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Just show the message and let user use Windows capture
            QMessageBox.information(
                self,
                "ì•ˆë‚´",
                "ì§€ê¸ˆ Shift + Win + S ë¥¼ ëˆŒëŸ¬ì„œ í™”ë©´ì„ ìº¡ì²˜í•˜ì„¸ìš”.\n"
                "ìº¡ì²˜ í›„ 'ë¶™ì—¬ë„£ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”."
            )
        else:
            # Try the old method with simple selector
            self.hide()
            
            try:
                # Use simple ROI selector
                from ui.widgets.simple_roi_selector import SimpleROISelector
                selector = SimpleROISelector()
                
                def on_selection(region):
                    # Capture the selected region
                    import time
                    import pyautogui
                    timestamp = time.strftime("%Y%m%d_%H%M%S")
                    filename = f"capture_{timestamp}.png"
                    
                    # Create captures directory if needed
                    captures_dir = os.path.join(os.path.dirname(__file__), "../../../captures")
                    os.makedirs(captures_dir, exist_ok=True)
                    
                    file_path = os.path.join(captures_dir, filename)
                    
                    # Capture using pyautogui
                    x, y, w, h = region
                    screenshot = pyautogui.screenshot(region=(x, y, w, h))
                    screenshot.save(file_path)
                    
                    # Update UI
                    self.image_path_input.setText(file_path)
                    # Delay preview update
                    from PyQt5.QtCore import QTimer
                    QTimer.singleShot(50, self._update_preview)
                    self.show()
                    
                selector.selectionComplete.connect(on_selection)
                selector.selectionCancelled.connect(lambda: self.show())
                
                # Small delay to ensure dialog is hidden
                from PyQt5.QtCore import QTimer
                QTimer.singleShot(100, selector.start_selection)
                
            except Exception as e:
                print(f"Simple selector error in capture: {e}")
                self.show()
                QMessageBox.warning(self, "ì˜¤ë¥˜", "í™”ë©´ ìº¡ì²˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
        
    def _paste_from_clipboard(self):
        """Paste image from clipboard"""
        # Use the unified clipboard utility
        file_path = save_clipboard_image()
        
        if file_path and os.path.exists(file_path):
            # Update UI
            self.image_path_input.setText(file_path)
            # Delay preview update to ensure dialog is properly sized
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(50, self._update_preview)
            QMessageBox.information(self, "ì„±ê³µ", "í´ë¦½ë³´ë“œì—ì„œ ì´ë¯¸ì§€ë¥¼ ë¶™ì—¬ë„£ì—ˆìŠµë‹ˆë‹¤.")
        else:
            QMessageBox.information(
                self, 
                "ì•ˆë‚´", 
                "í´ë¦½ë³´ë“œì— ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.\n\n"
                "ì‚¬ìš© ë°©ë²•:\n"
                "1. Windows: Shift + Win + S ë¡œ í™”ë©´ ìº¡ì²˜\n"
                "2. ì´ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ë¶™ì—¬ë„£ê¸°\n\n"
                "ì°¸ê³ : WSL í™˜ê²½ì—ì„œëŠ” Windows PowerShellì„ í†µí•´\n"
                "í´ë¦½ë³´ë“œì— ì ‘ê·¼í•©ë‹ˆë‹¤."
            )
    
        
    def _update_preview(self):
        """Update image preview"""
        image_path = self.image_path_input.text()
        if os.path.exists(image_path):
            pixmap = QPixmap(image_path)
            if not pixmap.isNull():
                # Get the preview label size
                label_width = self.image_preview.width() - 10  # Account for padding
                label_height = self.image_preview.height() - 10
                
                # Scale to fit preview while keeping aspect ratio
                # Use the smaller of the two dimensions to ensure it fits
                scaled = pixmap.scaled(
                    label_width,
                    label_height,
                    Qt.KeepAspectRatio,
                    Qt.SmoothTransformation
                )
                self.image_preview.setPixmap(scaled)
                
                # Show original size info
                size_text = f"ì›ë³¸ í¬ê¸°: {pixmap.width()} x {pixmap.height()}"
                self.image_preview.setToolTip(size_text)
            else:
                self.image_preview.setText("ì˜ëª»ëœ ì´ë¯¸ì§€")
                self.image_preview.setToolTip("")
        else:
            self.image_preview.setText("ì„ íƒëœ ì´ë¯¸ì§€ ì—†ìŒ")
            self.image_preview.setToolTip("")
            
    def _select_region(self):
        """Start region selection"""
        # Temporarily hide dialog
        self.hide()
        
        # Try simple selector first (better for WSL)
        try:
            from ui.widgets.simple_roi_selector import SimpleROISelector
            selector = SimpleROISelector()
            
            def on_selection_complete(region):
                try:
                    print(f"DEBUG: ROI selection complete with region: {region}, type: {type(region)}")
                    # Ensure region is properly formatted
                    if region and len(region) == 4:
                        # Convert all values to integers to avoid any type issues
                        formatted_region = tuple(int(x) for x in region)
                        self.roi_selector.set_region(formatted_region)
                        print(f"DEBUG: set_region successful with formatted region: {formatted_region}")
                    else:
                        print(f"DEBUG: Invalid region format: {region}")
                        self.roi_selector.set_region(None)
                    self.show()
                    print(f"DEBUG: dialog.show() successful")
                    selector.deleteLater()
                except Exception as e:
                    print(f"DEBUG: Error in on_selection_complete: {e}")
                    import traceback
                    traceback.print_exc()
                    # Still try to show the dialog
                    self.show()
                    selector.deleteLater()
                
            def on_selection_cancelled():
                self.show()
                selector.deleteLater()
                
            selector.selectionComplete.connect(on_selection_complete)
            selector.selectionCancelled.connect(on_selection_cancelled)
            
            # Small delay to ensure dialog is hidden
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(100, selector.start_selection)
            
        except Exception as e:
            print(f"Simple selector error: {e}")
            # Fallback to original overlay selector
            from ui.widgets.roi_selector import ROISelectorOverlay
            overlay = ROISelectorOverlay()
            
            def on_selection_complete(region):
                try:
                    print(f"DEBUG: Overlay ROI selection complete with region: {region}, type: {type(region)}")
                    # Ensure region is properly formatted
                    if region and len(region) == 4:
                        # Convert all values to integers to avoid any type issues
                        formatted_region = tuple(int(x) for x in region)
                        self.roi_selector.set_region(formatted_region)
                        print(f"DEBUG: overlay set_region successful with formatted region: {formatted_region}")
                    else:
                        print(f"DEBUG: Invalid overlay region format: {region}")
                        self.roi_selector.set_region(None)
                    self.show()
                    print(f"DEBUG: overlay dialog.show() successful")
                    overlay.deleteLater()
                except Exception as e:
                    print(f"DEBUG: Error in overlay on_selection_complete: {e}")
                    import traceback
                    traceback.print_exc()
                    # Still try to show the dialog
                    self.show()
                    overlay.deleteLater()
                
            def on_selection_cancelled():
                self.show()
                overlay.deleteLater()
                
            overlay.selectionComplete.connect(on_selection_complete)
            overlay.selectionCancelled.connect(on_selection_cancelled)
            
            # Small delay to ensure dialog is hidden
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(100, overlay.start_selection)
        
    def _clear_region(self):
        """Clear selected region"""
        self.roi_selector.set_region(None)
        
    def load_step_data(self):
        """Load data from existing step"""
        if self.step:
            self.name_input.setText(self.step.name)
            
            # Load image path if available
            if hasattr(self.step, 'image_path'):
                self.image_path_input.setText(self.step.image_path)
                self._update_preview()
                
            # Load region if available
            if hasattr(self.step, 'region') and self.step.region:
                self.roi_selector.set_region(self.step.region)
                
    def get_step_data(self) -> Dict[str, Any]:
        """Get configured step data"""
        data = {
            'name': self.name_input.text(),
            'image_path': self.image_path_input.text(),
            'region': self.roi_selector.get_region()
        }
        
        # Add custom data from subclasses
        data.update(self.get_custom_data())
        
        return data
        
    def get_custom_data(self) -> Dict[str, Any]:
        """Override to return step-specific data"""
        return {}
        
    def accept(self):
        """Validate and accept dialog"""
        # Basic validation
        if not self.name_input.text():
            QMessageBox.warning(self, "í™•ì¸ ì˜¤ë¥˜", "ë‹¨ê³„ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”")
            return
            
        if not self.image_path_input.text():
            QMessageBox.warning(self, "í™•ì¸ ì˜¤ë¥˜", "ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”")
            return
            
        if not os.path.exists(self.image_path_input.text()):
            QMessageBox.warning(self, "í™•ì¸ ì˜¤ë¥˜", "ì„ íƒí•œ ì´ë¯¸ì§€ íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            return
            
        super().accept()

class WaitImageStepDialog(ImageStepDialog):
    """Dialog for configuring wait image steps"""
    
    def __init__(self, step: Optional[WaitImageStep] = None, 
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(step, settings, parent)
        self.setWindowTitle("ì´ë¯¸ì§€ ëŒ€ê¸° ë‹¨ê³„ ì„¤ì •")
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Add wait-specific controls"""
        # Matching parameters group
        params_group = QGroupBox("Matching Parameters")
        params_layout = QVBoxLayout()
        
        # Timeout
        timeout_layout = QHBoxLayout()
        timeout_layout.addWidget(QLabel("Timeout (seconds):"))
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setMinimum(1)
        self.timeout_spin.setMaximum(300)
        self.timeout_spin.setValue(30)
        timeout_layout.addWidget(self.timeout_spin)
        params_layout.addLayout(timeout_layout)
        
        # Confidence
        confidence_layout = QHBoxLayout()
        confidence_layout.addWidget(QLabel("Confidence:"))
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setMinimum(0.1)
        self.confidence_spin.setMaximum(1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.9)
        self.confidence_spin.setDecimals(2)
        confidence_layout.addWidget(self.confidence_spin)
        
        # Test button
        self.test_btn = QPushButton("Test Match")
        self.test_btn.clicked.connect(self._test_match)
        confidence_layout.addWidget(self.test_btn)
        
        params_layout.addLayout(confidence_layout)
        
        # Test result
        self.test_result_label = QLabel()
        params_layout.addWidget(self.test_result_label)
        
        params_group.setLayout(params_layout)
        layout.addWidget(params_group)
        
    def load_step_data(self):
        """Load wait image step data"""
        super().load_step_data()
        
        if isinstance(self.step, WaitImageStep):
            self.timeout_spin.setValue(int(self.step.timeout))
            self.confidence_spin.setValue(self.step.confidence)
            
    def get_custom_data(self) -> Dict[str, Any]:
        """Get wait-specific data"""
        return {
            'step_type': StepType.WAIT_IMAGE,
            'timeout': self.timeout_spin.value(),
            'confidence': self.confidence_spin.value()
        }
        
    def _test_match(self):
        """Test image matching with current settings"""
        image_path = self.image_path_input.text()
        if not image_path or not os.path.exists(image_path):
            self.test_result_label.setText("Please select a valid image first")
            return
            
        # Perform test match
        result = self.image_matcher.find_image(
            image_path,
            confidence=self.confidence_spin.value(),
            region=self.roi_selector.get_region()
        )
        
        if result.found:
            self.test_result_label.setText(
                f"âœ“ Match found at ({result.center[0]}, {result.center[1]}) "
                f"with confidence {result.confidence:.2f}"
            )
            self.test_result_label.setStyleSheet("color: green;")
        else:
            self.test_result_label.setText(
                f"âœ— No match found (best confidence: {result.confidence:.2f})"
            )
            self.test_result_label.setStyleSheet("color: red;")

class ImageSearchStepDialog(ImageStepDialog):
    """Dialog for configuring image search steps"""
    
    def __init__(self, step: Optional[MacroStep] = None,
                 settings: Optional[Settings] = None,
                 parent=None):
        super().__init__(step, settings, parent)
        self.setWindowTitle("ì´ë¯¸ì§€ ê²€ìƒ‰ ë‹¨ê³„ ì„¤ì •")
        
    def add_custom_controls(self, layout: QVBoxLayout):
        """Add search-specific controls"""
        # Search parameters group
        params_group = QGroupBox("ê²€ìƒ‰ íŒŒë¼ë¯¸í„°")
        params_layout = QVBoxLayout()
        
        # Confidence
        confidence_layout = QHBoxLayout()
        confidence_layout.addWidget(QLabel("ì‹ ë¢°ë„:"))
        self.confidence_spin = QDoubleSpinBox()
        self.confidence_spin.setMinimum(0.1)
        self.confidence_spin.setMaximum(1.0)
        self.confidence_spin.setSingleStep(0.05)
        self.confidence_spin.setValue(0.9)
        self.confidence_spin.setDecimals(2)
        confidence_layout.addWidget(self.confidence_spin)
        params_layout.addLayout(confidence_layout)
        
        # Search all occurrences
        self.search_all_check = QCheckBox("ëª¨ë“  í•­ëª© ì°¾ê¸°")
        params_layout.addWidget(self.search_all_check)
        
        # Max results (when search all is checked)
        max_results_layout = QHBoxLayout()
        max_results_layout.addWidget(QLabel("ìµœëŒ€ ê²°ê³¼:"))
        self.max_results_spin = QSpinBox()
        self.max_results_spin.setMinimum(1)
        self.max_results_spin.setMaximum(100)
        self.max_results_spin.setValue(10)
        self.max_results_spin.setEnabled(False)
        max_results_layout.addWidget(self.max_results_spin)
        params_layout.addLayout(max_results_layout)
        
        # Connect search all checkbox
        self.search_all_check.toggled.connect(self.max_results_spin.setEnabled)
        
        params_group.setLayout(params_layout)
        layout.addWidget(params_group)
        
    def get_custom_data(self) -> Dict[str, Any]:
        """Get search-specific data"""
        return {
            'step_type': StepType.IMAGE_SEARCH,
            'confidence': self.confidence_spin.value(),
            'search_all': self.search_all_check.isChecked(),
            'max_results': self.max_results_spin.value()
        }
</file>

<file path="src/ui/widgets/excel_widget.py">
"""
Main Excel integration widget
"""

from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QSplitter, QMessageBox,
    QProgressDialog
)
from PyQt5.QtCore import Qt, pyqtSignal, QThread
from ui.widgets.file_selector import FileSelectorWidget
from ui.widgets.sheet_mapper import SheetMapperWidget
from ui.widgets.data_preview import DataPreviewWidget
from excel.excel_manager import ExcelManager
from excel.models import ExcelFileInfo, ColumnMapping
from logger.app_logger import get_logger

class ExcelLoadThread(QThread):
    """Thread for loading Excel files"""
    
    fileLoaded = pyqtSignal(ExcelFileInfo)
    error = pyqtSignal(str)
    
    def __init__(self, excel_manager: ExcelManager, file_path: str):
        super().__init__()
        self.excel_manager = excel_manager
        self.file_path = file_path
        
    def run(self):
        """Run Excel loading in thread"""
        try:
            file_info = self.excel_manager.load_file(self.file_path)
            self.fileLoaded.emit(file_info)
        except Exception as e:
            self.error.emit(str(e))

class ExcelWidget(QWidget):
    """Main Excel integration widget"""
    
    dataReady = pyqtSignal(object)  # ExcelData
    
    def __init__(self):
        super().__init__()
        self.logger = get_logger(__name__)
        self.excel_manager = ExcelManager()
        self.current_file_info: Optional[ExcelFileInfo] = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Create splitter for resizable sections
        splitter = QSplitter(Qt.Vertical)
        
        # File selector
        self.file_selector = FileSelectorWidget()
        self.file_selector.fileSelected.connect(self._on_file_selected)
        splitter.addWidget(self.file_selector)
        
        # Sheet mapper
        self.sheet_mapper = SheetMapperWidget()
        self.sheet_mapper.mappingComplete.connect(self._on_mapping_complete)
        splitter.addWidget(self.sheet_mapper)
        
        # Data preview
        self.data_preview = DataPreviewWidget()
        self.data_preview.rowSelected.connect(self._on_row_selected)
        splitter.addWidget(self.data_preview)
        
        # Set initial splitter sizes (30%, 30%, 40%)
        splitter.setSizes([300, 300, 400])
        
        layout.addWidget(splitter)
        self.setLayout(layout)
        
    def _on_file_selected(self, file_path: str):
        """Handle file selection"""
        # Show progress dialog
        progress = QProgressDialog("ì—‘ì…€ íŒŒì¼ ë¡œë”© ì¤‘...", None, 0, 0, self)
        progress.setWindowModality(Qt.WindowModal)
        progress.show()
        
        # Load file in thread
        self.load_thread = ExcelLoadThread(self.excel_manager, file_path)
        self.load_thread.fileLoaded.connect(lambda info: self._on_file_loaded(info, progress))
        self.load_thread.error.connect(lambda err: self._on_load_error(err, progress))
        self.load_thread.start()
        
    def _on_file_loaded(self, file_info: ExcelFileInfo, progress: QProgressDialog):
        """Handle successful file load"""
        progress.close()
        self.current_file_info = file_info
        self.sheet_mapper.set_file_info(file_info.sheets)
        self.logger.info(f"Loaded Excel file: {file_info.file_path}")
        
    def _on_load_error(self, error: str, progress: QProgressDialog):
        """Handle file load error"""
        progress.close()
        QMessageBox.critical(self, "íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜", f"ì—‘ì…€ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n{error}")
        self.logger.error(f"Failed to load Excel file: {error}")
        
    def _on_mapping_complete(self, sheet_name: str, mappings: list):
        """Handle mapping completion"""
        try:
            # Read sheet data
            excel_data = self.excel_manager.read_sheet(sheet_name)
            
            # Apply mappings
            for mapping in mappings:
                self.excel_manager.set_column_mapping(
                    mapping.excel_column,
                    mapping.variable_name,
                    mapping.data_type,
                    mapping.is_required
                )
            
            # Load data in preview
            self.data_preview.load_excel_data(excel_data)
            
            # Emit signal that data is ready
            self.dataReady.emit(excel_data)
            
            self.logger.info(f"Loaded sheet '{sheet_name}' with {len(mappings)} mappings")
            
        except Exception as e:
            QMessageBox.critical(self, "ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜", f"ì‹œíŠ¸ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n{str(e)}")
            self.logger.error(f"Failed to load sheet data: {e}")
            
    def _on_row_selected(self, row_index: int):
        """Handle row selection in preview"""
        self.logger.debug(f"Row {row_index} selected for execution")
        
    def get_excel_manager(self) -> ExcelManager:
        """Get Excel manager instance"""
        return self.excel_manager
        
    def save_current_file(self):
        """Save current Excel file with updates"""
        if self.excel_manager._current_data:
            try:
                save_path = self.excel_manager.save_file()
                QMessageBox.information(self, "ì €ì¥ ì™„ë£Œ", f"íŒŒì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:\n{save_path}")
                self.logger.info(f"Saved Excel file: {save_path}")
            except Exception as e:
                QMessageBox.critical(self, "ì €ì¥ ì˜¤ë¥˜", f"íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
                self.logger.error(f"Failed to save Excel file: {e}")
                
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the Excel widget"""
        # Find the splitter
        splitter = self.findChild(QSplitter)
        
        if is_compact:
            # Reduce splitter sizes and spacing
            if splitter:
                splitter.setSizes([200, 200, 300])
                
            # Apply compact mode to child widgets
            if hasattr(self.file_selector, 'set_compact_mode'):
                self.file_selector.set_compact_mode(is_compact)
            if hasattr(self.sheet_mapper, 'set_compact_mode'):
                self.sheet_mapper.set_compact_mode(is_compact)
            if hasattr(self.data_preview, 'set_compact_mode'):
                self.data_preview.set_compact_mode(is_compact)
                
            # Reduce layout margins
            self.layout().setContentsMargins(5, 5, 5, 5)
            self.layout().setSpacing(5)
        else:
            # Reset to normal sizes
            if splitter:
                splitter.setSizes([300, 300, 400])
                
            # Reset child widgets
            if hasattr(self.file_selector, 'set_compact_mode'):
                self.file_selector.set_compact_mode(is_compact)
            if hasattr(self.sheet_mapper, 'set_compact_mode'):
                self.sheet_mapper.set_compact_mode(is_compact)
            if hasattr(self.data_preview, 'set_compact_mode'):
                self.data_preview.set_compact_mode(is_compact)
                
            # Reset layout margins
            self.layout().setContentsMargins(9, 9, 9, 9)
            self.layout().setSpacing(6)
</file>

<file path="src/ui/widgets/execution_widget.py">
"""
Macro execution control widget
"""

from typing import Optional
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QProgressBar, QTableWidget, QTableWidgetItem, QGroupBox,
    QTextEdit, QSplitter, QHeaderView, QCheckBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QColor, QBrush, QFont
from automation.engine import ExecutionEngine, ExecutionState, ExecutionResult
from excel.excel_manager import ExcelManager
from core.macro_types import Macro, MacroStep
from config.settings import Settings
from logger.app_logger import get_logger

class ExecutionStatusWidget(QWidget):
    """Widget showing execution status"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Status label
        self.status_label = QLabel("ëŒ€ê¸° ì¤‘")
        self.status_label.setAlignment(Qt.AlignCenter)
        font = QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.status_label.setFont(font)
        layout.addWidget(self.status_label)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(True)
        layout.addWidget(self.progress_bar)
        
        # Statistics
        stats_layout = QHBoxLayout()
        
        self.total_label = QLabel("ì „ì²´: 0")
        stats_layout.addWidget(self.total_label)
        
        self.completed_label = QLabel("ì™„ë£Œ: 0")
        self.completed_label.setStyleSheet("color: green;")
        stats_layout.addWidget(self.completed_label)
        
        self.failed_label = QLabel("ì‹¤íŒ¨: 0")
        self.failed_label.setStyleSheet("color: red;")
        stats_layout.addWidget(self.failed_label)
        
        self.time_label = QLabel("ì†Œìš”ì‹œê°„: 0:00")
        stats_layout.addWidget(self.time_label)
        
        stats_layout.addStretch()
        layout.addLayout(stats_layout)
        
        self.setLayout(layout)
        
    def update_status(self, state: ExecutionState):
        """Update status display"""
        status_map = {
            ExecutionState.IDLE: ("ëŒ€ê¸° ì¤‘", "#000000"),
            ExecutionState.RUNNING: ("ì‹¤í–‰ ì¤‘", "#00aa00"),
            ExecutionState.PAUSED: ("ì¼ì‹œì •ì§€", "#ff8800"),
            ExecutionState.STOPPING: ("ì •ì§€ ì¤‘...", "#aa0000"),
            ExecutionState.STOPPED: ("ì •ì§€ë¨", "#aa0000"),
            ExecutionState.ERROR: ("ì˜¤ë¥˜", "#ff0000")
        }
        
        text, color = status_map.get(state, ("ì•Œ ìˆ˜ ì—†ìŒ", "#000000"))
        self.status_label.setText(text)
        self.status_label.setStyleSheet(f"color: {color};")
        
    def update_progress(self, current: int, total: int):
        """Update progress bar"""
        self.progress_bar.setMaximum(total)
        self.progress_bar.setValue(current)
        self.progress_bar.setFormat(f"{current}/{total} ({current/total*100:.1f}%)")
        
    def update_statistics(self, total: int, completed: int, failed: int, elapsed_seconds: float):
        """Update statistics"""
        self.total_label.setText(f"ì „ì²´: {total}")
        self.completed_label.setText(f"ì™„ë£Œ: {completed}")
        self.failed_label.setText(f"ì‹¤íŒ¨: {failed}")
        
        minutes = int(elapsed_seconds // 60)
        seconds = int(elapsed_seconds % 60)
        self.time_label.setText(f"ì†Œìš”ì‹œê°„: {minutes}:{seconds:02d}")

class ExecutionLogWidget(QTableWidget):
    """Widget showing execution log"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        # Set columns
        self.setColumnCount(5)
        self.setHorizontalHeaderLabels(["ì‹œê°„", "í–‰", "ë‹¨ê³„", "ìƒíƒœ", "ë©”ì‹œì§€"])
        
        # Configure table
        self.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.horizontalHeader().setSectionResizeMode(3, QHeaderView.Fixed)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        
        self.setColumnWidth(1, 60)  # Row
        self.setColumnWidth(3, 80)  # Status
        
        # Style
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QTableWidget.SelectRows)
        
    def add_log_entry(self, timestamp: str, row: int, step_name: str, 
                      success: bool, message: str = ""):
        """Add log entry"""
        row_count = self.rowCount()
        self.insertRow(row_count)
        
        # Time
        self.setItem(row_count, 0, QTableWidgetItem(timestamp))
        
        # Row number
        row_item = QTableWidgetItem(str(row + 1))
        row_item.setTextAlignment(Qt.AlignCenter)
        self.setItem(row_count, 1, row_item)
        
        # Step name
        self.setItem(row_count, 2, QTableWidgetItem(step_name))
        
        # Status
        status_item = QTableWidgetItem("ì„±ê³µ" if success else "ì‹¤íŒ¨")
        status_item.setTextAlignment(Qt.AlignCenter)
        if success:
            status_item.setForeground(QBrush(QColor(0, 150, 0)))
        else:
            status_item.setForeground(QBrush(QColor(200, 0, 0)))
        self.setItem(row_count, 3, status_item)
        
        # Message
        self.setItem(row_count, 4, QTableWidgetItem(message))
        
        # Auto scroll to bottom
        self.scrollToBottom()

class ExecutionControlWidget(QWidget):
    """Execution control buttons"""
    
    startRequested = pyqtSignal()
    pauseRequested = pyqtSignal()
    stopRequested = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        # Start button
        self.start_btn = QPushButton("â–¶ ì‹œì‘")
        self.start_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.start_btn.clicked.connect(self.startRequested.emit)
        layout.addWidget(self.start_btn)
        
        # Pause button
        self.pause_btn = QPushButton("â¸ ì¼ì‹œì •ì§€")
        self.pause_btn.setEnabled(False)
        self.pause_btn.clicked.connect(self.pauseRequested.emit)
        layout.addWidget(self.pause_btn)
        
        # Stop button
        self.stop_btn = QPushButton("â¹ ì •ì§€")
        self.stop_btn.setEnabled(False)
        self.stop_btn.setStyleSheet("""
            QPushButton:enabled {
                background-color: #f44336;
                color: white;
            }
        """)
        self.stop_btn.clicked.connect(self.stopRequested.emit)
        layout.addWidget(self.stop_btn)
        
        layout.addStretch()
        
        # Hotkey info
        hotkey_label = QLabel("ë‹¨ì¶•í‚¤: F9(ì¼ì‹œì •ì§€), ESC(ì •ì§€)")
        hotkey_label.setStyleSheet("color: #666; font-style: italic;")
        layout.addWidget(hotkey_label)
        
        self.setLayout(layout)
        
    def set_running_state(self, is_running: bool, is_paused: bool = False):
        """Update button states"""
        self.start_btn.setEnabled(not is_running)
        self.pause_btn.setEnabled(is_running)
        self.stop_btn.setEnabled(is_running)
        
        if is_paused:
            self.pause_btn.setText("â–¶ ì¬ê°œ")
        else:
            self.pause_btn.setText("â¸ ì¼ì‹œì •ì§€")

class ExecutionWidget(QWidget):
    """Complete execution widget"""
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
        # Execution engine
        self.engine = ExecutionEngine(settings)
        self.current_macro: Optional[Macro] = None
        self.excel_manager: Optional[ExcelManager] = None
        
        # Statistics
        self.start_time = None
        self.completed_count = 0
        self.failed_count = 0
        
        # Timer for elapsed time
        self.timer = QTimer()
        self.timer.timeout.connect(self._update_elapsed_time)
        
        self.init_ui()
        self.connect_signals()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QVBoxLayout()
        
        # Control buttons
        self.control_widget = ExecutionControlWidget()
        layout.addWidget(self.control_widget)
        
        # Status display
        status_group = QGroupBox("ì‹¤í–‰ ìƒíƒœ")
        status_layout = QVBoxLayout()
        self.status_widget = ExecutionStatusWidget()
        status_layout.addWidget(self.status_widget)
        status_group.setLayout(status_layout)
        layout.addWidget(status_group)
        
        # Options
        options_layout = QHBoxLayout()
        self.incomplete_only_checkbox = QCheckBox("ë¯¸ì™„ë£Œ í•­ëª©ë§Œ ì‹¤í–‰")
        self.incomplete_only_checkbox.setChecked(True)
        options_layout.addWidget(self.incomplete_only_checkbox)
        options_layout.addStretch()
        layout.addLayout(options_layout)
        
        # Log display
        log_group = QGroupBox("ì‹¤í–‰ ë¡œê·¸")
        log_layout = QVBoxLayout()
        
        # Log toolbar
        log_toolbar_layout = QHBoxLayout()
        log_toolbar_layout.addStretch()
        
        view_logs_btn = QPushButton("CSV ë¡œê·¸ ë³´ê¸°")
        view_logs_btn.clicked.connect(self.show_log_viewer)
        log_toolbar_layout.addWidget(view_logs_btn)
        
        log_layout.addLayout(log_toolbar_layout)
        
        self.log_widget = ExecutionLogWidget()
        log_layout.addWidget(self.log_widget)
        log_group.setLayout(log_layout)
        layout.addWidget(log_group)
        
        self.setLayout(layout)
        
    def connect_signals(self):
        """Connect signals"""
        # Control signals
        self.control_widget.startRequested.connect(self.start_execution)
        self.control_widget.pauseRequested.connect(self.toggle_pause)
        self.control_widget.stopRequested.connect(self.stop_execution)
        
        # Engine signals
        self.engine.stateChanged.connect(self._on_state_changed)
        self.engine.progressUpdated.connect(self._on_progress_updated)
        self.engine.rowCompleted.connect(self._on_row_completed)
        self.engine.stepExecuting.connect(self._on_step_executing)
        self.engine.executionFinished.connect(self._on_execution_finished)
        self.engine.error.connect(self._on_error)
        
    def set_macro_and_excel(self, macro: Macro, excel_manager: ExcelManager):
        """Set macro and Excel manager"""
        self.current_macro = macro
        self.excel_manager = excel_manager
        
    def start_execution(self):
        """Start macro execution"""
        if not self.current_macro or not self.excel_manager:
            self.logger.warning("No macro or Excel data loaded")
            return
            
        # Reset statistics
        self.completed_count = 0
        self.failed_count = 0
        from PyQt5.QtCore import QTime
        self.start_time = QTime.currentTime()
        self.log_widget.setRowCount(0)
        
        # Configure engine
        self.engine.set_macro(self.current_macro, self.excel_manager)
        
        # Set target rows based on checkbox
        if self.incomplete_only_checkbox.isChecked():
            # Let engine use default (incomplete rows)
            self.engine.set_target_rows([])
        else:
            # Execute all rows
            total_rows = len(self.excel_manager._current_data.dataframe)
            self.engine.set_target_rows(list(range(total_rows)))
            
        # Start execution
        self.engine.start()
        self.timer.start(1000)  # Update every second
        
    def toggle_pause(self):
        """Toggle pause state"""
        self.engine.toggle_pause()
        
    def stop_execution(self):
        """Stop execution"""
        self.engine.stop_execution()
        
    def _on_state_changed(self, state: ExecutionState):
        """Handle state change"""
        self.status_widget.update_status(state)
        
        is_running = state in [ExecutionState.RUNNING, ExecutionState.PAUSED]
        is_paused = state == ExecutionState.PAUSED
        self.control_widget.set_running_state(is_running, is_paused)
        
        if not is_running:
            self.timer.stop()
            
    def _on_progress_updated(self, current: int, total: int):
        """Handle progress update"""
        self.status_widget.update_progress(current, total)
        
    def _on_row_completed(self, result: ExecutionResult):
        """Handle row completion"""
        if result.success:
            self.completed_count += 1
        else:
            self.failed_count += 1
            
        # Add to log
        import time
        timestamp = time.strftime("%H:%M:%S", time.localtime(result.timestamp))
        self.log_widget.add_log_entry(
            timestamp,
            result.row_index,
            "í–‰ ì™„ë£Œ",
            result.success,
            result.error or f"ì†Œìš”ì‹œê°„: {result.duration_ms:.0f}ms"
        )
        
    def _on_step_executing(self, step: MacroStep, row_index: int):
        """Handle step execution"""
        # Could add detailed step logging here if needed
        pass
        
    def _on_execution_finished(self):
        """Handle execution finished"""
        self.logger.info("Execution finished")
        self.timer.stop()
        
    def _on_error(self, error_msg: str):
        """Handle execution error"""
        self.logger.error(f"Execution error: {error_msg}")
        
        # Show error dialog
        from ui.dialogs.error_report_dialog import ErrorReportDialog
        from logger.execution_logger import get_execution_logger
        
        log_file = get_execution_logger().get_current_log_file()
        ErrorReportDialog.show_error(
            "Execution Error",
            error_msg,
            log_file=log_file,
            parent=self
        )
        
    def _update_elapsed_time(self):
        """Update elapsed time display"""
        if self.start_time:
            elapsed = self.start_time.secsTo(QTimer.currentTime())
            total = self.completed_count + self.failed_count
            self.status_widget.update_statistics(
                total, self.completed_count, self.failed_count, elapsed
            )
            
    def show_log_viewer(self):
        """Show log viewer dialog"""
        from ui.dialogs.log_viewer_dialog import LogViewerDialog
        from logger.execution_logger import get_execution_logger
        
        # Open with current log file if available
        log_file = get_execution_logger().get_current_log_file()
        dialog = LogViewerDialog(log_file=log_file, parent=self)
        dialog.show()  # Non-modal
        
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the execution widget"""
        if is_compact:
            # Reduce spacing in main layout
            self.layout().setSpacing(5)
            self.layout().setContentsMargins(5, 5, 5, 5)
            
            # Adjust group boxes
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(5, 15, 5, 5)
                
            # Set compact height for log table rows
            self.log_widget.verticalHeader().setDefaultSectionSize(22)
        else:
            # Reset to normal spacing
            self.layout().setSpacing(10)
            self.layout().setContentsMargins(10, 10, 10, 10)
            
            # Reset group boxes
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(9, 20, 9, 9)
                
            # Reset log table row height
            self.log_widget.verticalHeader().setDefaultSectionSize(30)
</file>

<file path="src/ui/widgets/macro_editor.py">
"""
Drag and drop macro editor widget
"""

from typing import Optional, List, Dict, Any
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QLabel, QScrollArea, QFrame, QMenu, QMessageBox,
    QSplitter, QGroupBox, QToolButton, QDialog
)
from PyQt5.QtCore import Qt, pyqtSignal, QMimeData, QByteArray, QDataStream, QIODevice
from PyQt5.QtGui import QDrag, QDragEnterEvent, QDropEvent, QPalette, QIcon, QCursor
from core.macro_types import (
    MacroStep, StepType, Macro, StepFactory,
    MouseClickStep, KeyboardTypeStep, WaitTimeStep
)

class StepPaletteItem(QListWidgetItem):
    """Draggable step type item"""
    
    def __init__(self, step_type: StepType, display_name: str, icon: Optional[QIcon] = None):
        super().__init__(display_name)
        self.step_type = step_type
        if icon:
            self.setIcon(icon)
        self.setToolTip(self._get_tooltip())
        
    def _get_tooltip(self) -> str:
        """Get tooltip for step type"""
        tooltips = {
            StepType.MOUSE_CLICK: "ë§ˆìš°ìŠ¤ í´ë¦­ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.MOUSE_MOVE: "ë§ˆìš°ìŠ¤ ì´ë™ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.KEYBOARD_TYPE: "í…ìŠ¤íŠ¸ ì…ë ¥ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.KEYBOARD_HOTKEY: "ë‹¨ì¶•í‚¤ ì…ë ¥ ë™ì‘ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.WAIT_TIME: "ì§€ì •ëœ ì‹œê°„ë§Œí¼ ëŒ€ê¸°í•©ë‹ˆë‹¤",
            StepType.WAIT_IMAGE: "ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ ëŒ€ê¸°í•©ë‹ˆë‹¤",
            StepType.IMAGE_SEARCH: "í™”ë©´ì—ì„œ ì´ë¯¸ì§€ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤",
            StepType.OCR_TEXT: "í™”ë©´ì—ì„œ í…ìŠ¤íŠ¸ë¥¼ ê²€ìƒ‰í•˜ê³  í´ë¦­í•©ë‹ˆë‹¤",
            StepType.SCREENSHOT: "í™”ë©´ì„ ìº¡ì²˜í•©ë‹ˆë‹¤",
            StepType.IF_CONDITION: "ì¡°ê±´ë¬¸ì„ ì¶”ê°€í•©ë‹ˆë‹¤",
            StepType.LOOP: "ë°˜ë³µë¬¸ì„ ì¶”ê°€í•©ë‹ˆë‹¤"
        }
        return tooltips.get(self.step_type, "")

class StepPalette(QListWidget):
    """Palette of draggable step types"""
    
    def __init__(self):
        super().__init__()
        self.setDragEnabled(True)
        self.setDefaultDropAction(Qt.CopyAction)
        self.setMaximumWidth(200)
        self.init_steps()
        
    def init_steps(self):
        """Initialize available step types"""
        step_configs = [
            (StepType.MOUSE_CLICK, "ë§ˆìš°ìŠ¤ í´ë¦­", "ğŸ–±ï¸"),
            (StepType.MOUSE_MOVE, "ë§ˆìš°ìŠ¤ ì´ë™", "â†—ï¸"),
            (StepType.KEYBOARD_TYPE, "í…ìŠ¤íŠ¸ ì…ë ¥", "âŒ¨ï¸"),
            (StepType.KEYBOARD_HOTKEY, "ë‹¨ì¶•í‚¤", "âŒ˜"),
            (StepType.WAIT_TIME, "ëŒ€ê¸°", "â±ï¸"),
            (StepType.WAIT_IMAGE, "ì´ë¯¸ì§€ ëŒ€ê¸°", "ğŸ–¼ï¸"),
            (StepType.IMAGE_SEARCH, "ì´ë¯¸ì§€ ê²€ìƒ‰", "ğŸ”"),
            (StepType.OCR_TEXT, "í…ìŠ¤íŠ¸ ê²€ìƒ‰", "ğŸ”¤"),
            (StepType.SCREENSHOT, "í™”ë©´ ìº¡ì²˜", "ğŸ“·"),
            (StepType.IF_CONDITION, "ì¡°ê±´ë¬¸", "â“"),
            (StepType.LOOP, "ë°˜ë³µë¬¸", "ğŸ”„"),
        ]
        
        for step_type, name, emoji in step_configs:
            item = StepPaletteItem(step_type, f"{emoji} {name}")
            self.addItem(item)
            
    def startDrag(self, supportedActions):
        """Start dragging a step type"""
        item = self.currentItem()
        if isinstance(item, StepPaletteItem):
            drag = QDrag(self)
            mime_data = QMimeData()
            
            # Store step type in MIME data
            byte_array = QByteArray()
            stream = QDataStream(byte_array, QIODevice.WriteOnly)
            stream.writeQString(item.step_type.value)
            
            mime_data.setData("application/x-steptype", byte_array)
            mime_data.setText(item.text())
            drag.setMimeData(mime_data)
            
            drag.exec_(Qt.CopyAction)

class MacroStepWidget(QFrame):
    """Widget representing a single macro step"""
    
    editRequested = pyqtSignal(MacroStep)
    deleteRequested = pyqtSignal(str)  # step_id
    moveRequested = pyqtSignal(str, int)  # step_id, new_index
    selectionChanged = pyqtSignal(str, bool)  # step_id, selected
    
    def __init__(self, step: MacroStep, index: int):
        super().__init__()
        self.step = step
        self.index = index
        self.selected = False
        self.setFrameStyle(QFrame.Box)
        self.setAcceptDrops(True)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        layout.setContentsMargins(5, 5, 5, 5)
        
        # Selection checkbox
        from PyQt5.QtWidgets import QCheckBox
        self.select_cb = QCheckBox()
        self.select_cb.toggled.connect(self._on_selection_changed)
        layout.addWidget(self.select_cb)
        
        # Drag handle
        self.handle = QLabel("â‰¡")
        self.handle.setStyleSheet("font-size: 16px; color: #888;")
        self.handle.setCursor(Qt.OpenHandCursor)
        layout.addWidget(self.handle)
        
        # Step info
        info_layout = QVBoxLayout()
        
        # Step name and type with icon
        step_icon = self._get_step_icon()
        name_text = f"{step_icon} <b>{self.step.name or self.step.step_type.value}</b>"
        name_label = QLabel(name_text)
        info_layout.addWidget(name_label)
        
        # Step details based on type
        details_text = self._get_step_details()
        if details_text:
            details_label = QLabel(details_text)
            details_label.setWordWrap(True)
            details_label.setStyleSheet("color: #666; font-size: 11px;")
            info_layout.addWidget(details_label)
            
        # Step description
        if self.step.description:
            desc_label = QLabel(self.step.description)
            desc_label.setWordWrap(True)
            desc_label.setStyleSheet("color: #666; font-size: 11px;")
            info_layout.addWidget(desc_label)
            
        layout.addLayout(info_layout)
        layout.addStretch()
        
        # Enable/disable checkbox
        self.enable_btn = QToolButton()
        self.enable_btn.setCheckable(True)
        self.enable_btn.setChecked(self.step.enabled)
        self.enable_btn.setText("âœ“" if self.step.enabled else "âœ—")
        self.enable_btn.toggled.connect(self._on_enable_toggled)
        layout.addWidget(self.enable_btn)
        
        # Edit button
        edit_btn = QToolButton()
        edit_btn.setText("âœï¸")
        edit_btn.setToolTip("í¸ì§‘")
        edit_btn.clicked.connect(lambda: self.editRequested.emit(self.step))
        layout.addWidget(edit_btn)
        
        # Delete button
        delete_btn = QToolButton()
        delete_btn.setText("ğŸ—‘ï¸")
        delete_btn.setToolTip("ì‚­ì œ")
        delete_btn.clicked.connect(lambda: self.deleteRequested.emit(self.step.step_id))
        layout.addWidget(delete_btn)
        
        self.setLayout(layout)
        self._update_style()
        
    def _get_step_icon(self) -> str:
        """Get icon for step type"""
        icons = {
            StepType.MOUSE_CLICK: "ğŸ–±ï¸",
            StepType.MOUSE_MOVE: "â†—ï¸",
            StepType.KEYBOARD_TYPE: "âŒ¨ï¸",
            StepType.KEYBOARD_HOTKEY: "âŒ˜",
            StepType.WAIT_TIME: "â±ï¸",
            StepType.WAIT_IMAGE: "ğŸ–¼ï¸",
            StepType.IMAGE_SEARCH: "ğŸ”",
            StepType.OCR_TEXT: "ğŸ”¤",
            StepType.SCREENSHOT: "ğŸ“·",
            StepType.IF_CONDITION: "â“",
            StepType.LOOP: "ğŸ”„"
        }
        return icons.get(self.step.step_type, "")
        
    def _get_step_details(self) -> str:
        """Get step details based on type"""
        details = []
        
        if self.step.step_type == StepType.WAIT_IMAGE:
            if hasattr(self.step, 'image_path') and self.step.image_path:
                import os
                filename = os.path.basename(self.step.image_path)
                details.append(f"ì´ë¯¸ì§€: {filename}")
            if hasattr(self.step, 'timeout'):
                details.append(f"ëŒ€ê¸°ì‹œê°„: {self.step.timeout}ì´ˆ")
            if hasattr(self.step, 'confidence'):
                details.append(f"ì •í™•ë„: {int(self.step.confidence * 100)}%")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("âœ“ ì˜ì—­ ì§€ì •ë¨")
                
        elif self.step.step_type == StepType.IMAGE_SEARCH:
            if hasattr(self.step, 'image_path') and self.step.image_path:
                import os
                filename = os.path.basename(self.step.image_path)
                details.append(f"ì´ë¯¸ì§€: {filename}")
            if hasattr(self.step, 'confidence'):
                details.append(f"ì •í™•ë„: {int(self.step.confidence * 100)}%")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("âœ“ ì˜ì—­ ì§€ì •ë¨")
                
        elif self.step.step_type == StepType.MOUSE_CLICK:
            if hasattr(self.step, 'x') and hasattr(self.step, 'y'):
                details.append(f"ìœ„ì¹˜: ({self.step.x}, {self.step.y})")
            if hasattr(self.step, 'clicks') and self.step.clicks > 1:
                details.append(f"í´ë¦­ ìˆ˜: {self.step.clicks}")
                
        elif self.step.step_type == StepType.KEYBOARD_TYPE:
            if hasattr(self.step, 'text') and self.step.text:
                text_preview = self.step.text[:30] + "..." if len(self.step.text) > 30 else self.step.text
                details.append(f"í…ìŠ¤íŠ¸: {text_preview}")
                
        elif self.step.step_type == StepType.WAIT_TIME:
            if hasattr(self.step, 'seconds'):
                details.append(f"ëŒ€ê¸°: {self.step.seconds}ì´ˆ")
                
        elif self.step.step_type == StepType.OCR_TEXT:
            if hasattr(self.step, 'excel_column') and self.step.excel_column:
                details.append(f"ì—‘ì…€ ì—´: {self.step.excel_column}")
            elif hasattr(self.step, 'search_text') and self.step.search_text:
                text_preview = self.step.search_text[:20] + "..." if len(self.step.search_text) > 20 else self.step.search_text
                details.append(f"í…ìŠ¤íŠ¸: {text_preview}")
            if hasattr(self.step, 'exact_match') and self.step.exact_match:
                details.append("ì •í™•íˆ ì¼ì¹˜")
            if hasattr(self.step, 'region') and self.step.region:
                details.append("âœ“ ì˜ì—­ ì§€ì •ë¨")
                
        elif self.step.step_type == StepType.IF_CONDITION:
            if hasattr(self.step, 'condition_type'):
                condition_names = {
                    "image_exists": "ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ë©´",
                    "text_exists": "í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ë©´",
                    "variable_equals": "ë³€ìˆ˜ê°€ ê°™ìœ¼ë©´",
                    "variable_contains": "ë³€ìˆ˜ê°€ í¬í•¨í•˜ë©´",
                    "variable_greater": "ë³€ìˆ˜ê°€ í¬ë©´",
                    "variable_less": "ë³€ìˆ˜ê°€ ì‘ìœ¼ë©´"
                }
                details.append(condition_names.get(self.step.condition_type, self.step.condition_type))
            if hasattr(self.step, 'true_steps'):
                details.append(f"ì°¸: {len(self.step.true_steps)}ê°œ ë‹¨ê³„")
            if hasattr(self.step, 'false_steps'):
                details.append(f"ê±°ì§“: {len(self.step.false_steps)}ê°œ ë‹¨ê³„")
                
        elif self.step.step_type == StepType.SCREENSHOT:
            if hasattr(self.step, 'filename_pattern'):
                details.append(f"íŒŒì¼ëª…: {self.step.filename_pattern}")
            if hasattr(self.step, 'save_directory'):
                details.append(f"ì €ì¥ ê²½ë¡œ: {self.step.save_directory}")
            if hasattr(self.step, 'region') and self.step.region:
                x, y, w, h = self.step.region
                details.append(f"ì˜ì—­: ({x}, {y}) {w}x{h}")
            else:
                details.append("ì „ì²´ í™”ë©´")
                
        elif self.step.step_type == StepType.LOOP:
            if hasattr(self.step, 'loop_type'):
                loop_names = {
                    "count": "íšŸìˆ˜ ë°˜ë³µ",
                    "while_image": "ì´ë¯¸ì§€ ëŒ€ê¸°",
                    "for_each_row": "í–‰ë³„ ë°˜ë³µ"
                }
                details.append(loop_names.get(self.step.loop_type, self.step.loop_type))
            if hasattr(self.step, 'loop_count') and self.step.loop_type == "count":
                details.append(f"{self.step.loop_count}íšŒ")
            if hasattr(self.step, 'loop_steps'):
                details.append(f"{len(self.step.loop_steps)}ê°œ ë‹¨ê³„ ë°˜ë³µ")
                
        return " | ".join(details) if details else ""
        
    def _on_enable_toggled(self, checked: bool):
        """Handle enable/disable toggle"""
        self.step.enabled = checked
        self.enable_btn.setText("âœ“" if checked else "âœ—")
        self._update_style()
        
    def _update_style(self):
        """Update widget style based on state"""
        if self.selected:
            self.setStyleSheet("""
                MacroStepWidget {
                    background-color: #e3f2fd;
                    border: 2px solid #2196F3;
                    border-radius: 5px;
                }
            """)
        elif self.step.enabled:
            self.setStyleSheet("""
                MacroStepWidget {
                    background-color: white;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                }
                MacroStepWidget:hover {
                    border-color: #999;
                }
            """)
        else:
            self.setStyleSheet("""
                MacroStepWidget {
                    background-color: #f5f5f5;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    opacity: 0.7;
                }
            """)
            
    def _on_selection_changed(self, checked: bool):
        """Handle selection change"""
        self.selected = checked
        self._update_style()
        self.selectionChanged.emit(self.step.step_id, checked)
        
    def set_selected(self, selected: bool):
        """Set selection state"""
        self.select_cb.setChecked(selected)
        self.selected = selected
        self._update_style()
            
    def mousePressEvent(self, event):
        """Handle mouse press for dragging"""
        if event.button() == Qt.LeftButton:
            # Check if clicking on handle
            handle_rect = self.handle.geometry()
            if handle_rect.contains(event.pos()):
                self.drag_start_position = event.pos()
                
    def mouseMoveEvent(self, event):
        """Handle mouse move for dragging"""
        if not (event.buttons() & Qt.LeftButton):
            return
            
        if not hasattr(self, 'drag_start_position'):
            return
            
        if (event.pos() - self.drag_start_position).manhattanLength() < 10:
            return
            
        # Start drag
        drag = QDrag(self)
        mime_data = QMimeData()
        
        # Store step data
        byte_array = QByteArray()
        stream = QDataStream(byte_array, QIODevice.WriteOnly)
        stream.writeQString(self.step.step_id)
        stream.writeInt(self.index)
        
        mime_data.setData("application/x-macrostep", byte_array)
        mime_data.setText(self.step.name or self.step.step_type.value)
        drag.setMimeData(mime_data)
        
        drag.exec_(Qt.MoveAction)

class MacroFlowWidget(QWidget):
    """Widget displaying the macro flow with drag/drop support"""
    
    stepAdded = pyqtSignal(MacroStep, int)  # step, index
    stepMoved = pyqtSignal(str, int)  # step_id, new_index
    stepDeleted = pyqtSignal(str)  # step_id
    stepEdited = pyqtSignal(MacroStep)
    
    def __init__(self):
        super().__init__()
        self.macro = Macro()
        self.step_widgets: Dict[str, MacroStepWidget] = {}
        self.selected_steps: Dict[str, bool] = {}  # step_id -> selected
        self.setAcceptDrops(True)
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        self.layout = QVBoxLayout()
        self.layout.setSpacing(5)
        
        # Empty state label
        self.empty_label = QLabel("ë‹¨ê³„ë¥¼ ì—¬ê¸°ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”")
        self.empty_label.setAlignment(Qt.AlignCenter)
        self.empty_label.setStyleSheet("""
            QLabel {
                color: #999;
                font-size: 14px;
                padding: 50px;
                border: 2px dashed #ddd;
                border-radius: 5px;
            }
        """)
        self.layout.addWidget(self.empty_label)
        
        self.layout.addStretch()
        self.setLayout(self.layout)
        
    def set_macro(self, macro: Macro):
        """Set the macro to display"""
        self.macro = macro
        self._rebuild_ui()
        
    def _rebuild_ui(self):
        """Rebuild UI from macro"""
        # Clear existing widgets
        for widget in self.step_widgets.values():
            widget.deleteLater()
        self.step_widgets.clear()
        
        # Remove all items from layout
        while self.layout.count() > 0:
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
                
        # Show empty label or steps
        if not self.macro.steps:
            try:
                if self.empty_label:
                    self.layout.addWidget(self.empty_label)
                    self.empty_label.show()
            except RuntimeError:
                # Empty label was deleted, recreate it
                self.empty_label = QLabel("ë‹¨ê³„ë¥¼ ì—¬ê¸°ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”")
                self.empty_label.setAlignment(Qt.AlignCenter)
                self.empty_label.setStyleSheet("""
                    QLabel {
                        color: #999;
                        font-size: 14px;
                        padding: 50px;
                        border: 2px dashed #ddd;
                        border-radius: 5px;
                    }
                """)
                self.layout.addWidget(self.empty_label)
        else:
            if self.empty_label:
                try:
                    self.empty_label.hide()
                except RuntimeError:
                    pass
            for i, step in enumerate(self.macro.steps):
                widget = self._create_step_widget(step, i)
                self.layout.insertWidget(i, widget)
                self.step_widgets[step.step_id] = widget
                
        self.layout.addStretch()
        
    def _create_step_widget(self, step: MacroStep, index: int) -> MacroStepWidget:
        """Create widget for a step"""
        widget = MacroStepWidget(step, index)
        widget.editRequested.connect(self._on_step_edit)
        widget.deleteRequested.connect(self._on_step_delete)
        widget.moveRequested.connect(self.stepMoved.emit)
        widget.selectionChanged.connect(self._on_selection_changed)
        
        # Restore selection state
        if step.step_id in self.selected_steps:
            widget.set_selected(self.selected_steps[step.step_id])
            
        return widget
        
    def _on_step_edit(self, step: MacroStep):
        """Handle step edit request"""
        if not step:
            return
            
        try:
            step_id = step.step_id  # Define step_id here
            print(f"DEBUG: _on_step_edit called for step type: {step.step_type}")
            
            # Open appropriate dialog based on step type
            if step.step_type == StepType.WAIT_IMAGE:
                from ui.dialogs.image_step_dialog import WaitImageStepDialog
                dialog = WaitImageStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.image_path = step_data['image_path']
                    step.timeout = step_data['timeout']
                    step.confidence = step_data['confidence']
                    step.region = step_data['region']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.IMAGE_SEARCH:
                from ui.dialogs.image_step_dialog import ImageSearchStepDialog
                dialog = ImageSearchStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.image_path = step_data['image_path']
                    step.confidence = step_data['confidence']
                    step.region = step_data['region']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.OCR_TEXT:
                from ui.dialogs.text_search_step_dialog import TextSearchStepDialog
                # Get Excel columns from parent widget
                excel_columns = []
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'excel_widget'):
                        excel_manager = parent.excel_widget.get_excel_manager()
                        if excel_manager and excel_manager._current_data is not None:
                            excel_columns = list(excel_manager._current_data.columns)
                        break
                    parent = parent.parent()
                    
                dialog = TextSearchStepDialog(step, excel_columns, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.search_text = step_data['search_text']
                    step.excel_column = step_data['excel_column']
                    step.region = step_data['region']
                    step.exact_match = step_data['exact_match']
                    step.confidence = step_data['confidence']
                    step.click_after_find = step_data['click_after_find']
                    step.click_offset = step_data['click_offset']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.IF_CONDITION:
                from ui.dialogs.if_condition_step_dialog import IfConditionStepDialog
                # Get Excel columns from parent widget
                excel_columns = []
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'excel_widget'):
                        excel_manager = parent.excel_widget.get_excel_manager()
                        if excel_manager and excel_manager._current_data is not None:
                            excel_columns = list(excel_manager._current_data.columns)
                        break
                    parent = parent.parent()
                    
                dialog = IfConditionStepDialog(step, excel_columns, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    # Update step with new data
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.description = step_data['description']
                    step.condition_type = step_data['condition_type']
                    step.condition_value = step_data['condition_value']
                    step.true_steps = step_data['true_steps']
                    step.false_steps = step_data['false_steps']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.MOUSE_CLICK:
                from ui.dialogs.mouse_click_step_dialog import MouseClickStepDialog
                dialog = MouseClickStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.x = step_data['x']
                    step.y = step_data['y']
                    step.button = step_data['button']
                    step.clicks = step_data['clicks']
                    step.interval = step_data['interval']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.MOUSE_MOVE:
                from ui.dialogs.mouse_move_step_dialog import MouseMoveStepDialog
                dialog = MouseMoveStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.x = step_data['x']
                    step.y = step_data['y']
                    step.duration = step_data['duration']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.KEYBOARD_TYPE:
                from ui.dialogs.keyboard_type_step_dialog import KeyboardTypeStepDialog
                # Get Excel columns from parent widget
                excel_columns = []
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'excel_widget'):
                        excel_manager = parent.excel_widget.get_excel_manager()
                        if excel_manager and excel_manager._current_data is not None:
                            excel_columns = list(excel_manager._current_data.columns)
                        break
                    parent = parent.parent()
                    
                dialog = KeyboardTypeStepDialog(step, excel_columns, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.text = step_data['text']
                    step.interval = step_data['interval']
                    step.use_variables = step_data['use_variables']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.KEYBOARD_HOTKEY:
                from ui.dialogs.keyboard_hotkey_step_dialog import KeyboardHotkeyStepDialog
                dialog = KeyboardHotkeyStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.keys = step_data['keys']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.WAIT_TIME:
                print(f"DEBUG: Importing WaitTimeStepDialog")
                from ui.dialogs.wait_time_step_dialog import WaitTimeStepDialog
                print(f"DEBUG: Creating WaitTimeStepDialog")
                dialog = WaitTimeStepDialog(step, parent=self)
                print(f"DEBUG: Executing WaitTimeStepDialog")
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.seconds = step_data['seconds']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.SCREENSHOT:
                from ui.dialogs.screenshot_step_dialog import ScreenshotStepDialog
                dialog = ScreenshotStepDialog(step, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.filename_pattern = step_data['filename_pattern']
                    step.save_directory = step_data['save_directory']
                    step.region = step_data['region']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            elif step.step_type == StepType.LOOP:
                from ui.dialogs.loop_step_dialog import LoopStepDialog
                # Get all steps in macro for selection
                all_steps = self.macro.steps
                dialog = LoopStepDialog(step, all_steps, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    step_data = dialog.get_step_data()
                    step.name = step_data['name']
                    step.loop_type = step_data['loop_type']
                    step.loop_count = step_data['loop_count']
                    step.loop_steps = step_data['loop_steps']
                    if 'description' in step_data:
                        step.description = step_data['description']
                    self._rebuild_ui()
                    self.stepEdited.emit(step)
                    
            else:
                # For other step types, emit the signal as before
                self.stepEdited.emit(step)
                
        except Exception as e:
            print(f"DEBUG: Exception in _on_step_edit: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ë‹¨ê³„ í¸ì§‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
        
    def _on_step_delete(self, step_id: str):
        """Handle step deletion"""
        reply = QMessageBox.question(
            self, "ë‹¨ê³„ ì‚­ì œ", 
            "ì´ ë‹¨ê³„ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.macro.remove_step(step_id)
            self._rebuild_ui()
            self.stepDeleted.emit(step_id)
            
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter"""
        if event.mimeData().hasFormat("application/x-steptype") or \
           event.mimeData().hasFormat("application/x-macrostep"):
            event.acceptProposedAction()
            
    def dragMoveEvent(self, event):
        """Handle drag move"""
        if event.mimeData().hasFormat("application/x-steptype") or \
           event.mimeData().hasFormat("application/x-macrostep"):
            event.acceptProposedAction()
            
    def dropEvent(self, event: QDropEvent):
        """Handle drop"""
        try:
            # Calculate drop index
            drop_index = self._get_drop_index(event.pos())
            
            if event.mimeData().hasFormat("application/x-steptype"):
                # New step from palette
                byte_array = event.mimeData().data("application/x-steptype")
                stream = QDataStream(byte_array, QIODevice.ReadOnly)
                step_type_str_result = stream.readQString()
                step_type_str = step_type_str_result[0] if isinstance(step_type_str_result, tuple) else step_type_str_result
                
                step_type = StepType(step_type_str)
                new_step = StepFactory.create_step(step_type)
                
                # Set default name
                step_names = {
                    StepType.MOUSE_CLICK: "ë§ˆìš°ìŠ¤ í´ë¦­",
                    StepType.MOUSE_MOVE: "ë§ˆìš°ìŠ¤ ì´ë™",
                    StepType.KEYBOARD_TYPE: "í…ìŠ¤íŠ¸ ì…ë ¥",
                    StepType.KEYBOARD_HOTKEY: "ë‹¨ì¶•í‚¤",
                    StepType.WAIT_TIME: "ëŒ€ê¸°",
                    StepType.WAIT_IMAGE: "ì´ë¯¸ì§€ ëŒ€ê¸°",
                    StepType.IMAGE_SEARCH: "ì´ë¯¸ì§€ ê²€ìƒ‰",
                    StepType.OCR_TEXT: "í…ìŠ¤íŠ¸ ê²€ìƒ‰",
                    StepType.SCREENSHOT: "í™”ë©´ ìº¡ì²˜",
                    StepType.IF_CONDITION: "ì¡°ê±´ë¬¸",
                    StepType.LOOP: "ë°˜ë³µë¬¸"
                }
                new_step.name = step_names.get(step_type, step_type.value)
                
                self.macro.add_step(new_step, drop_index)
                self._rebuild_ui()
                self.stepAdded.emit(new_step, drop_index)
                
                # Automatically open configuration dialog for new step
                self._on_step_edit(new_step)
                
            elif event.mimeData().hasFormat("application/x-macrostep"):
                # Moving existing step
                byte_array = event.mimeData().data("application/x-macrostep")
                stream = QDataStream(byte_array, QIODevice.ReadOnly)
                step_id_result = stream.readQString()
                step_id = step_id_result[0] if isinstance(step_id_result, tuple) else step_id_result
                old_index = stream.readInt()
                
                # Adjust drop index if moving down
                if old_index < drop_index:
                    drop_index -= 1
                    
                self.macro.move_step(step_id, drop_index)
                self._rebuild_ui()
                self.stepMoved.emit(step_id, drop_index)
                
            event.acceptProposedAction()
            
        except Exception as e:
            QMessageBox.critical(self, "\uc624\ub958", f"\ub4dc\ub798\uadf8 \uc568 \ub4dc\ub86d \uc911 \uc624\ub958\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4:\n{str(e)}")
            print(f"Drop event error: {e}")
            import traceback
            traceback.print_exc()
        
    def _get_drop_index(self, pos) -> int:
        """Calculate index where item should be dropped"""
        if not self.macro.steps:
            return 0
            
        # Find the widget under the cursor
        for i, step in enumerate(self.macro.steps):
            widget = self.step_widgets.get(step.step_id)
            if widget:
                widget_rect = widget.geometry()
                if pos.y() < widget_rect.center().y():
                    return i
                    
        return len(self.macro.steps)
        
    def _on_selection_changed(self, step_id: str, selected: bool):
        """Handle step selection change"""
        self.selected_steps[step_id] = selected
        
    def get_selected_steps(self) -> List[MacroStep]:
        """Get list of selected steps"""
        selected = []
        for step in self.macro.steps:
            if self.selected_steps.get(step.step_id, False):
                selected.append(step)
        return selected

class MacroEditorWidget(QWidget):
    """Complete macro editor with palette and flow"""
    
    macroChanged = pyqtSignal(Macro)
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize UI"""
        layout = QHBoxLayout()
        
        # Create splitter
        splitter = QSplitter(Qt.Horizontal)
        
        # Step palette
        palette_group = QGroupBox("ë‹¨ê³„ íŒ”ë ˆíŠ¸")
        palette_layout = QVBoxLayout()
        
        palette_label = QLabel("ë‹¨ê³„ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”")
        palette_label.setWordWrap(True)
        palette_layout.addWidget(palette_label)
        
        self.palette = StepPalette()
        palette_layout.addWidget(self.palette)
        
        palette_group.setLayout(palette_layout)
        splitter.addWidget(palette_group)
        
        # Macro flow
        flow_group = QGroupBox("ë§¤í¬ë¡œ íë¦„")
        flow_layout = QVBoxLayout()
        
        # Scroll area for flow
        scroll = QScrollArea()
        self.flow_widget = MacroFlowWidget()
        self.flow_widget.stepAdded.connect(self._on_change)
        self.flow_widget.stepMoved.connect(self._on_change)
        self.flow_widget.stepDeleted.connect(self._on_change)
        self.flow_widget.stepEdited.connect(self._on_step_edit)
        
        scroll.setWidget(self.flow_widget)
        scroll.setWidgetResizable(True)
        flow_layout.addWidget(scroll)
        
        flow_group.setLayout(flow_layout)
        splitter.addWidget(flow_group)
        
        # Set splitter sizes (20% palette, 80% flow)
        splitter.setSizes([200, 800])
        
        layout.addWidget(splitter)
        self.setLayout(layout)
        
    def set_macro(self, macro: Macro):
        """Set the macro to edit"""
        self.flow_widget.set_macro(macro)
        
    def get_macro(self) -> Macro:
        """Get the current macro"""
        return self.flow_widget.macro
        
    def get_selected_steps(self) -> List[MacroStep]:
        """Get list of selected steps"""
        return self.flow_widget.get_selected_steps()
        
    def _on_change(self):
        """Handle macro change"""
        self.macroChanged.emit(self.flow_widget.macro)
        
    def _on_step_edit(self, step: MacroStep):
        """Handle step edit request"""
        # This will be connected to step configuration dialog
        pass
        
    def set_compact_mode(self, is_compact: bool):
        """Apply compact mode to the macro editor"""
        if is_compact:
            # Adjust palette width
            self.palette.setMaximumWidth(150)
            
            # Find the splitter and adjust sizes
            splitter = self.findChild(QSplitter)
            if splitter:
                splitter.setSizes([150, 850])
                
            # Adjust group box margins
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(5, 15, 5, 5)
        else:
            # Reset to normal sizes
            self.palette.setMaximumWidth(200)
            
            # Reset splitter
            splitter = self.findChild(QSplitter)
            if splitter:
                splitter.setSizes([200, 800])
                
            # Reset group box margins
            for group_box in self.findChildren(QGroupBox):
                group_box.setContentsMargins(9, 20, 9, 9)
</file>

<file path="src/ui/main_window.py">
"""
Main application window
"""

from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QMenuBar, QMenu, QAction, QStatusBar, QLabel,
    QMessageBox, QTabWidget, QFileDialog
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QIcon
from config.settings import Settings
from logger.app_logger import get_logger
from core.macro_storage import MacroStorage, MacroFormat
from core.macro_types import Macro
import os
from typing import List, Optional

class MainWindow(QMainWindow):
    """Main application window"""
    
    def __init__(self, settings: Settings):
        super().__init__()
        self.settings = settings
        self.logger = get_logger(__name__)
        
        # Macro storage
        self.macro_storage = MacroStorage()
        self.current_macro_path: Optional[str] = None
        self.recent_macros: List[str] = self.settings.get("macro.recent_files", [])
        
        self.init_ui()
        self.load_window_state()
        
        # Apply compact mode if enabled
        if self.settings.get("ui.compact_mode", False):
            self.apply_compact_mode(True)
        
    def init_ui(self):
        """Initialize user interface"""
        self.setWindowTitle("Excel Macro Automation")
        
        # Set window size from settings
        window_size = self.settings.get("ui.window_size", [1280, 720])
        self.resize(*window_size)
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Create main layout
        layout = QVBoxLayout(central_widget)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        
        # Add Excel widget
        from ui.widgets.excel_widget import ExcelWidget
        self.excel_widget = ExcelWidget()
        self.tab_widget.addTab(self.excel_widget, "Excel")
        
        # Add Macro Editor widget
        from ui.widgets.macro_editor import MacroEditorWidget
        self.macro_editor = MacroEditorWidget()
        self.tab_widget.addTab(self.macro_editor, "Editor")
        
        # Add Execution widget
        from ui.widgets.execution_widget import ExecutionWidget
        self.execution_widget = ExecutionWidget(self.settings)
        self.tab_widget.addTab(self.execution_widget, "Run")
        
        # Connect Excel and Macro widgets to Execution
        self.excel_widget.dataReady.connect(self._on_excel_data_ready)
        self.macro_editor.macroChanged.connect(self._on_macro_changed)
        
        # Create menu bar
        self.create_menu_bar()
        
        # Create status bar
        self.create_status_bar()
        
    def create_menu_bar(self):
        """Create application menu bar"""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        new_action = QAction("New Project", self)
        new_action.setShortcut("Ctrl+N")
        file_menu.addAction(new_action)
        
        open_action = QAction("Open Project", self)
        open_action.setShortcut("Ctrl+O")
        file_menu.addAction(open_action)
        
        save_action = QAction("Save Project", self)
        save_action.setShortcut("Ctrl+Alt+S")
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        # Macro menu items
        save_macro_action = QAction("Save Macro", self)
        save_macro_action.setShortcut("Ctrl+S")
        save_macro_action.triggered.connect(self.save_macro)
        file_menu.addAction(save_macro_action)
        
        load_macro_action = QAction("Load Macro", self)
        load_macro_action.setShortcut("Ctrl+O")
        load_macro_action.triggered.connect(self.load_macro)
        file_menu.addAction(load_macro_action)
        
        export_macro_action = QAction("Export Macro", self)
        export_macro_action.setShortcut("Ctrl+E")
        export_macro_action.triggered.connect(self.export_macro)
        file_menu.addAction(export_macro_action)
        
        file_menu.addSeparator()
        
        # Recent macros submenu
        self.recent_macros_menu = QMenu("Recent Macros", self)
        file_menu.addMenu(self.recent_macros_menu)
        self.update_recent_macros_menu()
        
        file_menu.addSeparator()
        
        exit_action = QAction("Exit", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Edit menu
        edit_menu = menubar.addMenu("Edit")
        
        settings_action = QAction("Settings", self)
        settings_action.setShortcut("Ctrl+,")
        edit_menu.addAction(settings_action)
        
        # View menu
        view_menu = menubar.addMenu("View")
        
        theme_action = QAction("Toggle Theme", self)
        view_menu.addAction(theme_action)
        
        # Add compact mode toggle
        self.compact_mode_action = QAction("Compact Mode", self)
        self.compact_mode_action.setCheckable(True)
        self.compact_mode_action.setChecked(self.settings.get("ui.compact_mode", False))
        self.compact_mode_action.setShortcut("Ctrl+Shift+C")
        self.compact_mode_action.setStatusTip("Toggle compact mode to reduce UI spacing (Ctrl+Shift+C)")
        self.compact_mode_action.triggered.connect(self.toggle_compact_mode)
        view_menu.addAction(self.compact_mode_action)
        
        view_menu.addSeparator()
        
        log_viewer_action = QAction("Execution Logs", self)
        log_viewer_action.setShortcut("Ctrl+L")
        log_viewer_action.triggered.connect(self.show_log_viewer)
        view_menu.addAction(log_viewer_action)
        
        # Help menu
        help_menu = menubar.addMenu("Help")
        
        about_action = QAction("About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
        
    def create_status_bar(self):
        """Create application status bar"""
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        
        # Add permanent widgets
        self.status_label = QLabel("Ready")
        self.status_bar.addPermanentWidget(self.status_label)
        
    def show_about(self):
        """Show about dialog"""
        QMessageBox.about(
            self,
            "About Excel Macro Automation",
            "Excel-based Task Automation Macro\n\n"
            "Version: 1.0.0\n"
            "Automate repetitive tasks using Excel data"
        )
        
    def show_log_viewer(self):
        """Show log viewer dialog"""
        from ui.dialogs.log_viewer_dialog import LogViewerDialog
        dialog = LogViewerDialog(parent=self)
        dialog.show()  # Non-modal
        
    def closeEvent(self, event):
        """Handle window close event"""
        if self.settings.get("ui.confirm_exit", True):
            reply = QMessageBox.question(
                self,
                "Confirm Exit",
                "Are you sure you want to exit?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                self.save_window_state()
                event.accept()
            else:
                event.ignore()
        else:
            self.save_window_state()
            event.accept()
            
    def save_window_state(self):
        """Save window size and position"""
        self.settings.set("ui.window_size", [self.width(), self.height()])
        self.settings.save()
        
    def load_window_state(self):
        """Load window size and position"""
        # Window state loading is handled in init_ui
        pass
        
    def _on_excel_data_ready(self, excel_data):
        """Handle Excel data ready"""
        excel_manager = self.excel_widget.get_excel_manager()
        macro = self.macro_editor.get_macro()
        self.execution_widget.set_macro_and_excel(macro, excel_manager)
        
    def _on_macro_changed(self, macro):
        """Handle macro change"""
        excel_manager = self.excel_widget.get_excel_manager()
        if excel_manager._current_data:
            self.execution_widget.set_macro_and_excel(macro, excel_manager)
            
    def save_macro(self):
        """Save current macro to file"""
        try:
            macro = self.macro_editor.get_macro()
            if not macro or not macro.steps:
                QMessageBox.warning(self, "Warning", "No macro to save.")
                return
                
            # Get save path
            if self.current_macro_path:
                # Use current path
                file_path = self.current_macro_path
            else:
                # Show save dialog
                file_path, selected_filter = QFileDialog.getSaveFileName(
                    self,
                    "Save Macro",
                    os.path.expanduser("~/"),
                    "JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
                )
                
                if not file_path:
                    return
                    
            # Determine format based on extension
            if file_path.endswith('.emf'):
                format_type = MacroFormat.ENCRYPTED
            else:
                format_type = MacroFormat.JSON
                if not file_path.endswith('.json'):
                    file_path += '.json'
                    
            # Save macro
            success = self.macro_storage.save_macro(macro, file_path, format_type)
            
            if success:
                self.current_macro_path = file_path
                self.add_to_recent_macros(file_path)
                self.update_window_title()
                self.status_label.setText(f"Macro saved to {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", "Macro saved successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to save macro.")
                
        except Exception as e:
            self.logger.error(f"Error saving macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to save macro: {str(e)}")
            
    def load_macro(self):
        """Load macro from file"""
        try:
            # Show open dialog
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Load Macro",
                os.path.expanduser("~/"),
                "Macro files (*.json *.emf);;JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
            )
            
            if not file_path:
                return
                
            # Load macro
            macro = self.macro_storage.load_macro(file_path)
            
            if macro:
                self.macro_editor.set_macro(macro)
                self.current_macro_path = file_path
                self.add_to_recent_macros(file_path)
                self.update_window_title()
                self.status_label.setText(f"Macro loaded from {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", "Macro loaded successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to load macro.")
                
        except Exception as e:
            self.logger.error(f"Error loading macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load macro: {str(e)}")
            
    def export_macro(self):
        """Export selected macro steps"""
        try:
            # Get selected steps from macro editor
            selected_steps = self.macro_editor.get_selected_steps()
            
            if not selected_steps:
                QMessageBox.warning(self, "Warning", "No steps selected for export.")
                return
                
            # Create partial macro
            macro = self.macro_editor.get_macro()
            partial_macro = Macro(
                name=f"{macro.name}_partial",
                description=f"Partial export of {macro.name}",
                steps=selected_steps,
                variables=macro.variables  # Include all variables for now
            )
            
            # Show save dialog
            file_path, selected_filter = QFileDialog.getSaveFileName(
                self,
                "Export Macro Steps",
                os.path.expanduser("~/"),
                "JSON files (*.json);;Encrypted files (*.emf);;All files (*.*)"
            )
            
            if not file_path:
                return
                
            # Determine format
            if file_path.endswith('.emf'):
                format_type = MacroFormat.ENCRYPTED
            else:
                format_type = MacroFormat.JSON
                if not file_path.endswith('.json'):
                    file_path += '.json'
                    
            # Save partial macro
            success = self.macro_storage.save_macro(partial_macro, file_path, format_type)
            
            if success:
                self.status_label.setText(f"Exported {len(selected_steps)} steps to {os.path.basename(file_path)}")
                QMessageBox.information(self, "Success", f"Exported {len(selected_steps)} steps successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to export macro steps.")
                
        except Exception as e:
            self.logger.error(f"Error exporting macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to export macro: {str(e)}")
            
    def add_to_recent_macros(self, file_path: str):
        """Add file to recent macros list"""
        # Remove if already exists
        if file_path in self.recent_macros:
            self.recent_macros.remove(file_path)
            
        # Add to front
        self.recent_macros.insert(0, file_path)
        
        # Keep only last 5
        self.recent_macros = self.recent_macros[:5]
        
        # Save to settings
        self.settings.set("macro.recent_files", self.recent_macros)
        self.settings.save()
        
        # Update menu
        self.update_recent_macros_menu()
        
    def update_recent_macros_menu(self):
        """Update recent macros menu"""
        self.recent_macros_menu.clear()
        
        if not self.recent_macros:
            action = QAction("(No recent macros)", self)
            action.setEnabled(False)
            self.recent_macros_menu.addAction(action)
            return
            
        for file_path in self.recent_macros:
            if os.path.exists(file_path):
                action = QAction(os.path.basename(file_path), self)
                action.setStatusTip(file_path)
                action.triggered.connect(lambda checked, path=file_path: self.load_recent_macro(path))
                self.recent_macros_menu.addAction(action)
                
    def load_recent_macro(self, file_path: str):
        """Load a recent macro"""
        try:
            macro = self.macro_storage.load_macro(file_path)
            
            if macro:
                self.macro_editor.set_macro(macro)
                self.current_macro_path = file_path
                self.update_window_title()
                self.status_label.setText(f"Macro loaded from {os.path.basename(file_path)}")
            else:
                QMessageBox.critical(self, "Error", f"Failed to load macro from {os.path.basename(file_path)}")
                self.recent_macros.remove(file_path)
                self.update_recent_macros_menu()
                
        except Exception as e:
            self.logger.error(f"Error loading recent macro: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load macro: {str(e)}")
            
    def update_window_title(self):
        """Update window title with current macro file"""
        title = "Excel Macro Automation"
        if self.current_macro_path:
            title += f" - {os.path.basename(self.current_macro_path)}"
        self.setWindowTitle(title)
        
    def toggle_compact_mode(self):
        """Toggle compact mode for the UI"""
        is_compact = self.compact_mode_action.isChecked()
        self.settings.set("ui.compact_mode", is_compact)
        self.settings.save()
        
        # Apply compact mode styling
        self.apply_compact_mode(is_compact)
        self.status_label.setText(f"Compact mode {'enabled' if is_compact else 'disabled'}")
        
    def apply_compact_mode(self, is_compact: bool):
        """Apply compact mode styling to the application"""
        if is_compact:
            # Compact mode stylesheet
            compact_style = """
            /* General compact styling */
            QWidget {
                font-size: 11px;
            }
            
            /* Reduce padding in tabs */
            QTabBar::tab {
                padding: 3px 8px;
                min-height: 20px;
            }
            
            /* Compact buttons */
            QPushButton {
                padding: 3px 8px;
                min-height: 22px;
            }
            
            /* Compact list items */
            QListWidget::item {
                padding: 2px;
                min-height: 20px;
            }
            
            /* Compact table rows */
            QTableWidget::item {
                padding: 2px;
            }
            
            /* Compact menu items */
            QMenu::item {
                padding: 3px 20px 3px 10px;
            }
            
            /* Compact group boxes */
            QGroupBox {
                margin-top: 1ex;
                padding-top: 10px;
            }
            
            QGroupBox::title {
                top: -7px;
                left: 10px;
            }
            
            /* Compact status bar */
            QStatusBar {
                min-height: 18px;
                font-size: 10px;
            }
            
            /* Compact splitters */
            QSplitter::handle {
                background-color: #ddd;
                height: 3px;
            }
            
            /* Compact scroll bars */
            QScrollBar:vertical {
                width: 10px;
            }
            
            QScrollBar:horizontal {
                height: 10px;
            }
            
            /* Compact line edits */
            QLineEdit, QTextEdit, QPlainTextEdit {
                padding: 2px;
            }
            
            /* Compact spin boxes */
            QSpinBox, QDoubleSpinBox {
                padding: 2px;
                min-height: 20px;
            }
            
            /* Compact combo boxes */
            QComboBox {
                padding: 2px 5px;
                min-height: 20px;
            }
            
            /* Compact tool buttons */
            QToolButton {
                padding: 2px;
                min-height: 20px;
                min-width: 20px;
            }
            
            /* Compact dialogs */
            QDialog {
                font-size: 11px;
            }
            
            /* Compact labels */
            QLabel {
                margin: 1px;
            }
            
            /* Compact progress bars */
            QProgressBar {
                min-height: 14px;
                max-height: 14px;
                font-size: 10px;
            }
            
            /* Compact checkboxes and radio buttons */
            QCheckBox, QRadioButton {
                spacing: 3px;
            }
            
            /* Compact tree widget */
            QTreeWidget::item {
                padding: 1px;
                min-height: 18px;
            }
            """
            self.setStyleSheet(compact_style)
            
            # Apply specific compact settings to widgets
            self._apply_compact_to_widgets(True)
        else:
            # Reset to normal styling
            self.setStyleSheet("")
            self._apply_compact_to_widgets(False)
            
    def _apply_compact_to_widgets(self, is_compact: bool):
        """Apply compact mode settings to specific widgets"""
        # Set tab widget spacing
        if is_compact:
            self.tab_widget.setDocumentMode(True)
            self.centralWidget().layout().setContentsMargins(5, 5, 5, 5)
            self.centralWidget().layout().setSpacing(5)
        else:
            self.tab_widget.setDocumentMode(False)
            self.centralWidget().layout().setContentsMargins(9, 9, 9, 9)
            self.centralWidget().layout().setSpacing(6)
            
        # Apply to child widgets if they have compact mode support
        for i in range(self.tab_widget.count()):
            widget = self.tab_widget.widget(i)
            if hasattr(widget, 'set_compact_mode'):
                widget.set_compact_mode(is_compact)
</file>

</files>
